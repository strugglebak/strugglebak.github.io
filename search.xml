<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>CMU-15-445-645-笔记-01-课程简介与关系模型</title>
    <url>/2022/06/04/CMU-15-445-645-%E7%AC%94%E8%AE%B0-01-%E8%AF%BE%E7%A8%8B%E7%AE%80%E4%BB%8B%E4%B8%8E%E5%85%B3%E7%B3%BB%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<blockquote>
<p>注: 本文首发我的 b 站专栏文章<a href="https://www.bilibili.com/read/cv14530070" target="_blank" rel="noopener">CMU 15-445/645-笔记-01-课程简介与关系模型</a></p>
</blockquote>
<a id="more"></a>
<p><img src="./Cover.png" alt></p>
<ul>
<li>课程目标</li>
</ul>
<p><img src="./1.png" alt></p>
<ul>
<li>参考书推荐用 《Database System Concepts》</li>
<li>该课程主要是手写 Database Storage Manager 而不是 Database System（因为项目不支持 SQL 解析）</li>
<li><p>数据库拓展研究</p>
<p>  <img src="./2.png" alt></p>
</li>
<li><p>用 CSV（Comma-Seperated Value）文件存 database</p>
</li>
<li><p>怎么用呢，举个例子</p>
<p>  <img src="./3.png" alt></p>
</li>
<li><p>但这种方式是有问题的</p>
<ul>
<li>每个专辑的 entry 中的 artist 都是一样的么？</li>
<li>Ice Cube 没有拼写错误？</li>
<li>如果别人在文件里重写了一个无效的 string 怎么办呢？</li>
<li>如果一张专辑里面有多个 artist，那么怎么存储这些数据呢？</li>
<li>如何查询数据？</li>
<li>多线程同一时间写同一个文件怎么办？</li>
<li>如何保证数据安全（在写数据的时候机器故障咋办？）</li>
<li><p>Database Management System 的作用</p>
<p>  <img src="./4.png" alt></p>
</li>
</ul>
</li>
<li><p>1970 年 Ted Codd 提出的关系型模型（Relational Model）是为了解决之前数据库不断重构数据结构，以及数据结构转存之后不断销毁数据的问题</p>
</li>
<li>关系模型三板斧如下<ul>
<li>用简单数据结构存数据</li>
<li>用高级语言访问数据</li>
<li>大型数据库的物理存储策略基于 Database Management System 的实现</li>
</ul>
</li>
<li>这种思想把 逻辑层 和 物理层 完全解耦</li>
<li><p>关系型数据模型并不是唯一的数据模型</p>
<p>  <img src="./5.png" alt></p>
<p>  比如如下</p>
<p>  <img src="./6.png" alt></p>
<ul>
<li>Relational（MySQL, PostgreSQL，Oracle，DB2，SQL server，SQLite）</li>
<li>Key/Value，Graph，Document， Column-family（NoSQL）</li>
<li>Array/Matrix（Mathine Learning）</li>
<li>Hierarchical，Network （Obsolete / Rare）旧时代的余晖。。。</li>
</ul>
</li>
<li><p>关系型模型可以对任何东西进行建模</p>
</li>
<li><p>关系型模型主要关注三个方面</p>
<p>  <img src="./7.png" alt></p>
</li>
</ul>
<ul>
<li><p>一个 关系（relation） 是一个无序的集合，这个集合包含代表 entities 的属性的关系（relationship），比如</p>
<p>  <img src="./8.png" alt></p>
</li>
<li><p>tuple 在 关系 中就是一个 属性值 的集合</p>
</li>
<li><p>原始关系模型中，所有的值必须保证原子性或者它必须是一个单个属性值（比如只能是一个 String，一个 int，或者一个 float等，不能是数组或者嵌套的对象等）</p>
</li>
<li>NULL 这个属性值代表未知，SQL 查询会遇到麻烦</li>
<li>主键 Primary Key，唯一标识记录的 id</li>
<li>外键 Foreign Key，用于指定一张表中的属性必须存在于另一张表中</li>
<li>注意 relation 和 table 语义一样</li>
<li><p>一个外键的例子</p>
<p>  <img src="./9.png" alt></p>
</li>
<li><p>如何从 Database 中取数据？<br>  通过 DML （Data Manipulation Languages）</p>
<p>  <img src="./10.png" alt></p>
</li>
</ul>
<ul>
<li>Relational Algebra 关系代数</li>
<li><p>Ted Codd 提出了在 Relational Algebra 中的其中基本运算符</p>
<p>  <img src="./11.png" alt></p>
<ul>
<li><p>SELECT</p>
<p>  <img src="./12.png" alt></p>
</li>
<li><p>PROJECTION<br>  即 SELECT b_id-100, a_id FROM R WHERE a_id=’2’</p>
<p>  <img src="./13.png" alt></p>
</li>
<li><p>UNION<br>  <img src="./14.png" alt></p>
</li>
<li><p>INTERSECTION<br>  <img src="./15.png" alt></p>
</li>
<li><p>DIFFERENCE<br>  <img src="./16.png" alt></p>
</li>
<li><p>PRODUCT<br>  <img src="./17.png" alt></p>
</li>
<li><p>JOIN<br>  即 SELECT * FROM R NATURAL JOIN S;</p>
<p>  <img src="./18.png" alt></p>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>一些后续研究的额外的操作符</p>
<p>  <img src="./19.png" alt></p>
</li>
<li><p>一些优化策略</p>
<p>  <img src="./20.png" alt></p>
</li>
<li><p>关系型模型与任何查询语言的实现无关，实际上当 Ted Codd 在他写关系型模型论文时并没有提出 SQL，他提出了 关系代数，并推出了自己的语言叫 Alpha，与（1970）同年推出的 SQL、Ingres （伯克利）、Quel 都是竞争对手。</p>
</li>
<li><p>SQL 只是一个标准</p>
</li>
<li><p>结论</p>
<p>  <img src="./21.png" alt></p>
</li>
</ul>
]]></content>
      <categories>
        <category>Database</category>
      </categories>
      <tags>
        <tag>Database</tag>
      </tags>
  </entry>
  <entry>
    <title>CMU-15-445-645-笔记-06-Hash表</title>
    <url>/2022/06/05/CMU-15-445-645-%E7%AC%94%E8%AE%B0-06-Hash%E8%A1%A8/</url>
    <content><![CDATA[<blockquote>
<p>注: 本文首发我的 b 站专栏文章<a href="https://www.bilibili.com/read/cv14598675" target="_blank" rel="noopener">CMU 15-445/645-笔记-06-Hash表</a></p>
</blockquote>
<a id="more"></a>
<p><img src="./Cover.png" alt></p>
<ul>
<li><p>课程目标</p>
<p>  <img src="./1.png" alt></p>
</li>
<li><p>目前已经讲过的内容</p>
<p>  <img src="./2.png" alt></p>
</li>
<li><p>数据结构</p>
<p>  <img src="./3.png" alt></p>
<p>  memcache 本质上来讲就是一个超大的 hash table，而 MySQL 的 innodb 引擎使用的是 B+ tree，它们将 tuple 存储在 B+ tree 的叶子节点上</p>
<p>  临时数据也可以用数据结构来维护（就是缓存），比如在执行一个查询时，为了高效地计算某些东西，可以在运行时构建一个数据结构，放入所需数据，完成查询的执行，然后将这个临时数据结构丢弃掉</p>
<p>  表索引（table index）也有对应的数据结构，即使用 tuple 中的 key 来构建一个词汇表，有些像书中的目录，这样就能很快地找到那个对应的单个元素，也没必要对整个数据库进行循环扫描了</p>
</li>
<li><p>设计数据结构</p>
<p>  <img src="./4.png" alt></p>
<ol>
<li>如何弄一个数据结构，使得无须对该数据结构进行大改或者每次要重新转换整个数据结构的情况下，支持快速读写</li>
<li><p>该如何让多个线程或者多个查询去访问这个数据结构，并且该数据结构表示的数据不会再物理存储层面出现问题，因为同时被线程修改的某个地址的数据会变成脏数据，从而让它们访问到某些无效的 page 或者是某些无效的内存位置</p>
<p>这里最关心的应该还是数据结构的 物理完整性，而不是 逻辑完整性</p>
</li>
</ol>
</li>
<li><p>Hash 表</p>
<p>  <img src="./5.png" alt></p>
<p>  hash 表是一个抽象的数据类型，它可以提供无序的关联数据的实现（unordered associative array implementation）的 API</p>
<p>  注意，hash 函数并不会一直让我们精确地找到我们想要找的东西，因为这会产生 hash 碰撞，但至少它能让我们找到正确的位置，然后我们知道该如何在周围找到我们想要的那个数据</p>
<p>  hash 表操作时间复杂度最坏的情况为什么是 O(n) 呢？这是因为 key 通过 hash 都碰撞到一起，放在一个数据/队列/链表中了，所以这个时候就需要遍历查找想要的那个 key</p>
<p>  虽然 hash 表操作平均时间复杂度为 O(1)，但不同的 hash 函数执行时间可能不一样，有些快有些慢，在面对超大规模基数的数据查询时，慢的 hash 函数会导致整个应用需要付出大量的金钱，比如商业交易这一场景</p>
<ul>
<li><p>静态 Hash 表</p>
<p>  <img src="./6.png" alt></p>
<p>  一个最简单的 hash 表如上图所示，它其实就是一个巨大的数组，看起来就像是一大块内存</p>
<p>  数组中每个 offset 位置都对应了一个给定的元素</p>
<p>  通过对 key 进行 hash，即将 key 与所有元素数量进行取模（如果该 key 对应这个数组的下标），就会得到它对应的 offset 值</p>
<p>  <img src="./7.png" alt><br>  <img src="./8.png" alt></p>
<p>  但实际上 hash 表并不完全是这样，hash 表需要保存的是一些指向这些原始的 key 所在位置的指针</p>
<p>  <img src="./9.png" alt></p>
<p>  对于这种 hash 表而言，存在的问题是什么呢？</p>
<ol>
<li>需要提前知道 hash 表中元素的数量</li>
<li><p>key 与 key 之间没有碰撞（collision）</p>
<p>碰撞 指的是，对 key 进行 hash 后的结果指向了同一个 slot</p>
<p><img src="./10.png" alt></p>
<p>完美 hash 函数（perfect hash function）是一种存在于研究文献中的一种理论上的东西，因为在实际工作中，如果 key1 != key2，那么有可能 hash(key1) = hash(key2)。实际上能实现所谓完美 hash 函数的方式是通过另一张 hash 表将一个 key 映射到另一个 hash value 上（这种方式真的很蠢，因为速度会很慢），比如 Java 中的 concurrentHashmap，第一次 hash 是为了分区，第二次 hash 是为了确定具体位置，但也不能保证完美</p>
</li>
</ol>
<p>那么该如何在摈弃上述两个假设的前题下实现一个 hash 表呢？</p>
<p><img src="./11.png" alt></p>
<p>要实现一个 hash 表，它的数据结构应该是由 2 部分组成</p>
</li>
</ul>
<ol>
<li><p>hash 函数<br> 该函数将任意的 key 映射到一个较小范围的 integer value 上，同时该函数会生成一个 32/64 bit 的唯一 hash 值（也可能不唯一）</p>
<p> hash 函数的速度和碰撞率之间要做取舍</p>
</li>
<li><p>hashing scheme<br> 即当在 hash 表中遇上 hash 碰撞时，用 hashing scheme 来处理这种问题，hashing scheme 是一种机制或者说步骤</p>
<p> 同样的，这个也需要在内存和计算（速度）之间做取舍，即时间换空间，空间换时间。</p>
</li>
</ol>
<ul>
<li><p>Hash 函数</p>
<p>  <img src="./12.png" alt></p>
<p>  hash 函数就是一个速度很快的函数，将任意的 byte array 或者任意的 key 传入函数，它就会返回一个 32/64 bit 的 integer</p>
<p>  比如一些著名的 hash 函数，比如 SHA-256/MD5</p>
<p>  实际上 SHA-256 是不可逆的加密 hash 函数，它是一种使用了 公钥/私钥 的东西</p>
<p>  对于 MD5 来说，可以将任意的 key 传入它的 hash 函数，然后返回一个 32 bit 的唯一 hash 值，它本来应该是不可逆的，但现在因为有人破解了它，所以可逆</p>
<p>  在数据库系统中，如果要做 hash 表，那么我们对它的加密性并不在意，所以也不会去用 SHA-256（用这个加密速度也超慢）</p>
<p>  MD5 是一种单向散列（one-way hash），可以将它作为构建 hash 表的 hash 函数，但没必要因为它还是非常慢。同时它也是不安全的，因为可以通过彩虹表对它进行破解</p>
<p>  一些 hash 函数图</p>
<p>  <img src="./13.png" alt></p>
<ul>
<li>CRC-64 是 1975 年被发明出来的，它的碰撞率虽然合理，但是速度非常非常慢</li>
<li>MurmurHash，从数据库层面来讲，它的诞生开启了现代 hash 函数的时代。它在 2008 年诞生，是开源的。G 家在 2010 年早期采用了 MurmurHash，并对其做了改进，使得长度更短的 key 可以获得更快的速度，然后 G 家就发布了 CityHash。2014 年时他们由基于这个做了改进，然后发布了 FarmHash，它的碰撞率比 CityHash 更低</li>
<li><p>Meta 的 XXHash 的速度更快，碰撞率最低（这里指的是 XXHash 3）</p>
<p>2 张 hash 函数的 benchmark 图</p>
<p><img src="./14.png" alt><br><img src="./15.png" alt></p>
<p>从上图可以看到，当 key 的大小为 32 byte 和 64 byte 时，FarmHash、CityHash、XXHash3 都出现了非常漂亮的尖峰，这是因为它们进行计算处理的 key 都刚好填满单个 Cache Line（CPU 和主存之间数据传输的最小单位）。当从内存中读取一次数据时，将 64 byte 大小的 key 放入 Cache 中，这样就可以一次性操作所有从该缓存中找到的数据，即一次操作一整个 Cache line 中的数据。当 key 的大小超过 64 byte 后，CityHash 和 FarmHash 就会切换到另一种不同的算法上，导致速度上会有些不同</p>
<p>所以在数据库系统中，尽可能多地去使用 XXHash3</p>
</li>
</ul>
</li>
<li><p>静态 Hashing Schemes</p>
<p>  <img src="./16.png" alt></p>
<p>  注意，此处讨论的内容跟所使用的 hash 函数没有关系，所有的 hashing scheme 的工作方式都是一样的，因为这是做完 hash 计算，跳转到某个位置时才做的</p>
<p>  Cuckoo 和 Robin Hood Hashing 都是基于 Linear Probe Hashing 做的改进版</p>
<p>  注意这些都是 静态 Hashing Schemes，意味着在分配内存时，一开始就得知道要保存的 key 的数量，在某些情况下，可以猜出这个 hash 取模的基数有多大（key % n，n 就是这个基数）。在进行查询处理或者使用 hash 表进行 join 操作时，需要知道在 hash 表中大概要对多少个 key 进行 hash，然后就可以进行内存分配了</p>
<p>  如果 hash 表容量快满了，就必须对其进行扩容，基本上是扩展到原来的 2 倍。即将第一个 hash 表中所有的 key 复制到第二个 hash 表上，但这样做代价非常高（所有元素重新打散并 hash 存储，代价很高）</p>
<p>  理想情况下，如果大概知道 hash 表的容量上限是多少，也就没必要去做扩容的操作了</p>
<ol>
<li><p>Linear Probe Hashing</p>
<p> <img src="./17.png" alt></p>
<p> Linear Probe Hashing 有时也叫 Open Addressing，即开地址法，它就是一个大型的 slot 表，通过 hash 函数来跳转到该表中的某个 offset 值上，或者是在该表中添加一些 slot</p>
<p> Python 的 Dictionary 背后的数据结构其实就是 hash 表，它就是一个使用了 Linear Probe Hashing 的 hash 表</p>
<p> 如何解决 hash 碰撞？如果在进行 hash 计算所得到的 slot 位置上已经有数据在上面，那么就挨着这条数据往下扫描，直到遇到下一个能插入数据的空 slot 为止（空的 slot 指没有找到 key 对应的 value）</p>
<p> 一个例子</p>
<p> <img src="./18.png" alt><br> <img src="./19.png" alt></p>
<p> slot 上会保留原始的 key/value 对，原始的 key 会有所保留的原因是，当要开始查找时，如果有多个 entry（key/value 对），那么就必须在 slot 上往下扫描，我们需要知道在该 slot 中存放的 key 是不是我们想要的那个，毕竟也没法保证根据 hash 计算得到的 slot 表中的位置就是我们想要的那个准确位置</p>
<p> 比如对 C 进行 hash，但此时 C 落在了之前 A 的位置</p>
<p> <img src="./20.png" alt></p>
<p> 所以此时就直接跳到 A 的下一个位置，然后把 entry（这里指 key/value 对） 插入到那个位置上</p>
<p> <img src="./21.png" alt></p>
<p> 比如插入 E 也是一样的</p>
<p> <img src="./22.png" alt></p>
<p> 那么假设要删除 C，应该怎么做呢？</p>
<p> <img src="./23.png" alt><br> <img src="./24.png" alt></p>
<p> 先对 C 进行 hash，hash 完后，找到的是 A 所在的位置，但这并不是要删除的那个数据，于是继续往下扫描，找到了 C，直接移除</p>
<p> <img src="./25.png" alt></p>
<p> 但是这里会有一个问题</p>
<p> <img src="./26.png" alt></p>
<p> 如果去查找 D，那么它会发现 C 的位置是一个空 slot，那么它就认为它的查找已经完成了，即便这个 D 所对应的数据是在下面的</p>
<p> 所以有两种方式来做移除</p>
<ol>
<li><p>tombstone<br> 即在原来 C 的位置上放一个这个标记，表示这里没有一个 logic entry 了，但从物理上来讲，这个 slot 是被占用了</p>
<p> <img src="./27.png" alt></p>
<p> 当查找 D 时，会落到这个有 tombstone 标记的 slot 上面</p>
<p> <img src="./28.png" alt></p>
<p> 然后虽然这个 slot 中没有数据，但它确实不是空 slot，所以直接跳到下一个</p>
<p> 但，这就浪费了空间。这需要后续清理掉，并用上 fill factor（填充因子）</p>
</li>
<li><p>data movement<br> <img src="./29.png" alt><br> 就是做数据移动，看到有空数据往上移动</p>
<p> <img src="./30.png" alt></p>
<p> 但要记住这个 slot 表是 环形 的</p>
<p> <img src="./31.png" alt></p>
<p> 技术上来讲，B 应该是在 F 后面的，虽然物理上不是，如果像上图中那样，将 B 移动到箭头所指向的位置，可能会导致某些错误发生</p>
<p> <img src="./32.png" alt></p>
<p> 因为 B 原来 hash 的位置是在上面，如果移动到下面的位置，在查找 B 时，会看到那里啥都没有</p>
<p> 所以大部分情况下都会去使用 tombstone，数据移动这种方式实际上很复杂</p>
<p>在实战中，一般使用 n 或者 2n 作为 slot 的数量，n 为要放入 key 的数量</p>
</li>
</ol>
</li>
<li><p>Robin Hood Hashing</p>
<p> 在了解这个之前，得先了解 Non-Unique Keys，即非唯一 Key，因为在实际的数据集中，没办法假设所有的 Key 都是唯一的，所以需要在 hash 表中对它们进行处理，有 2 种方法可以做到</p>
<p> 第 1 种方法是，维护一个单独的链表，上面保存了所有的值。即在 hash 表中的 key 会指向属于该 key 的单独链表，该链表上所保存的 value 对应的都是同一个 key</p>
<p> <img src="./33.png" alt></p>
<p> 第 2 种方法是，保存冗余的 key，这也是最常见的。即在 slot 数组中不断地复制这个 key</p>
<p> <img src="./34.png" alt></p>
<p> 在实战中，第 2 种方法用的多</p>
<p> Bobin Hood Hashing 是在 1985 年提出的，出自当时一篇无人问津的 paper，然后过去 10 年，它在 Hacker News 上出现过几次。而 Bobin Hood（罗宾汉）是一个英国的民间传说，讲述的是一个劫富济贫的侠盗的故事。那么 Bobin Hood Hashing 做的事情也是类似的，就是会让那些 “poor” key 从 “rich” key 身上偷取 slot</p>
<p> <img src="./35.png" alt></p>
<p> Number of Positions（距离数）表示的是你所在的位置与你第一次进行 hash 所计算出的位置之间的距离差。</p>
<p> 距离数越大，越 “poor”，反之越 “rich”</p>
<p> 基本思路是，对整个 hash 表进行平衡，尝试让每个 key 都尽可能靠近它原本所在的位置。即对所有的 key 来讲，在全局状态下尽可能快地找到它们，而不是针对于某一个。</p>
<p> 一个例子</p>
<p> <img src="./36.png" alt></p>
<p> 在插入数据 A 时，可以记录下数据 A 实际所在的位置与第一次 hash 计算出的原始位置所差的跳转次数</p>
<p> 第一次插入 A 时，跳转次数为 0，所以是 A | val[0]，对于 B 也是一样</p>
<p> C 要插入时，本来要插 A 的位置，但因为 A 的位置不是空的，所以它插入到 A 的下一位</p>
<p> <img src="./37.png" alt></p>
<p> 所以是 C | val[1]，因为 C 当前所在的位置距离它第一次通过 hash 所得出的位置相差 1 个单位</p>
<p> 对于 D 来说也是一样的</p>
<p> <img src="./38.png" alt></p>
<p> 而对于 E</p>
<p> <img src="./39.png" alt></p>
<p> 因为 E 需要跳转 2 次才能达到 D 跳转一次的位置（D 跳转一次就到它原本第一次 hash 计算出来的位置了），E[2] &gt; D[1]，所以 E 比 D 要更 “poor”，所以 E 就要去 偷 D 所在的 slot 的位置，并插入其中</p>
<p> <img src="./40.png" alt></p>
<p> 那么现在就只能将 D 插入到 E 的下面了，并将 D | val[1]，更新为 D | val[2]</p>
<p> <img src="./41.png" alt></p>
<p> 而 F 就是放到 D 下面</p>
<p> <img src="./42.png" alt></p>
<p> 这种方法会使得写入或者插入的代价更高，因为这种方式进行了多次写入的操作，而 Linear Probe Hashing 只需要一次写入</p>
<p> 但是在该算法下，需要对更多的条件进行检查，看看能否将一个放到另一个的位置上，只要有一次条件误判，就会付出巨大的代价。更多的写入操作带来更多的缓存无效。所以在实战中，还是优先使用 Linear Probe Hashing，它依然是最快的方法</p>
</li>
<li><p>Cuckoo Hashing</p>
<p> <img src="./43.png" alt></p>
<p> 思路是，使用多个 hash 表，然后要做的是该判断往哪个 hash 表中插入 key，即哪个 hash 表能提供一个空余的 slot</p>
<p> 在 Cuckoo Hashing 中，查找和删除的时间复杂度始终是 O(1)，这意味着当进行查找时，始终都会跳到 hash 表上，准确地找到那个数据</p>
<p> 但插入操作的代价可能更高，因为要判断是在 hash 表 1 中还是 hash 表 2 中进行存储等操作</p>
<p> 例子</p>
<p> 注意大多数人在使用 Cuckoo Hashing 时，通常都只使用 2 个 hash 表</p>
<p> 对于 Cuckoo Hashing 中的每个 hash 表来说，必须为 hash 函数提供一个单独的 hash seed，拿到 key 之后，对它 hash 2 次（这里对同一个 key，给 hash 函数不同的 seed，那么就会生成不同的 hash 值）</p>
<p> <img src="./44.png" alt></p>
<p> 这个时候要插入 B 了</p>
<p> <img src="./45.png" alt></p>
<p> 但是在 hash 表 1 中，对应的位置已经有 A 了，这个时候就选择 hash 表 2 插入</p>
<p> <img src="./46.png" alt></p>
<p> 这个时候插入 C</p>
<p> <img src="./47.png" alt></p>
<p> 但现在 hash1(C) 和 hash2(C) 的位置都被 A 和 B 占了，这个时候该怎么办呢？</p>
<p> 答案是随机选一个，这里选的是 hash 表 2，然后移除掉 B，插入 C</p>
<p> <img src="./48.png" alt></p>
<p> 那么 B 怎么办呢？重新 hash 一下 B，抢走 A 的 slot</p>
<p> <img src="./49.png" alt></p>
<p> 那么 A 怎么办呢？重新 hash 一下 A，把 A 放到 hash 表 2 中的一个空 slot 的地方</p>
<p> <img src="./50.png" alt></p>
<p> 但这个方式存在 递归碰撞，即有可能在碰到最后一个元素后，又碰到最初的那个元素去了，这种情况下，需要扩容（卧槽，这 tm 扩容。。。）</p>
</li>
</ol>
</li>
<li><p>动态 Hash 表</p>
<p>  <img src="./51.png" alt></p>
<p>  动态 hash 表能够在无须重建整个东西的情况下，根据需要调整大小，比如 chained hash table，这是最常用的一种动态 hash 表</p>
<ol>
<li><p>Chained Hash 表</p>
<p> <img src="./52.png" alt></p>
<p> 也叫 chained hashing/bucket hash table，里面主要维护了一个包含了 bucket 的链表，通过将具有相同 hash key 的所有元素放入相同的 bucket 来解决冲突，也就是在 bucket list 末尾追加，所以每个 bucket chain 都可以永远扩容下去</p>
<p> 所以要查找的话，也只能循环扫描了</p>
<p> 例子</p>
<p> <img src="./53.png" alt></p>
<p> 可以将这些 bucket 当作是 page</p>
</li>
<li><p>Extendible Hashing</p>
<p> <img src="./54.png" alt></p>
<p> 基于 chained hash 表的思想，但是不同于它的无限扩容，Extendible Hashing 要做是将链表逐步拆分</p>
<p> 这里 “拆分” 的意思也跟 “重建” 差不多，也要进行一波扩容并重新 hash 的操作，但这里只是对 某个独立的局部 进行操作</p>
<p> 要拆分的只是那些要 overflow 的 chain，而不是整个 hash 表</p>
<p> 拆分完那些 overflowed bucket 之后，在其对应的 slot array 中，允许多个 slot 指向同一个 bucket chain</p>
<p> 优势是，在移动数据时，只需要移动那些 overflowed 的 bucket 就行</p>
<p> 例子</p>
<p> 要有 1 个 全局 counter，它负责 bit 的数量，即负责需要看几个 bit 才能去找对应的 bucket</p>
<p> <img src="./55.png" alt></p>
<p> 而对于每个 bucket chain 或者每个 bucket，给它们一个局部的 counter，表示需要看几个 bit 才能找到该位置</p>
<p> <img src="./56.png" alt></p>
<p> 在这个例子中，第 1 个 bucket 中的局部 counter 的值是 1，表示只需要看 1 bit 就能定位到这个 bucket</p>
<p> 这就是为啥你看那个蓝色圈出来的 bit，看 00 和 01 时，它们俩都会映射到同一个 bucket，因为它们第 1 个 bit 都是 0，因为这个 bucket 存在 overflow 的情况，还没有对它进行拆分</p>
<p> 另外 2 个 bucket 拥有的分别是蓝色圈出来的 10 和 11，因为它们的局部 counter 的值是 2，也就是说需要看 2 个 bit 才行</p>
<p> 现在假设要查找 A</p>
<p> <img src="./57.png" alt></p>
<p> 注意这里生成的 hash 是一堆 bit 序列</p>
<p> 然后看下全局 counter，它会检查这个 hash 函数生成的 bit 序列中的前多少位，以此来决定要跳转到哪个 bucket</p>
<p> <img src="./58.png" alt></p>
<p> 例子中全局 counter 的值是 2，那么只需要看这个 bit 序列的前 2 位，即 01，然后在 slot array 中查找</p>
<p> <img src="./59.png" alt></p>
<p> 找到 01，跟着指针，就找到了对应的那个 bucket</p>
<p> <img src="./60.png" alt></p>
<p> 如果这个时候要插入 B</p>
<p> <img src="./61.png" alt></p>
<p> 因为全局 counter 是 2，那么看 B 的前 2 位，是 10，跟着 slot array 中 10 指的位置，第 2 个 bucket 那儿有一个空余的位置，插入它即可</p>
<p> 如果这个时候要插入 C</p>
<p> <img src="./62.png" alt></p>
<p> C 目前要插入的位置是第 2 个 bucket，但是此时第 2 个 bucket 没空间了，它变成 overflowed 的了，所以现在必须要对它进行拆分</p>
<p> 怎么拆分呢？</p>
<p> 先把全局 counter 增加到 3</p>
<p> <img src="./63.png" alt></p>
<p> 然后将 slot array 扩容到原来的 2 倍，这样就可以处理 3 bit 的情况了</p>
<p> <img src="./64.png" alt></p>
<p> 注意，这个 slot array 的扩容操作代价很低，因为这只是一个指针数组，可以在上面用一个 latch 来保护它，调整完大小再将数据放回去，无须移动 bucket 中的数据</p>
<p> <img src="./65.png" alt></p>
<p> 如上图，对 bucket 进行重构，将保存在这些单个 page 上的数据进行拆分，并根据局部 counter 中的值，将它们重新映射</p>
<p> 现在再尝试插入 C</p>
<p> <img src="./66.png" alt></p>
<p> 3 个 bit，C 的 hash 结果的前 3 位是 101，找到 slot array 中 101 的位置，跟着它的指针，即能找到对应位置插入</p>
<p> 注意这里并没有对全部的 bucket 进行拆分，而只是拆分了之前那个 overflowed 的 bucket，即之前的第 2 个</p>
<p> 删除操作其实就是将插入操作逆向执行</p>
<p> 每个 bucket 就是 page</p>
<p> Buffer 池中可能存储的是一张表下涉及的多个 page 的数据条目，也可能是多个表下的部分数据条目</p>
</li>
<li><p>Linear Hashing</p>
<p> <img src="./67.png" alt></p>
<p> Extendible Hashing 存在一个小问题，就是要拆分 overflowed bucket 时，需要将 slot array 扩容为原来的 2 倍大，在调整 slot array 的大小时，需要在上面使用一个 latch，这样能保证直到重新分配完所有的数据为止，其他人不会对其进行读写</p>
<p> 这会成为一个性能瓶颈，因为这个 hash 表同一时间可能会被多个人访问</p>
<p> Linear Hashing 的思路是，只需要去重新分配那些 overflowed bucket 即可，没必要去用一个全局的 latch 来阻止所有人访问这个 hash 表</p>
<p> 那么如何做到呢？</p>
<p> Linear Hashing 会去维护多个 hash 函数，这些 hash 函数的工作方式和之前讲到的 Cuckoo Hashing 中相同，用不同的 seed 对给定的 key 生成不同的 hash 值，然后找到那个对应的 bucket</p>
<p> 这里需要维护一个新的东西，叫 split pointer，它会去跟踪那个要进行 split 的 overflowed bucket</p>
<p> 例子</p>
<p> <img src="./68.png" alt></p>
<p> 初始状态下，这个 split pointer 指向 slot array 的第 0 个</p>
<p> <img src="./69.png" alt></p>
<p> 此处 hash 函数中的 n 即拥有的 entry 的数量</p>
<p> 假设现在要去查找 key 为 6 的相关数据</p>
<p> <img src="./70.png" alt></p>
<p> 6 % 4 = 2，那么在 slot array 中就是 2 所在的位置，顺着其指针找，找到第 3 个 bucket，然后在 bucket 中顺序查找比对 key，就找到了对应的位置</p>
<p> 假设现在要插入 17</p>
<p> <img src="./71.png" alt></p>
<p> 那么 17 % 4 就是 1，找到 slot array 中 1 所在的位置，顺着其指针找，找到第 2 个 bucket，但在这个 bucket 中，没有空余的 slot，那么怎么办呢？创建一个 overflow bucket，在这个上面放 17 这个值</p>
<p> <img src="./72.png" alt></p>
<p> 因为现在创建了一个 overflowed bucket，就相当于触发了一次 overflow，所以现在不管这个 split pointer 指向的是哪个 bucket，对应 bucket 现在都要进行一次拆分，比如图中的第一个 bucket，哪怕这个 bucket 还可以存数据</p>
<p> 拆分的工作方式是这样的</p>
<p> <img src="./73.png" alt></p>
<p> 在 slot array 的地方再增加一个 entry，也就是新增了一个格子 4。用一个新的 hash 函数，即 key % 2n，而这个 split pointer 会帮助我们跟踪，该使用第 1 个还是第 2 个 hash 函数，它也会告诉我们，在 slot array 中，拆分 bucket 的距离有多远</p>
<p> <img src="./74.png" alt></p>
<p> 然后在 slot array 为 4 的位置，新增一个 bucket，把 20 放入这个新增的 bucket 中。</p>
<p> <img src="./75.png" alt></p>
<p> 然后将这个 split pointer 下移一个单位</p>
<p> 那么如果此时再想进行一次查找时，首先用第一个 hash 函数对其进行 hash</p>
<p> <img src="./76.png" alt></p>
<p> 如果此时 hash 得到的结果所指向的位置时在 split pointer 所在的这条分界线之上，那么就知道正在查找的那个 bucket 已经被拆分了</p>
<p> <img src="./77.png" alt></p>
<p> 因此现在就应该使用第 2 个 hash 函数来去找数据，因为数据肯定不在原来要拆分的那个 bucket 上</p>
<p> 如果是查找 9 ，逻辑也是一样的</p>
<p> <img src="./78.png" alt></p>
<p> 9 % 4 = 1，因为在 1 所在 slot array 的那个位置 在 split pointer 分界线之下，所以它是没有被拆分的，所以使用第一个 hash 函数是对的，那么就可以顺着指针直接去找了</p>
<p> 然而算法最糟糕的情况是，每个人都往同一个 bucket 中插入数据，这会导致它花了很长时间对 bucket 进行拆分，但使用一个具备低碰撞率的优秀 hash 函数的话，可以解决这个问题</p>
<p> 如果进行删除操作，split pointer 会往回移动，不过如果要实现会相当棘手</p>
<p> 例子</p>
<p> 假设现在要删除 20</p>
<p> <img src="./79.png" alt></p>
<p> 如果用第 1 个 hash，那么它算出来就是 0，但此处的位置是在 split pointer 的分界线之上，所以需要用第 2 个 hash</p>
<p> <img src="./80.png" alt></p>
<p> 于是在 slot array 的 4 这个位置，delete 对应的 bucket 里的 20</p>
<p> <img src="./81.png" alt></p>
<p> 那么这个 bucket 就空了，如果要回收，就是反向操作</p>
<p> 首先清掉这个空 bucket，并且清掉指针</p>
<p> <img src="./82.png" alt></p>
<p> 然后将 split pointer 往回移动一个单位</p>
<p> <img src="./83.png" alt></p>
<p> 现在，分界线消失了，第 2 个 hash 函数也没了，内存回收完毕</p>
<p> <img src="./84.png" alt></p>
<p> （这里 4 的消失，我认为也是随着指针清空然后这个也被 remove 掉了）</p>
<p> 如果回收完后 紧接着 是下面这种情况，在 overflowed bucket 中插入一个 21</p>
<p> <img src="./85.png" alt></p>
<p> 就会触发 overflow（因为 slot array 的位置 1 对应的 bucket 放不下，要放到其 overflow bucket 中），那么又要根据算法拆分 bucket</p>
<p> 算法做了很多事情让插入更快，但很难做到快速删除</p>
</li>
</ol>
</li>
</ul>
</li>
<li><p>结论</p>
<p>  <img src="./86.png" alt></p>
<p>  hash 表没办法比较 key 的大小，所以不适合用于表索引的一些场景</p>
<p>  相反，在创建索引时，最常用的就是 B+ Tree</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Database</category>
      </categories>
      <tags>
        <tag>Database</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS入门</title>
    <url>/2019/01/11/CSS%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h2 id="CSS-历史"><a href="#CSS-历史" class="headerlink" title="CSS 历史"></a>CSS 历史</h2><p>CSS 层叠样式表 Cascading Style Sheets<br>1994 年，哈肯提出 CSS 的最初建议，1997 年，W3C 开始接管 CSS，1998 年，CSS2.1 被发表出来，修改了 2.0 中基本不被支持的内容，增加了一些已有的浏览器的扩展内容</p>
<p>我们不管 IE8 !!!</p>
<p>CSS3 从 2011 年开始被分为多模块单独分级</p>
<ul>
<li>CSS 选择器 Level3</li>
<li>CSS 媒体查询 Level3</li>
<li>CSS Color Level3</li>
<li>…</li>
</ul>
<p>google 上搜索 css spec</p>
<p>周边工具<br>LESS CSS: 一种简化的功能更多的 CSS 语言<br>SASS: 一种简化的功能更多的 CSS 语言<br>PostCSS: 一种 CSS 处理程序</p>
<h2 id="添加-CSS"><a href="#添加-CSS" class="headerlink" title="添加 CSS"></a>添加 CSS</h2><ul>
<li>style 属性，内联样式，就是将样式写在标签上</li>
<li>直接在 head 标签包起来的区域中写 style 标签</li>
<li><p>新建一个外部 .css 文件，在这个文件中写 CSS 代码，然后在主 html 中引入这个 .css 文件，引用的方式为，就是加入 css link:</p>
  <figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">&lt;link <span class="attribute">rel</span>=<span class="string">"stylesheet"</span> <span class="attribute">href</span>=<span class="string">"./a.css"</span>&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在 CSS 中引入另一个 CSS，具体操作就是在需要被引入的 CSS 文件中加入(这种方法比较少用)</p>
  <figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@import</span> url(<span class="string">./b.css</span>);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="CSS-优先级"><a href="#CSS-优先级" class="headerlink" title="CSS 优先级"></a>CSS 优先级</h2><p>从上到下，优先级递减</p>
<ol start="0">
<li>内联样式(html 标签元素中的 style 属性)</li>
<li>id 选择器(#xxx)</li>
<li>类选择器(.xxx), 属性选择器([type=”xxx”]), 伪类(:hover)</li>
<li>类型选择器(div),伪元素(::after)</li>
</ol>
<p>对优先级没有影响的</p>
<ul>
<li>通配符(*)</li>
<li>关系选择符(+ &gt; ~ ‘ ‘) </li>
<li>否定伪类(:not())</li>
</ul>
<p>对优先级有影响的</p>
<ul>
<li>在 <code>:not()</code> 内部声明的选择器会影响优先级</li>
</ul>
<p>注意，每种选择器的优先级都是通过计算其 <em>特殊性</em> 来得到一个 <em>特殊性值</em> ,然后通过比较这个值来排优先级</p>
<p>那么考虑到一种极端情况是，假如计算出来的这个 特殊性值 都一样怎么办?</p>
<ul>
<li>看它有没有 <code>!important</code>,若有，则它直接变成最高优先级(但是不到万不得已不要使用，因为这回破坏样式表中原来优先级规则，会加大调试难度)</li>
<li>看来源排序，一般这种排序的顺序为: <code>创作人员的样式 &gt; 读者人员的样式 &gt; 用户代理的默认样式</code></li>
<li>若以上比较还相同，则看样式的配置顺序了，越靠后的优先级越高(因为会覆盖)</li>
</ul>
<h2 id="CSS-选择器"><a href="#CSS-选择器" class="headerlink" title="CSS 选择器"></a>CSS 选择器</h2><p>这里列举一下比较常用的</p>
<h3 id="基本选择器"><a href="#基本选择器" class="headerlink" title="基本选择器"></a>基本选择器</h3><ol>
<li>通配选择器<br>也就是 <code>*</code>,选中所有的元素</li>
<li><p>类选择器<br>也就是选择标签中含有该类名的元素, 比如有这样的标签 <code>&lt;div class=&quot;xxx&quot;&gt;&lt;/div&gt;</code> , 那么选中它就可以写成</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.xxx</span> &#123;</span><br><span class="line">    <span class="comment">/* css 代码 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>元素选择器<br>也就是标签名,类似于 <code>main</code>, <code>div</code>, 一般最好指定它的上一层父级使用,也可以结合其他选择器使用</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">main</span> &gt; <span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="comment">/* css 代码 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">main</span> &gt; <span class="selector-tag">div</span><span class="selector-class">.xxx</span> &#123;</span><br><span class="line">    <span class="comment">/* css 代码 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>id 选择器<br>也就是选择标签中含有该 id 名的元素，注意这里一个页面中不能有重复的 id 名, 比如有这样的标签 <code>&lt;div id=&quot;xxx&quot;&gt;&lt;/div&gt;</code></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#xxx</span> &#123;</span><br><span class="line">    <span class="comment">/* css 代码 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>群组选择器<br>也叫 “大家都一样选择器”,假如想要选择的多个类名所对应的标签都具有相同的样式, 可以这么写</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.xxx</span>, <span class="selector-class">.yyy</span>, <span class="selector-class">.zzz</span> &#123;</span><br><span class="line">    <span class="comment">/* css 代码 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>注意中间是用 <em>逗号</em> 隔开的</p>
<h3 id="层次选择器"><a href="#层次选择器" class="headerlink" title="层次选择器"></a>层次选择器</h3><p>两种常用的如 <code>xxx yyy</code>, <code>xxx&gt;yyy</code></p>
<ol>
<li><code>xxx yyy</code><br>选择 xxx 元素中包含的 <em>所有的</em> yyy 元素</li>
<li><code>xxx&gt;yyy</code><br>选择 xxx 元素中 <em>第一层</em> 中包含的 <em>所有的</em> yyy 元素(提示: DOM 的结构是一颗树的结构)</li>
</ol>
<p>两种不常用的如 <code>xxx+yyy</code>, <code>xxx~yyy</code></p>
<ol>
<li><code>xxx+yyy</code><br><em>同一级下</em>,选择 xxx 元素旁边 <em>第一个</em> yyy 元素(提示: 想像一颗 DOM 树，从左往右寻找)</li>
<li><code>xxx~yyy</code><br><em>同一级下</em>,选择 xxx 元素旁边 <em>所有的</em> yyy 元素(提示: 想像一颗 DOM 树，从左往右寻找)</li>
</ol>
<p>点击这儿 <a href="http://js.jirengu.com/qesokalemu/1/edit" target="_blank" rel="noopener">demo 链接</a></p>
<h3 id="属性选择器"><a href="#属性选择器" class="headerlink" title="属性选择器"></a>属性选择器</h3><ul>
<li><code>[attr]</code>: 只要是具有 attr 属性的元素，我全都要!!</li>
<li><code>xxx[attr]</code>: 选择具有 attr 属性的 xxx 元素</li>
<li><code>xxx[attr=value]</code>: 选择具有 attr 属性同时该属性值为 value 的 xxx 元素</li>
<li><code>xxx[attr|=value]</code>: 选择具有 attr 属性该属性值 <em>可以为 value 也可以为 value- 开头</em> 的 xxx 元素</li>
<li><p><code>xxx[attr~=value]</code>: 选择具有 attr 属性同时该属性值中 <em>有多个空格</em> (就像一句话,该 value 为这句话中的某个单词) 的 xxx 元素</p>
<p>  举个栗子: <code>&lt;a href=&quot;http://www.baidu.com&quot; title=&quot;xxx yyy zzz&quot;&gt;&lt;/a&gt;</code><br>  则对应 <code>a[title~=&quot;xxx&quot;]</code> 或 <code>a[title~=&quot;yyy&quot;]</code> 或 <code>a[title~=&quot;zzz&quot;]</code></p>
</li>
<li><p><code>xxx[attr*=value]</code>: 选择具有 attr 属性同时该属性值 <em>任意位置都有value</em> 的 xxx 元素</p>
</li>
<li><code>xxx[attr^=value]</code>: 选择具有 attr 属性同时该属性值为 <em>以 value 开头的任何字符串</em> 的 xxx 元素</li>
<li><code>xxx[attr$=value]</code>: 选择具有 attr 属性同时该属性值为 <em>以 value 结尾的任何字符串</em> 的 xxx 元素</li>
</ul>
<h3 id="伪类选择器"><a href="#伪类选择器" class="headerlink" title="伪类选择器"></a>伪类选择器</h3><p>什么是伪类选择器？了解这个之前，应该了解下什么是伪类？mdn 的解释就是 “CSS 伪类是添加到选择器的关键字，指定要选择的元素的特殊状态。例如，:hover 可被用于在用户将鼠标悬停在按钮上时改变按钮的颜色”</p>
<p>那么所谓的伪类选择器就是在这个 “:hover” 之前加了一个<em>基本选择器</em>，比如 “button:hover”</p>
<p>主要有 动态伪类选择器，目标伪类选择器，元素状态伪类选择器，结构伪类选择器，否定伪类选择器</p>
<h4 id="动态伪类选择器"><a href="#动态伪类选择器" class="headerlink" title="动态伪类选择器"></a>动态伪类选择器</h4><p>选择元素为 xxx 的 a 标签中的超链接时:<br><code>xxx:link</code>: 表示该超链接没有被访问过<br><code>xxx:visited</code>: 表示该超链接已经被访问过<br>选择元素为 xxx 时，不管有没有超链接:<br><code>xxx:hover</code>: 表示该元素被鼠标悬停选中<br><code>xxx:active</code>: 表示该元素被激活<br><code>xxx:focus</code>: 表示该元素获得焦点</p>
<p>注意对该伪类的设置要遵循 link&gt;visited&gt;hover&gt;active 的规则(若你设置中出现了 link 或 visited),即你应该这样写代码<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">xxx</span><span class="selector-pseudo">:link</span> &#123;<span class="comment">/* css 代码*/</span>&#125;</span><br><span class="line"><span class="selector-tag">xxx</span><span class="selector-pseudo">:visited</span> &#123;<span class="comment">/* css 代码*/</span>&#125;</span><br><span class="line"><span class="selector-tag">xxx</span><span class="selector-pseudo">:active</span> &#123;<span class="comment">/* css 代码*/</span>&#125;</span><br><span class="line"><span class="selector-tag">xxx</span><span class="selector-pseudo">:hover</span> &#123;<span class="comment">/* css 代码*/</span>&#125;</span><br></pre></td></tr></table></figure></p>
<p>因为下面的 css 代码优先级会高一些，若调换顺序，则 css 代码不会生效,这应当是一个常识问题</p>
<h4 id="目标伪类选择器"><a href="#目标伪类选择器" class="headerlink" title="目标伪类选择器"></a>目标伪类选择器</h4><p>经常这样使用<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">xxx</span><span class="selector-pseudo">:target</span> &#123;<span class="comment">/* css 代码 */</span>&#125;</span><br></pre></td></tr></table></figure></p>
<p>或者<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">xxx</span><span class="selector-pseudo">:target</span> <span class="selector-tag">yyy</span> &#123;<span class="comment">/* css 代码 */</span>&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样做有什么用呢，一般用来 <em>选中 xxx 元素中的 a 标签中的 href 指向的锚点</em><br>点击这儿<a href="http://js.jirengu.com/feladahaqu/1/edit" target="_blank" rel="noopener">demo 链接</a></p>
<h4 id="元素状态伪类选择器"><a href="#元素状态伪类选择器" class="headerlink" title="元素状态伪类选择器"></a>元素状态伪类选择器</h4><p>一般用在表单元素上</p>
<ul>
<li><code>xxx:checked</code>: 选择选中的复选或单选按钮</li>
<li><code>xxx:enabled</code>: 选择所有启用的表单元素</li>
<li><code>xxx:disabled</code>: 选择所有禁用的表单元素</li>
</ul>
<p>一般是这样用<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">input</span><span class="selector-pseudo">:checked</span> &#123;<span class="comment">/* css 代码 */</span>&#125;</span><br><span class="line"><span class="selector-tag">input</span><span class="selector-pseudo">:enabled</span> &#123;<span class="comment">/* css 代码 */</span>&#125;</span><br><span class="line"><span class="selector-tag">input</span><span class="selector-pseudo">:disabled</span> &#123;<span class="comment">/* css 代码 */</span>&#125;</span><br><span class="line"><span class="selector-tag">input</span>:<span class="selector-attr">[type=<span class="string">"text"</span>]</span> &#123;<span class="comment">/* css 代码 */</span>&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="结构伪类选择器"><a href="#结构伪类选择器" class="headerlink" title="结构伪类选择器"></a>结构伪类选择器</h4><p>假设有很多 xxx 元素排列在一起, 如 xxx xxx xxx xxx xxx xxx</p>
<ul>
<li><code>xxx:first-child</code> : 这个指这么多 xxx 元素的 <strong>第一个</strong></li>
<li><code>xxx:last-child</code> : 这个指这么多 xxx 元素的 <strong>最后一个</strong></li>
<li><code>xxx:nth-child(n)</code> : 这个指这么多 xxx 元素的 <strong>第 n 个</strong></li>
<li><code>xxx:nth-last-child(n)</code> : 这个指这么多 xxx 元素的 <strong>倒数第 n 个</strong></li>
<li><code>xxx:first-of-type</code>: 这个指这么多 xxx 元素的 <strong>指定的第一个</strong></li>
<li><code>xxx:last-of-type</code>: 这个指这么多 xxx 元素的 <strong>指定的最后一个</strong></li>
<li><code>xxx:nth-of-type(n)</code> : 这个指这么多 xxx 元素的 <strong>指定的第 n 个</strong></li>
<li><code>xxx:empty</code>: 就是选择没有 xxx 元素的的元素(<strong>文本节点都不能包含</strong>)</li>
</ul>
<p>其中，若 xxx 元素是这样排列的 xxx xxx yyy xxx yyy xxx xxx<br>那么 <code>xxx:nth-child(3)</code> 并不会选中该元素，如上第三个是 yyy，而 <code>xxx:nth-of-type(3)</code> 就可以，这就说明一点，前者匹配的规则要比后者严格</p>
<p>一些小技巧:</p>
<ul>
<li>无论是使用 <code>nth-child(n)</code> 或是使用 <code>nth-type-of(n)</code>,其中的 n 都可以这么写(若提前知道了一共有多少个排列的元素)</li>
</ul>
<figure class="highlight excel"><table><tr><td class="code"><pre><span class="line"><span class="built_in">n</span> * 元素个数</span><br><span class="line"><span class="built_in">n</span> + 元素个数</span><br><span class="line">-<span class="built_in">n</span> * 元素个数</span><br><span class="line"><span class="built_in">n</span> * 元素个数 + 一个数</span><br></pre></td></tr></table></figure>
<p>以上 n 的取值范围为 0,1,2,…</p>
<ul>
<li>想要取奇数元素或者偶数元素???可以这么写</li>
</ul>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">nth-child</span><span class="params">(odd)</span></span> <span class="comment">/*取奇数*/</span></span><br><span class="line"><span class="function"><span class="title">nth-child</span><span class="params">(even)</span></span> <span class="comment">/*取偶数*/</span></span><br></pre></td></tr></table></figure>
<h4 id="否定伪类选择器"><a href="#否定伪类选择器" class="headerlink" title="否定伪类选择器"></a>否定伪类选择器</h4><p><code>xxx:not(yyy)</code>: 表示选择除了 yyy 元素之外的 xxx 元素,可以这么用</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 选中不是 type 为 submit 的 input 元素*/</span></span><br><span class="line"><span class="selector-tag">input</span><span class="selector-pseudo">:not(</span><span class="selector-attr">[type=submit]</span>) &#123;<span class="comment">/* css 代码 */</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 选中不是 hover 状态的 div 元素 */</span></span><br><span class="line"><span class="selector-tag">div</span><span class="selector-pseudo">:not(hover)</span> &#123;<span class="comment">/* css 代码 */</span>&#125;</span><br></pre></td></tr></table></figure>
<h2 id="伪元素"><a href="#伪元素" class="headerlink" title="伪元素"></a>伪元素</h2><p>什么是伪元素？？其实就是为了和伪类分开(伪类用的符号是 <code>:</code>),伪元素用的符号就是 <code>::</code><br>一般经常使用到的就是 <code>::before</code> 和 <code>::after</code> 了,作用就是为当前元素插入其他内容,比如如下的用法<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">a</span><span class="selector-attr">[href^=http]</span><span class="selector-pseudo">::after</span>&#123;</span><br><span class="line">    <span class="attribute">content</span>:<span class="string">"("</span> <span class="built_in">attr</span>(href) <span class="string">")"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>若 a 标签是这么写的 <code>&lt;a href=&quot;http://www.baidu.com&quot;&gt;baidu&lt;/a&gt;</code>, 那么它最终会显示成 <code>baidu(http://www.baidu.com)</code></p>
<p>这里需要强调一点的就是，<strong>::after/::before 生成的内容不会成为 DOM 的一部分</strong>,此时若我们想粘贴复制这个地址当然是不行的</p>
<p>想其他的伪类还有 <code>::first-letter</code>, <code>::first-line</code> 之类的, mdn 上都都有就不多研究了</p>
<h2 id="CSS-学习资源"><a href="#CSS-学习资源" class="headerlink" title="CSS 学习资源"></a>CSS 学习资源</h2><ol>
<li>google: 关键字 + MDN</li>
<li>CSS Tricks</li>
<li>google: 阮一峰 CSS</li>
<li>张鑫旭的 240 多篇关于 CSS 的博客</li>
<li>Codrops 炫酷 CSS 效果</li>
<li>CSS 揭秘这本书</li>
<li>CSS 2.1 中文 spec</li>
</ol>
<p>举例，可以使用 google 搜索 center css tricks 查看这个居中的 CSS 方法</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Specificity" target="_blank" rel="noopener">优先级</a><br><a href="https://developer.mozilla.org/zh-CN/search?" target="_blank" rel="noopener">其他参考</a></p>
]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>CMU-15-445-645-笔记-05-Buffer池与内存管理</title>
    <url>/2022/06/05/CMU-15-445-645-%E7%AC%94%E8%AE%B0-05-Buffer%E6%B1%A0%E4%B8%8E%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<blockquote>
<p>注: 本文首发我的 b 站专栏文章<a href="https://www.bilibili.com/read/cv14580880" target="_blank" rel="noopener">CMU 15-445/645-笔记-05-Buffer池与内存管理</a></p>
</blockquote>
<a id="more"></a>
<p><img src="./Cover.png" alt></p>
<ul>
<li><p>课程目标</p>
<p>  <img src="./1.png" alt></p>
</li>
<li><p>上节课回顾</p>
<p>  <img src="./2.png" alt></p>
<p>  画红线的部分</p>
<ol>
<li>想要能够去支持超出我们所拥有的内存容量大小的数据库</li>
<li>最小化在磁盘上执行查询时速度缓慢带来的影响</li>
</ol>
<ul>
<li><p>数据库 Workloads</p>
<p>  <img src="./3.png" alt></p>
<p>  HTAP（混合事务分析处理 Hybrid Transaction Analytical Processsing），是几年前 Gartner 发明的一个新流行词，它所描述的是既做 OLTP 又做 OLAP 的数据库系统</p>
</li>
<li><p>Bifurcated Environment</p>
<p>  <img src="./4.png" alt></p>
<p>  一般数据库的标准配置是这样的</p>
<ol>
<li>前端 OLTP 数据库</li>
<li><p>后端 OLAP 大型数据仓库（back-end data warehouse）</p>
<p>这两者有时候被称为 Data Silo，即数据孤岛，数据存储相互独立，彼此之间不会真的交流</p>
<p><img src="./5.png" alt></p>
<p>然后就可以进行 ETL（Extract Transform Load） 的操作，即将业务系统的数据经过抽取、清洗、转换之后加载到数据仓库的过程</p>
<p>以 Zynga 这家游戏公司为例，Zynga 收购了很多游戏初创公司，比如 FarmVille，它买下这些公司时，会去运行他们自己的前端 OLTP 数据库，只有他们将这些数据放入他们的后端大型仓库时，他们才能更高地分析出怎么做才能让你们在 FarmVille 上买东西</p>
<p>等后端 OLAP 数据仓库拿到分析后的信息数据后，就推到前端 OLTP 数据库中，并对外暴露</p>
<p><img src="./6.png" alt></p>
<p>所以 HTAP 基本上在做一些平常只能在 OLAP 端所做的，可以直接在前端的 Data Silo 里面做这些，并且不用等数据传回到后端数据仓库了</p>
<p>这可以用 MySQL、PostgreSQL、mongoDB 来做前端数据库，可以用 Hadoop、Spark、Greenplum、Vertica 来做后端数据仓库</p>
</li>
</ol>
</li>
<li><p>数据库存储</p>
<p>  <img src="./7.png" alt></p>
<ol>
<li>空间管理<br> 这里指的是在哪里将数据写入磁盘</li>
<li>时间管理<br> 这里指的是什么时候将 pages 读入内存</li>
</ol>
</li>
<li><p>面向磁盘的 DBMS</p>
<p>  <img src="./8.png" alt></p>
<p>  如果执行引擎在请求 page 时，内存中没有足够的空余来容纳我们需要的那个 page，这个时候就必须要决定哪个 page 进行写出操作，即 “remove”，而这正是 Buffer 池要解决的问题</p>
<p>  系统的其他部分无须知道或者关系哪些东西在内存里，哪些东西不在，它只会等它需要拿到的东西，然后返回一个指针给到执行引擎</p>
</li>
</ul>
</li>
<li><p>Buffer 池的组织</p>
<p>  <img src="./9.png" alt></p>
<p>  Buffer 池需要我们在数据库系统内部分配一块很大的内存，就是调用 malloc，拿到一些内存块，并将从磁盘中读取到的所有的 pages 都放到这个里面去。注意这段内存完全是由数据库系统来控制，而不是交给操作系统来做。</p>
<p>  然后，这段内存区域被分成一个个固定大小的 chunk，它被称为 frame，frame 对应的是之前提到的 slot（slot 存储的虽然是对应 tuple 的 offset，但对外来看，相当于指代了一段存储区域），即 Buffer 池内存区域中的区块或者是 chunk，frame 里存放的是 page</p>
<p>  当数据库系统发出一个请求 page 的请求，会发生啥呢？</p>
<p>  <img src="./10.png" alt></p>
<p>  首先会去看 Buffer 池中有没有这个 page，如果没有就拷贝一份到内存中，也就是其中一个 frame</p>
<p>  <img src="./11.png" alt></p>
<p>  注意 Buffer 池中 page 的顺序可能和磁盘上的顺序不一致，所以在此之上，就需要一个额外的 indirection 层，如果需要某个特定的 page，只要通过这个 indirection 层就能知道这个 page 在哪个 frame 中</p>
</li>
<li><p>Buffer 池元数据</p>
<p>  <img src="./12.png" alt></p>
<p>  page 表其实就是一个 hash 表，用来跟踪在内存中有哪些 page，可以通过 page 表和 page ID 找到在 frame 中对应的那个 page</p>
<p>  数据库系统必须维护一些额外的元数据，以此来跟踪当前 Buffer 池中的 page 发生了什么</p>
<p>  要跟踪的有俩</p>
<ol>
<li>Dirty Flag<br> 这个 flag 表示的是，从磁盘读取到这个 page 后，这个 page 是否被修改过，比如查询或者事务对其修改过</li>
<li><p>Pin/引用计数<br> 这个表示 想要使用该 page 的当前线程数量/正在对该 page 进行的 查询 的数量（这里又联想到 GC），page 目前还在被强引用，说明此时不应该将 page 写出到磁盘上</p>
<p><img src="./13.png" alt></p>
<p>比如在上图的例子中，如果不想让 page3 从 Buffer 池中移除掉，就把他 Pin 住</p>
<p><img src="./14.png" alt><br><img src="./15.png" alt></p>
<p>如果想要去读取一个不在当前内存中的 page2，那么就要在这个 page 表中加上一个 latch 锁，这样 Buffer 池就可以从磁盘中拿到这个 page2，然后更新 page 表里面指向 page2 的指针。为什么要加锁？因为同一时间可能有多个线程在跑，资源会有冲突</p>
<p>这也解释了为什么 mmap is suck，因为操作系统不会管你是不是在用 page2，它可能会提前将 page2 写出到磁盘</p>
</li>
</ol>
</li>
</ul>
<ul>
<li><p>Locks vs. Latches</p>
<p>  <img src="./16.png" alt></p>
<p>  以数据库的语义来讲，lock 是某种高级逻辑原语（high-level logical primitive），它会去保护数据库中的逻辑内容，比如 tuple、表以及数据库，事务在运行时会去持有这个 lock</p>
<p>  latch 是一种低级保护原语（low-level protection primitive），它用来保护数据库系统内部的关键部分，比如物理数据结构、内存区域</p>
<p>  在执行操作 （operation）期间，数据库会持有这些 latch，用来保护某些东西</p>
<p>  如果在执行操作时，没能拿到对应的 latch，那么这个操作就会被中止，同时也不需要关心回滚问题</p>
<p>  在操作系统的语义里面，latch 就相当于 mutex，mutex 也被用来保护一些关键内容，但是在 latch 中所使用的 mutex 实现其实是 spin lock（自旋锁）</p>
</li>
<li><p>Page 表 vs. Page 目录</p>
<p>  <img src="./17.png" alt></p>
<p>  Page 表是内存中的内部映射，它将 page ID 映射到它们在 Buffer 池中 frame 的位置，这个没必要做持久化，但必须要保证它是线程安全的。因为如果系统崩溃了，恢复后 Buffer 池里面的东西丢了就丢了，对数据库而言没有影响</p>
<p>  Page 目录是用来找到 page 在数据库文件中的位置，对 Page 目录做出的所有改变都必须持久化，它们必须要被写到磁盘上。因为如果系统崩溃了，恢复后我们需要知道在哪里可以找到之前的 page</p>
</li>
<li><p>Buffer 池内存分配策略</p>
<p>  <img src="./18.png" alt></p>
<ol>
<li><p>全局策略<br> 即这个策略能使整个要试着执行的 workload 都受益，比如查看所有运行在该系统上的查询/事务，选择哪些内容应该存储到内存</p>
</li>
<li><p>局部策略<br> 针对每个单个查询/事务，让其进行得更快的最佳方法</p>
<p>大多数数据库系统可能会试着尽量同时采取全局和局部优化策略</p>
</li>
</ol>
<ul>
<li><p>Buffer 池优化</p>
<p>  <img src="./19.png" alt></p>
<ol>
<li><p>多 Buffer 池</p>
<p> <img src="./20.png" alt></p>
<p> 可以在每个 Buffer 池上使用局部策略，这样就可以为放入的数据进行量身定制，比如让每个表都有一个 Buffer 池，当处于以下情况时，</p>
<ul>
<li>在某些表中可能会进行一系列的循环扫描</li>
<li>在某些表中可能会进行索引查询</li>
<li><p>某个时刻需要跳转到某个 page 上（表内查询）</p>
<p>就可以根据这 2 种 workload 类型来决定使用不同的替换策略，比如让一个 Buffer 池处理索引，另一个 Buffer 池处理表</p>
<p>这么做同时也会减少那些尝试访问 Buffer 池的不同线程之间争抢 latch 锁的情况，比如，如果有多个 page 表，那么每条线程就能在同一时间访问不同的 page 表，因此它们就不会去争抢这些 latch（这我是有点怀疑的，是不是一定要 page 表的数量要大于线程数？？）</p>
<p>Oracle、DB2、Sybase、SQL server、Informix 这些全都支持多 Buffer 池， MySQL 的做法是，对于一个给定的 page ID，它会通过 round-robin hash 来判断这个数据在哪，放在哪个 Buffer 池里面。</p>
<p><img src="./21.png" alt><br><img src="./22.png" alt></p>
<p>有 2 种方式来使用这些</p>
</li>
<li><p>Buffer 池通过管理和维护数据库对象（Database Object）的 record ID，来管理数据库对象，即将数据库对象的 record ID 维护到一个列表中，这样就能根据每个 ID 找到对应的对象条目。通过 record ID 能找到 Object ID、page ID、slot number，通过 Object ID 能找到对应的 Buffer 池，通过 page ID 和 slot number 就能找到对应的数据</p>
</li>
<li>传入 record ID，通过 hash 来确定数据在 Buffer 池中的位置，通过取模来确定在哪个 Buffer 池里</li>
</ul>
</li>
<li><p>Pre-Fetching（预取）</p>
<p> <img src="./23.png" alt></p>
<p> 当处理完 page1 后，如果要继续请求 page2 或 page3 的数据，通过 pre-fetching 的方式，它已经在 Buffer 池中了，那么也无序停顿去从磁盘中把相关 page 取出然后写入到 Buffer 池内存中</p>
<p> 另外，mmap 也是可以做到 pre-fetching 的</p>
<p> 有一个 index game 例子（这个例子主要是讲操作系统怎么去做 pre-fetching 的）</p>
<p> <img src="./24.png" alt></p>
<p> <img src="./25.png" alt></p>
<p> index-page3 和 index-page5 它们在磁盘上并没有连续排列在一起，所以操作系统会尝试去 pre fetch page2 和 page3，但实际上并不需要 page2，需要的是 page5，但是还没有 pre fetch 到它。出现这个的原因是操作系统并不知道查询要去做什么，因为操作系统做的是 索引扫描（像例子中的树那样的一个结构，需要 dfs 遍历），它不像数据库系统那样做的是 按照顺序扫描</p>
<p> 而对于 Buffer 池的 pre-fetching 来讲，这不是没有代价的，因为需要跟踪一些额外的元数据</p>
</li>
<li><p>扫描共享 scan sharing</p>
<p> <img src="./26.png" alt></p>
<p> 这个优化策略想的是，查询之间可以利用彼此的结果，某个查询可以复用另一个查询从磁盘中读取到的数据，也可以将该数据用于其他的查询</p>
<p> 但这和结果缓存（result caching）的方式不同，结果缓存指的是，当运行完全相同的查询时，计算出了某些结果，然后将这些结果缓存起来，遇到相同的查询时就再展示出来，而不是去重新执行这个查询</p>
<p> 而扫描共享的工作方式是，当允许将多个查询附加到一个单个游标（这个游标指的是上文所说的移动的 Q1 箭头 →）上，即将这些查询注册到这个游标数据结构管理的一个集合中时，扫描 pages，并将它们放入 Buffer 池中</p>
<p> 这有点像是那种 发布/订阅 的模式：我想知道你是否拿到了一个新的 page，然后你就可以去通知可能在等待这个 page 的线程，即便这个线程并不是真的要去拿到这个 page 去读取数据</p>
<p> <img src="./27.png" alt></p>
<p> DBMS 开始工作后，如果一个查询开始了一次扫描，然后它意识到这里有另一个查询也在做相同的扫描，它就将它自己附加到第一个查询的游标上，当这个查询拿到 page 时，它就通知我们该查询拿到了这个 page，我们也就可以去访问它了</p>
<p> 所以第二个查询出现的位置必须被跟踪到，记录好这个位置后，拿到数据即可返回，然后继续走原来剩余的逻辑</p>
<p> 知道了第一个查询结束时的游标位置，如果那里可能还有其他数据需要回去读取，就能直接回到之前那个点上，去获取剩余的数据</p>
<p> 这项技术只有 DB2 和 SQL server 完全支持，而 Oracle 支持一种基本的扫描共享技术，称之为游标共享（Cursor Sharing），但只有当有 2 个查询在同一时刻执行时，它才会有效</p>
<p> 两个相同查询的例子</p>
<p> <img src="./28.png" alt></p>
<p> 假设第一个查询 Q1，它要计算 SUM，那么它需要从磁盘中遍历整个 pages，然后将遍历的 page 写出到 Buffer 池中，按照惯例，此时 Buffer 池中已满，它需要将 page0 移除掉，并替换上 page3</p>
<p> <img src="./29.png" alt></p>
<p> 替换成功后，继续扫描，但是这个时候，第二个查询 Q2 出现了，它也想从磁盘中遍历整个 pages</p>
<p> <img src="./30.png" alt></p>
<p> 在没有扫描共享的情况下，就会出问题，因为此时 Buffer 池已满，对于 Q2 来讲它需要的是 Buffer 池中的 page0，但是刚刚 page0 已经被 Buffer 池扔回到磁盘里面去了，那么 Q2 这个查询就 gg 了</p>
<p> 所以在有扫描共享的情况下，Q2 只需要跳到 Q1 目前所在的位置，并且去读取 Q1 要读的相同的数据，并计算出 Q2 所找的那部分数据的结果</p>
<p> <img src="./31.png" alt><br> <img src="./32.png" alt></p>
<p> 而当 Q1 结束时，Q1 的游标就消失了，Q2 查询从头开始</p>
<p> <img src="./33.png" alt><br> <img src="./34.png" alt></p>
<p> 直到遍历到 page2，Q2 结束，这就是 Q2 扫描的路径</p>
<p> 那么每个查询在读取数据的同时也在计算中间结果，它们也需要一块内存区域去存放这些数据，而这个内存区域跟这个 Buffer 池是分开的，但通常情况下，这块内存区域也可以由一个 Buffer 池所支持。但它到底是在一个全局 Buffer 池中还是在这个查询所私有的 Buffer 池中，还得取决于具体实现</p>
<p> 如果在扫描 Buffer 池中的数据，并更新中间结果时，可能会遇上内存溢出，为了腾出空间保留中间结果，会将 Buffer 池中的 page 数据刷出到磁盘</p>
<p> 通过 locks 可以对一些 pages 进行跟踪管理是否允许对这些 pages 进行读写，或者时将 locks 应用于一些数据库对象上</p>
<p> 如果将 Q2 的查询修改下，让它去计算 100 条数据的平均值</p>
<p> <img src="./35.png" alt></p>
<p> 这里并没有明确说这里要的是否是 前 100 个 tuple 的数据。因为现在 Q2 的游标是在 page2 处，所以遍历可以从 page3 开始，然后看下这前 3 个 page 中前 100 个 tuple，计算出结果。但如果从 page0 开始扫描计算，那可能会得到一个不同的结果。但因为关系模型中数据库是无序的，所以根据关系模型，这是没问题的。</p>
</li>
<li><p>Buffer 池 Bypass</p>
<p> <img src="./36.png" alt></p>
<p> 思路是，分配一小块内存给执行查询的那条线程，当它从磁盘中读取 page 时，如果该 page 不在 Buffer 池中，那么它将会把这个 page 从磁盘写入本地内存而不是 Buffer 池。当查询完成时，所有的这些 page 都会被丢弃掉。</p>
<p> 这么做是为了避免去 page 表中进行查询所带来的开销，因为 page 表中对应的条目是带锁的。</p>
<p> 在 Informix 中，这叫做 “Light Scans”，主流数据库都支持它</p>
<p> 注意，只有当操作的是中间结果以及查询扫描的量不大的场景才适用</p>
</li>
</ol>
</li>
</ul>
</li>
<li><p>操作系统 Page 缓存</p>
<p>  <img src="./37.png" alt></p>
<p>  数据库所有的磁盘操作都是通过最底层的 OS API 来做的，比如 fopen/fread/fwrite 等。默认情况下，操作系统会维护它自己的文件系统缓存，比如，当从磁盘读取一个 page 时，OS 会去在它的文件系统缓存中保存一份副本，写入到 Buffer 池中时，里面就会有另一个副本。但大部分数据库系统不会让 OS 对要读取的文件进行任何缓存处理，因为它们要自己管理内存。</p>
<p>  但是，唯一利用操作系统 page 缓存的就是 PostgreSQL，因为从它们工程师的角度看，他们就无须再管理一个额外的缓存，他们依然有他们自己的 Buffer 池，但没有那么大，这样就不会去使用系统中所有的内存。但像 MySQL 或 Oracle 就会</p>
<p>  htop</p>
<p>  <img src="./38.png" alt></p>
<p>  Mem 部分，橙条代表操作系统的 page 缓存，绿条代表该计算机上运行的进程的实际使用物理内存</p>
<p>  使用如下命令清除 OS page 缓存</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sync; <span class="built_in">echo</span> 3 &gt; /proc/sys/vm/drop_caches</span><br></pre></td></tr></table></figure>
<p>  <img src="./39.png" alt></p>
<p>  可以看到机器使用的总内存已经下降到 3GB 左右</p>
<p>  顺便，如果 Buffer 池的大小小于要读取的数据库表的大小的话，那么在 Buffer 池中命中 pages 的数量，要小于在磁盘中读取 pages 的数量</p>
<p>  <img src="./40.png" alt></p>
<p>  比如上图中，从磁盘读取的 27932 &gt;&gt; Buffer 池中的 16316</p>
<p>  这取决于 Buffer 池的大小，如果把 Buffer 池大小设置（下图为修改 PostgreSQL 的配置文件，修改项为 shared_buffers）为比要读取的数据库表大小还大，那么</p>
<p>  <img src="./41.png" alt><br>  <img src="./42.png" alt></p>
<p>  Buffer 池就会命中（hit）全部的 pages，因为给了数据库系统合适大小的内存量，对于这个查询而言，就没必要去从磁盘拿 page 了</p>
<p>  hit 的意思是找的东西在 Buffer 池中的数量</p>
<p>  pg_prewarm 会告诉数据库系统去读取磁盘上该表的所有数据，并将他放入 Buffer 池中（SELECT pg_prewram(‘testreals’)）</p>
<p>  为什么其他主流数据库系统不依赖操作系统 page 缓存呢？因为假设在 OS page cache 中放入一个 page，而在 Buffer 池中放入该 page 的一个副本，如果这个时候要对 Buffer 池中修改这个 page 部分，那么 OS page cache 和 Buffer 池中的 page 就不再是同一个东西了，OS page cache 中存的就是老 page 数据，那么这个数据就冗余了。</p>
<p>  同时，不同数据库支持的操作系统也不一样，如果都用操作系统 page 缓存，那么可能出现性能上的差异，为了保证跨 OS 间的一致性，必须要把这个交给数据库系统本身来管理</p>
<p>  如果使用的是 Direct IO，这就会告诉操作系统不要去缓存任何东西，这样数据库系统就始终得跑到磁盘上去获取数据了</p>
<p>  操作系统 page 缓存是磁盘和数据库之间的东西</p>
</li>
<li><p>Buffer 替换策略</p>
<p>  <img src="./43.png" alt></p>
<p>  如果现在需要讲一个 page 放入内存中，但是内存里没有空间放它，这个时候该怎么办呢？</p>
<p>  在替换策略中，最重要的就是 准确性，因为要确保移除的 page 是在未来不太会被用到的那些 page</p>
<ol>
<li>运行某些算法来弄清楚该移除哪个 page 会比读取 page 时所花的时间要长</li>
<li><p>跟踪大量额外的元数据也会带来开销，因为可能会出现跟踪的元数据的体积比 page 本身还要大</p>
<p>非常高端的、价格很昂贵的企业级数据库和开源数据库之间有什么区别呢？</p>
</li>
<li><p>高端数据库拥有非常复杂的替换策略，它们会跟踪统计 page 的相关使用数据，会尝试从查询实际所做的事情中推断出最好的决策</p>
</li>
<li>开源数据库的某些比较新的系统中，它们在这方面并没有做的像高端数据库那么好，它们就只能做些简单版的东西了</li>
</ol>
<ul>
<li><p>Least-Recently Used（LRU）</p>
<p>  一种使用起来超简单的技术就是 LRU，即跟踪一个 page 最后一次被访问时的时间戳，然后只要看哪个 page 拥有的时间戳是最老的，哪个就应该要被移除掉</p>
<p>  那么此时就可以维护一个单独的数据结构，比如队列，根据 page 的时间戳进行排序</p>
</li>
<li><p>Clock<br>  一个 LRU 的近似算法，就是 Clock</p>
<p>  <img src="./44.png" alt></p>
<p>  在 Clock 中，没必要去追踪每个 page 的时间戳，相反，唯一需要去跟踪的信息是每个 page 的标志位（reference bit），它会告诉你自从上次检查过该 page 后，这个 page 是否被访问了，所以你需要将你的 page 弄成一个环形的 Buffer，like a clock。在一圈时钟这个时间段内，如果标志位没有变化，就可以从 Buffer 池中移除这个 page。</p>
<p>  <img src="./45.png" alt></p>
<p>  假设某些查询访问了 page1，那么此时 page1 的标志位会被设置成 1，注意这里无论多少查询访问过这个 page1 多少次，这里的值始终都被设置为 1，因为标志位不是计数器。</p>
<p>  当现在需要去移除 page 时</p>
<p>  <img src="./46.png" alt><br>  <img src="./47.png" alt></p>
<p>  clock 会从 page1 这个地方开始走起来，当看到 page1 的标志位为 1 时，说明这个 page1 被访问过，所以不应该去移除掉 page1，但现在只是将 page1 的标志位设置成 0。然后走向下一个 page2。此时它发现 page2 的标志位是 0，就可以将 page2 移除掉（因为它不是 1，如果是 1 会被先设置成 0 然后遍历下一个 page）</p>
<p>  使用 Clock 算法的优点是，在移除 page 时，不会精确地移除最近最少使用的那个 page。</p>
<p>  在某些查询上表现得很好，比如点查询（point query）时访问单个东西</p>
</li>
<li><p>问题</p>
<p>  <img src="./48.png" alt></p>
<p>  但 Clock 和 LRU 都容易受到 sequential flooding 带来的影响</p>
<p>  这意味着，当进行读取每个 page 的特殊扫描时，这可能会污染 page 缓存，可能会将接下来真正要用到的 page 从 Buffer 池中移除掉。因为它扫描并读取了一堆 page，所有的这些 page 的时间戳都会比实际想要的那个 page 要新。因为要被移除的那些 page 应该是 最近 被使用的，而不是 最近最少 被使用的</p>
<p>  例子</p>
<p>  Q1 是一个点查询，它读取了 page0，并放入了 Buffer 池中</p>
<p>  <img src="./49.png" alt></p>
<p>  接着有另一个遍历查询 Q2，它会读取所有的 page</p>
<p>  <img src="./50.png" alt></p>
<p>  现在想要在 Buffer 池中给 page3 分配一个空间，如果用的是 LRU，那么它会指出 page0 是 Buffer 池中最近最少使用的 page，那么移除掉 page0，放入 page3</p>
<p>  <img src="./51.png" alt></p>
<p>  但是在 workload 中，会有不断地去执行类似于 Q1 那样的查询</p>
<p>  <img src="./52.png" alt></p>
<blockquote>
<p>注意上图中，在 Disk Pages 上的红色 Q2 应为 Q3</p>
</blockquote>
<p>  不断的执行 Q3，它要读的是 page0。但是之前 page0 已经从 Buffer 池中被移除掉了，这样就 fucked up 了。</p>
<p>  而真正应该要被移除的应该是 page1 和 page2，因为 Q2 会去读取更多的数据，而其他查询（Q1 和 Q3）并不会到 Buffer 池中读取这些数据（page 0 之后的 page）</p>
</li>
<li><p>更好的策略：LRU-K</p>
<p>  <img src="./53.png" alt></p>
<p>  思路是，将最近使用过 1 次的判断标准扩展为最近使用过 K 次，没有达到 K 次访问的数据并不会被缓存。访问记录不能无限记录，当访问次数达到 K 次后，将 数据索引 从 历史队列 移到 缓存队列 中</p>
<p>  相比于 LRU 比较时间戳，LRU-K 看的是时间戳时间的间隔，统计哪一个 page 的上一次和下一次的访问的时间间隔最长，那么哪一个 page 就是最近最少使用的</p>
</li>
<li><p>更好的策略：本地化（Localization）</p>
<p>  <img src="./54.png" alt></p>
<p>  使用多个 Buffer 池，让每个查询本地化，即每个 Buffer 池能对应住一个查询，那么对于单个查询来讲，只会去移除对于这个查询而言最近最少使用的那个 page，而不是对于整个查询而言最近最少使用的那个 page</p>
</li>
<li><p>更好的策略：优先级提示（Priority Hints）</p>
<p>  <img src="./55.png" alt></p>
<p>  有索引时，就知道查询时如何进行扫描的，也能知道哪些不同的 page 被访问了，可以使用这个信息来判断该移除哪些 page</p>
<p>  例子，假设有一个 Insert 的操作 Q1，对应的表里面有一个全局的计数器，每次 Insert 时，它就会加 1</p>
<blockquote>
<p>注意这里索引的存储结构一般是类似 B+ Tree 的结构</p>
</blockquote>
<p>  <img src="./56.png" alt></p>
<p>  如果根据这个 id 从小到大排序，意味着遍历始终是沿着树的右侧往下走，去拿到这些 page 的</p>
<p>  <img src="./57.png" alt></p>
<p>  因此这个时候就应该提示 Buffer 管理器，这些被红色框圈起来的 page 就应该试着待在内存中</p>
</li>
<li><p>处理 Dirty Pages</p>
<p>  <img src="./58.png" alt></p>
<p>  在 page 上有一个 dirty bit，它表示自从上次它被放入 Buffer 池中后，是否还有查询对该 page 的内容做了修改。</p>
<p>  快的方式：如果一个 page 在 Buffer 池中不是 dirty 的，直接 drop 掉它就好<br>  慢的方式：如果一个 page 在 Buffer 池中是 dirty 的话，在将该空间重新用于新的 page 之前，必须将这个 page 安全地写回磁盘</p>
<p>  而这是有 trade-off 的，因为一大堆不是 dirty 的 page，可能最近需要用到它，所以直接 drop 掉会带来后面重新读取磁盘并写入内存的 I/O 影响。</p>
<p>  而如果不想要 drop 掉这些不是 dirty 的 page，那就要花点代价将 dirty page 从 Buffer 池中移除掉，然后复用移除掉的这些空间。但是这么做就需要 2 次磁盘 I/O 了，一次 I/O 是用来写出 dirty page，从 Buffer 池中移除，另一次 I/O 则是读取那个想要的 page（感觉和上面那个 drop 非 dirty page 的情况差不多）</p>
</li>
<li><p>后台写操作（Background Writing）</p>
<p>  <img src="./59.png" alt></p>
<p>  为了避免 必须立即 将 page 写出以便在 Buffer 池中释放可用空间的问题，在数据库系统中有一条执行定时任务的线程，它会在 Buffer 池中找出那些被标记为 dirty 的 page，将它们写出到磁盘上，然后可以将这些 page 标记为 clean。那么当使用替换策略去决定该移除哪个 page 时，就有一堆 clean 的 page 可以 drop 掉了。</p>
<p>  但是这个操作要小心，因为在该 dirty page 对应的修改操作写入日志之前，我们不希望将这些 dirty page 写出到磁盘</p>
<p>  同样的，这也是 mmap 无法做到的事情</p>
</li>
</ul>
</li>
<li><p>其他内存池</p>
<p>  <img src="./60.png" alt></p>
</li>
<li><p>结论</p>
<p>  <img src="./61.png" alt></p>
<p>  这节课的重点在于我们该如何去管理内存并做得比 OS 更好</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Database</category>
      </categories>
      <tags>
        <tag>Database</tag>
      </tags>
  </entry>
  <entry>
    <title>DOM原生接口回顾</title>
    <url>/2019/02/20/DOM%E5%8E%9F%E7%94%9F%E6%8E%A5%E5%8F%A3%E5%9B%9E%E9%A1%BE/</url>
    <content><![CDATA[<h2 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h2><p>什么是 DOM，DOM 就是 Document Object Model(文档对象模型),一般来讲 Document(文档) 就是指 xml/html 文档, html 是 xml 的衍生品, Object 就是把文档变成一个对象, Model 就是被抽象成的模型</p>
<p>写 html 时先写啥</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"zh-Hans"</span>&gt;</span></span><br><span class="line">// head body html 都是可以省略并且符合 html 规范的</span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>其中 html 的树形结构如下图所示</p>
<p><img src="./img1.png" alt></p>
<p>然而这个树并不是存在于内存中的,那么怎么样才能把这种结构存在内存中呢?<br>就是通过一个对象 (Object)来存储,它们中间有一层模型(Model)的映射关系,而通过这个模型,可以将文档(Document)变成对象(Object),也就是所谓的 DOM</p>
<p>那么 Object 里面到底存什么呢,有一个 DOM 标准<br>可以存成 <code>Element</code> 对象,也可以存成 <code>Text</code> 对象,也可以存成 <code>Document</code><br>如下图</p>
<p><img src="./img2.png" alt></p>
<p>这三个原型链的 <code>__proto__</code> 都是 <code>Node</code>,其继承关系如下</p>
<ul>
<li>Node<ul>
<li>Document<ul>
<li>html</li>
</ul>
</li>
<li>Element<ul>
<li>head body meta title script h1 h2 p</li>
</ul>
</li>
<li>Text<ul>
<li>标题1 span</li>
</ul>
</li>
<li>Comment 注释</li>
<li>…(其他)</li>
</ul>
</li>
</ul>
<p>DOM 的转化公式如下<br><img src="./img3.png" alt></p>
<h3 id="Node-接口"><a href="#Node-接口" class="headerlink" title="Node 接口"></a>Node 接口</h3><p>属性</p>
<ul>
<li>childNodes</li>
<li>firstChild</li>
<li>innerText</li>
<li>lastChild</li>
<li>nextSibling</li>
<li>nodeName</li>
<li>nodeType</li>
<li>nodeValue</li>
<li>outerText</li>
<li>ownerDocument</li>
<li>parentElement</li>
<li>parentNode</li>
<li>previousSibling</li>
<li>textContent</li>
</ul>
<p>没有人在工作中用 DOM API ,除非你很闲</p>
<p>html 中回车也算文本</p>
<p><code>document.body.childNodes</code> 会获取到<strong>子标签,包括标签间的空格以及回车</strong><br><code>document.body.children</code> 会获取到<strong>子节点,不包括标签间的空格以及回车</strong></p>
<p><code>nextElementSibling</code> 获取到下一个 Element 的兄弟节点</p>
<p><code>document.documentElement.nodeName</code> 才能获取到 html</p>
<p><code>nodeType</code> Element node 是 1, Text node 是 3<br>具体参考<a href="https://developer.mozilla.org/en-US/docs/Web/API/Node/nodeType" target="_blank" rel="noopener">nodeType MDN</a><br>需要注意的是 <a href="https://www.google.com/search?client=ubuntu&amp;channel=fs&amp;q=DocumentFragment+%E4%BC%98%E5%8C%96&amp;ie=utf-8&amp;oe=utf-8" target="_blank" rel="noopener">DocumentFragment 优化</a></p>
<p><code>innerText</code> 和 <code>textContent</code><br>前者的 API 是 IE 的,直接获取文本内容,后者是 Firefox 以及 Opera 的,<br>详情见 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Node/textContent" target="_blank" rel="noopener">textContent 与 innerText 的区别</a><br>主要是 <code>innerText</code> 会检查 css,比如会检查 css 中有没有 <code>display: none;</code> 属性,而 <code>textContent</code> 就不会,这样的话就 <code>textContent</code> 而言性能就高一些</p>
<p>构造函数是怎么把标签变成对象的?</p>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        name: <span class="string">'芳芳'</span>,</span><br><span class="line">        age: <span class="number">18</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">createPerson() <span class="comment">// 调用</span></span><br></pre></td></tr></table></figure>
<p>只要这个函数返回了一个对象,那么就构造了这个对象,只是说用几个属性抽象成了这个对象</p>
<p>方法</p>
<ul>
<li>appendChild()</li>
<li>cloneNode() // 深拷贝节点</li>
<li>contains()</li>
<li>hasChildNodes()</li>
<li>insertBefore()</li>
<li>isEqualNode()</li>
<li>isSameNode()</li>
<li>removeChild()</li>
<li>replaceChild()</li>
<li>normalize() // 常规化</li>
</ul>
<p><code>cloneNode</code> 中间有传的参数表示是否进行深拷贝 <code>var dupNode = node.cloneNode([deep]);</code> 以 div 节点为例,假如这个节点有一个或者多个子节,那么<strong>深拷贝会连这个节点及其子节点都拷贝过去</strong>,而 <strong>浅拷贝则只会拷贝这个节点,不会拷贝这个节点的子节点</strong></p>
<p><code>isEqualNode</code> 与 <code>isSameNode</code><br><code>isSameNode</code> 可以简写成 <code>===</code>,而 <code>isEqualNode</code> 从概念上讲有点像 <code>==</code> ,但是对于节点来说不能用 <code>==</code> 符号来替代</p>
<p><code>normalize</code><br>以下是 MDN 上的 demo 代码</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> wrapper = <span class="built_in">document</span>.createElement(<span class="string">"div"</span>);</span><br><span class="line"></span><br><span class="line">wrapper.appendChild( <span class="built_in">document</span>.createTextNode(<span class="string">"Part 1 "</span>) );</span><br><span class="line">wrapper.appendChild( <span class="built_in">document</span>.createTextNode(<span class="string">"Part 2 "</span>) );</span><br><span class="line"></span><br><span class="line"><span class="comment">// At this point, wrapper.childNodes.length === 2</span></span><br><span class="line"><span class="comment">// wrapper.childNodes[0].textContent === "Part 1 "</span></span><br><span class="line"><span class="comment">// wrapper.childNodes[1].textContent === "Part 2 "</span></span><br><span class="line"></span><br><span class="line">wrapper.normalize();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Now, wrapper.childNodes.length === 1</span></span><br><span class="line"><span class="comment">// wrapper.childNodes[0].textContent === "Part 1 Part 2 "</span></span><br></pre></td></tr></table></figure>
<p>在标签中加入文本</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">div1.innerText</span> = <span class="string">'hello world'</span></span><br></pre></td></tr></table></figure>
<p><code>innerText</code> 有个副作用,假如如上的 div 中有个 span, 那么使用 <code>innerText</code> 就是会将这个 span 元素清空掉</p>
<p>更安全的方式是生成一个节点</p>
<figure class="highlight coffeescript"><table><tr><td class="code"><pre><span class="line">div1.appendChild(<span class="built_in">document</span>.createTextNode(<span class="string">'hello world'</span>))</span><br></pre></td></tr></table></figure>
<h2 id="Document-和标签的-API"><a href="#Document-和标签的-API" class="headerlink" title="Document 和标签的 API"></a>Document 和标签的 API</h2><p>属性</p>
<ul>
<li>anchors // 获取锚点元素</li>
<li>body</li>
<li>characterSet //获取字符</li>
<li>childElementCount</li>
<li>children</li>
<li>doctype</li>
<li>documentElement</li>
<li>domain</li>
<li>head</li>
<li>hidden</li>
<li>images</li>
<li>links</li>
<li>location</li>
<li>onxxxxxxxxx // 一系列的事件监听</li>
<li>origin</li>
<li>plugins</li>
<li>readyState</li>
<li>referrer</li>
<li>scripts</li>
<li>scrollingElement</li>
<li>styleSheets</li>
<li>title</li>
<li>visibilityState</li>
</ul>
<p><code>referrer</code><br>待续</p>
<p>方法</p>
<ul>
<li>close()</li>
<li>createDocumentFragment()</li>
<li>createElement()</li>
<li>createTextNode()</li>
<li>execCommand()</li>
<li>exitFullscreen()</li>
<li>getElementById()</li>
<li>getElementsByClassName()</li>
<li>getElementsByName()</li>
<li>getElementsByTagName() // 很难用</li>
<li>getSelection()</li>
<li>hasFocus()</li>
<li>open()</li>
<li>querySelector() // 返回一个元素</li>
<li>querySelectorAll() // 返回所有元素</li>
<li>registerElement()</li>
<li>write()</li>
<li>writeln() // 写一行</li>
</ul>
<p><code>close</code><br>像如下代码</p>
<figure class="highlight coffeescript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.write(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">document</span>.write(<span class="number">2</span>)</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;<span class="built_in">document</span>.write(<span class="number">3</span>)&#125;, <span class="number">1000</span>)</span><br></pre></td></tr></table></figure>
<p>执行的结果(先显示了 1 跟 2)显示出来是 3, 这是为什么呢</p>
<p><code>document</code> 运行的过程如下</p>
<p>页面在加载第一个标签时就处于 <code>open</code> 状态,页面加载完毕之后才能 <code>close</code> ,这个时候若想要再 <code>write</code>, 必须先回到最开始的 <code>open</code> 状态,进而把之前的内容给覆盖掉,所以这个 api 在使用时需要特别小心<br>,尽量少用 <code>write</code></p>
<p><img src="./img4.png" alt></p>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/API/Document/close" target="_blank" rel="noopener">write MDN</a></p>
<p><code>execCommand</code><br>写富文本编辑器(有样式的)时可以用到这个 api,</p>
<p><code>querySelector</code> 返回一个元素<br><code>querySelectorAll</code> 返回一个伪数组(原型链中没有 <code>Array.prototype</code>)</p>
<h2 id="Element"><a href="#Element" class="headerlink" title="Element"></a>Element</h2><p><code>innerHTML</code> 与 <code>innerText</code> 的区别<br>以一个输入框举例</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;input type=<span class="string">"text"</span> id=<span class="string">"input1"</span>&gt;<span class="xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">x</span>&gt;</span></span></span><br><span class="line"><span class="xml">    写入页面</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">&lt;div id=<span class="string">"output"</span>&gt;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">x.onclick = function() &#123;</span></span><br><span class="line"><span class="regexp">    output.innerHTML = input1.value</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<p>加入这个时候用户输入的是 <code>&lt;b&gt;123&lt;/b&gt;</code>, <code>innerHTML</code> 会将用户的输入处理成有加粗的 123,所以这就是有危险的,万一输入框中是一段 js 代码呢<br>而 <code>innerText</code> 则处理的是纯文本,用户输入什么它就输出什么</p>
<p>详情见 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Element" target="_blank" rel="noopener">Element MDN</a></p>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ul>
<li>DOM 现在的通用版本是 DOM Level 3</li>
<li>节点的类型有 7 种,分别是<ul>
<li>Element node</li>
<li>Text node</li>
<li>ProcessingInstruction node (Attribute ???)</li>
<li>Comment node</li>
<li>Document node</li>
<li>DocumentType node</li>
<li>DocumentFragment node</li>
</ul>
</li>
<li>元素 Element 的 NodeType 值为 1 或者 Node. ELEMENT_NODE</li>
<li><p>有如下代码, x.nextSibling 的值为 <strong>回车构成的文本节点</strong></p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">&lt;<span class="keyword">div</span> <span class="built_in">id</span>=x&gt;&lt;/<span class="keyword">div</span>&gt;</span><br><span class="line">&lt;<span class="keyword">div</span> <span class="built_in">id</span>=y&gt;&lt;/<span class="keyword">div</span>&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>有如下代码, 那么 parent1.childNodes 的值是 {0:child1, length:1} 伪数组</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">&lt;<span class="keyword">div</span> <span class="built_in">id</span>=parent1&gt;&lt;<span class="keyword">div</span> <span class="built_in">id</span>=child1&gt;&lt;/<span class="keyword">div</span>&gt;&lt;/<span class="keyword">div</span>&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>parent.childNodes 是动态集合。所谓动态集合就是一个活的集合，DOM树删除或新增一个相关节点，都会立刻反映在NodeList接口之中。</p>
</li>
<li>document.querySelectorAll方法返回的是一个静态集合。DOM内部的变化，并不会实时反映在该方法的返回结果之中。</li>
<li>HTMLCollection实例对象的成员只能是Element节点，NodeList实例对象的成员可以包含其他节点。</li>
<li>HTMLCollection实例对象可以用id属性或name属性引用节点元素，NodeList只能使用数字索引引用。</li>
</ul>
]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>dom</tag>
      </tags>
  </entry>
  <entry>
    <title>DOM事件原理</title>
    <url>/2019/02/20/DOM%E4%BA%8B%E4%BB%B6%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h2 id="DOM-的版本"><a href="#DOM-的版本" class="headerlink" title="DOM 的版本"></a>DOM 的版本</h2><p><a href="http://www.w3.org/DOM/DOMTR#dom1" target="_blank" rel="noopener">DOM1链接</a><br>DOM Level 1 主要有两个版本,但主要学习的是 DOM Level 2 的事件标准, 因为 DOM Level 1 太简单了</p>
<p>所以事件标准用的最广泛的是 DOM Level 2</p>
<p>例子<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">X</span> <span class="attr">onclick</span>=<span class="string">"print"</span>&gt;</span>A<span class="tag">&lt;/<span class="name">button</span>&gt;</span>  // 错误使用</span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">Y</span> <span class="attr">onclick</span>=<span class="string">"print()"</span>&gt;</span>B<span class="tag">&lt;/<span class="name">button</span>&gt;</span> // 正确使用</span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">Z</span> <span class="attr">onclick</span>=<span class="string">"print.call()"</span>&gt;</span>C<span class="tag">&lt;/<span class="name">button</span>&gt;</span> // 正确使用</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">    <span class="function"><span class="keyword">function</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">'hi'</span>);</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="actionscript">    X.onclick = print <span class="comment">// 正确使用 // 类型为函数对象</span></span></span><br><span class="line"><span class="actionscript">    Y.onclick = print() <span class="comment">// 错误使用 // undefined</span></span></span><br><span class="line"><span class="actionscript">    Z.onclick = print.call() <span class="comment">// 错误使用 //undefined</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>html 中 <code>onclick=&quot;要执行的代码&quot;</code><br>一旦用户点击,浏览器就 <code>eval(&quot;要执行的代码&quot;)</code></p>
<p>而 js 中,一旦用户点击,那么浏览器就点击<br><code>X.onclick.call(X, {})</code></p>
<p>还有一个例子<br><figure class="highlight scilab"><table><tr><td class="code"><pre><span class="line">&lt;button id=xxx&gt;xxx&lt;/button&gt;</span><br><span class="line"><span class="comment">// 属性,唯一</span></span><br><span class="line">xxx.onclick = <span class="function"><span class="keyword">function</span><span class="params">()</span> &#123;</span></span><br><span class="line">    console.<span class="built_in">log</span>(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line">xxx.onclick = <span class="function"><span class="keyword">function</span><span class="params">()</span> &#123;</span></span><br><span class="line">    console.<span class="built_in">log</span>(<span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 队列,不唯一</span></span><br><span class="line"><span class="comment">// xxx 拥有一个队列 eventListeners</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span><span class="params">()</span> &#123;</span></span><br><span class="line">    console.<span class="built_in">log</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f2</span><span class="params">()</span> &#123;</span></span><br><span class="line">    console.<span class="built_in">log</span>(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line">xxx.addEventListener(<span class="string">'click'</span>, f1)</span><br><span class="line">xxx.addEventListener(<span class="string">'click'</span>, f2)</span><br></pre></td></tr></table></figure></p>
<p>再再再一个例子<br><figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">&lt;<span class="keyword">div</span> <span class="built_in">id</span>='grand1'&gt;</span><br><span class="line">    &lt;<span class="keyword">div</span> <span class="built_in">id</span>='parent1'&gt;</span><br><span class="line">        &lt;<span class="keyword">div</span> <span class="built_in">id</span>='child1'&gt;</span><br><span class="line">        &lt;/<span class="keyword">div</span>&gt;</span><br><span class="line">    &lt;/<span class="keyword">div</span>&gt;</span><br><span class="line">&lt;/<span class="keyword">div</span>&gt;</span><br></pre></td></tr></table></figure></p>
<p>所以</p>
<ul>
<li>当点击 ‘child1’ 时,有没有点击到 ‘parent1’ 和 ‘grand1’ (是都点击到)</li>
<li>代码 1</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 当点击 'child1' 时,三个函数是否调用 (是的都调用到了)</span></span><br><span class="line">grand1.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'爷爷'</span>);</span><br><span class="line">&#125;);</span><br><span class="line">parent1.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> <span class="title">fn2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'爸爸'</span>);</span><br><span class="line">&#125;);</span><br><span class="line">child1.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> <span class="title">fn3</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'儿子'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<ul>
<li>代码 2</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 那么 fn1 fn2 fn3 的执行顺序是</span></span><br><span class="line"><span class="comment">// 1 2 3 还是 3 2 1 ???</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 然而 w3c 觉得都可以</span></span><br><span class="line"><span class="comment">// flasy: undefined null 0 '' NaN</span></span><br><span class="line"></span><br><span class="line">grand1.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'爷爷'</span>);</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br><span class="line">parent1.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> <span class="title">fn2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'爸爸'</span>);</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br><span class="line">child1.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> <span class="title">fn3</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'儿子'</span>);</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不传第三个参数 or 传 flase : 儿子爸爸爷爷</span></span><br><span class="line"><span class="comment">// 传第三个参数为 true        : 爷爷爸爸儿子</span></span><br></pre></td></tr></table></figure>
<ul>
<li>代码 3</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 假如再多一个事件呢</span></span><br><span class="line">grand1.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'爷爷'</span>);</span><br><span class="line">&#125;);</span><br><span class="line">parent1.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> <span class="title">fn2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'爸爸'</span>);</span><br><span class="line">&#125;);</span><br><span class="line">child1.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> <span class="title">fn3</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'儿子1'</span>);</span><br><span class="line">&#125;);</span><br><span class="line">child1.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> <span class="title">fn4</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'儿子2'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 那就是队列呗,先进先出</span></span><br></pre></td></tr></table></figure>
<ul>
<li>代码 4</li>
</ul>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">// 如果是最后一个节点,既有<span class="string">"冒泡"</span> 也有 <span class="string">"捕获"</span>的情况下,那么是先执行哪个呢</span><br><span class="line">child1.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> <span class="title">fn3</span><span class="params">()</span></span>&#123;</span><br><span class="line">    console.<span class="built_in">log</span>(<span class="string">'儿子捕获'</span>);</span><br><span class="line">&#125;, <span class="literal">true</span>);</span><br><span class="line">child1.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> <span class="title">fn3</span><span class="params">()</span></span>&#123;</span><br><span class="line">    console.<span class="built_in">log</span>(<span class="string">'儿子冒泡'</span>);</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">// 当然是 <span class="string">" 捕获"</span> 先执行,然而这是跟其执行顺序有关,比如像这样</span><br><span class="line">child1.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> <span class="title">fn3</span><span class="params">()</span></span>&#123;</span><br><span class="line">    console.<span class="built_in">log</span>(<span class="string">'儿子冒泡'</span>);</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br><span class="line">child1.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> <span class="title">fn3</span><span class="params">()</span></span>&#123;</span><br><span class="line">    console.<span class="built_in">log</span>(<span class="string">'儿子捕获'</span>);</span><br><span class="line">&#125;, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">// 以上就是 <span class="string">"冒泡"</span> 先执行</span><br></pre></td></tr></table></figure>
<p>所以事件模型如下图所示<br><img src="./img1.png" alt></p>
<h3 id="写个例子"><a href="#写个例子" class="headerlink" title="写个例子"></a>写个例子</h3><p>bootstrap 上的 popover 例子 <a href="https://getbootstrap.com/docs/4.1/components/popovers/" target="_blank" rel="noopener">bootstrap popover</a></p>
<p>自己写来验证</p>
<p>html 代码<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>JS Bin<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"wrapper"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"clickMe"</span>&gt;</span>点我<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"popover"</span> <span class="attr">class</span>=<span class="string">"popover"</span>&gt;</span></span><br><span class="line">      浮层</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span>  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>css<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.wrapper</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">display</span>: inline-block;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.popover</span> &#123;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid red;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">100%</span>; <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">white-space</span>: nowrap;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">margin-left</span>: <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">background</span>: white;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.popover</span><span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">''</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">right</span>: <span class="number">100%</span>; <span class="attribute">top</span>:<span class="number">0</span>;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">10px</span> solid transparent;</span><br><span class="line">  <span class="attribute">border-right-color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.popover</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">''</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">right</span>: <span class="number">100%</span>; <span class="attribute">top</span>:<span class="number">0</span>;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">10px</span> solid transparent;</span><br><span class="line">  <span class="attribute">border-right-color</span>: white;</span><br><span class="line">  <span class="attribute">margin-right</span>: -<span class="number">1px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>效果图如下所示<br><img src="./img2.png" alt></p>
<p>想要做到点击 ‘点我’ 按钮屏蔽 ‘浮层’ 元素,以下有一个简单的方法,即通过 <strong>监听 body</strong> 的方式<br>javascript<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">clickMe.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  popover.style.display = <span class="string">'block'</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听 body</span></span><br><span class="line"><span class="built_in">document</span>.body.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'click body'</span>);</span><br><span class="line">  <span class="comment">// 执行代码逻辑...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>但是这种方式存在缺陷,因为 body 的宽和高被限定了,在 body 中加入 css <code>body{ border: 1px solid green}</code>,如下图所示<br><img src="./img3.png" alt><br>就造成了点击不是 body 的别处就不会响应相应逻辑<br>所以可以通过 <strong>改变 body 宽高</strong>,<strong>监听文档 <code>document</code></strong> 或者 <strong>监听 html <code>document.documentElement</code></strong> 的方式来进行,如下的 js 代码</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">clickMe.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'display block'</span>);</span><br><span class="line">  popover.style.display = <span class="string">'block'</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听 document</span></span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'display none'</span>);</span><br><span class="line">  <span class="comment">// 执行代码逻辑...</span></span><br><span class="line">  popover.style.display = <span class="string">'none'</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>然而以上代码还是有 bug,用户点击按钮时页面没有反应,这是由于 DOM 事件响应的顺序造成的,出现 bug 的原因如下图所示<br><img src="./img4.png" alt></p>
<p>原因其实很简单, <code>document</code> 和 <code>button</code> 的两个函数<strong>都是在冒泡阶段执行的</strong></p>
<h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p>阻止冒泡,思路: 切断 button 向上冒泡那一层,使用 <code>stopPropagation</code> 函数, js 代码如下</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">clickMe.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'display block'</span>);</span><br><span class="line">  popover.style.display = <span class="string">'block'</span>;</span><br><span class="line">  e.stopPropagation();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听 document</span></span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'display none'</span>);</span><br><span class="line">  <span class="comment">// 执行代码逻辑...</span></span><br><span class="line">  popover.style.display = <span class="string">'none'</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>但是点击 ‘浮层’,浮层就会消失,原因是在 <code>wrapper</code> 那里没有阻止冒泡, 加上即可</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">clickMe.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'display block'</span>);</span><br><span class="line">  popover.style.display = <span class="string">'block'</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">wrapper.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  e.stopPropagation();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听 document</span></span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'display none'</span>);</span><br><span class="line">  <span class="comment">// 执行代码逻辑...</span></span><br><span class="line">  popover.style.display = <span class="string">'none'</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="更好的解决方法"><a href="#更好的解决方法" class="headerlink" title="更好的解决方法"></a>更好的解决方法</h3><p><code>document</code> 只用监听一次,如下代码<br>使用 jQuery 来做<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(clickMe).on(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    $(popover).show();</span><br><span class="line">    $(<span class="built_in">document</span>).one(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        $(popover).hide();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">$(wrapper).on(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">    e.stopPropagation();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>好处是不用每次点击 <code>document</code> 就增加一个函数,比较节省内存, <code>one</code> 只执行一次,执行完就销毁</p>
<p>或者使用异步代码</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(clickMe).on(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  $(popover).show();</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    $(<span class="built_in">document</span>).one(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      $(popover).hide();</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>这里异步代码执行的逻辑是,先 <code>show</code> ,然后执行 <code>setTimeout</code> 并且将 click 事件绑定在函数 function 上,然后等待 <code>button</code> 的 click 事件冒泡结束后,下次若有点击出现在 <code>document</code> 上时,便执行已经绑定好的 function 里的 <code>hide</code> 函数</p>
<h3 id="最后的-bug"><a href="#最后的-bug" class="headerlink" title="最后的 bug"></a>最后的 bug</h3><p>假如最后的代码是这样</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(clickMe).on(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    $(popover).show();</span><br><span class="line">    $(<span class="built_in">document</span>).one(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        $(popover).hide();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>即去掉了 <code>wrapper</code> 的点击事件的添加,那么呈现出来的效果就还是点击按钮没反应,原因如下图所示</p>
<p><img src="./img5.png" alt></p>
<p>由于代码并非异步执行,所以在冒泡阶段,代码首先执行了 <code>show</code>,而后 <code>document</code> 立即执行了添加事件监听,将 <code>document</code> 已经绑定好的函数执行了,也就是执行到了最后的 <code>hide</code></p>
<h2 id="DOM-一些注意事项"><a href="#DOM-一些注意事项" class="headerlink" title="DOM 一些注意事项"></a>DOM 一些注意事项</h2><ul>
<li>尽量不用全局变量(window),要用局部变量,不然变量名跟全局变量一样的话就会互相覆盖,局部变量就用函数包起来,让这个变量有个局部作用域</li>
<li><p>立即执行函数,声明一个函数,立即执行这个函数 (避免使用全局变量)</p>
<ul>
<li><p>代码如下</p>
<figure class="highlight qml"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> <span class="built_in">parent</span> = <span class="built_in">document</span>.querySelecor(<span class="string">'#self'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">parent</span>);</span><br><span class="line">&#125;.call()</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> <span class="built_in">parent</span> = <span class="built_in">document</span>.querySelecor(<span class="string">'#self'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">parent</span>);</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>以上的代码,在刷新页面时会报错,解决方法如下</p>
<ul>
<li><p>加括号</p>
<figure class="highlight qml"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> <span class="built_in">parent</span> = <span class="built_in">document</span>.querySelecor(<span class="string">'#self'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">parent</span>);</span><br><span class="line">&#125;.call())</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> <span class="built_in">parent</span> = <span class="built_in">document</span>.querySelecor(<span class="string">'#self'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">parent</span>);</span><br><span class="line">&#125;).call()</span><br></pre></td></tr></table></figure>
</li>
<li><p>加正/负号, ~,!号</p>
<figure class="highlight qml"><table><tr><td class="code"><pre><span class="line">+<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> <span class="built_in">parent</span> = <span class="built_in">document</span>.querySelecor(<span class="string">'#self'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">parent</span>);</span><br><span class="line">&#125;.call()</span><br><span class="line">-<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> <span class="built_in">parent</span> = <span class="built_in">document</span>.querySelecor(<span class="string">'#self'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">parent</span>);</span><br><span class="line">&#125;.call()</span><br><span class="line">~<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> <span class="built_in">parent</span> = <span class="built_in">document</span>.querySelecor(<span class="string">'#self'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">parent</span>);</span><br><span class="line">&#125;.call()</span><br><span class="line">!<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> <span class="built_in">parent</span> = <span class="built_in">document</span>.querySelecor(<span class="string">'#self'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">parent</span>);</span><br><span class="line">&#125;.call()</span><br></pre></td></tr></table></figure>
</li>
<li><p>用代码块</p>
<figure class="highlight qml"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 这里不能用 var ,用 var 就相当于声明了全局变量,因为 var 声明的变量会提升</span></span><br><span class="line">    <span class="keyword">let</span> <span class="built_in">parent</span> = <span class="built_in">document</span>.querySelecor(<span class="string">'#self'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">parent</span>);</span><br><span class="line">    <span class="comment">// let 的作用域始终在包含它的花括号里</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h2 id="DOM-事件小总结"><a href="#DOM-事件小总结" class="headerlink" title="DOM 事件小总结"></a>DOM 事件小总结</h2><p>DOM 事件响应的模型<br><img src="./img6.png" alt></p>
<p>如上图所示,这里有三个 <code>div</code>,其嵌套关系为 ‘爷爷 &gt; 爸爸 &gt; 儿子’,对于添加事件监听来说,如果给 <code>addEventListener</code> 后传参为 <code>true</code>,则将其事件添加进 <strong>捕获阶段</strong>;如果给 <code>addEventListener</code>后传参为 <code>false</code> 或者不传参,则将其事件添加进 <strong>冒泡阶段</strong></p>
<p>若三个 div 节点监听的事件均在捕获阶段,那么对应函数执行的顺序就是 fn1 &gt; fn2 &gt; fn3;</p>
<p>若三个 div 节点监听的事件均在冒泡阶段,那么对应函数执行的顺序就是 fn33 &gt; fn22 &gt; fn11;</p>
<p>对于 ‘儿子’ 来说,若同时存在 fn3 和 fn33,那么<strong>优先响应先添加进的事件</strong></p>
]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>dom</tag>
      </tags>
  </entry>
  <entry>
    <title>Elements-kinds-in-V8-(翻译)</title>
    <url>/2021/11/23/Elements-kinds-in-V8-%E7%BF%BB%E8%AF%91/</url>
    <content><![CDATA[<blockquote>
<p>注：该文章翻译自<a href="https://v8.dev/blog/elements-kinds" target="_blank" rel="noopener">https://v8.dev/blog/elements-kinds</a> V8 的官方博客，这是关于解释在 V8 中「elements」的类型都有哪些的一篇文章，文章有翻译的不是很清楚的地方，欢迎各位指正</p>
</blockquote>
<a id="more"></a>
<p>JavaScript 对象可以和任何属性有关联。对象属性的名称可以包含任何字符。有趣的是 JavaScript 引擎可以选择名称为纯数字的属性来进行优化，而这个属性其实就是<a href="https://tc39.es/ecma262/#array-index" target="_blank" rel="noopener">数组 index</a>。</p>
<p>在 V8 中，会特殊处理整数名称的属性（最常见的形式是由 Array 构造函数生成的对象）。尽管很多情况下这些数字索引属性的表现和其他属性一样，但为了优化，V8 将它们和非数字属性分开存储。在内部，V8 甚至给这些属性一个特殊的名称：<em>elements</em>。对象通过<a href="https://v8.dev/blog/fast-properties" target="_blank" rel="noopener">properties</a>可以 map 到一些 value ，而数组通过 index 可以 map 到一些子元素。</p>
<p>尽管这些内部细节从来没有直接向 JavaScript 开发人员公开，但它们解释了为什么某些代码模式比其他模式更快。</p>
<h2 id="常见的-elements-类型"><a href="#常见的-elements-类型" class="headerlink" title="常见的 elements 类型"></a>常见的 elements 类型</h2><p>在运行 JavaScript 代码时，V8 会追踪每个数组的 elements 的类型。V8 可以根据这些信息，在对拥有这种 elements 类型的数组进行操作时，进行针对性的优化。例如，当在数组上调用 <code>reduce</code>，<code>map</code> 或 <code>forEach</code> 时，V8 可以根据数组的 elements 类型来优化这些操作。</p>
<p>以这个数组为例:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br></pre></td></tr></table></figure>
<p>这个数组的 elements 类型是什么呢？如果用 <code>typeof</code> 来回答，结果就是这个数组含有 <code>number</code> 类型的数。在语言层面，这就是我们能看到的：JavaScript 不会区分整数(integers)，浮点数(floats)和双精度数(doubles)，它们都只是数字。但在引擎层面，我们可以做更精确地区分。该数组的 elements 类型为 <code>PACKED_SMI_ELEMENTS</code>。在 V8 中，术语 <code>Smi</code> 是指用于存储小整数(small integers)的一种特定格式。</p>
<p>然后，向同一个数组中添加浮点数会把这个数组转为更通用的 elements 类型</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="comment">// elements 类型: PACKED_SMI_ELEMENTS</span></span><br><span class="line">array.push(<span class="number">4.56</span>);</span><br><span class="line"><span class="comment">// elements 类型: PACKED_DOUBLE_ELEMENTS</span></span><br></pre></td></tr></table></figure>
<p>向数组中添加字符串将再次改变数组 elements 类型</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="comment">// elements 类型: PACKED_SMI_ELEMENTS</span></span><br><span class="line">array.push(<span class="number">4.56</span>);</span><br><span class="line"><span class="comment">// elements 类型: PACKED_DOUBLE_ELEMENTS</span></span><br><span class="line">array.push(<span class="string">'x'</span>);</span><br><span class="line"><span class="comment">// elements 类型: PACKED_ELEMENTS</span></span><br></pre></td></tr></table></figure>
<p>到目前为止，我们已经看到了 3 种不同的 elements 类型，以下是基本类型</p>
<ul>
<li><strong>Sm</strong> all  <strong>i</strong> ntegers，也就是 Smi</li>
<li>Doubles，用于不能用 Smi 表示的浮点数(floating-point)和整数(integers)</li>
<li>常规 elements，用于不能表示为 Smi 或双精度值(doubles)的值</li>
</ul>
<p>注意，doubles 是 Smi 的一种更通用的变体，常规 elements 是 doubles 之上的另一种泛化。用 Smi 表示的数字集 是 用 double 表示的数字集的子集。</p>
<p>重点是 elements 类型只向一个方向转化，从特殊的(比如: <code>PACKED_SMI_ELEMENTS</code>) 转向更常规的(比如: <code>PACKED_ELEMENTS</code>)，比如一旦一个数组被标记为是 <code>PACKED_ELEMENTS</code>，它就不能再转化成 <code>PACKED_DOUBLE_ELEMENTS</code> 类型的了。</p>
<p>目前，我们已经了解到</p>
<ul>
<li>V8 会对每个数组赋予一个 elements 类型</li>
<li>数组的 elements 类型并不是一成不变的 —— 它可以在运行时改变。之前的例子中有从 <code>PACKED_SMI_ELEMENTS</code> 转向 <code>PACKED_ELEMENTS</code> 的</li>
<li>elements 类型只能从特定类型转向常规类型</li>
</ul>
<h2 id="PACKED-和-HOLEY-类型"><a href="#PACKED-和-HOLEY-类型" class="headerlink" title="PACKED 和 HOLEY 类型"></a><code>PACKED</code> 和 <code>HOLEY</code> 类型</h2><p>目前我们只谈到了 packed 类型的数组。在数组中创建 holes (使数组变稀疏)会将其 elements 类型降级成它的 “holey” 版本</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4.56</span>, <span class="string">'x'</span>];</span><br><span class="line"><span class="comment">// elements 类型: PACKED_ELEMENTS</span></span><br><span class="line">array.length; <span class="comment">// 5</span></span><br><span class="line">array[<span class="number">9</span>] = <span class="number">1</span>; <span class="comment">// array[5] 到 array[8] 现在都是 holes</span></span><br><span class="line"><span class="comment">// elements 类型: HOLEY_ELEMENTS</span></span><br></pre></td></tr></table></figure>
<p>V8 之所以有这种区别，它在优化 packed 类型数组的操作上比 holey 类型数组更积极。在 packed 类型数组上大多数操作都可以有效率地执行。相比之下，在 holey 类型数组上，这些操作就需要在原型链上进行额外的检测，并耗费性能高昂的查询。</p>
<p>到目前为止，我们已经看到每种基本 elements 类型(即 Smis，double 和常规 elements 类型)都有两种: packed 版本和 holey 版本。它们不仅可以从 <code>PACKED_SMI_ELEMENTS</code> 转变成 <code>PACKED_DOUBLE_ELEMENTS</code>，而且还可以从任何 <code>PACKED</code> 类型转变成其 <code>HOLEY</code> 对应类型。<br>总结一下:</p>
<ul>
<li>最常见的 elements 类型有 <code>PACKED</code> 类型和 <code>HOLEY</code> 类型</li>
<li>在 packed 类型数组上的操作比 holey 类型数组更有效率</li>
<li>elements 类型可以从 <code>PACKED</code> 类型转变成 <code>HOLEY</code> 类型</li>
</ul>
<h2 id="elements-类型-格"><a href="#elements-类型-格" class="headerlink" title="elements 类型 格"></a>elements 类型 格</h2><p>这套标记转换系统被 V8 弄成了一个 <a href="https://zh.wikipedia.org/wiki/%E6%A0%BC_(%E6%95%B0%E5%AD%A6" target="_blank" rel="noopener">格</a>)。下面是只有几个 elements 类型的简化示意图:</p>
<p><img src="./1.png" alt></p>
<p>它只能通过格来向下转变。一旦一个 Smis 数组添加了单个浮点数(single floating-point)，即便之后使用 Smi 覆盖该浮点数，它都会被标记为 DOUBLE。同样的，一旦一个数组中出现了 hole，即便之后将这个 hole 补上了，它都会被标记为 holey。</p>
<p>V8 目前区分了 <a href="https://source.chromium.org/chromium/v8/v8.git/+/ec37390b2ba2b4051f46f153a8cc179ed4656f5d:src/elements-kind.h;l=14" target="_blank" rel="noopener">21 种不同的 elements 类型</a>，每一种都可能有一堆优化</p>
<p>通常，更特定的 elements 类型支持更细粒度的优化。格中 elements 类型越往下，其对象的操作就会越慢。为了获取最佳性能，避免不太特定的类型的这种不必要的转换，应坚持使用最适合情况的特定 elements 类型。</p>
<h2 id="性能建议"><a href="#性能建议" class="headerlink" title="性能建议"></a>性能建议</h2><p>大多数情况下，elements 类型的追踪工作是在底层运行的，没必要考虑得那么细。但为了从系统中获取最大收益，以下几件事情是可以做的。</p>
<h3 id="避免读取超出数组长度的内容"><a href="#避免读取超出数组长度的内容" class="headerlink" title="避免读取超出数组长度的内容"></a>避免读取超出数组长度的内容</h3><p>有点出乎意料(鉴于这篇文章的标题)的是，我们的第 1 个性能建议与 elements 类型追踪没有直接联系(尽管背后发生的事情有点像)。读取超过数组长度的数据会对性能产生惊人的影响，例如当 <code>array.length === 5</code> 时去读 <code>array[42]</code> 的数据。这个例子中数组下标 <code>42</code> 已经越界，数组本身就没这属性，JS 引擎就会耗费昂贵的性能去原型链上找。一旦加载遇到这种情况，V8 会记住 “这个加载需要处理特殊情况”，而且它的速度再也不会像读取到越界之前那么快了。</p>
<p>不要把循环写成这样:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不要这么写!</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, item; (item = items[i]) != <span class="literal">null</span>; i++) &#123;</span><br><span class="line">  doSomething(item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码读取数组中的所有元素，然后再读取一个元素。直到它发现 <code>undefined</code> 的或 <code>null</code> 元素时才结束。(jQuery 在一些地方就这么干的。)</p>
<p>相反，用老方式写循环，并不断迭代，直到到达最后一个元素。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> index = <span class="number">0</span>; index &lt; items.length; index++) &#123;</span><br><span class="line">  <span class="keyword">const</span> item = items[index];</span><br><span class="line">  doSomething(item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果循环的对象是可迭代的(比如数组和 <code>NodeLists</code>)就更好了，直接用 <code>for-of</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> item <span class="keyword">of</span> items) &#123;</span><br><span class="line">  doSomething(item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于特定数组，也可以用内置 <code>forEach</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">items.forEach(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">  doSomething(item);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>现在 <code>for-of</code> 和 <code>forEach</code> 的性能都和老式的 for 循环差不多了。</p>
<p>避免读取超出数组长度的内容！在这种情况下，V8 的边界检查会失败，检查该属性是否存在也就会失败，然后 V8 就要从原型链上找了。如果之后在计算中不小心使用到了这个值(也就是超出数组长度的值)，影响会更糟，例如:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Maximum</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> max = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt;= array.length; i++) &#123; <span class="comment">// 糟糕的比较</span></span><br><span class="line">    <span class="keyword">if</span> (array[i] &gt; max) max = array[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这里，最后一次迭代超出了数组长度，返回结果为 <code>undefined</code>，这既影响了加载，又影响了比较：不再只比较数字，它要处理特殊情况。把终止条件改为正确的 <code>i &lt; array.length</code> 可使本示例的性能提高 6 倍(在有 10,000 个元素的数组上进行测试，迭代次数只减少了 0.01%)。</p>
<h3 id="避免-elements-类型的变化"><a href="#避免-elements-类型的变化" class="headerlink" title="避免 elements 类型的变化"></a>避免 elements 类型的变化</h3><p>通常，如果需要在一个数组上执行很多操作，试着只用一种元素类型，尽可能是特定类型，这样 V8 可以尽可能对这些操作进行优化。</p>
<p>这比看上去要难。比如仅向一个 Smi 数组中添加 <code>-0</code> 就能把它变成 <code>PACKED_DOUBLE_ELEMENTS</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> array = [<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, +<span class="number">0</span>];</span><br><span class="line"><span class="comment">// PACKED_SMI_ELEMENTS</span></span><br><span class="line">array.push(<span class="number">-0</span>);</span><br><span class="line"><span class="comment">// PACKED_DOUBLE_ELEMENTS</span></span><br></pre></td></tr></table></figure>
<p>结果就是，之后对该数组的任何操作的优化都与对 Smi 的优化不一样。</p>
<p>避免使用 <code>-0</code>，除非明确需要在代码中区分 <code>-0</code> 和 <code>+0</code>。(最好不要这么做)</p>
<p>对于 <code>NaN</code> 和 <code>Infinity</code> 而言都是一样的。它们都被看作是浮点数(doubles)，所以在一个 <code>SMI_ELEMENTS</code> 数组中添加一个 <code>NaN</code> 或者是 <code>Infinity</code>，这个数组就会变成 <code>DOUBLE_ELEMENTS</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> array = [<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>];</span><br><span class="line"><span class="comment">// PACKED_SMI_ELEMENTS</span></span><br><span class="line">array.push(<span class="literal">NaN</span>, <span class="literal">Infinity</span>);</span><br><span class="line"><span class="comment">// PACKED_DOUBLE_ELEMENTS</span></span><br></pre></td></tr></table></figure>
<p>要对一个整数数组进行大量的操作了，在它初始化时就应考虑下把 <code>-0</code> 变成 <code>0</code>，<code>NaN</code> 和 <code>Infinity</code> 之类的值就应该过滤掉。这样一来，这个数组才会维持在 <code>PACKED_SMI_ELEMENTS</code> 状态。这种一次性标准化后的开销对于后续优化都是值得的。</p>
<p>实际上，如果要对数字(numbers)数组进行数学操作，可以考虑下 TypedArray。这也有对应的特定的 elements 类型。</p>
<h3 id="优先使用-array-而不是-array-like-的对象"><a href="#优先使用-array-而不是-array-like-的对象" class="headerlink" title="优先使用 array 而不是 array-like 的对象"></a>优先使用 array 而不是 array-like 的对象</h3><p>有些 JS 里的对象，特别是 DOM，看起来像是数组但其实它们并不是真正意义上的数组。创建的 array-like 的数组就像下面这样</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arrayLike = &#123;&#125;;</span><br><span class="line">arrayLike[<span class="number">0</span>] = <span class="string">'a'</span>;</span><br><span class="line">arrayLike[<span class="number">1</span>] = <span class="string">'b'</span>;</span><br><span class="line">arrayLike[<span class="number">2</span>] = <span class="string">'c'</span>;</span><br><span class="line">arrayLike.length = <span class="number">3</span>;</span><br></pre></td></tr></table></figure>
<p>这个对象有 <code>length</code> ，也可以通过下标索引访问子元素(就像数组一样!)，但它在其原型链上缺少数组方法，比如 <code>forEach</code>。不过仍可以通过下面的方式在这个对象上调用数组的方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.forEach.call(arrayLike, (value, index) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123; index &#125;</span>: <span class="subst">$&#123; value &#125;</span>`</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 先打印 '0: a', 然后打印 '1: b', 最后打印 '2: c'.</span></span><br></pre></td></tr></table></figure>
<p>这段代码调用 array-like 对象上内置的 <code>Array.prototype.forEach</code> 方法，结果符合预期。但这比在真数组上调用 <code>forEach</code> 慢，而后者在 V8 中已被高度优化。要多次在此对象上使用内置的数组方法的话，就应先把它转成真数组再用：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> actualArray = <span class="built_in">Array</span>.prototype.slice.call(arrayLike, <span class="number">0</span>);</span><br><span class="line">actualArray.forEach(<span class="function">(<span class="params">value, index</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123; index &#125;</span>: <span class="subst">$&#123; value &#125;</span>`</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 先打印 '0: a', 然后打印 '1: b', 最后打印 '2: c'.</span></span><br></pre></td></tr></table></figure>
<p>这种一次性转换的开销对于后续的优化来讲都是值得的，特别是当对数组执行大量操作时。</p>
<p><code>arguments</code> 对象是一个 array-like 对象，可以在其上调用数组内置函数，但这种操作不会像对真数组那样做全方位的优化。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> logArgs = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">Array</span>.prototype.forEach.call(<span class="built_in">arguments</span>, (value, index) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123; index &#125;</span>: <span class="subst">$&#123; value &#125;</span>`</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line">logArgs(<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>);</span><br><span class="line"><span class="comment">// 先打印 '0: a', 然后打印 '1: b', 最后打印 '2: c'.</span></span><br></pre></td></tr></table></figure>
<p>ES2015 rest 参数可以在这里帮个忙。它们可以用真数组，而不是优雅地用 array-like 的 <code>arguments</code> 对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> logArgs = <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">  args.forEach(<span class="function">(<span class="params">value, index</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123; index &#125;</span>: <span class="subst">$&#123; value &#125;</span>`</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line">logArgs(<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>);</span><br><span class="line"><span class="comment">// 先打印 '0: a', 然后打印 '1: b', 最后打印 '2: c'.</span></span><br></pre></td></tr></table></figure>
<p>现在你还有啥借口用 <code>arguments</code> 对象。</p>
<p>所以一般来讲，尽可能避免使用 array-like 的对象，应尽可能使用真数组。</p>
<h3 id="避免多态"><a href="#避免多态" class="headerlink" title="避免多态"></a>避免多态</h3><p>如果代码中要处理很多不同的 elements 类型的数组，它可能会导致多态操作，这比只用处理单个 elements 类型的代码要慢。</p>
<p>看如下示例，里面调用了各种 elements 类型的库函数。(注意下这不是原来的 <code>Array.prototype.forEach</code> 方法，除了本文讨论的对特定 elements 类型的优化，这个示例自己也有一套优化。)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> each = <span class="function">(<span class="params">array, callback</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> index = <span class="number">0</span>; index &lt; array.length; ++index) &#123;</span><br><span class="line">    <span class="keyword">const</span> item = array[index];</span><br><span class="line">    callback(item);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> doSomething = <span class="function">(<span class="params">item</span>) =&gt;</span> <span class="built_in">console</span>.log(item);</span><br><span class="line"></span><br><span class="line">each([], () =&gt; &#123;&#125;);</span><br><span class="line"></span><br><span class="line">each([<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>], doSomething);</span><br><span class="line"><span class="comment">// `PACKED_ELEMENTS` 调用了 `each` 方法。V8 使用了内联缓存</span></span><br><span class="line"><span class="comment">// (或者说叫 "IC") 记住了这个 `each` 方法是被这个 elements 类型调用的。</span></span><br><span class="line"><span class="comment">// 若不出意外，V8 会乐观地假定在 `each` 方法里访问 `array.length` 和 `array[index]` 时</span></span><br><span class="line"><span class="comment">// 是单一的(比如只接受一种 elements 类型)，之后每次调用 `each` 方法，V8 就会去检查这个类型</span></span><br><span class="line"><span class="comment">// 是不是 `PACKED_ELEMENTS`，如果是，V8 会重用之前生成的代码；</span></span><br><span class="line"><span class="comment">// 如果不是，就需要做更多事情了</span></span><br><span class="line"></span><br><span class="line">each([<span class="number">1.1</span>, <span class="number">2.2</span>, <span class="number">3.3</span>], doSomething);</span><br><span class="line"><span class="comment">// `PACKED_DOUBLE_ELEMENTS` 调用了 `each` 方法。 V8 此时看到，在它的内联缓存里面，</span></span><br><span class="line"><span class="comment">// 给 `each` 方法传的是不同的 elements 类型的数组了，那么在 `each` 方法里访问 `array.length` 和 `array[index]` 时就被打上了多态的标记。</span></span><br><span class="line"><span class="comment">// 现在每次在调用 `each` 方法时 V8 都要去做下额外的检查:</span></span><br><span class="line"><span class="comment">// 1. 这个是不是 `PACKED_ELEMENTS`(就像上面说过的)</span></span><br><span class="line"><span class="comment">// 2. 这个是不是 `PACKED_DOUBLE_ELEMENTS`</span></span><br><span class="line"><span class="comment">// 3. 这个还是不是其他的 elements 类型</span></span><br><span class="line"><span class="comment">// 这就会引起性能上的损耗</span></span><br><span class="line"></span><br><span class="line">each([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], doSomething);</span><br><span class="line"><span class="comment">// `PACKED_SMI_ELEMENTS` 调用了 `each` 方法。这就触发了另一个种程度的多态性。现在在内联缓存中，对于 `each` 方法来说有 3 种不同的 elements 类型。从现在开始每次调用 `each` 方法，就需要另外检查 elements 类型，才能将生成的代码重新用于 `PACKED_SMI_ELEMENTS` 数组，而这都需要以消耗性能为代价才能做的。</span></span><br></pre></td></tr></table></figure>
<p>内置方法(如 <code>Array.prototype.forEach</code>)可以更有效地处理这种多态性，因此如果对性能敏感，请考虑使用这些内置方法而不是用户手写的库函数</p>
<p>V8 中关于单态与多态的另一个例子就跟对象的 shape 相关，也就是对象的隐藏类。要了解更多请参考 <a href="https://mrale.ph/blog/2015/01/11/whats-up-with-monomorphism.html" target="_blank" rel="noopener">这篇文章</a></p>
<h3 id="避免创建-holes"><a href="#避免创建-holes" class="headerlink" title="避免创建 holes"></a>避免创建 holes</h3><p>在真正的代码看来，访问 holey 数组和 packed 数组之间的性能差异通常太小，甚至无法测量。如果性能测试表明在优化的代码中保留每一条机器指令是值得的，那么可以尝试把数组维持在 packed 模式。比如说，我们要创建一个数组</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> array = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">3</span>);</span><br><span class="line"><span class="comment">// 此时这个数组是稀疏的，所以它被标记为 `HOLEY_SMI_ELEMENTS`</span></span><br><span class="line"><span class="comment">// 根据当前的信息这就是最可能的结果</span></span><br><span class="line"></span><br><span class="line">array[<span class="number">0</span>] = <span class="string">'a'</span>;</span><br><span class="line"><span class="comment">// 等等，这是一个字符而不是一个 Smi，所以 elements 类型转成 `HOLEY_ELEMENTS`</span></span><br><span class="line"></span><br><span class="line">array[<span class="number">1</span>] = <span class="string">'b'</span>;</span><br><span class="line">array[<span class="number">2</span>] = <span class="string">'c'</span>;</span><br><span class="line"><span class="comment">// 此时，数组的 3 个位置都被填满了。所以数组是 packed 了(不再是稀疏的了)。</span></span><br><span class="line"><span class="comment">// 然而现在已经不能把这个数组再转成一个特定类型比如 `PACKED_ELEMENTS` 了。</span></span><br><span class="line"><span class="comment">// elements 类型仍然为 `HOLEY_ELEMENTS`</span></span><br></pre></td></tr></table></figure>
<p>一旦数组被标记为 holey，它将永远保持在 holey 状态，即便之后数组里面有元素了</p>
<p>创建数组的更好方法是使用如下方式</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> array = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>];</span><br><span class="line"><span class="comment">// elements 类型: PACKED_ELEMENTS</span></span><br></pre></td></tr></table></figure>
<p>如果事先不知道所有的值，可以创建一个空数组，然后将值 <code>push</code> 进去</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> array = [];</span><br><span class="line"><span class="comment">// …</span></span><br><span class="line">array.push(someValue);</span><br><span class="line"><span class="comment">// …</span></span><br><span class="line">array.push(someOtherValue);</span><br></pre></td></tr></table></figure>
<p>这种方法确保了数组永远不会转换为 holey elements 类型。因此，V8 可能会为这个数组的某些操作生成更快的优化代码。</p>
<h2 id="调试-elements-类型"><a href="#调试-elements-类型" class="headerlink" title="调试 elements 类型"></a>调试 elements 类型</h2><p>为了弄明白啥是对象的 elements 类型，可用 d8 的调试版本运行(通过在 debug 模式下<a href="https://v8.dev/docs/build" target="_blank" rel="noopener">从源码进行构建</a>，或使用 <a href="https://github.com/GoogleChromeLabs/jsvu" target="_blank" rel="noopener">jsvu</a> 弄到预编译的二进制文件)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">out/x64.debug/d8 --allow-natives-syntax</span><br></pre></td></tr></table></figure>
<p>这将打开一个 d8 REPL，其中可用 <code>%DebugPrint(object)</code> 等<a href="https://cs.chromium.org/chromium/src/v8/src/runtime/runtime.h?l=20&amp;rcl=05720af2b09a18be5c41bbf224a58f3f0618f6be" target="_blank" rel="noopener">特殊函数</a>。输出的 <code>elements</code> 字段显示了传递给 这个 debug 函数的对象的 elements 类型。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">d8&gt; const array = [1, 2, 3]; %DebugPrint(array);</span><br><span class="line">DebugPrint: 0x1fbbad30fd71: [JSArray]</span><br><span class="line"> - map = 0x10a6f8a038b1 [FastProperties]</span><br><span class="line"> - prototype = 0x1212bb687ec1</span><br><span class="line"> - elements = 0x1fbbad30fd19 &lt;FixedArray[3]&gt; [PACKED_SMI_ELEMENTS (COW)]</span><br><span class="line"> - length = 3</span><br><span class="line"> - properties = 0x219eb0702241 &lt;FixedArray[0]&gt; &#123;</span><br><span class="line">    <span class="comment">#length: 0x219eb0764ac9 &lt;AccessorInfo&gt; (const accessor descriptor)</span></span><br><span class="line"> &#125;</span><br><span class="line"> - elements= 0x1fbbad30fd19 &lt;FixedArray[3]&gt; &#123;</span><br><span class="line">           0: 1</span><br><span class="line">           1: 2</span><br><span class="line">           2: 3</span><br><span class="line"> &#125;</span><br><span class="line">[…]</span><br></pre></td></tr></table></figure>
<p>注意，COW 表示<a href="https://zh.wikipedia.org/wiki/%E5%AF%AB%E5%85%A5%E6%99%82%E8%A4%87%E8%A3%BD" target="_blank" rel="noopener">copy-on-write</a>，这是另一个内部优化。</p>
<p>在调试构建中可用的另一个有用的 flag 是 <code>--trace-elements-transitions</code>。用上它能让 V8 提示你 elements 类型转换是在啥时发生的。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ cat my-script.js</span><br><span class="line">const array = [1, 2, 3];</span><br><span class="line">array[3] = 4.56;</span><br><span class="line"></span><br><span class="line">$ out/x64.debug/d8 --trace-elements-transitions my-script.js</span><br><span class="line">elements transition [PACKED_SMI_ELEMENTS -&gt; PACKED_DOUBLE_ELEMENTS] <span class="keyword">in</span> ~+34 at x.js:2 <span class="keyword">for</span> 0x1df87228c911 &lt;JSArray[3]&gt; from 0x1df87228c889 &lt;FixedArray[3]&gt; to 0x1df87228c941 &lt;FixedDoubleArray[22]&gt;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>翻译</category>
      </categories>
      <tags>
        <tag>V8</tag>
      </tags>
  </entry>
  <entry>
    <title>Cookie、登录和注册</title>
    <url>/2019/02/20/Cookie%E3%80%81%E7%99%BB%E5%BD%95%E5%92%8C%E6%B3%A8%E5%86%8C/</url>
    <content><![CDATA[<h1 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h1><p>Cookie 是什么，Cookie 就是一串数据，而这串数据可以存在用户本地的终端上，从而起到辨别用户身份的作用。</p>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>1993 年 3 月由网景公司前程序员卢·蒙特利发明，最开始定义于 RFC 2109, 而目前应用最广泛的标准是网景公司制定的标准上进行扩展后的版本</p>
<h2 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h2><p>HTTP 协议本身是个无状态的协议，如果单单只通过这个协议，那么对于服务端来说，用户上一次操作了啥它是不知道的,比如一个购物网站，用户买了点东西，到最后结帐时服务器不会知道用户买了什么，为了解决这个问题，Cookie 应运而生，即用户在买了点东西之后，服务器发送一段包含商品信息的 Cookie 给用户，这下用户在浏览其他网页时(或者在做其他的操作时)浏览器将这段 Cookie 发送回服务器，用户有买其他东西的时候在继续如上的操作，那么在结帐时服务器只需要那段用户(浏览器)返回的 Cookie 就行了，这样就知道了用户买了啥。</p>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ol>
<li>服务器通过 Set-Cookie 响应头设置 Cookie</li>
<li>浏览器得到 Cookie 之后，每次请求都要带上 Cookie 发送给服务器</li>
<li>服务器读取 Cookie 就知道了用户的一些信息(登录信息、购物信息等)</li>
</ol>
<h2 id="其他一些-Cookie-相关"><a href="#其他一些-Cookie-相关" class="headerlink" title="其他一些 Cookie 相关"></a>其他一些 Cookie 相关</h2><ul>
<li>不同浏览器登录带上的 Cookie 是不一样的</li>
<li>Cookie 可以被用户篡改，Session 可以解决这个问题</li>
<li>Cookie 的默认有效期为 20 分钟左右，不同的浏览器策略不一样,后端可用 Set-Cookie 的 Max-Age 属性来强制设置有效期</li>
<li>Cookie 遵守的同源策略跟 AJAX 的略有不同<br>  比如<br>  当请求 qq.com 下的资源时，浏览器会默认带上 qq.com 对应的 Cookie，不会带上 baidu.com 对应的 Cookie<br>  当请求 v.qq.com 下的资源时，浏览器不仅会带上 v.qq.com 的Cookie，还会带上 qq.com 的 Cookie<br>  另外，可以用过设置 Set-Cookie 的 Path 属性将 Cookie 与部分 Web 站点关联起来,起到一些限制作用</li>
<li><p>删除 cookie 的唯一方式</p>
  <figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 删除 Cookie 则指定 Set-Cookie 的 Expire 属性，指定一个已经过期的日期即可</span></span><br><span class="line">document.cookie = 'fontSize=;expires=Thu, 01-Jan-<span class="number">1970</span> 00:00:01 GMT';</span><br><span class="line"><span class="comment">// 这里 fontSize 为空，expires 为 1970 年的一个日期</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="注册和登录"><a href="#注册和登录" class="headerlink" title="注册和登录"></a>注册和登录</h1><p><a href="https://github.com/strugglebak/sign-in-and-sign-up-demo" target="_blank" rel="noopener">代码链接</a></p>
<h2 id="注册逻辑"><a href="#注册逻辑" class="headerlink" title="注册逻辑"></a>注册逻辑</h2><p>这里从最简单的情况开始说起，即一般来说，前端通过 POST 请求发送邮箱、密码、确认密码到后端，而后端通过解析 HTTP 请求的第四部分的信息得到前端发送的邮箱、密码、确认密码，然后会经历以下步骤</p>
<ol>
<li>确认邮箱是否有效(当然这个也可以放到前端来做)</li>
<li>密码与确认密码是否一致(当然这个也可以放到前端来做)</li>
<li>检测邮箱对应用户是否已经注册(这里就要用到数据库的查询功能了),若存在则返回一个 400 状态码,若不存在就直接将信息录入数据库</li>
</ol>
<h2 id="登录逻辑"><a href="#登录逻辑" class="headerlink" title="登录逻辑"></a>登录逻辑</h2><p>登录的逻辑也是差不多的，收到前端登录请求后,解析出主要的信息(邮箱、密码)、然后查询数据对比用户是否存在，用户存在则发送 Cookie 给前端并返回 200 OK，用户不存在则返回一个 401</p>
<h2 id="一些细节"><a href="#一些细节" class="headerlink" title="一些细节"></a>一些细节</h2><p>解析请求时需要监听这个请求传输过程中的 data 事件，为什么需要监听这个事件呢？因为当 <code>http.createServer</code> 的回调被调用的时候，也就是这个 server 接收到了所有的请求头的时候，但在这个时候也可能没有接收到请求中的 data 部分，所以这个时候就需要等待。当这段数据流发送过来时，就会触发 <code>data</code> 事件;当数据流都发送结束时，就会触发 <code>end</code> 事件。通过监听这两个事件来拿到请求中的 POST 上传的数据内容，代码如下<br><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readBody</span>(<span class="params">request</span>)</span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">     <span class="keyword">let</span> body = []</span><br><span class="line">     <span class="comment">// 监听 data 事件</span></span><br><span class="line">     request.on(<span class="string">'data'</span>, <span class="function">(<span class="params">chunk</span>) =&gt;</span> &#123;</span><br><span class="line">       body.push(chunk);</span><br><span class="line">     &#125;).on(<span class="string">'end'</span>, <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">       <span class="comment">// data 事件结束</span></span><br><span class="line">       <span class="comment">// body 转码</span></span><br><span class="line">       body = Buffer.concat(body).toString();</span><br><span class="line">       resolve(body)</span><br><span class="line">     &#125;)</span><br><span class="line">   &#125;)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p>这段代码的逻辑是，先将那些一段一段的数据放到一个数据里面，然后用一个 <code>Buffer</code> 将这些数据连起来并最终返回一个大的 <code>Buffer</code>,最后再将这段二进制数据变成字符串，然后通过 Promise 将数据结果传出去</p>
]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML5入门</title>
    <url>/2019/01/08/HTML5%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h2 id="HTML-简介"><a href="#HTML-简介" class="headerlink" title="HTML 简介"></a>HTML 简介</h2><p>HTML 超文本标记语言 Hyper Text Markup Language<br>由 W3C (World Wide Web Consortium,万维网联盟)组织制订规范<br>HTML 有多少版本?</p>
<ol>
<li>HTML 4.01</li>
<li>XHTML   (XML HTML)</li>
<li>HTML 5  (兼容前面两种版本)</li>
<li>HTML 5.1 (最新发布的)</li>
<li>HTML 5.2 (这个我查了是 2017 年 11 月 2 日发布的)</li>
</ol>
<p>能运行在微信上的网页统称 H5，跟技术无关<br>可以搜索 HTML spec 来搜索 HTML5 的<a href="https://www.w3.org/TR/html/" target="_blank" rel="noopener">规范文档</a>，找到第 4 章 <strong>The element of HTML</strong>,这一章后面都可以看</p>
<h2 id="DOCTYPE"><a href="#DOCTYPE" class="headerlink" title="DOCTYPE"></a>DOCTYPE</h2><ol>
<li>这是用来选择你的文档类型的</li>
<li><p>HTML 5 的 DOCTYPE 是</p>
 <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>HTML 中必须要写 DOCTYPE，不写可能会有隐藏的 bug</p>
</li>
</ol>
<p>最重要的三个标签<br>html head body</p>
<ul>
<li>head 标签可以不写 <a href="https://www.w3.org/TR/html/document-metadata.html#the-head-element" target="_blank" rel="noopener">head链接</a>，但是你不写，浏览器会自动帮你补全</li>
<li>body 标签也可以不写 <a href="https://www.w3.org/TR/html/sections.html#the-body-element" target="_blank" rel="noopener">body链接</a>，但是你不写，浏览器也会自动帮你加个 body 上去</li>
<li>html 标签也可以不写 <a href="https://www.w3.org/TR/html/semantics.html#the-html-element" target="_blank" rel="noopener">html链接</a></li>
</ul>
<p>上面可以有个 W3C 验证器来做验证<br>最少的 html 代码如下<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">DOCKTYPE</span> <span class="attr">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>我的网页<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">你好</span><br></pre></td></tr></table></figure></p>
<p>从上面可以看到，这个代码中可以没有 head,body,html 标签，可以从网页上显示，其中浏览器帮你补全了以上三个标签，但是记住，一般写代码的时候必须要加上</p>
<h2 id="常见标签"><a href="#常见标签" class="headerlink" title="常见标签"></a>常见标签</h2><table>
<thead>
<tr>
<th>标签</th>
<th>标签全称</th>
<th>标签翻译</th>
</tr>
</thead>
<tbody>
<tr>
<td>a</td>
<td>anchor</td>
<td>锚</td>
</tr>
<tr>
<td>form</td>
<td>form</td>
<td>表单</td>
</tr>
<tr>
<td>input</td>
<td>input</td>
<td>输入控件</td>
</tr>
<tr>
<td>button</td>
<td>button</td>
<td>按钮</td>
</tr>
<tr>
<td>h1</td>
<td>head</td>
<td>标题</td>
</tr>
<tr>
<td>p</td>
<td>paragraph</td>
<td>段落</td>
</tr>
<tr>
<td>ul</td>
<td>unorder list</td>
<td>无序列表</td>
</tr>
<tr>
<td>ol</td>
<td>order list</td>
<td>有序列表</td>
</tr>
<tr>
<td>li</td>
<td>list item</td>
<td>列表项</td>
</tr>
<tr>
<td>small</td>
<td>small</td>
<td>文本变小</td>
</tr>
<tr>
<td>strong</td>
<td>strong</td>
<td>文本加粗(表示情感上的加粗)</td>
</tr>
<tr>
<td>div</td>
<td>division</td>
<td>分割</td>
</tr>
<tr>
<td>span</td>
<td>span</td>
<td>范围</td>
</tr>
<tr>
<td>kbd</td>
<td>keyboard</td>
<td>键盘</td>
</tr>
<tr>
<td>video</td>
<td>video</td>
<td>视频</td>
</tr>
<tr>
<td>audio</td>
<td>audio</td>
<td>音频</td>
</tr>
<tr>
<td>svg</td>
<td>scalable vector graphic</td>
<td>可缩放的矢量图形(不规则的图形)</td>
</tr>
<tr>
<td>nav</td>
<td>navigation</td>
<td>导航栏标签</td>
</tr>
<tr>
<td>main</td>
<td>main</td>
<td>表示最主要的内容</td>
</tr>
<tr>
<td>footer</td>
<td>footer</td>
<td>表示网页底部的东西</td>
</tr>
<tr>
<td>hr</td>
<td>horizontal rule</td>
<td>水平分割线</td>
</tr>
<tr>
<td>dl</td>
<td>description list</td>
<td>描述列表</td>
</tr>
<tr>
<td>dt</td>
<td>description term</td>
<td>描述项</td>
</tr>
<tr>
<td>dd</td>
<td>description defination</td>
<td>描述定义</td>
</tr>
<tr>
<td>br</td>
<td>break row</td>
<td>强制换行</td>
</tr>
<tr>
<td>tr</td>
<td>table row</td>
<td>表格中的行</td>
</tr>
<tr>
<td>td</td>
<td>table data</td>
<td>表格中的一个包含数据的单元</td>
</tr>
</tbody>
</table>
<p>注意</p>
<ul>
<li>不懂标签的使用就直接查 MDN 文档</li>
<li>strong 和 bold 的区别就是一种”感情强调”的区别</li>
<li>HTML <strong>不管样式,只管内容</strong>,所以<strong>HTML 标签是没有块级元素和内联元素的区别的,在 CSS 里面才有</strong></li>
<li>HTML 语义化就是<strong>弄懂单词</strong>的意思,比如导航条的英文是 navigation 所以它对应的标签就是 nav</li>
</ul>
<h2 id="几个相对重要的标签"><a href="#几个相对重要的标签" class="headerlink" title="几个相对重要的标签"></a>几个相对重要的标签</h2><p>主要是 iframe/a/form/input/table 这几个</p>
<h3 id="iframe-标签"><a href="#iframe-标签" class="headerlink" title="iframe 标签"></a>iframe 标签</h3><p>这个标签就是在一个页面中再嵌套一个页面<br>示例代码<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>JS Bin<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">    iframe &#123;</span><br><span class="line">      width: 100%;</span><br><span class="line">      height: 400px;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        两个 a 标签都是开一个新窗口</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">iframe</span> <span class="attr">name</span>=<span class="string">xxx</span> <span class="attr">src</span>=<span class="string">"#"</span> <span class="attr">frameborder</span>=<span class="string">"0"</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">target</span>=<span class="string">xxx</span> <span class="attr">href</span>=<span class="string">"http://qq.com"</span>&gt;</span>QQ<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">target</span>=<span class="string">xxx</span> <span class="attr">href</span>=<span class="string">"http://baidu.com"</span>&gt;</span>baidu<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<h3 id="a-标签"><a href="#a-标签" class="headerlink" title="a 标签"></a>a 标签</h3><p>其中 a 标签有 4 个属性:</p>
<ul>
<li>_blank</li>
<li>_self</li>
<li>_parent</li>
<li>_top</li>
</ul>
<p>这 4 个属性要结合 iframe 来理解，这里应该用嵌套 2 层的 iframe 举例<br>如下</p>
<p>a 标签还有个 download 属性<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://qq.com"</span> <span class="attr">download</span>&gt;</span>下载<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>上面这段代码就是可以下载 qq.com 的整个首页到本地。另外，如果你把 http 协议响应的 content-type 修改成<br><figure class="highlight elm"><table><tr><td class="code"><pre><span class="line"><span class="title">content</span>-<span class="keyword">type</span>: application/octet-stream</span><br></pre></td></tr></table></figure></p>
<p>那么浏览器就会以<em>下载</em> 的形式去接收这个请求，而不是渲染页面</p>
<p>还有需要注意的一点是，href 需要指定一个协议，比如像这样<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"qq.com"</span>&gt;</span>QQ<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>你就打不开这个链接，这个时候浏览器会寻找当前目录下的一个叫 qq.com 的文件进而渲染出来，但是可以这样写<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"//qq.com"</span>&gt;</span>QQ<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>关于 a 标签的 <strong>无协议的绝对地址</strong> ,这里的 // 表示当前协议是什么协议，就跳转到该协议中对应的域名链接, 可以用 npm 下载一个 server 工具来试验<br><figure class="highlight axapta"><table><tr><td class="code"><pre><span class="line">sudo npm i -g http-<span class="keyword">server</span></span><br></pre></td></tr></table></figure></p>
<p>然后使用命令<br><figure class="highlight axapta"><table><tr><td class="code"><pre><span class="line">http-<span class="keyword">server</span> -c<span class="number">-1</span> <span class="meta"># 使用无缓存</span></span><br></pre></td></tr></table></figure></p>
<p>然后浏览器访问<br><figure class="highlight dts"><table><tr><td class="code"><pre><span class="line"><span class="symbol">http:</span><span class="comment">//127.0.0.1:8080</span></span><br></pre></td></tr></table></figure></p>
<p>注意，只有<strong>锚点是不发起请求的</strong>，因为锚点的作用是页面内的跳转。 如<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#sss"</span>&gt;</span>QQ<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>关于 javascript 伪协议<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"javascript: alert(1);"</span>&gt;</span>QQ<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>这样点击这个链接就直接执行 javascipt 代码,这样就表示不想跳转和不想发起请求<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"javascript:;"</span>&gt;</span>QQ<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<h3 id="form-标签"><a href="#form-标签" class="headerlink" title="form 标签"></a>form 标签</h3><p>这个也是用来跳转页面，与 a 标签发起的 GET 请求不一样的是，form 标签发起的是一个 POST 请求,注意，如果 form 里面没有表单提交按钮，那么就无法提交这个 form，除非你用 js<br><figure class="highlight stata"><table><tr><td class="code"><pre><span class="line">&lt;<span class="keyword">form</span> <span class="keyword">class</span>=<span class="string">""</span> action=<span class="string">"index2.html"</span> method=<span class="string">"post"</span>&gt;</span><br><span class="line">    &lt;<span class="keyword">input</span> <span class="keyword">type</span>=<span class="string">"submit"</span> name=<span class="string">""</span> value=<span class="string">"提交"</span>&gt;</span><br><span class="line">&lt;/<span class="keyword">form</span>&gt;</span><br></pre></td></tr></table></figure></p>
<p>注意这个时候请求的 content-type 是<br><figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">Content-<span class="keyword">Type</span>: application/x-www-<span class="keyword">form</span>-urlencoded</span><br></pre></td></tr></table></figure></p>
<p>这个 <code>application/x-www-form-urlencoded</code> 决定了编码的方式</p>
<p>没有办法让 GET 请求拥有第 4 部分,但是可以在 POST 请求中修改 action ，通过写死查询参数的方法来让 POST 请求拥有第 1 部分</p>
<p>注意 form  标签也有 target 属性</p>
<h3 id="input-标签"><a href="#input-标签" class="headerlink" title="input 标签"></a>input 标签</h3><p>主要是 type 属性<br>首先是 input 中 type=”button” 和 type=”submit” 的区别,比如说在 form 标签中提交按钮这么写<br><figure class="highlight hsp"><table><tr><td class="code"><pre><span class="line">&lt;<span class="keyword">button</span>&gt;<span class="keyword">button</span>&lt;/<span class="keyword">button</span>&gt;</span><br></pre></td></tr></table></figure></p>
<p>这个时候这个按钮就会自动升级为 submit 按钮,就会有提交功能,但是假如是这样写<br><figure class="highlight hsp"><table><tr><td class="code"><pre><span class="line">&lt;<span class="keyword">button</span> type=<span class="string">"button"</span>&gt;<span class="keyword">button</span>&lt;/<span class="keyword">button</span>&gt;</span><br></pre></td></tr></table></figure></p>
<p>那它就只是个 button，并不能发起 POST 请求, input 标签也是如此，所以重点就在于 submit 这个 type,有些时候，因为有 submit 这个 type,所以在输入框输入东西然后按 enter 键就可以自动提交了</p>
<p>关于 checkbox type 一般的写法是这样<br><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">&lt;input <span class="attribute">type</span>=<span class="string">"checkbox"</span> <span class="attribute">id</span>=<span class="string">"xxx"</span>&gt;&lt;label <span class="attribute">for</span>=<span class="string">"xxx"</span>&gt;嗯嗯&lt;/label&gt;&lt;/input&gt;</span><br></pre></td></tr></table></figure></p>
<p>这样写的作用就是用这个 label 跟这个 input 关联，然后鼠标在点击那个”嗯嗯”的文字的时候，能够自动勾选到这个 checkbox, 所以 label 的 for 和 input 的 id 是一对，它们要一起出现,然而老司机的写法是这样的<br><figure class="highlight stata"><table><tr><td class="code"><pre><span class="line">&lt;<span class="keyword">label</span>&gt;用户名&lt;<span class="keyword">input</span> <span class="keyword">type</span>=<span class="string">"text"</span> name=<span class="string">"xxx"</span>&gt;&lt;/<span class="keyword">label</span>&gt;</span><br></pre></td></tr></table></figure></p>
<p>用 label 将 input 包起来，这样就自动关联了。需要注意的是， name 是必须要的，这样服务器才能得到这些数据</p>
<p>关于 radio type 在 form 标签中示例代码如下<br><figure class="highlight stata"><table><tr><td class="code"><pre><span class="line">&lt;<span class="keyword">label</span>&gt;&lt;<span class="keyword">input</span> name=<span class="string">"love"</span> <span class="keyword">type</span>=<span class="string">"radio"</span> value=<span class="string">"yes"</span>&gt;Yes&lt;/<span class="keyword">label</span>&gt;</span><br><span class="line">&lt;<span class="keyword">label</span>&gt;&lt;<span class="keyword">input</span> name=<span class="string">"love"</span> <span class="keyword">type</span>=<span class="string">"radio"</span> value=<span class="string">"no"</span>&gt;<span class="keyword">No</span>&lt;/<span class="keyword">label</span>&gt;</span><br></pre></td></tr></table></figure></p>
<p>注意到这里的 name 都是 love,所以在单选的时候就只能选一个了</p>
<p>下拉列表<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">section</span> <span class="attr">name</span>=<span class="string">"group"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">""</span>&gt;</span>-<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"1"</span>&gt;</span>第一组<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"2"</span>&gt;</span>第二组<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"3"</span> <span class="attr">disabled</span>&gt;</span>第三组<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"4"</span> <span class="attr">selected</span>&gt;</span>第四组<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>这其中 section 也有 mutiple 属性，就是可以多选</p>
<p>关于 textarea 用户的多行文本<br><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">&lt;textarea <span class="attribute">name</span>=<span class="string">"text"</span> <span class="attribute">rows</span>=<span class="string">"8"</span> <span class="attribute">cols</span>=<span class="string">"80"</span>&gt;&lt;/textarea&gt;</span><br></pre></td></tr></table></figure></p>
<p>一般用 CSS 控制宽高<br><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">&lt;textarea <span class="attribute">style</span>=<span class="string">"resize: none; width:200px; height:400px;"</span> <span class="attribute">name</span>=<span class="string">"text"</span> <span class="attribute">rows</span>=<span class="string">"8"</span> <span class="attribute">cols</span>=<span class="string">"80"</span>&gt;&lt;/textarea&gt;</span><br></pre></td></tr></table></figure></p>
<h3 id="table-标签"><a href="#table-标签" class="headerlink" title="table 标签"></a>table 标签</h3><p>html 规定， table 标签中只能有三个元素<br><figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="section">&lt;table&gt;</span></span><br><span class="line">    <span class="section">&lt;thead&gt;</span><span class="section">&lt;/thead&gt;</span></span><br><span class="line">    <span class="section">&lt;tbody&gt;</span><span class="section">&lt;/tbody&gt;</span></span><br><span class="line">    <span class="section">&lt;tfoot&gt;</span><span class="section">&lt;/tfoot&gt;</span></span><br><span class="line"><span class="section">&lt;/table&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>其中的子标签<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">th</span>&gt;</span><span class="tag">&lt;/<span class="name">th</span>&gt;</span> 表示 table header，也就是表的标题</span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span>&gt;</span><span class="tag">&lt;/<span class="name">tr</span>&gt;</span> 表示 table row，也就是表的行</span><br><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span> 表示 table data，也就是表的数据</span><br></pre></td></tr></table></figure></p>
<p>table 的完整用法如下<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">border</span>=<span class="string">1</span>&gt;</span></span><br><span class="line">    // colgroup 是用来设定 table 的对应列的列宽的</span><br><span class="line">    <span class="tag">&lt;<span class="name">colgroup</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">col</span> <span class="attr">width</span>=<span class="string">100</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">col</span> <span class="attr">width</span>=<span class="string">200</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">col</span> <span class="attr">width</span>=<span class="string">300</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">col</span> <span class="attr">width</span>=<span class="string">70</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">colgroup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">thead</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">th</span>&gt;</span><span class="tag">&lt;/<span class="name">th</span>&gt;</span><span class="tag">&lt;<span class="name">th</span>&gt;</span>姓名<span class="tag">&lt;/<span class="name">th</span>&gt;</span><span class="tag">&lt;<span class="name">th</span>&gt;</span>班级<span class="tag">&lt;/<span class="name">th</span>&gt;</span><span class="tag">&lt;<span class="name">th</span>&gt;</span>分数<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">thead</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tbody</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">th</span>&gt;</span><span class="tag">&lt;/<span class="name">th</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>小明<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>1<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>75<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"></span><br><span class="line">      <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">th</span>&gt;</span><span class="tag">&lt;/<span class="name">th</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>小小<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>2<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>77<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"></span><br><span class="line">      <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">th</span>&gt;</span>平均分<span class="tag">&lt;/<span class="name">th</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>76<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tbody</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tfoot</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">th</span>&gt;</span>总分<span class="tag">&lt;/<span class="name">th</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>152<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tfoot</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>可以用 CSS 将 table 中 border 空隙去掉<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">    table &#123;</span><br><span class="line">        border-collapse: collapse;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>需要注意的是，thead tbody tfoot 这三个标签的顺序，它们之间顺序是没有关联的，因为就算是瞎写，浏览器也会自动纠正显示;并且假如你 thead 或者 tbody 或者 tfoot 不写，浏览器就会自动将你写的加入到 tbody 中，若是三个都不写，那就直接按照你写的数据的顺序进行渲染和显示</p>
]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>html5</tag>
      </tags>
  </entry>
  <entry>
    <title>Fast-Properties-in-V8-(翻译)</title>
    <url>/2021/11/23/Fast-Properties-in-V8-%E7%BF%BB%E8%AF%91/</url>
    <content><![CDATA[<blockquote>
<p>注：该文章翻译自 <a href="https://v8.dev/blog/fast-properties" target="_blank" rel="noopener">Fast properties in V8</a> V8 的关于对象属性内存分配策略的官方文章，文章有翻译的不是很清楚的地方，欢迎各位指正</p>
</blockquote>
<a id="more"></a>
<p>在这篇博客文章中，我们将解释 V8 在内部是怎么处理 JavaScript properties 的。从 JavaScript 的角度来看，properties 只有几个必要的区别。JavaScript 对象与字典类似，使用 string 作为 key 和任意 object 作为 value。但是<a href="https://tc39.es/ecma262/#sec-ordinaryownpropertykeys" target="_blank" rel="noopener">在对象的迭代过程中</a>，规范对于以整数作为 index 的 properties 和其他 properties 的迭代方式是不同的。除此(迭代方式)之外，不同 properties 的表现基本相同，与它们是否以整数作为 index 无关。</p>
<p>但出于性能和内存的考虑，V8 底层确实依赖 properties 的几种不同表现。在这篇博客中，我们将解释为了能快速访问动态添加的 properties ，V8 是怎么做的。了解 properties 的工作方式对于解释 V8 中的<a href="https://mrale.ph/blog/2012/06/03/explaining-js-vms-in-js-inline-caches.html" target="_blank" rel="noopener">内联缓存(inline caches)</a>之类的优化工作至关重要。</p>
<p>这篇文章解释了 V8 对以整数作为 index 的 properties 和具名 properties 做处理的区别。然后我们展示了 V8 在添加具名 properties 时如何去维护隐藏类(HiddenClasses)，通过维护隐藏类可以快速识别一个对象的特征。接着我们将继续深入介绍如何根据用法优化具名 properties 来快速访问或修改。在最后一节中，我们将详细谈谈 V8 是怎么处理以整数作为 index 的 properties 或数组 index 的。</p>
<h2 id="具名-properties-和-elements"><a href="#具名-properties-和-elements" class="headerlink" title="具名 properties 和 elements"></a>具名 properties 和 elements</h2><p>让我们开始分析一个非常简单的对象，例如 <code>{ a：&#39;foo&#39;, b：&#39;bar&#39; }</code>。该对象具有两个具名 properties，<code>&#39;a&#39;</code> 和 <code>&#39;b&#39;</code>。对于 properties 名字来说它没有任何的数组 index。数组 index 这种 properties(通常称为 elements)是数组上最为突出的特点。例如数组 <code>[&#39;foo&#39;，&#39;bar&#39;]</code> 有两个数组 index properties：<code>0</code>，其对应 value 为 <code>&#39;foo&#39;</code>；<code>1</code>，其对应 value 为 <code>&#39;bar&#39;</code>。V8 主要用这个对 properties 做第一层的区分。</p>
<p>下图显示了一个基本的 JavaScript 对象在内存中的样子。</p>
<p><img src="./1.png" alt></p>
<p><strong>elements</strong>和<strong>properties</strong>存在两个单独的数据结构中，这样在不同使用模式下添加/访问 properties 和 elements 会更加有效。</p>
<p><strong>elements</strong>主要用于各种 <a href="https://tc39.es/ecma262/#sec-properties-of-the-array-prototype-object" target="_blank" rel="noopener">Array.prototype 方法</a>，例如 <code>pop</code> 或 <code>slice</code>。鉴于这些函数是在连续范围内去访问 properties 的，在大多数情况下 V8 内部会把它们看作简单数组。在本文的稍后部分会说明，为了节省内存我们是怎么将这些简单数组转变成稀疏字典(sparse dictionary)的形式的。</p>
<p>具名 properties 以类似的方式存在单独的数组中。但与 elements 不同，我们不能简单地用 key 来推断它们在 properties 数组中的位置，我们需要一些其他元数据。在 V8 中，每个 JavaScript 对象都会关联一个隐藏类。隐藏类 存放了有关对象特征的信息，除此之外，还存放了 properties 名字 对应 properties 数组 index 的 map。为了使事情复杂化，有时我们使用字典而不是简单数组来表示 properties。我们将在专用部分中对此进行详细说明。</p>
<p>本节内容：</p>
<ul>
<li><strong>以整数作为 index 的数组的 properties</strong> 存在单独的 <strong>elements store</strong>中。</li>
<li><strong>具名 properties</strong>存在<strong>properties store</strong>中。</li>
<li><strong>Elements</strong>和<strong>properties</strong>可以是数组或字典。</li>
<li>每个 JavaScript 对象都有一个关联的隐藏类，用于保存对象特征的信息。</li>
</ul>
<h2 id="隐藏类-HiddenClasses-和描述符数组-DescriptorArrays"><a href="#隐藏类-HiddenClasses-和描述符数组-DescriptorArrays" class="headerlink" title="隐藏类(HiddenClasses)和描述符数组(DescriptorArrays)"></a>隐藏类(HiddenClasses)和描述符数组(DescriptorArrays)</h2><p>在解释了 elements 和 具名 properties 的常规区别之后，我们需要看一下隐藏类在 V8 中的工作方式。此隐藏类存了一个对象的元信息，包括对象上的属性数量以及对对象原型的引用。隐藏类在概念上类似于典型的面向对象编程语言中的类。但在基于原型的语言（例如 JavaScript）中，通常不可能预先知道这个类。因此在这种情况下，V8 会即时创建隐藏类，并随着对象的变化而动态更新。隐藏类用于标识对象特征，也对 V8 编译器的优化和内联缓存起到非常重要的作用。例如，如果优化编译器可以通过隐藏类确保兼容的对象结构，那么它就可以直接访问到对象的内联属性。</p>
<p>让我们来看看隐藏类的重要部分。</p>
<p><img src="./2.png" alt></p>
<p>在 V8 中，JavaScript 对象的第一个字段指向隐藏类。(实际上，在 V8 堆上并由垃圾回收器管理的任何对象都是这种情况。)就 properties 而言，最重要的信息是位于 隐藏类的第三个 bit 的字段，这个字段用来存放 properties 的数量和能访问到描述符数组的指针。描述符数组中包含有关具名 properties 的信息，像这个 properties 的名字和 value 的存储位置之类的。注意，这里我们不跟踪整数 index properties，因此描述符数组中没有条目。</p>
<p>隐藏类的基本设定是对象具有相同的结构，例如在相同顺序下的相同具名 properties 会共享相同的隐藏类。为此，当对象添加了一个属性时，我们使用不同的隐藏类。在下面的示例中，我们创建一个空对象，并添加三个具名 properties。</p>
<p><img src="./3.png" alt></p>
<p>每次添加新属性时，对象的隐藏类都会更改。V8 在后台创建一个将隐藏类连接在一起的转换树。当将属性 <code>&#39;a&#39;</code> 添加到空对象时，V8 知道要采用哪个隐藏类。如果以相同的顺序添加相同的属性，此转换树可确保在最后得到的隐藏类是相同的。以下示例表明，即使在两者之间添加简单的 index properties(也就是整数下标)，转换树也是一样没有变化。</p>
<p><img src="./4.png" alt></p>
<p>但是，如果我们创建一个添加了其他属性的新对象，在本例中为属性 <code>&#39;d&#39;</code>，V8 将为新的隐藏类创建一个单独的分支。</p>
<p><img src="./5.png" alt></p>
<p>本节内容：</p>
<ul>
<li>具有相同结构(相同顺序的相同 properties)的对象具有相同的隐藏类。</li>
<li>默认情况下，每个添加的新具名属性都会导致创建新的隐藏类。</li>
<li>添加数组 index 的这种 properties 不会创建新的隐藏类。</li>
</ul>
<h2 id="三种不同的具名-properties"><a href="#三种不同的具名-properties" class="headerlink" title="三种不同的具名 properties"></a>三种不同的具名 properties</h2><p>在概述了 V8 如何使用隐藏类记录对象的特征之后，让我们深入研究这些 properties 的实际存储方式。如上面引言中所述，properties 有两种基本类型：<code>named</code> 和 <code>indexed</code>。以下部分介绍具名 properties。</p>
<p>在 V8 中，像 <code>{a: 1, b: 2}</code> 这样的简单对象可以有不同的内部展示。虽然 JavaScript 对象表现得或多或少像外部的简单字典，但 V8 试图避免字典，因为它们妨碍某些优化，如<a href="https://en.wikipedia.org/wiki/Inline_caching" target="_blank" rel="noopener">内联缓存</a>，我们将在单独的一篇文章中解释。</p>
<p><strong>对象内 properties</strong>与<strong>普通 properties</strong>：V8 支持所谓的对象内 properties，这些属性直接存储在对象上。这些是 V8 中最快的属性，因为它们无需任何间接访问即可使用。对象内 properties 的个数由对象的初始大小确定。如果添加的 properties 所需要的空间比对象能存储的空间多，它们就会把这些 properties 存到 properties store 中。properties store 里的属性是能被间接访问到的，并且这个 properties store 可以自己增加 property。</p>
<p><img src="./6.png" alt></p>
<p><strong>快 properties</strong>与<strong>慢 properties</strong>：下一个重要区别是快 properties 与慢 properties 之间的区别。通常将线性 properties store 中存放的 properties 定义为 “快”。快 properties 仅通过 properties store 中的 index 访问。要得到在 properties store 中的具名 properties 的实际位置，我们必须参考隐藏类上的描述符数组，如前所述。</p>
<p><img src="./7.png" alt></p>
<p>但如果一个对象添加和删除了许多属性，它可能会花费大量时间和内存开销来维护描述符数组和隐藏类。因此，V8 还支持所谓的慢 properties。具有慢 properties 的对象，它的 properties store 就是一个独立的字典。所有 properties 元信息不再存储在隐藏类的描述符数组中，而是直接存储在 properties 字典 中。因此不更新隐藏类也可以添加和删除属性。由于内联缓存不适用于字典属性，因此后者通常比快 properties 慢。</p>
<p>本节内容：</p>
<ul>
<li><p>有三种不同的具名 properties 类型：对象内 properties、快 properties、慢 properties/字典 properties。</p>
<ol>
<li>对象内 properties 直接存储在对象上，并提供最快的访问。</li>
<li>快 properties 位于 properties store 中，所有元信息都存储在隐藏类的描述符数组中。</li>
<li>慢 properties 位于独立的 properties 字典中，不再通过隐藏类共享元信息。</li>
</ol>
</li>
<li><p>慢 properties 允许高效地删除和添加属性，但访问速度比其他两种类型慢。</p>
</li>
</ul>
<h2 id="elements-或数组-index-properties"><a href="#elements-或数组-index-properties" class="headerlink" title="elements 或数组 index properties"></a>elements 或数组 index properties</h2><p>到目前为止，我们已经研究了具名 properties，而没讲数组常用的整数 index properties。整数 index properties 的处理与具名 properties 一样复杂。即使所有 index properties 总是单独存储在 elements store 中，那也有 <a href="https://cs.chromium.org/chromium/src/v8/src/elements-kind.h?q=elements-kind.h&amp;sq=package:chromium&amp;dr&amp;l=14" target="_blank" rel="noopener">20</a> 种不同的 elements 类型!</p>
<p><strong>Packed or Holey Elements</strong>：V8 作出的第一个主要区别是 elements backing store 里的 item 是 packed 的还是有 hole 的。如果删除一个能用 index 访问到的元素或未定义元素，则会在 backing store 中出现 hole。一个简单的例子是<code>[1,,3]</code>，其中第二项就是一个 hole。以下示例说明了此问题：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> o = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>];</span><br><span class="line"><span class="built_in">console</span>.log(o[<span class="number">1</span>]);          <span class="comment">// 打印 'b'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> o[<span class="number">1</span>];                <span class="comment">// 在 elements store 中引入一个 hole</span></span><br><span class="line"><span class="built_in">console</span>.log(o[<span class="number">1</span>]);          <span class="comment">// 打印 'undefined'; 属性 1 不存在</span></span><br><span class="line">o.__proto__ = &#123;<span class="number">1</span>: <span class="string">'B'</span>&#125;;     <span class="comment">// 在 prototype 上定义属性 1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(o[<span class="number">0</span>]);          <span class="comment">// 打印 'a'</span></span><br><span class="line"><span class="built_in">console</span>.log(o[<span class="number">1</span>]);          <span class="comment">// 打印 'B'</span></span><br><span class="line"><span class="built_in">console</span>.log(o[<span class="number">2</span>]);          <span class="comment">// 打印 'c'</span></span><br><span class="line"><span class="built_in">console</span>.log(o[<span class="number">3</span>]);          <span class="comment">// 打印 undefined</span></span><br></pre></td></tr></table></figure>
<p><img src="./8.png" alt></p>
<p>总之，如果这个被操作的数组/对象上没有属性，那就必须要在原型链上继续找。考虑到 elements 是独立的，我们不会在隐藏类上存放当前数组的 index properties 的信息，我们需要一个名为 the_hole 的特殊值来标记不存在的属性。这对于数组方法的性能来说至关重要。如果我们知道没有 hole，即 elements store 已经是 packed 状态，我们就可以执行本地操作而没必要在原型链上去做耗费性能的查找。</p>
<p><strong>快 elements 或字典 elements</strong>：对 elements 来说，第二个主要区别是它们是快模式还是字典模式。快 elements 是简单的 VM 内部数组，它的属性 index 与 elements store 中的 index 有一个 map 的关系。但这种简单的形式对于非常大的 稀疏/holey 数组是非常浪费的，因为这些数组只有非常少的子项。在这种情况下，我们使用基于字典的形式来节省内存，但代价是访问速度稍慢：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> sparseArray = [];</span><br><span class="line">sparseArray[<span class="number">9999</span>] = <span class="string">'foo'</span>; <span class="comment">// 用字典元素创建一个数组</span></span><br></pre></td></tr></table></figure>
<p>在此示例中，(从内存中)分配具有 10k 个子项的完整数组将非常浪费。取而代之的是，V8 创建了一个字典，在其中存储 key-value-descriptor 这样的三元组。在这种情况下，key 为 <code>&#39;9999&#39;</code>，value 为 <code>&#39;foo&#39;</code>，descriptor 就使用默认的描述符。鉴于我们没有办法在隐藏类上存储描述符详细信息，每当使用自定义描述符定义 index properties 时，V8 都会使用慢 elements：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> array = [];</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(array, <span class="number">0</span>, &#123;<span class="attr">value</span>: <span class="string">'fixed'</span> configurable: <span class="literal">false</span>&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(array[<span class="number">0</span>]);      <span class="comment">// 打印 'fixed'.</span></span><br><span class="line">array[<span class="number">0</span>] = <span class="string">'other value'</span>;   <span class="comment">// 不能覆盖 index 0.</span></span><br><span class="line"><span class="built_in">console</span>.log(array[<span class="number">0</span>]);      <span class="comment">// 仍然打印 'fixed'.</span></span><br></pre></td></tr></table></figure>
<p>在此示例中，我们在数组上添加了一个不可配置的属性。此信息存储在慢 elements 字典三元组的描述符部分中。重要的是要注意，数组方法在具有慢 elements 的对象上执行时速度要慢得多。</p>
<p><strong>Smi</strong> 和 <strong>Double Elements</strong>：在 V8 中快 elements 还有另一个重要的区别。例如，如果仅将整数存储在一个常用的数组中，则 GC 不必查看该数组，因为整数直接编码为所谓的小整数（Small integers – Smis）。另一个特殊情况是仅包含双精度的数组。与 Smis 不同，浮点数通常表示为占用几个字长的完整对象。但对于纯双精度数组来说 V8 存的是原始双精度值，以避免内存和性能开销。以下示例列出了 Smi 和 double 元素的 4 个示例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a1 = [<span class="number">1</span>,   <span class="number">2</span>, <span class="number">3</span>];  <span class="comment">// Smi Packed</span></span><br><span class="line"><span class="keyword">const</span> a2 = [<span class="number">1</span>,    , <span class="number">3</span>];  <span class="comment">// Smi Holey, a2[1] 在 prototype 上找</span></span><br><span class="line"><span class="keyword">const</span> b1 = [<span class="number">1.1</span>, <span class="number">2</span>, <span class="number">3</span>];  <span class="comment">// Double Packed</span></span><br><span class="line"><span class="keyword">const</span> b2 = [<span class="number">1.1</span>,  , <span class="number">3</span>];  <span class="comment">// Double Holey, b2[1] 在 prototype 上找</span></span><br></pre></td></tr></table></figure>
<p><strong>特殊 elements</strong>：到目前为止，我们提供的信息涵盖了 20 种不同 elements 类型中的 7 种。为简单起见，我们去掉了定型数组(TypedArrays)中的 9 个 elements 类型，也去掉了多个 String wrapper 中的 elements 类型以及 arguments 对象中的多个特殊 elements 类型。</p>
<p><strong>ElementsAccessor</strong>：如你所想我们并不想用 C++ 写数组方法 20 遍，为每个<a href="https://v8.dev/blog/elements-kinds" target="_blank" rel="noopener">element 类型</a>写一遍。这里就到了体现 C++ 神奇的地方了。我们构建了 <code>ElementsAccessor</code>，而不是一遍又一遍地实现数组方法，在这里我们只需要实现简单的函数即可访问 backing store 中的元素。<code>ElementsAccessor</code> 需要 <a href="https://en.wikipedia.org/wiki/Curiously_recurring_template_pattern" target="_blank" rel="noopener">CRTP</a> 去对每个数组方法创建指定的版本。因此，如果在数组上调用诸如 <code>slice</code> 之类的方法，V8 内部则会调用用 C++ 编写的内置函数，并通过 <code>ElementsAccessor</code> 将其分派到该函数的指定版本：</p>
<p><img src="./9.png" alt></p>
<p>本节内容：</p>
<ul>
<li>有快模式和字典模式的 index properties 和 elements。</li>
<li>快 properties 可以被 packed，它们也可以有 holes，这些 holes 说明一些 index properties 被删掉了。</li>
<li>elements 的 content 专门用于加快数组方法的执行并减少 GC 开销。</li>
</ul>
<p>了解 properties 的工作方式是理解 V8 中许多优化的关键。对于 JavaScript 开发人员来说，有许多内部决策是无法直接看到的，但是它们解释了为什么某些代码模式比其他模式更快。更改 properties 或 elements 类型通常会使 V8 创建不同的隐藏类，这可能导致类型污染，从而 <a href="http://mrale.ph/blog/2015/01/11/whats-up-with-monomorphism.html" target="_blank" rel="noopener">阻止 V8 生成最佳代码</a>。</p>
]]></content>
      <categories>
        <category>翻译</category>
      </categories>
      <tags>
        <tag>V8</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML标签(更详细版)</title>
    <url>/2019/01/12/HTML%E6%A0%87%E7%AD%BE-%E6%9B%B4%E8%AF%A6%E7%BB%86%E7%89%88/</url>
    <content><![CDATA[<blockquote>
<p>更 blog 的时候没注意之前写的这篇，先拿过来凑个数(哈哈哈我真的不是故意的，还是推荐看这篇吧 ^-^)</p>
</blockquote>
<h2 id="HTML-简介"><a href="#HTML-简介" class="headerlink" title="HTML 简介"></a>HTML 简介</h2><p>HTML 即 Hyper Text Markup Language(超文本标记语言)，由 W3C (World Wide Web Consortium,万维网联盟)组织制订规范</p>
<h3 id="HTML-目前的版本"><a href="#HTML-目前的版本" class="headerlink" title="HTML 目前的版本"></a>HTML 目前的版本</h3><ul>
<li>HTML 4.01</li>
<li>XHTML (XML 与 HTML)</li>
<li>HTML 5 (兼容前面两种版本)</li>
<li>HTML 5.1</li>
<li>HTML 5.2 (截至到目前 2018 年 2 月 23 日为止的最新版本)</li>
</ul>
<p>注意了，目前大家所说的所谓的 H5 是指能运行在微信上的网页，这样的网页<em>统称 H5</em>。以及有关 HTML 的相关文档 <a href="https://www.w3.org/TR/html" target="_blank" rel="noopener">看这里</a>,或者可以在 google 上搜索 “HTML spec”,找到第 4 章 – The Element of HTML，这一章主要就是讲 HTML 元素的，后面的那几章都是可以看的。</p>
<h3 id="HTML-中的-DOCTYPE"><a href="#HTML-中的-DOCTYPE" class="headerlink" title="HTML 中的 DOCTYPE"></a>HTML 中的 DOCTYPE</h3><ul>
<li>所谓的 DOCTYPE，是用来选择你的文档类型的</li>
<li><p>HTML 5 中的 DOCTYPE 的写法如下</p>
  <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>HTML 中的 DOCTYPE 是必须要写的，不写可能会带来一些隐藏的 bug</p>
</li>
</ul>
<h3 id="HTML-中重要的三个标签"><a href="#HTML-中重要的三个标签" class="headerlink" title="HTML 中重要的三个标签"></a>HTML 中重要的三个标签</h3><p>这 3 个标签分别是 html、head、body，这三个标签都有个共同点就是，这三个标签都可以不用写上去，但是浏览器会自动将其补全。所以代码最少的 html 如下<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">DOCTYPE</span> <span class="attr">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>Demo<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">hello world!</span><br></pre></td></tr></table></figure></p>
<p>而在浏览器中显示的代码为<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">doctype</span> <span class="attr">html</span>=<span class="string">""</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">title</span>&gt;</span>Demo<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">            hello world!</span><br><span class="line">        <span class="tag">&lt;/<span class="name">doctype</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>注意，虽然浏览器会自动补全这三个标签，但是在写代码的时候还是写上好些。</p>
<h3 id="常见标签"><a href="#常见标签" class="headerlink" title="常见标签"></a>常见标签</h3><p>下表是常见标签的中英文对照</p>
<table>
<thead>
<tr>
<th>标签</th>
<th>英文</th>
<th>中文</th>
</tr>
</thead>
<tbody>
<tr>
<td>a</td>
<td>anchor</td>
<td>锚</td>
</tr>
<tr>
<td>form</td>
<td>form</td>
<td>表单</td>
</tr>
<tr>
<td>input</td>
<td>input</td>
<td>输入控件</td>
</tr>
<tr>
<td>button</td>
<td>button</td>
<td>按钮</td>
</tr>
<tr>
<td>h1..h5</td>
<td>header</td>
<td>标题</td>
</tr>
<tr>
<td>p</td>
<td>paragraph</td>
<td>段落</td>
</tr>
<tr>
<td>ul</td>
<td>unorder list</td>
<td>无序列表</td>
</tr>
<tr>
<td>ol</td>
<td>order list</td>
<td>有序列表</td>
</tr>
<tr>
<td>li</td>
<td>list item</td>
<td>列表的子项(就是列表的儿子,经常与 ul、ol 配套使用)</td>
</tr>
<tr>
<td>small</td>
<td>small</td>
<td>文本变小</td>
</tr>
<tr>
<td>strong</td>
<td>strong</td>
<td>文本加粗(并同时表示一种强调)</td>
</tr>
<tr>
<td>div</td>
<td>division</td>
<td>分割</td>
</tr>
<tr>
<td>span</td>
<td>span</td>
<td>范围</td>
</tr>
<tr>
<td>kbd</td>
<td>keyboard</td>
<td>键盘</td>
</tr>
<tr>
<td>video</td>
<td>video</td>
<td>视频</td>
</tr>
<tr>
<td>audio</td>
<td>audio</td>
<td>音频</td>
</tr>
<tr>
<td>svg</td>
<td>scalable vector graphic</td>
<td>可缩放的矢量图形(不规则的图形)</td>
</tr>
<tr>
<td>nav</td>
<td>navigation</td>
<td>导航栏</td>
</tr>
<tr>
<td>main</td>
<td>main</td>
<td>表示最主要的内容</td>
</tr>
<tr>
<td>footer</td>
<td>footer</td>
<td>表示网页底部的内容</td>
</tr>
<tr>
<td>hr</td>
<td>horizontal rule</td>
<td>水平分割线</td>
</tr>
<tr>
<td>dl</td>
<td>description list</td>
<td>描述列表</td>
</tr>
<tr>
<td>dt</td>
<td>description term</td>
<td>dl 的子元素</td>
</tr>
<tr>
<td>dd</td>
<td>description details</td>
<td>dl 的子元素(必须跟着 dt 元素)</td>
</tr>
<tr>
<td>br</td>
<td>line break</td>
<td>强制换行</td>
</tr>
<tr>
<td>table</td>
<td>table</td>
<td>表格</td>
</tr>
<tr>
<td>tr</td>
<td>table row</td>
<td>定义表格中的行</td>
</tr>
<tr>
<td>td</td>
<td>table data</td>
<td>定义了表格中的一个包含数据的单元(cell)</td>
</tr>
<tr>
<td>section</td>
<td>section</td>
<td>独立的区块</td>
</tr>
</tbody>
</table>
<h2 id="几个稍微重要的标签"><a href="#几个稍微重要的标签" class="headerlink" title="几个稍微重要的标签"></a>几个稍微重要的标签</h2><p>下面几个重要的标签主要是 iframe、a、form、input/button、table 标签</p>
<h3 id="iframe-标签"><a href="#iframe-标签" class="headerlink" title="iframe 标签"></a>iframe 标签</h3><p>这个标签的作用就是在一个页面中再嵌套一个页面<br>示例代码<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>JS Bin<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">            iframe &#123;</span><br><span class="line">            width: 100%;</span><br><span class="line">            height: 400px;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        // 两个 a 标签都是开一个新窗口</span><br><span class="line">        <span class="tag">&lt;<span class="name">iframe</span> <span class="attr">name</span>=<span class="string">xxx</span> <span class="attr">src</span>=<span class="string">"#"</span> <span class="attr">frameborder</span>=<span class="string">"0"</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">target</span>=<span class="string">xxx</span> <span class="attr">href</span>=<span class="string">"http://qq.com"</span>&gt;</span>QQ<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">target</span>=<span class="string">xxx</span> <span class="attr">href</span>=<span class="string">"http://baidu.com"</span>&gt;</span>baidu<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<h3 id="a-标签"><a href="#a-标签" class="headerlink" title="a 标签"></a>a 标签</h3><p>a 标签有 4 个属性</p>
<ul>
<li>_blank</li>
<li>_self</li>
<li>_parent</li>
<li>_top</li>
</ul>
<p>这 4 个属性要结合两层嵌套的 iframe 来理解，以下是示例代码</p>
<ul>
<li><p>index1.html</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">            iframe &#123;</span><br><span class="line">            width: 100%;</span><br><span class="line">            height: 400px;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        index1.html</span><br><span class="line">        <span class="comment">&lt;!--两个 a 标签都是开一个新窗口--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">"./index2.html"</span> <span class="attr">frameborder</span>=<span class="string">"0"</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>index2.html</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    index2.html</span><br><span class="line">    <span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">"./index3.html"</span> <span class="attr">width</span>=<span class="string">""</span> <span class="attr">height</span>=<span class="string">""</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>index3.html</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    index3.html</span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">target</span>=<span class="string">"_blank"</span> <span class="attr">href</span>=<span class="string">"http://qq.com"</span>&gt;</span>qq_blank<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">target</span>=<span class="string">"_self"</span> <span class="attr">href</span>=<span class="string">"http://qq.com"</span>&gt;</span>qq_self<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">target</span>=<span class="string">"_parent"</span> <span class="attr">href</span>=<span class="string">"http://qq.com"</span>&gt;</span>qq_parent<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">target</span>=<span class="string">"_top"</span> <span class="attr">href</span>=<span class="string">"http://qq.com"</span>&gt;</span>qq_top<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>用浏览器打开 index1.html，然后分别点击 qq_blank、qq_self、qq_parent、qq_top 的链接，可以看到<br><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">_blank 的作用就是打开一个新窗口</span><br><span class="line">_self 就是在当前自己的页面打开 qq<span class="selector-class">.com</span> (index3<span class="selector-class">.html</span> 中)</span><br><span class="line">_parent 就是在其父 <span class="selector-tag">iframe</span> 中打开 qq<span class="selector-class">.com</span> (index2<span class="selector-class">.html</span> 中)</span><br><span class="line">_top 就是在顶部打开 qq<span class="selector-class">.com</span> (index1<span class="selector-class">.html</span> 中)</span><br></pre></td></tr></table></figure></p>
<ul>
<li>download 属性<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://qq.com"</span> <span class="attr">download</span>&gt;</span>下载<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>如上所示点击该 a 标签可以下载 qq.com 的整个首页到本地。需要注意的是，假如将 http 协议响应的 content-type 修改成<br><figure class="highlight elm"><table><tr><td class="code"><pre><span class="line"><span class="title">content</span>-<span class="keyword">type</span>: application/octet-stream</span><br></pre></td></tr></table></figure></p>
<p>那么浏览器就会以<em>下载</em>的形式去接收这个请求，而不是渲染页面</p>
<h3 id="form-标签"><a href="#form-标签" class="headerlink" title="form 标签"></a>form 标签</h3><p>实际上 form 标签也可以用来跳转页面，与 a 标签发起的 GET 请求不一样的是，form 标签发起的是一个 POST 请求。注意，在 form 表单中，必须要一个<em>提交按钮</em>，不然就无法完成提交操作，除非用 js<br><figure class="highlight stata"><table><tr><td class="code"><pre><span class="line">&lt;<span class="keyword">form</span> <span class="keyword">class</span>=<span class="string">""</span> action=<span class="string">"index2.html"</span> method=<span class="string">"post"</span>&gt;</span><br><span class="line">    &lt;<span class="keyword">input</span> <span class="keyword">type</span>=<span class="string">"submit"</span> name=<span class="string">""</span> value=<span class="string">"提交"</span>&gt;</span><br><span class="line">&lt;/<span class="keyword">form</span>&gt;</span><br></pre></td></tr></table></figure></p>
<p>而这个时候请求的 content-type 是<br><figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">Content-<span class="keyword">Type</span>: application/x-www-<span class="keyword">form</span>-urlencoded</span><br></pre></td></tr></table></figure></p>
<p>其表示了”数据被编码成以 ‘&amp;’ 分隔的键-值对, 同时以 ‘=’ 分隔键和值. 非字母或数字的字符会被 percent encoded”</p>
<p>form 标签也具有 target 属性，其属性的效果与 a 标签相同</p>
<h3 id="input-button-标签"><a href="#input-button-标签" class="headerlink" title="input/button 标签"></a>input/button 标签</h3><p>input/button 标签中需要注意的地方就是 type，其中 type 有 button、submit、checkbox、radio 等</p>
<ul>
<li>type=”button” 与 type=”submit”</li>
</ul>
<p>上下两个 button 都是可以提交的，其中 button1 自动升级为 submit 按钮<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span>&gt;</span>button1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"submit"</span>&gt;</span>button2<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>下面该 button 不能提交<br><figure class="highlight hsp"><table><tr><td class="code"><pre><span class="line">&lt;<span class="keyword">button</span> type=<span class="string">"button"</span>&gt;<span class="keyword">button</span>&lt;/<span class="keyword">button</span>&gt;</span><br></pre></td></tr></table></figure></p>
<p>下面第一种写法不能进行 post 提交，而第二种是可以的<br><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">&lt;input <span class="attribute">type</span>=<span class="string">"button"</span> <span class="attribute">value</span>=<span class="string">"demo"</span> <span class="attribute">method</span>=<span class="string">"post"</span>&gt;</span><br><span class="line">&lt;input <span class="attribute">type</span>=<span class="string">"submit"</span> <span class="attribute">value</span>=<span class="string">"demo"</span> <span class="attribute">method</span>=<span class="string">"post"</span>&gt;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>type=”checkbox”<br>一般的写法是这样<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">&lt;input <span class="attribute">type</span>=<span class="string">"checkbox"</span> <span class="attribute">id</span>=<span class="string">"xxx"</span>&gt;&lt;label <span class="attribute">for</span>=<span class="string">"xxx"</span>&gt;demo1&lt;/label&gt;&lt;/input&gt;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>用 label 的 for 属性与 input 的 id 属性进行关联，鼠标在点击 label 中的文字 demo1 的时候，能自动勾选到 checkbox<br>其实更加老司机的写法是这样<br><figure class="highlight stata"><table><tr><td class="code"><pre><span class="line">&lt;<span class="keyword">label</span>&gt;&lt;<span class="keyword">input</span> <span class="keyword">type</span>=<span class="string">"checkbox"</span> name=<span class="string">"xxx"</span>&gt;demo1&lt;/<span class="keyword">label</span>&gt;</span><br></pre></td></tr></table></figure></p>
<p>用 label 标签将 input 标签包起来，形成自动关联</p>
<ul>
<li>type=”radio”<br>示例代码<figure class="highlight stata"><table><tr><td class="code"><pre><span class="line">&lt;<span class="keyword">label</span>&gt;&lt;<span class="keyword">input</span> name=<span class="string">"love"</span> <span class="keyword">type</span>=<span class="string">"radio"</span> value=<span class="string">"yes"</span>&gt;Yes&lt;/<span class="keyword">label</span>&gt;</span><br><span class="line">&lt;<span class="keyword">label</span>&gt;&lt;<span class="keyword">input</span> name=<span class="string">"love"</span> <span class="keyword">type</span>=<span class="string">"radio"</span> value=<span class="string">"no"</span>&gt;<span class="keyword">No</span>&lt;/<span class="keyword">label</span>&gt;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="table-标签"><a href="#table-标签" class="headerlink" title="table 标签"></a>table 标签</h3><p>html 规定， table 标签中只能有三个元素<br><figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="section">&lt;table&gt;</span></span><br><span class="line">    <span class="section">&lt;thead&gt;</span><span class="section">&lt;/thead&gt;</span></span><br><span class="line">    <span class="section">&lt;tbody&gt;</span><span class="section">&lt;/tbody&gt;</span></span><br><span class="line">    <span class="section">&lt;tfoot&gt;</span><span class="section">&lt;/tfoot&gt;</span></span><br><span class="line"><span class="section">&lt;/table&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>其中的子标签<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">th</span>&gt;</span><span class="tag">&lt;/<span class="name">th</span>&gt;</span> 表示 table header，也就是表的标题</span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span>&gt;</span><span class="tag">&lt;/<span class="name">tr</span>&gt;</span> 表示 table row，也就是表的行</span><br><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span> 表示 table data，也就是表的数据</span><br></pre></td></tr></table></figure></p>
<p>table 的完整用法如下<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">border</span>=<span class="string">1</span>&gt;</span></span><br><span class="line">    // colgroup 是用来设定 table 的对应列的列宽的</span><br><span class="line">    <span class="tag">&lt;<span class="name">colgroup</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">col</span> <span class="attr">width</span>=<span class="string">100</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">col</span> <span class="attr">width</span>=<span class="string">200</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">col</span> <span class="attr">width</span>=<span class="string">300</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">col</span> <span class="attr">width</span>=<span class="string">70</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">colgroup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">thead</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">th</span>&gt;</span><span class="tag">&lt;/<span class="name">th</span>&gt;</span><span class="tag">&lt;<span class="name">th</span>&gt;</span>姓名<span class="tag">&lt;/<span class="name">th</span>&gt;</span><span class="tag">&lt;<span class="name">th</span>&gt;</span>班级<span class="tag">&lt;/<span class="name">th</span>&gt;</span><span class="tag">&lt;<span class="name">th</span>&gt;</span>分数<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">thead</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tbody</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">th</span>&gt;</span><span class="tag">&lt;/<span class="name">th</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>小明<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>1<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>75<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">th</span>&gt;</span><span class="tag">&lt;/<span class="name">th</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>小小<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>2<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>77<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">th</span>&gt;</span>平均分<span class="tag">&lt;/<span class="name">th</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>76<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tbody</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tfoot</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">th</span>&gt;</span>总分<span class="tag">&lt;/<span class="name">th</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>152<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tfoot</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>可以用 CSS 将 table 中 border 空隙去掉<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">    table &#123;</span><br><span class="line">        border-collapse: collapse;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>需要注意的是，thead tbody tfoot 这三个标签的顺序，它们之间顺序是没有关联的，因为就算是瞎写，浏览器也会自动纠正显示;并且假如你 thead 或者 tbody 或者 tfoot 不写，浏览器就会自动将你写的加入到 tbody 中，若是三个都不写，那就直接按照你写的数据的顺序进行渲染和显示</p>
<h2 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h2><figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">// 下面是在顶层窗口或者是 iframe 打开新页面</span><br><span class="line">&lt;<span class="keyword">a</span> target=<span class="string">"_top"</span> href=<span class="string">"xxx"</span>&gt;&lt;/<span class="keyword">a</span>&gt;</span><br><span class="line"></span><br><span class="line">// 下面是在 name=xxx 的窗口或者 iframe 打开页面</span><br><span class="line">&lt;<span class="keyword">a</span> target=<span class="string">"xxx"</span> href=<span class="string">"xxx"</span>&gt;&lt;/<span class="keyword">a</span>&gt;</span><br><span class="line"></span><br><span class="line">// 当前标签被点击后则当前页面刷新</span><br><span class="line">&lt;<span class="keyword">a</span> href=<span class="string">""</span>&gt;link&lt;/<span class="keyword">a</span>&gt;</span><br><span class="line"></span><br><span class="line">// 当前标签被点击后，页面锚点变成 <span class="comment"># ,页面也会滚动到顶部</span></span><br><span class="line">&lt;<span class="keyword">a</span> href=<span class="string">"#"</span>&gt;link&lt;/<span class="keyword">a</span>&gt;</span><br><span class="line"></span><br><span class="line">// 当前标签被点击后，浏览器发起 GET /HTTP/<span class="number">1.1</span> 的请求</span><br><span class="line">&lt;<span class="keyword">a</span> href=<span class="string">"/.."</span>&gt;link&lt;/<span class="keyword">a</span>&gt;</span><br></pre></td></tr></table></figure>
<p>属于 iframe 标签的属性有 frameborder / name / sandbox / src</p>
<p>关于无协议链接<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"//qq.com"</span>&gt;</span>QQ<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li>浏览器会根据当前协议，补全无协议链接的协议</li>
<li>如果用 file:// 协议浏览页面，就会访问到 file://qq.com，这就是一个不存在的路径</li>
<li>应尽量不使用 file:// 协议浏览网页，避免无协议链接出错</li>
</ul>
<p>JavaScript 伪协议</p>
<ul>
<li>伪协议的作用就是用户在点击 a 标签时执行一段 js 代码</li>
<li>用伪协议的上述作用实现[点击 a 标签不执行任何动作的奇葩需求]</li>
</ul>
<p>对于 input 标签，不加 name 属性时，在表单进行提交时 input 的值就不会出现在请求里</p>
]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>html5</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTP初探</title>
    <url>/2019/01/08/HTTP%E5%88%9D%E6%8E%A2/</url>
    <content><![CDATA[<h2 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h2><p>首先是李爵士(Tim Berners-Lee)发明了万维网(World Wide Web)，90年代之前，在互联网上人们当时使用的主要应用就是 Email，而 www 就在这样的历史背景下诞生了，www 主要包含3个概念</p>
<ul>
<li>URI, Uniform Resource Identifier, 统一资源标识符, 通常用来表示网址</li>
<li>HTTP, HyperText Transfer Protocol, 超文本传输协议，</li>
<li>HTML, HyperText Markup Language，超文本标记语言，主要用来显示页面和做页面间的跳转</li>
</ul>
<h2 id="解释一下-URI"><a href="#解释一下-URI" class="headerlink" title="解释一下 URI"></a>解释一下 URI</h2><p>URI 主要分为 URL 和 URN</p>
<ul>
<li>URL，Uniform Resource Locator,统一资源定位符，它是因特网上标准的资源的地址</li>
<li>URN，Uniform Resource Name，统一资源标识符</li>
</ul>
<p>有什么区别呢?很简单，比如说一本书的 URN, 以 《JavaScript高级程序设计》为例，它的 URN 为 ISBN: 9787115275790，可以将这个 URN 在谷歌上搜索，就可以查到这本书，所以它是 <strong>一种期望为资源提供持久的、与位置无关的标识方式</strong>，相当于说我知道这本书的名字，但是我不知道它放在图书馆的什么地方。</p>
<p>而 URL 呢? <strong>它是与位置相关的</strong>，我们可以通过 URL 确定一个唯一的地址，我们可以通过这个地址去访问资源。</p>
<p>所以一般来说用 URL 会比较多，因为方便。URL 的标准格式如下<br><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">协议类型:[<span class="string">//服务器地址[:端口号</span>]][<span class="string">/资源层级UNIX文件路径</span>]文件名[<span class="string">?查询</span>][<span class="symbol">#片段ID</span>]</span><br></pre></td></tr></table></figure></p>
<p>例如:<br><img src="./img1.png" alt></p>
<p>这个锚点就是浏览器中”推荐位”的位置，如果是 5,就把 5 对应的搜索结果下拉到第一的位置</p>
<h2 id="解释一下-DNS"><a href="#解释一下-DNS" class="headerlink" title="解释一下 DNS"></a>解释一下 DNS</h2><p>其实就是 Domain Name System ,即域名解析系统，将对应的域名解析成 ip 给客户端访问</p>
<h2 id="请求与响应"><a href="#请求与响应" class="headerlink" title="请求与响应"></a>请求与响应</h2><p>见下图<br><img src="./img2.png" alt></p>
<p>这个就是浏览器和服务器的交互过程，基本上就是，浏览器发起访问请求，然后服务器接受到请求之后就会发起响应给浏览器，然后浏览器就下载响应内容呈现给用户，整个交互过程的协议就是 HTTP，另外，交互中服务器使用的端口为 80 端口。</p>
<h3 id="请求"><a href="#请求" class="headerlink" title="请求"></a>请求</h3><p><strong>请求</strong>的格式如下<br><figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="symbol">1 </span>动词 路径 协议/版本</span><br><span class="line"></span><br><span class="line"><span class="symbol">2 </span>Key1: value1</span><br><span class="line"><span class="symbol">2 </span>Key2: value2</span><br><span class="line"><span class="symbol">2 </span>Key3: value3</span><br><span class="line"><span class="symbol">2 </span>Content-Type: application/x-www-form-urlencoded</span><br><span class="line"><span class="symbol">2 </span>Host: www.baidu.<span class="keyword">com</span></span><br><span class="line"><span class="symbol">2 </span>User-Agent: curl/<span class="number">7.54.0</span></span><br><span class="line"></span><br><span class="line"><span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">4 </span>要上传的数据</span><br></pre></td></tr></table></figure></p>
<p>注意:</p>
<ul>
<li>这里的请求 <strong>最多包含四部分(1 2 3 4)</strong>，最少包含三部分(1 2 3)</li>
<li>第三部分(3)是回车，没有其他内容</li>
<li>这里的”动词”表示的是 <strong>请求方法</strong>，像 GET HEAD POST PUT DELETE TRACE OPTIONS 等</li>
<li>这里的”路径”就是 url,它包括了<em>查询参数</em>，但是不包括<em>锚点</em></li>
<li>如果输入没有路径，那么默认的路径就是 /</li>
<li>Content-Type 标注了 4 的格式</li>
</ul>
<p>例如<br><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">curl</span> -s -v -- <span class="string">"https://www.baidu.com"</span></span><br></pre></td></tr></table></figure></p>
<p>请求为<br><figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/</span> HTTP/1.1</span><br><span class="line"><span class="attribute">Host</span>: www.baidu.com</span><br><span class="line"><span class="attribute">User-Agent</span>: curl/7.47.0</span><br><span class="line"><span class="attribute">Accept</span>: */*</span><br></pre></td></tr></table></figure></p>
<h3 id="响应"><a href="#响应" class="headerlink" title="响应"></a>响应</h3><p><strong>响应</strong>的格式如下<br><figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="symbol">1 </span>协议/版本号 状态码 状态解释</span><br><span class="line"></span><br><span class="line"><span class="symbol">2 </span>Key1: value1</span><br><span class="line"><span class="symbol">2 </span>Key2: value2</span><br><span class="line"><span class="symbol">2 </span>Content-Length: <span class="number">17931</span></span><br><span class="line"><span class="symbol">2 </span>Content-Type: text/html</span><br><span class="line"></span><br><span class="line"><span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">4 </span>要下载的内容</span><br></pre></td></tr></table></figure></p>
<p>注意:</p>
<ul>
<li>状态解释可以不去理解它</li>
<li>第 2 部分的 Content-Type 标注了第 4 部分的格式</li>
<li>第 2 部分的 Content-Type 遵循 MIME 规范</li>
</ul>
<p>例如<br><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">curl</span> -s -v -- <span class="string">"https://www.baidu.com"</span></span><br></pre></td></tr></table></figure></p>
<p>响应为<br><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">HTTP/1.1</span> <span class="number">200</span> <span class="string">OK</span></span><br><span class="line"><span class="attr">Accept-Ranges:</span> <span class="string">bytes</span></span><br><span class="line"><span class="attr">Cache-Control:</span> <span class="string">private,</span> <span class="literal">no</span><span class="string">-cache,</span> <span class="literal">no</span><span class="string">-store,</span> <span class="string">proxy-revalidate,</span> <span class="literal">no</span><span class="string">-transform</span></span><br><span class="line"><span class="attr">Connection:</span> <span class="string">Keep-Alive</span></span><br><span class="line"><span class="attr">Content-Length:</span> <span class="number">2443</span></span><br><span class="line"><span class="attr">Content-Type:</span> <span class="string">text/html</span></span><br><span class="line"><span class="attr">Date:</span> <span class="string">Thu,</span> <span class="number">25</span> <span class="string">Jan</span> <span class="number">2018</span> <span class="number">23</span><span class="string">:59:53</span> <span class="string">GMT</span></span><br><span class="line"><span class="attr">Etag:</span> <span class="string">"58860402-98b"</span></span><br><span class="line"><span class="attr">Last-Modified:</span> <span class="string">Mon,</span> <span class="number">23</span> <span class="string">Jan</span> <span class="number">2017</span> <span class="number">13</span><span class="string">:24:18</span> <span class="string">GMT</span></span><br><span class="line"><span class="attr">Pragma:</span> <span class="literal">no</span><span class="string">-cache</span></span><br><span class="line"><span class="attr">Server:</span> <span class="string">bfe/1.0.8.18</span></span><br><span class="line"><span class="attr">Set-Cookie:</span> <span class="string">BDORZ=27315;</span> <span class="string">max-age=86400;</span> <span class="string">domain=.baidu.com;</span> <span class="string">path=/</span></span><br><span class="line"></span><br><span class="line"><span class="string">一堆</span> <span class="string">HTML</span> <span class="string">代码...</span></span><br></pre></td></tr></table></figure></p>
<h2 id="几个需要记住的状态码"><a href="#几个需要记住的状态码" class="headerlink" title="几个需要记住的状态码"></a>几个需要记住的状态码</h2><p>状态码的第一个数字代表当前响应的类型</p>
<ul>
<li>1xx 消息 — 请求已经被服务器接收，继续处理，这个<strong>不常用</strong></li>
<li>2xx 成功 — 请求已经成功被服务器接收、理解、并接受</li>
<li>3xx 重定向 — 需要后续操作才能完成这一请求</li>
<li>4xx 请求错误 — 请求含有词法错误或者无法被执行，通常表示客户端发送请求时出问题的情况</li>
<li>5xx 服务器错误 — 服务器在处理某个正确请求时发生错误</li>
</ul>
<p>以下是一些经常用到的状态码</p>
<h3 id="200-OK"><a href="#200-OK" class="headerlink" title="200 OK"></a>200 OK</h3><p>请求已成功，请求所希望的响应头或数据体将随此响应返回</p>
<h3 id="301-Moved-Permanently"><a href="#301-Moved-Permanently" class="headerlink" title="301 Moved Permanently"></a>301 Moved Permanently</h3><p>被请求的资源已经被永久移动到新的位置，并且将来对此资源的任何引用都应该使用本响应返回的若干个 URI 之一,简单来说就是 <strong>重定向</strong>了</p>
<h3 id="302-Found"><a href="#302-Found" class="headerlink" title="302 Found"></a>302 Found</h3><p>要求客户端执行临时重定向，由于这样的重定向是<strong>临时的</strong>，客户端应当继续向原有地址发送以后的请求</p>
<h3 id="403-Forbidden"><a href="#403-Forbidden" class="headerlink" title="403 Forbidden"></a>403 Forbidden</h3><p>服务器已经理解从客户端发送过来的请求，但是拒绝执行它</p>
<h3 id="404-Not-Found"><a href="#404-Not-Found" class="headerlink" title="404 Not Found"></a>404 Not Found</h3><p>喜闻乐见的 404,这是表示请求失败，即请求所希望得到的资源没有在服务器上发现，但允许客户端的后续请求</p>
<h3 id="500-Internal-Server-Error"><a href="#500-Internal-Server-Error" class="headerlink" title="500 Internal Server Error"></a>500 Internal Server Error</h3><p>通用错误消息，服务器遇到了一个不曾预料的情况，导致了它无法完成对请求的处理</p>
<h3 id="502-Bad-Gateway"><a href="#502-Bad-Gateway" class="headerlink" title="502 Bad Gateway"></a>502 Bad Gateway</h3><p>作为网关或者代理的服务器尝试执行请求时，从上游服务器接收到的无效的响应</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://zh.wikipedia.org/wiki/HTTP%E7%8A%B6%E6%80%81%E7%A0%81" target="_blank" rel="noopener">wiki HTTP 状态码</a></p>
]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title>JSONP初探</title>
    <url>/2019/02/20/JSONP%E5%88%9D%E6%8E%A2/</url>
    <content><![CDATA[<h2 id="同源-amp-跨域"><a href="#同源-amp-跨域" class="headerlink" title="同源&amp;跨域"></a>同源&amp;跨域</h2><p>在了解 jsonp 之前，需要先了解两个概念: 同源、跨域</p>
<p>什么是同源?简单来说，所谓的同源，就是若这堆 url 中的 <strong>协议/域名/端口</strong> 这三个要素<strong>分别相等</strong>，则我们判定这堆 url <strong>同源</strong>;<br>什么是跨域?它实际上的意思跟同源相反，就是若这堆 url 中的 <strong>协议/域名/端口</strong> <strong>有任何一个不同</strong>,则我们判定这堆 url <strong>跨域</strong></p>
<p>以下是表<br>| url                         | 结果 | 原因       |<br>|—————————–|——|————|<br>| <a href="http://127.0.0.1:3000/index" target="_blank" rel="noopener">http://127.0.0.1:3000/index</a> | 同源 | 三个都相同 |<br>| <a href="https://127.0.0.1:3000" target="_blank" rel="noopener">https://127.0.0.1:3000</a>      | 跨域 | 协议不同   |<br>| <a href="https://localhost:3000" target="_blank" rel="noopener">https://localhost:3000</a>      | 跨域 | 域名不同   |<br>| <a href="http://127.0.0.1:3001" target="_blank" rel="noopener">http://127.0.0.1:3001</a>       | 跨域 | 端口不同   |</p>
<p>现在浏览器的同源策略变得很严格，为什么? 因为它要<strong>保证用户信息的安全，防止恶意窃取用户信息</strong>,你登录一个网站需要 cookie，然后你又去浏览其他网站，<br>若没有同源策略限制，其他网站就能够读取到你登录的网站的 cookie(这就是跨域访问了)，冒充你登录，查看你 cookie 的隐私信息，就很危险。所以对于非同源<br>来说，就有如下三种限制</p>
<ol>
<li>不能读取 cookie/localStorage/indexDB</li>
<li>不能获取 DOM 节点</li>
<li>不能发送一般的 AJAX 请求</li>
</ol>
<p>但是有时候做开发我们又希望能够有以上三种限制的权限好去完成一些需求,这个时候老一辈工程师就想了一些办法(我就是想跨个域)</p>
<h2 id="跨域方式"><a href="#跨域方式" class="headerlink" title="跨域方式"></a>跨域方式</h2><p>很容易想到的方式就是用标签，我们知道 iframe,form,img,link,script 这些标签都可以发送请求，但是它们的表现怎么样呢?<br>假设 html 主要代码如下<br><figure class="highlight django"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">id</span>=<span class="string">"amount"</span>&gt;</span></span><span class="template-variable">&#123;&#123;amount&#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"button"</span>&gt;</span>发送请求<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br></pre></td></tr></table></figure></p>
<p>后端 node.js 主要代码如下<br><figure class="highlight lasso"><table><tr><td class="code"><pre><span class="line"><span class="params">...</span></span><br><span class="line"><span class="keyword">if</span>(path === <span class="string">'/pay'</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> amount = fs.readFileSync(<span class="string">'./db'</span>, <span class="string">'utf8'</span>)</span><br><span class="line">    amount -= <span class="number">1</span></span><br><span class="line">    fs.writeFileSync(<span class="string">'./db'</span>, amount)</span><br><span class="line">    <span class="comment">// 返回 js 代码</span></span><br><span class="line">    response.setHeader(<span class="string">'Content-Type'</span>, <span class="string">'application/javascript'</span>)</span><br><span class="line">    <span class="comment">// 返回时浏览器会自动执行这句话 amount.innertext = '88'</span></span><br><span class="line">    response.write(<span class="string">'amount.innerText = '</span> + amount)</span><br><span class="line">    response.end()</span><br><span class="line">&#125;</span><br><span class="line"><span class="params">...</span></span><br></pre></td></tr></table></figure></p>
<h3 id="iframe-发送请求"><a href="#iframe-发送请求" class="headerlink" title="iframe 发送请求"></a>iframe 发送请求</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">button.addEventListener(<span class="string">'click'</span>, (e)=&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> dom = <span class="built_in">document</span>.createElement(<span class="string">'iframe'</span>)</span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(dom)</span><br><span class="line">    dom.src = <span class="string">'/pay'</span></span><br><span class="line">    dom.onload = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123; <span class="comment">// 状态码是 200~299 则表示成功</span></span><br><span class="line">        e.currentTarget.remove()</span><br><span class="line">        alert(<span class="string">'成功'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    dom.onerror = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123; <span class="comment">// 状态码大于等于 400 则表示失败</span></span><br><span class="line">        e.currentTarget.remove()</span><br><span class="line">        alert(<span class="string">'失败'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>这种方式是可以，但是会出现一个页面 bug，就是只有它先被 body append 之后才能发送请求，之后还要销毁掉它，这样就不好了</p>
<h3 id="form-发送请求"><a href="#form-发送请求" class="headerlink" title="form 发送请求"></a>form 发送请求</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">button.addEventListener(<span class="string">'click'</span>, (e)=&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> dom = <span class="built_in">document</span>.createElement(<span class="string">'form'</span>)</span><br><span class="line">    dom.src = <span class="string">'/pay'</span></span><br><span class="line">    dom.method = <span class="string">'POST'</span></span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(dom)</span><br><span class="line">    dom.submit()</span><br><span class="line">    dom.onload = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123; <span class="comment">// 状态码是 200~299 则表示成功</span></span><br><span class="line">        e.currentTarget.remove()</span><br><span class="line">        alert(<span class="string">'成功'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    dom.onerror = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123; <span class="comment">// 状态码大于等于 400 则表示失败</span></span><br><span class="line">        e.currentTarget.remove()</span><br><span class="line">        alert(<span class="string">'失败'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>但是这个每次点击 submit 后就直接刷新页面，所以后端也没接收到 ‘/pay’ 的相关请求, form 方案也是不行的</p>
<h3 id="img-发送请求"><a href="#img-发送请求" class="headerlink" title="img 发送请求"></a>img 发送请求</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">button.addEventListener(<span class="string">'click'</span>, (e)=&gt;&#123;</span><br><span class="line">    <span class="keyword">let</span> dom = <span class="built_in">document</span>.createElement(<span class="string">'img'</span>)</span><br><span class="line">    dom.src = <span class="string">'/pay'</span></span><br><span class="line">    dom.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">        alert(<span class="string">'成功'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    dom.onerror = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">        alert(<span class="string">'失败'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>img 虽然能发送请求吧，但是由于img标签本身需要一个图片url(有效的),表明其加载的资源有效，才不会触发 error 事件被 window<br>捕获到,这也是不行的</p>
<h3 id="link-发送请求"><a href="#link-发送请求" class="headerlink" title="link 发送请求"></a>link 发送请求</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">button.addEventListener(<span class="string">'click'</span>, (e)=&gt;&#123;</span><br><span class="line">    <span class="keyword">let</span> dom = <span class="built_in">document</span>.createElement(<span class="string">'link'</span>)</span><br><span class="line">    dom.rel = <span class="string">'/pay'</span></span><br><span class="line">    dom.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">        alert(<span class="string">'成功'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    dom.onerror = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">        alert(<span class="string">'失败'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>嗯。。。完全没反应啊，哈哈，所以实际上动态创建 link 发请求的方式也不行啊</p>
<h3 id="用-script-发送请求"><a href="#用-script-发送请求" class="headerlink" title="用 script 发送请求"></a>用 script 发送请求</h3><p>好了终于用到 script 标签了，看看它的表现如何</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">button.addEventListener(<span class="string">'click'</span>, (e)=&gt;&#123;</span><br><span class="line">    <span class="keyword">let</span> dom = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>)</span><br><span class="line">    dom.src = <span class="string">'/pay'</span></span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(dom)</span><br><span class="line">    dom.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">        alert(<span class="string">'成功'</span>)</span><br><span class="line">        e.currentTarget.remove()</span><br><span class="line">    &#125;</span><br><span class="line">    dom.onerror = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">        alert(<span class="string">'失败'</span>)</span><br><span class="line">        e.currentTarget.remove()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>试验结果，很好，我们终于找到一个标签，它能够正确的发送请求，以及正确的触发了 load 事件，我们终于可以跨域了</p>
<h3 id="终结"><a href="#终结" class="headerlink" title="终结"></a>终结</h3><p>我们刚刚尝试出了一种方式，用 script 标签发送请求后，后端返回一串 javascript 代码字符串然后被浏览器自动执行了，<br>这是什么？这就是 <strong>SRJ(Server Rendered Javascript)</strong>，也是一种无刷新并能进行局部页面更新的一套方案</p>
<p>举个实例，我们在引用另一个网站的 js 代码的时候，比如</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">//code.juery.com/jquery-2.1.1.min.js</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>就是在请求另一个网站的 script, 也是上述方案的应用</p>
<h2 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h2><p>好了，有了以上的理解，那么 JSONP 就基本上知道是怎么回事了，<strong>JSONP 就是通过动态加载 script 标签来完成对目标 url 的请求</strong><br>它的全称叫 JSON + padding, 也叫 String + padding<br>以下是 JSONP 方式过程</p>
<p>请求方: baidu.com 的前端程序员(浏览器)<br>响应方: tencent.com 的后端程序员(服务器)</p>
<ul>
<li><p>请求方创建 script, src 指向响应方，同时传一个查询参数像 <code>?callbackName=yyy</code></p>
  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addScriptTag</span>(<span class="params">src</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>);</span><br><span class="line">    script.setAttribute(<span class="string">"type"</span>,<span class="string">"text/javascript"</span>);</span><br><span class="line">    script.src = src;</span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(script);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Your public IP address is: '</span> + data.ip);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    addScriptTag(<span class="string">'http://tencent.com/ip?callback=foo'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>响应方则根据查询参数 <code>callbackName</code> ,构造形如</p>
<ul>
<li><code>yyy.call(undefind, &#39;你要的数据&#39;)</code></li>
<li><p><code>yyy(&#39;你要的数据&#39;)</code><br>这样的响应</p>
<figure class="highlight erlang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">foo</span><span class="params">(&#123;</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="string">"ip"</span>: <span class="string">"8.8.8.8"</span></span></span></span><br><span class="line"><span class="function"><span class="params">&#125;)</span></span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>浏览器接收到响应，就会执行 <code>yyy.call(undefined, &#39;你要的数据&#39;)</code></p>
</li>
<li>那么请求方就知道了它要的数据</li>
</ul>
<p>以上就是 <code>JSONP</code></p>
<p>以下是其相关的约定:</p>
<ol>
<li>callbackName -&gt; callback</li>
<li>yyy -&gt; 随机数 frank 随机数()</li>
</ol>
<p><a href="https://github.com/strugglebak/nodejs-test/tree/jsonp" target="_blank" rel="noopener">试验代码示例在这儿呢</a></p>
<h3 id="特点归纳"><a href="#特点归纳" class="headerlink" title="特点归纳"></a>特点归纳</h3><ol>
<li>安全问题，因为请求的代码可能是恶意代码</li>
<li>script 没有 onerror 事件,所以确定 JSONP 请求成功与否不是很容易</li>
</ol>
<h3 id="jQuery-实现"><a href="#jQuery-实现" class="headerlink" title="jQuery 实现"></a>jQuery 实现</h3><p>先引入 jQuery</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>然后添加如下代码</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">    url: <span class="string">"http://jack.com:8002/pay"</span>,</span><br><span class="line">    dataType: <span class="string">"jsonp"</span>,</span><br><span class="line">    success: <span class="function"><span class="keyword">function</span>(<span class="params"> response </span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(response)</span><br><span class="line">        <span class="keyword">if</span> (response === <span class="string">'success'</span>) &#123;</span><br><span class="line">            amount.innerText = amount.innerText - <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>然而以上跟 ajax 没有啥关系</p>
<h3 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h3><p>JSONP 为什么不支持 POST 请求?</p>
<ul>
<li>因为 JSONP 是通过动态创建 script 实现的</li>
<li>而动态创建的 script 只能用 GET,不能用 POST</li>
</ul>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="http://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html" target="_blank" rel="noopener">阮一峰-浏览器同源政策以及其规避方法</a><br><a href="https://github.com/MuYunyun/cross-domain" target="_blank" rel="noopener">跨域 demo 实验</a></p>
]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>jsonp</tag>
      </tags>
  </entry>
  <entry>
    <title>JS里的函数</title>
    <url>/2019/02/20/JS%E9%87%8C%E7%9A%84%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h2 id="函数的声明方式"><a href="#函数的声明方式" class="headerlink" title="函数的声明方式"></a>函数的声明方式</h2><ol>
<li><p>具名函数</p>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">x</span><span class="params">(input1, input2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">x.toString(); <span class="comment">//以及其他7种方法</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>匿名函数</p>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x;</span><br><span class="line">x = <span class="function"><span class="keyword">function</span><span class="params">(input1, input2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>变量加具名函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="function"><span class="keyword">function</span> <span class="title">y</span> (<span class="params">input1, input2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(y); <span class="comment">// 这个 y 是 undefined</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>但是<br><figure class="highlight nimrod"><table><tr><td class="code"><pre><span class="line">function y(...) <span class="meta">&#123;...&#125;</span></span><br><span class="line">console.log(y) // 这个是可以的</span><br></pre></td></tr></table></figure></p>
<p>这个是<strong>不一致</strong>造成的，因为前者的作用域在函数体内</p>
<ol start="4">
<li>window.Function 函数对象(并不常用)<figure class="highlight oxygene"><table><tr><td class="code"><pre><span class="line">f = <span class="keyword">new</span> <span class="function"><span class="keyword">Function</span><span class="params">(<span class="string">'x'</span>, <span class="string">'y'</span>, <span class="string">'return x+y'</span>)</span>;</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>以下是例子<br><figure class="highlight oxygene"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> n = <span class="number">1</span>;</span><br><span class="line">f = <span class="keyword">new</span> <span class="function"><span class="keyword">Function</span><span class="params">(<span class="string">'x'</span>, <span class="string">'y'</span>, <span class="string">'return x+'</span> + n + <span class="string">'+y'</span>)</span>;</span></span><br></pre></td></tr></table></figure></p>
<p>那么 <code>f(1, 2)</code> 的值是多少呢，就是 4</p>
<ol start="5">
<li>箭头函数表示<figure class="highlight coffeescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">f</span> = <span class="params">(x, y)</span> =&gt;</span> &#123;<span class="keyword">return</span> x+y&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>也可以表示为<br><figure class="highlight coffeescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">f</span> = <span class="params">(x, y)</span> =&gt;</span> x+y</span><br></pre></td></tr></table></figure></p>
<p>比如<br><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">n2 = n =&gt; n*n</span><br><span class="line"><span class="function"><span class="title">n2</span><span class="params">(<span class="number">4</span>)</span></span> <span class="comment">// 16</span></span><br></pre></td></tr></table></figure></p>
<p>一个小知识点，所有的函数都个属性叫做 <code>name</code><br><figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">f.name <span class="comment">// 'f'</span></span><br></pre></td></tr></table></figure></p>
<p>然鹅匿名函数<br><figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> f2 = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">f2.name <span class="comment">// 'f2'</span></span><br></pre></td></tr></table></figure></p>
<p>然鹅<br><figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> f3 = <span class="function"><span class="keyword">function</span> <span class="title">f4</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">f3.name <span class="comment">// 'f4'</span></span><br></pre></td></tr></table></figure></p>
<p>然鹅<br><figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">f5 = <span class="keyword">new</span> <span class="keyword">Function</span>(<span class="string">'x'</span>, <span class="string">'y'</span>, <span class="symbol">'return</span> x+y')</span><br><span class="line">f5.name // <span class="symbol">'anonymous</span>' 这里居然是匿名...</span><br></pre></td></tr></table></figure></p>
<h2 id="调用函数"><a href="#调用函数" class="headerlink" title="调用函数"></a>调用函数</h2><figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span><span class="params">(x, y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f <span class="comment">// f 是个变量，不会执行到 f 函数</span></span><br></pre></td></tr></table></figure>
<p>比如一个求面积的函数<br><figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getTriArea</span><span class="params">(width, height)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> n = width * height;</span><br><span class="line">    <span class="keyword">var</span> m = n / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> m;</span><br><span class="line">&#125;;</span><br><span class="line">getTriArea(<span class="number">4</span>, <span class="number">3</span>); <span class="comment">// 6</span></span><br></pre></td></tr></table></figure></p>
<p>那么在内存里面，函数是怎么存的呢, 试着用纯对象来模拟函数<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> f = &#123;&#125;</span><br><span class="line">f.name = <span class="string">'f'</span></span><br><span class="line">f.params = [<span class="string">'x'</span>, <span class="string">'y'</span>] <span class="comment">// 函数参数</span></span><br><span class="line">f.fbody = <span class="string">'console.log(1)'</span> <span class="comment">// 函数体</span></span><br><span class="line">f.call = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">window</span>.eval(f.fbody);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用以上代码</span></span><br><span class="line">f.call() <span class="comment">// 1</span></span><br></pre></td></tr></table></figure></p>
<p>f 是这个对象，而 f.call() 是执行这个函数体的代码</p>
<p><strong>可以执行代码的对象就叫做函数</strong></p>
<p>JS 有 7 种数据类型</p>
<p><code>number string boolean null undefined symbol object</code></p>
<p>日常复习的原型结构图<br><img src="./img1.png" alt></p>
<p>一般而言，有两种调用方法<br><figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line">f(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">f.call(undefined, <span class="number">1</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure></p>
<p>只有下面那种才是真正的调用<br><figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span><span class="params">(x, y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f.call(<span class="literal">undefined</span>, <span class="number">1</span>, <span class="number">2</span>) <span class="comment">// 参数从第二个开始传</span></span><br></pre></td></tr></table></figure></p>
<h2 id="this-和-arguments"><a href="#this-和-arguments" class="headerlink" title="this 和 arguments"></a>this 和 arguments</h2><p>以上面的例子<br><figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line">f.call(undefined, 1, 2) // 3</span><br><span class="line">-----------------------------</span><br><span class="line"><span class="code">         |        |  |</span></span><br><span class="line"><span class="code">         +        +  +</span></span><br><span class="line"><span class="code">        this     [1, 2] arguments</span></span><br><span class="line"></span><br><span class="line">1. call 的第一个参数可以用 this 得到</span><br><span class="line">2. call 的后面的参数可以用 arguments 得到</span><br></pre></td></tr></table></figure></p>
<p>在<strong>普通模式</strong>下，如果传入的第一个参数是 <code>undefined</code> 或不传,那么 <code>this</code> 的<br>值就是 <code>window</code>，如果用<strong>严格模式</strong> <code>&#39;use strict&#39;</code>，那么 <code>this</code> 的<br>值就是 <code>undefined</code>, <code>this</code> 就是 <code>call</code> 的第一个参数</p>
<p>什么是<strong>伪数组</strong>,就是 <code>__proto__</code> 中没有指向 <code>Array.prototype</code></p>
<h2 id="call-stack-调用栈"><a href="#call-stack-调用栈" class="headerlink" title="call stack 调用栈"></a>call stack 调用栈</h2><p>以下是一个较为复杂的例子<br><figure class="highlight scilab"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span><span class="params">()</span> &#123;</span></span><br><span class="line">    console.<span class="built_in">log</span>(<span class="string">'a1'</span>)</span><br><span class="line">    b()</span><br><span class="line">    console.<span class="built_in">log</span>(<span class="string">'a2'</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'a'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span><span class="params">()</span> &#123;</span></span><br><span class="line">    cosole.<span class="built_in">log</span>(<span class="string">'b1'</span>)</span><br><span class="line">    c()</span><br><span class="line">    console.<span class="built_in">log</span>(<span class="string">'b2'</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'b'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">c</span><span class="params">()</span> &#123;</span></span><br><span class="line">    console.<span class="built_in">log</span>(<span class="string">'c'</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'c'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a.call()</span><br><span class="line">console.<span class="built_in">log</span>(<span class="string">'end'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// a1 b1 c b2 a2</span></span><br></pre></td></tr></table></figure></p>
<p>下图是对上图的解释<br><img src="./img2.png" alt></p>
<p>再一个例子,用<strong>递归</strong><br><figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span></span> <span class="built_in">sum</span>(n) &#123;</span><br><span class="line">    <span class="keyword">if</span> (n === <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        // <span class="keyword">return</span> n + <span class="built_in">sum</span>(n-<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> n + <span class="built_in">sum</span>.<span class="keyword">call</span>(undefined, n-<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">sum</span>.<span class="keyword">call</span>(undefined, <span class="number">5</span>) // <span class="number">1</span> + <span class="number">2</span> + <span class="number">3</span> + <span class="number">4</span> + <span class="number">5</span></span><br></pre></td></tr></table></figure></p>
<h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">2</span></span><br><span class="line">    f2.call()</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> a = <span class="number">3</span></span><br><span class="line">        <span class="built_in">console</span>.log(a)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f1.call()</span><br><span class="line"><span class="built_in">console</span>.log(a)</span><br></pre></td></tr></table></figure>
<p>见下图<br><img src="./img3.png" alt><br>本质上还是<strong>就近原则</strong></p>
<p>以下对代码进行变形<br><figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">var <span class="keyword">a</span> = <span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>() &#123;</span></span><br><span class="line">   <span class="comment"> // 这里进行代码的改动</span></span><br><span class="line">    f2.call()</span><br><span class="line">    console.<span class="built_in">log</span>(<span class="keyword">a</span>)</span><br><span class="line">    var <span class="keyword">a</span> = <span class="number">2</span><span class="comment"> // 变量提升,先把声明提上去</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f2</span>() &#123;</span></span><br><span class="line">        var <span class="keyword">a</span> = <span class="number">3</span></span><br><span class="line">        console.<span class="built_in">log</span>(<span class="keyword">a</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f1.call()</span><br><span class="line">console.<span class="built_in">log</span>(<span class="keyword">a</span>)</span><br></pre></td></tr></table></figure></p>
<p>浏览器在执行代码时，会先找变量，后执行程序逻辑,以上代码在进行<br><strong>变量提升</strong>后就相当于<br><figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">var <span class="keyword">a</span> = <span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>() &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f2</span>() &#123;</span></span><br><span class="line">        var <span class="keyword">a</span> = <span class="number">3</span></span><br><span class="line">        console.<span class="built_in">log</span>(<span class="keyword">a</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    var <span class="keyword">a</span></span><br><span class="line">    f2.call()</span><br><span class="line">    console.<span class="built_in">log</span>(<span class="keyword">a</span>)<span class="comment"> // undefined</span></span><br><span class="line">    <span class="keyword">a</span> = <span class="number">2</span><span class="comment"> // 变量提升,先把声明提上去</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f1.call()</span><br><span class="line">console.<span class="built_in">log</span>(<span class="keyword">a</span>)</span><br></pre></td></tr></table></figure></p>
<p>又一个例子<br><figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">var <span class="keyword">a</span> = <span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>() &#123;</span></span><br><span class="line">    console.<span class="built_in">log</span>(<span class="keyword">a</span>)</span><br><span class="line">    var <span class="keyword">a</span> = <span class="number">2</span></span><br><span class="line">    f4.call()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f4</span>() &#123;</span></span><br><span class="line">    console.<span class="built_in">log</span>(<span class="keyword">a</span>)<span class="comment"> // a = ??</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f1.call()</span><br><span class="line">console.<span class="built_in">log</span>(<span class="keyword">a</span>)</span><br></pre></td></tr></table></figure></p>
<p>以上代码做变量提升后为<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a;</span><br><span class="line">    <span class="built_in">console</span>.log(a) <span class="comment">// 这里的 a 是 undefined</span></span><br><span class="line">    a = <span class="number">2</span></span><br><span class="line">    f4.call()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f4</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a) <span class="comment">// 这里的 a 是 1 ,因为这个 a 跟 f4 这个作用域有关，或者跟它的父作用域有关</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">f1.call()</span><br><span class="line"><span class="built_in">console</span>.log(a)</span><br></pre></td></tr></table></figure></p>
<p>再再再一个例子<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a;</span><br><span class="line">    <span class="built_in">console</span>.log(a) <span class="comment">// 这里的 a 是 undefined</span></span><br><span class="line">    a = <span class="number">2</span></span><br><span class="line">    f4.call()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f4</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a) <span class="comment">// 下面的 ??? 代码，使得这里的 a = 2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ???</span></span><br><span class="line">a = <span class="number">2</span> <span class="comment">// 这里修改了 a 的值</span></span><br><span class="line"></span><br><span class="line">f1.call()</span><br><span class="line"><span class="built_in">console</span>.log(a)</span><br></pre></td></tr></table></figure></p>
<p>再再再再一个例子<br><figure class="highlight stata"><table><tr><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">    &lt;<span class="keyword">li</span>&gt;选项1&lt;/<span class="keyword">li</span>&gt;</span><br><span class="line">    &lt;<span class="keyword">li</span>&gt;选项2&lt;/<span class="keyword">li</span>&gt;</span><br><span class="line">    &lt;<span class="keyword">li</span>&gt;选项3&lt;/<span class="keyword">li</span>&gt;</span><br><span class="line">    &lt;<span class="keyword">li</span>&gt;选项4&lt;/<span class="keyword">li</span>&gt;</span><br><span class="line">    &lt;<span class="keyword">li</span>&gt;选项5&lt;/<span class="keyword">li</span>&gt;</span><br><span class="line">    &lt;<span class="keyword">li</span>&gt;选项6&lt;/<span class="keyword">li</span>&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> liTags</span><br><span class="line"><span class="keyword">var</span> i</span><br><span class="line">liTags = document.querySelector('<span class="keyword">li</span>')</span><br><span class="line"><span class="keyword">for</span> (i = 0; i &lt; liTags.length; i++) &#123;</span><br><span class="line">    liTags[i].onclick = function() &#123;</span><br><span class="line">        console.<span class="built_in">log</span>(i) <span class="comment">// 一个小时之后</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// for 循环之后，i 就是 6</span></span><br><span class="line">console.<span class="built_in">log</span>(i)</span><br></pre></td></tr></table></figure></p>
<p>为什么是这样呢，一个”合理”的解释是，在执行 <code>onclick</code> 函数之前，这个 <code>i</code> 已经跑完了 for 循环了。 function 里面的 <code>i</code> 会跑去寻找它父作用域的已经声明并且赋值过的 <code>i</code>，由于程序运行的速度很快，我们可以理解为，在执行 function 里面的函数时，此时 <code>i</code> 已经变成 6 了</p>
<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>如果一个函数使用了范围外的值，那么这个(函数 + 这个变量)就叫<strong>闭包</strong><br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f4</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><figure class="highlight clean"><table><tr><td class="code"><pre><span class="line">/######################################/</span><br><span class="line">var f1 = function f2()&#123;&#125;</span><br><span class="line">console.log(f2) <span class="comment">// f2 is not defined(f2 不存在,而且 f2 不是 undefined)</span></span><br><span class="line"></span><br><span class="line">/######################################/</span><br><span class="line">function f()&#123;</span><br><span class="line">    console.log(this)</span><br><span class="line">&#125;</span><br><span class="line">f.call(<span class="number">1</span>) <span class="comment">// Number 对象 1</span></span><br><span class="line"></span><br><span class="line">/######################################/</span><br><span class="line">function f()&#123;</span><br><span class="line">    <span class="string">'use strict'</span></span><br><span class="line">    console.log(this)</span><br><span class="line">&#125;</span><br><span class="line">f.call(<span class="number">1</span>) <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">/######################################/</span><br><span class="line">function f()&#123;</span><br><span class="line">    console.log(this)</span><br><span class="line">&#125;</span><br><span class="line">f.call() <span class="comment">// 打印 Window</span></span><br><span class="line"></span><br><span class="line">/######################################/</span><br><span class="line">function f()&#123;</span><br><span class="line">    <span class="string">'use strict'</span></span><br><span class="line">    console.log(this)</span><br><span class="line">&#125;</span><br><span class="line">f.call() <span class="comment">// 打印 undefined</span></span><br><span class="line"></span><br><span class="line">/######################################/</span><br><span class="line">function f()&#123;</span><br><span class="line">    return <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">a = f <span class="comment">// a is function f</span></span><br><span class="line"></span><br><span class="line">/######################################/</span><br><span class="line">function f()&#123;</span><br><span class="line">    return <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">var a = f.call() <span class="comment">// a = 1</span></span><br><span class="line"></span><br><span class="line">/######################################/</span><br><span class="line">function f()&#123;</span><br><span class="line">    console.log(this)</span><br><span class="line">&#125;</span><br><span class="line">f.call() <span class="comment">// 打印的是 window</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/######################################/</span><br><span class="line">var a = <span class="number">1</span>,<span class="number">2</span> <span class="comment">//报错</span></span><br><span class="line">var a = (<span class="number">1</span>,<span class="number">2</span>) <span class="comment">// a = 2 最后一个</span></span><br><span class="line">var a = (<span class="number">1</span>, console.log(<span class="number">2</span>)) <span class="comment">// a 为 undefined</span></span><br><span class="line"></span><br><span class="line">/######################################/</span><br><span class="line">function f1()&#123;</span><br><span class="line">    console.log(this)</span><br><span class="line">    function f2()&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var obj = &#123;name: <span class="string">'obj'</span>&#125;</span><br><span class="line">f1.call( obj ) <span class="comment">// 打印 obj 对象</span></span><br><span class="line"></span><br><span class="line">/######################################/</span><br><span class="line">function f1()&#123;</span><br><span class="line"></span><br><span class="line">    function f2()&#123;</span><br><span class="line">        console.log(this)</span><br><span class="line">    &#125;</span><br><span class="line">    f2.call()</span><br><span class="line">&#125;</span><br><span class="line">var obj = &#123;name: <span class="string">'obj'</span>&#125;</span><br><span class="line">f1.call( obj ) <span class="comment">// Window 对象</span></span><br><span class="line"></span><br><span class="line">/######################################/</span><br><span class="line">function f1()&#123;</span><br><span class="line">    console.log(this) <span class="comment">// 第一个 this</span></span><br><span class="line">    function f2()&#123;</span><br><span class="line">        console.log(this) <span class="comment">// 第二个 this</span></span><br><span class="line">    &#125;</span><br><span class="line">    f2.call()</span><br><span class="line">&#125;</span><br><span class="line">var obj = &#123;name: <span class="string">'obj'</span>&#125;</span><br><span class="line">f1.call( obj ) <span class="comment">// 先打印 obj 对象,然后打印 Window 对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// this 就是 call 的第一个参数，第一个 this 对应的 call 是 f1.call(obj)，第二个 this 对应的 call 是 f2.call()</span></span><br><span class="line"><span class="comment">// this 和 arguments 都是参数，参数都要在函数执行（call）的时候才能确定</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>JS里的字符串</title>
    <url>/2019/02/20/JS%E9%87%8C%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<blockquote>
<p>简单记录一下 String 里的一些方法</p>
</blockquote>
<h2 id="length"><a href="#length" class="headerlink" title="length"></a>length</h2><p>String 作为一个类似数组的对象，里面有个直接属性 length</p>
<h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><h3 id="创造-String"><a href="#创造-String" class="headerlink" title="创造 String"></a>创造 String</h3><ul>
<li>String()</li>
</ul>
<h3 id="其他类型转换成-String"><a href="#其他类型转换成-String" class="headerlink" title="其他类型转换成 String"></a>其他类型转换成 String</h3><ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/fromCharCode" target="_blank" rel="noopener">String.fromCharCode()</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/fromCodePoint" target="_blank" rel="noopener">String.fromCodePoint()</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/toString" target="_blank" rel="noopener">String.prototype.toString()</a></li>
</ul>
<h3 id="增"><a href="#增" class="headerlink" title="增"></a>增</h3><ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/concat" target="_blank" rel="noopener">String.prototype.concat()</a></li>
</ul>
<h3 id="删"><a href="#删" class="headerlink" title="删"></a>删</h3><ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/Trim" target="_blank" rel="noopener">String.prototype.trim()</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/TrimLeft" target="_blank" rel="noopener">String.prototype.trimLeft()</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/TrimRight" target="_blank" rel="noopener">String.prototype.trimRight()</a></li>
</ul>
<h3 id="改"><a href="#改" class="headerlink" title="改"></a>改</h3><ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace" target="_blank" rel="noopener">String.prototype.replace()</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/toLowerCase" target="_blank" rel="noopener">String.prototype.toLowerCase()</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/valueOf" target="_blank" rel="noopener">String.prototype.toUpperCase()</a></li>
</ul>
<h3 id="查"><a href="#查" class="headerlink" title="查"></a>查</h3><ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/charAt" target="_blank" rel="noopener">String.prototype.charAt()</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/charCodeAt" target="_blank" rel="noopener">String.prototype.charCodeAt()</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith" target="_blank" rel="noopener">String.prototype.endsWith()</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith" target="_blank" rel="noopener">String.prototype.startsWith()</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/includes" target="_blank" rel="noopener">String.prototype.includes()</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/indexOf" target="_blank" rel="noopener">String.prototype.indexOf()</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/lastIndexOf" target="_blank" rel="noopener">String.prototype.lastIndexOf()</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/match" target="_blank" rel="noopener">String.prototype.match()</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/search" target="_blank" rel="noopener">String.prototype.search()</a></li>
</ul>
<h3 id="拷"><a href="#拷" class="headerlink" title="拷"></a>拷</h3><ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/substr" target="_blank" rel="noopener">String.prototype.repeat()</a></li>
</ul>
<h3 id="裁"><a href="#裁" class="headerlink" title="裁"></a>裁</h3><ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/substring" target="_blank" rel="noopener">String.prototype.substring()</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/slice" target="_blank" rel="noopener">String.prototype.slice()</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/substr" target="_blank" rel="noopener">String.prototype.substr()</a></li>
</ul>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>字符串创建后可以理解为创建了一个 const 常量，所以实际上对它本身是无法做修改的，上面的 api 中的增/删/改实际上是把字串所在的内存空间拷贝了一份，<br>按照规则返回这个空间的地址，也就是返回了一个新的类似数组的对象</p>
]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>JS里的对象、原型、原型链</title>
    <url>/2019/02/19/JS%E9%87%8C%E7%9A%84%E5%AF%B9%E8%B1%A1%E3%80%81%E5%8E%9F%E5%9E%8B%E3%80%81%E5%8E%9F%E5%9E%8B%E9%93%BE/</url>
    <content><![CDATA[<h2 id="全局对象"><a href="#全局对象" class="headerlink" title="全局对象"></a>全局对象</h2><p>ES 规定全局对象为 global(浏览器中的 window 为其全局对象)<br>window 就是一个哈希表<br>window 的属性就是全局变量</p>
<p>1.ECMAScript 规定</p>
<ul>
<li>global.parseInt</li>
<li>global.parseFloat</li>
<li>global.Number</li>
<li>global.String</li>
<li>global.Boolean</li>
<li>global.Object</li>
</ul>
<p>2.浏览器自加属性(某些浏览器私有的属性)</p>
<ul>
<li>window.alert</li>
<li>window.prompt</li>
<li>window.comfirm</li>
<li>window.console.log</li>
<li>window.console.dir</li>
<li>window.document(文档 w3c DOM)</li>
<li>window.document.createElement</li>
<li>window.document.getElementById</li>
</ul>
<h2 id="简单类型和对象"><a href="#简单类型和对象" class="headerlink" title="简单类型和对象"></a>简单类型和对象</h2><h3 id="Number"><a href="#Number" class="headerlink" title="Number()"></a>Number()</h3><p>1.Number(‘1’)<br>2.var n = new Number(1)<br>1 =&gt; {valueof(): 1, }<br>var n1 = 1<br>var n2 = new Number(1)</p>
<p>见下图<br><img src="./img1.png" alt></p>
<p>想让类似 <code>var n = 1; n.toString()</code>(虽然 toString 不存在)<br>就两步,先创建一个临时对象出来<code>temp = new Number(1); temp.toString()</code> 返回 temp 给表达式后将 temp 删掉<br>所以这就好解释<br><figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">var n = <span class="number">1</span><span class="comment">;</span></span><br><span class="line">n.xxx = <span class="number">2</span><span class="comment">;</span></span><br><span class="line">n.xxx // undefined</span><br></pre></td></tr></table></figure></p>
<p>为什么上面的 <code>n.xxx</code> 为 undefined</p>
<h3 id="String"><a href="#String" class="headerlink" title="String()"></a>String()</h3><p>搜索 string MDN ,查看常用 api</p>
<ul>
<li>String.trim() 去掉空格</li>
<li>String.concat() 连接字符串</li>
<li>String.slice() 切片</li>
<li>Strng.replace() 替换</li>
</ul>
<h3 id="Boolean"><a href="#Boolean" class="headerlink" title="Boolean()"></a>Boolean()</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="literal">false</span></span><br><span class="line"><span class="keyword">var</span> f2 = <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">false</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(f) &#123;<span class="built_in">console</span>.log(<span class="number">1</span>)&#125;</span><br><span class="line"><span class="keyword">if</span>(f2) &#123;<span class="built_in">console</span>.log(<span class="number">2</span>)&#125;</span><br><span class="line"><span class="number">2</span> <span class="comment">// 只打印 2</span></span><br></pre></td></tr></table></figure>
<ol>
<li>5 个 false 值: 0 NaN ‘’ null undefined false</li>
<li>所有对象都是相当于 true 的值</li>
</ol>
<h3 id="Object"><a href="#Object" class="headerlink" title="Object()"></a>Object()</h3><figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 一般是这样写</span></span><br><span class="line"><span class="keyword">var</span> n = &#123;&#125;</span><br><span class="line"><span class="comment">// 而不是这样</span></span><br><span class="line"><span class="keyword">var</span> n = <span class="keyword">new</span> <span class="keyword">object</span>()</span><br></pre></td></tr></table></figure>
<h2 id="公用属性-原型"><a href="#公用属性-原型" class="headerlink" title="公用属性(原型)"></a>公用属性(原型)</h2><p>在 JS 中，原型是指 <strong>原型对象</strong> ,而每个对象都拥有一个原型对象,对象以其原型为模板，从原型来继承方法和属性。而对于原型对象来说，它们也可能拥有原型，也会从中继承其方法和属性，这样的层层递进的关系就是 <strong>原型链</strong></p>
<p>通常做法是使用隐藏 key <code>__proto__</code> 用来指向共有的属性</p>
<p>Object 类型和其他类型如 Number 有如下关系<br><img src="./img2.png" alt></p>
<p>还有一张图<br><img src="./img3.png" alt></p>
<p>S —&gt; String<br>n —&gt; Number<br>b —&gt; Boolean<br>o —&gt; Object</p>
<p><code>Object.prototype</code> Object 的共有属性<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> o1 = &#123;&#125;</span><br><span class="line">o1.__proto__ === <span class="built_in">Object</span>.prototype <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 注意</span></span><br><span class="line"><span class="built_in">Object</span>.__proto__ === <span class="built_in">Function</span>.prototype，因为 <span class="built_in">Function</span> 是 <span class="built_in">Object</span> 的构造函数</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> n1 = <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">1</span>)</span><br><span class="line">n1.__proto__ === <span class="built_in">Number</span>.prototype <span class="comment">// true</span></span><br><span class="line">n1.__proto__.__proto__ === <span class="built_in">Object</span>.prototype <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s1 = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">'1'</span>)</span><br><span class="line">s1.__proto__ === <span class="built_in">String</span>.prototype <span class="comment">// true</span></span><br><span class="line">s1.__proto__.__proto__ === <span class="built_in">Object</span>.prototype <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b1 = <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">true</span>)</span><br><span class="line">b1.__proto__ === <span class="built_in">Boolean</span>.prototype <span class="comment">// true</span></span><br><span class="line">b1.__proto__.__proto__ === <span class="built_in">Object</span>.prototype <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p>
<h2 id="window-的-prototype"><a href="#window-的-prototype" class="headerlink" title="window 的 prototype"></a>window 的 prototype</h2><p>不写代码也有 prototype<br><img src="./img4.png" alt></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> 对象 = <span class="keyword">new</span> <span class="type"></span>函数()</span><br><span class="line">对象.__proto__ === 函数.prototype</span><br></pre></td></tr></table></figure>
<p>那么 <code>__proto__</code> 与 <code>prototype</code> 的区别?<br>前者是对象的属性，后者是函数的属性</p>
<p>比较难懂的地方在哪里呢?<br><figure class="highlight elm"><table><tr><td class="code"><pre><span class="line"><span class="title">var</span> obj = 函数.proto<span class="keyword">type</span></span><br><span class="line"><span class="title">obj</span>.__proto__ === <span class="type">Object</span>.proto<span class="keyword">type</span></span><br></pre></td></tr></table></figure></p>
<p>所以存在<br><figure class="highlight elm"><table><tr><td class="code"><pre><span class="line">函数.proto<span class="keyword">type</span>.__proto__ === <span class="type">Object</span>.prototype</span><br><span class="line"><span class="title">var</span> obj2 = 函数</span><br><span class="line"><span class="title">obj2</span>.__proto__ === <span class="type">Function</span>.proto<span class="keyword">type</span></span><br><span class="line">函数.__proto__ === <span class="type">Function</span>.proto<span class="keyword">type</span></span><br><span class="line"><span class="type">Function</span>.__proto__ === <span class="type">Function</span>.proto<span class="keyword">type</span></span><br><span class="line"><span class="type">Function</span>.proto<span class="keyword">type</span>.__proto__ === <span class="type">Object</span>.prototype</span><br></pre></td></tr></table></figure></p>
<p>Function 这个类型很奇怪，它既是对象也是函数<br><img src="./img5.png" alt></p>
<p>所以对于 <code>__proto__</code> 和 <code>prototype</code> 来说</p>
<ul>
<li>不能断章取义，<code>__proto__</code> 和 <code>prototype</code> 只是两个 key 而已</li>
<li>我们一般研究对象的 <code>__proto__</code> 和函数的 <code>prototype</code></li>
<li>对象.<code>__proto__</code> === 某函数.<code>prototype</code></li>
<li>如果把函数看成对象，那么 函数.<code>__proto__</code> === Function.<code>prototype</code></li>
<li>如果把 Function 看成对象，那么 Function.<code>__proto__</code> === Function.<code>prototype</code></li>
</ul>
]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>JS里的数据</title>
    <url>/2019/02/19/JS%E9%87%8C%E7%9A%84%E6%95%B0%E6%8D%AE/</url>
    <content><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><ol>
<li>1991年,李爵士发明 www</li>
<li>1992年，同事发明 CSS</li>
<li>1993年，创建 W3C</li>
<li>1995年，网景浏览器 Netscape —&gt; Navigator 脚本</li>
<li>Branden Eich JS 之父，推出 Mocha 脚本语言，看起来像 Java</li>
<li><p>语言的转变 Mocha —&gt; LiveScript —&gt; JavaScript</p>
</li>
<li><p>这个时候 Unicode UTF-8 发布,这个时候 JS 已经有 bug 了，主要在于编码方面的</p>
</li>
<li><p>1996年, MS IE 想要抢占浏览器市场，发明 JScript</p>
</li>
<li>ECMAScript (申报标准)&lt;—-网景开源 —-&gt; firefox</li>
<li>IE5.5 MS推出 JS发请求</li>
<li>2004年, Gmail 网页上的程序</li>
<li>后端—&gt;前端 Front-end(以 JS 为生)</li>
<li>2010年左右，中国开始逐渐有前端开发这类职位</li>
</ol>
<p>然而，JS 这个时候</p>
<ol>
<li>全局变量(没有模块化)</li>
<li>标准化(内置代码少)</li>
</ol>
<p>这个时候 ECMAScript 进行一次代码升级 从 ES3 —&gt; ES5(ES4 死了)，但是步子太小<br>Rails 社区 Ruby —&gt; CoffeeScript JS 改良版<br>添加了 类、箭头函数、opiond chain 语法<br>ECMAScript6 步子合适,JS 终于成为一个现代编程语言</p>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>JS 一共有 7 种数据类型</p>
<ul>
<li>数字/字符串/布尔/symbol(符号)/null/undefined/对象</li>
<li>即 number/string/boolean/symbol/null/undefined/object(array,function…)</li>
<li>所以你看，”JS 一切皆对象” 这句话严格意义上来说是错的</li>
</ul>
<h3 id="number"><a href="#number" class="headerlink" title="number"></a>number</h3><p>十进制<br><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>      <span class="string">//</span> <span class="number">1</span></span><br><span class="line"><span class="number">1.1</span>    <span class="string">//</span> <span class="number">1.1</span></span><br><span class="line"><span class="number">.1</span>     <span class="string">//</span> <span class="number">0.1</span></span><br><span class="line"><span class="number">1.23e2</span> <span class="string">//</span> <span class="number">123</span></span><br></pre></td></tr></table></figure></p>
<p>二进制(以 0b 开头)<br><figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line"><span class="number">0b11</span> // <span class="number">3</span></span><br></pre></td></tr></table></figure></p>
<p>八进制(0 开头)<br><figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="symbol">011 </span>// <span class="number">9</span></span><br></pre></td></tr></table></figure></p>
<p>十六进制(0x 开头)<br><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="number">0x11</span> <span class="string">//</span> <span class="number">17</span></span><br></pre></td></tr></table></figure></p>
<h3 id="字符串-String"><a href="#字符串-String" class="headerlink" title="字符串(String)"></a>字符串(String)</h3><figure class="highlight scheme"><table><tr><td class="code"><pre><span class="line"><span class="symbol">'你好</span>' <span class="string">"你好"</span> '' <span class="string">""</span>(<span class="name">空字符串</span>)</span><br></pre></td></tr></table></figure>
<p>转义符号 “\” 用于多行字符串(不是字符串里有回车)<br><figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line">var s = '<span class="number">1234</span>5 \            // 坑人语法</span><br><span class="line">            <span class="number">6789</span>0'</span><br><span class="line">var s2 = '<span class="number">1234</span>5' +          <span class="comment">//好读的语法</span></span><br><span class="line">            '<span class="number">6789</span>0'</span><br><span class="line"></span><br><span class="line">var s3 = '<span class="number">1234</span>5 ' (这里有空格) <span class="comment">// 而这里有报错</span></span><br><span class="line">        '<span class="number">6789</span>0'</span><br></pre></td></tr></table></figure></p>
<p>因为上面，所以 ES 6 做了升级处理,如下<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注意这里是反引号</span></span><br><span class="line"><span class="comment">// 这里也是包含有回车的</span></span><br><span class="line"><span class="keyword">var</span> s4 = <span class="string">` 12345</span></span><br><span class="line"><span class="string">67890`</span></span><br></pre></td></tr></table></figure></p>
<h3 id="布尔-boolean"><a href="#布尔-boolean" class="headerlink" title="布尔(boolean)"></a>布尔(boolean)</h3><ul>
<li>true</li>
<li>false</li>
<li>&amp;&amp; 与</li>
<li>|| 或</li>
</ul>
<h3 id="symbol"><a href="#symbol" class="headerlink" title="symbol"></a>symbol</h3><h4 id="symbol-来源"><a href="#symbol-来源" class="headerlink" title="symbol 来源"></a>symbol 来源</h4><p>symbol 就是那个对象<strong>全局的唯一的值</strong>,这其实很像数据库中的唯一识别 id，这个唯一识别的 id 对应一条完整的数据<br>而这个是用来干嘛的，简单来说就是<strong>这个值是用来标识一个对象的属性的</strong>,好了，为什么需要标识这个对象的属性呢?<br>想像一下你需要用别人提供的一个对象，然后你想在这个对象里面加个方法，但是假设你加的方法名跟对象里面的方法名一样，就会对原有对象方法进行了<br>修改，这样就污染了原对象。那么能不能有一种机制来起到报警/提示/避免的作用呢? 有，ES6 就引入了这种新的<strong>原始数据类型</strong>叫 symbol</p>
<h4 id="理解-symbol"><a href="#理解-symbol" class="headerlink" title="理解 symbol"></a>理解 symbol</h4><p>引入 symbol 前<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(options) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = options.name;</span><br><span class="line">        <span class="keyword">this</span>.age = options.age;</span><br><span class="line">    &#125;</span><br><span class="line">    getAge() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> xxx = <span class="keyword">new</span> person(&#123;</span><br><span class="line">    name: <span class="string">'xxx'</span>,</span><br><span class="line">    age: <span class="number">1</span></span><br><span class="line">&#125;);</span><br><span class="line">xxx.getAge() <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> GetAge =  &#123; <span class="comment">// mixin</span></span><br><span class="line">    getAge() &#123; <span class="built_in">console</span>.log(<span class="string">'xxx'</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这里就修改了原对象方法</span></span><br><span class="line"><span class="built_in">Object</span>.assign(person.prototype, GetAge);</span><br><span class="line">xxx.getAge() <span class="comment">// 'xxx'</span></span><br></pre></td></tr></table></figure></p>
<p>引入 symbol 后<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> getAge = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(options) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = options.name;</span><br><span class="line">        <span class="keyword">this</span>.age = options.age;</span><br><span class="line">    &#125;</span><br><span class="line">    [getAge]() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> xxx = <span class="keyword">new</span> person(&#123;</span><br><span class="line">    name: <span class="string">'xxx'</span>,</span><br><span class="line">    age: <span class="number">1</span></span><br><span class="line">&#125;);</span><br><span class="line">xxx[getAge]() <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// let getAge = Symbol(); // 报错 重复定义</span></span><br><span class="line">getAge = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="keyword">const</span> GetAge =  &#123; <span class="comment">// mixin</span></span><br><span class="line">    [getAge]() &#123; <span class="built_in">console</span>.log(<span class="string">'xxx'</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// getAge 是一个新的 Symbol 值，所以这里就没有覆盖掉以前的</span></span><br><span class="line"><span class="built_in">Object</span>.assign(person.prototype, GetAge);</span><br><span class="line">xxx[getAge]() <span class="comment">// 'xxx'</span></span><br></pre></td></tr></table></figure></p>
<h4 id="symbol-实例"><a href="#symbol-实例" class="headerlink" title="symbol 实例"></a>symbol 实例</h4><p>假如有一个函数是这样的<br><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span><span class="params">(type)</span> &#123;</span></span><br><span class="line">    <span class="keyword">switch</span>(<span class="built_in">type</span>) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'xxx'</span>:</span><br><span class="line">            console.<span class="built_in">log</span>(<span class="string">'1'</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>现在调用它<br><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">var demo = &#123;</span><br><span class="line">    xxx: <span class="string">'xxx'</span>,</span><br><span class="line">    yyy: <span class="string">'yyy'</span></span><br><span class="line">&#125;</span><br><span class="line">test(<span class="string">'xxx'</span>); <span class="regexp">//</span> <span class="string">'1'</span></span><br><span class="line"><span class="regexp">//</span> 或者</span><br><span class="line">test(demo.xxx); <span class="regexp">//</span> <span class="string">'1'</span></span><br></pre></td></tr></table></figure></p>
<p>但是这么做不好，因为字符串可能有些有拼写错误会造成一些 bug，可以这么改<br><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"><span class="keyword">type</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(<span class="keyword">type</span>) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="keyword">type</span>.xxx:</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'1'</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> demo = &#123;</span><br><span class="line">    xxx: <span class="string">'xxx'</span>,</span><br><span class="line">    yyy: <span class="string">'yyy'</span></span><br><span class="line">&#125;</span><br><span class="line">test(demo.xxx); <span class="comment">// '1'</span></span><br></pre></td></tr></table></figure></p>
<p>但是我们发现，此时不管 <code>demo.xxx</code> 里的值为何值它都是会执行 <code>console.log(&#39;1&#39;)</code><br><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">demo.xxx = <span class="string">'demo'</span>;</span><br><span class="line">test(demo.xxx); <span class="regexp">//</span> <span class="string">'1'</span></span><br></pre></td></tr></table></figure></p>
<p>只要不冲突，那干什么都行的话，那为什么不用 Symbol ???<br><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> demo = &#123;</span><br><span class="line">    xxx: <span class="built_in">Symbol</span>(),</span><br><span class="line">    yyy: <span class="built_in">Symbol</span>()</span><br><span class="line">&#125;</span><br><span class="line">test(demo.xxx); <span class="comment">// '1'</span></span><br></pre></td></tr></table></figure></p>
<p>另外需要强调的是，Symbol 可以创建一个独一无二的值，<strong>但它并不是字符串!!!</strong><br>也可以给 Symbol 传参，但是这个只是起到一个’注释’的作用，如下<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a1 = <span class="built_in">Symbol</span>(<span class="string">'a'</span>);</span><br><span class="line"><span class="keyword">var</span> a2 = <span class="built_in">Symbol</span>(<span class="string">'a'</span>);</span><br><span class="line">a1 === a2; <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(a1); <span class="comment">// Symbol(a)</span></span><br><span class="line"><span class="built_in">console</span>.log(a2); <span class="comment">// Symbol(a)</span></span><br></pre></td></tr></table></figure></p>
<h3 id="null-与-undefined"><a href="#null-与-undefined" class="headerlink" title="null 与 undefined"></a>null 与 undefined</h3><p>如果一个值为 null 或者 undefined 则它都表示什么也没有，这也是 JS 的原创 bug</p>
<p>区别:</p>
<p>i.(规范)如果一个变量没有被赋值，那么这个变量的值就是 <strong>undefined</strong></p>
<p>ii.(大家都认为)如果你想<strong>表示一个没有赋值的 String/Number/Boolean/Symbol</strong>,就用 <strong>undefined</strong></p>
<p>iii.(大家都认为)如果你想<strong>表示一个没有赋值的对象</strong>,就用 <strong>null</strong></p>
<h3 id="object"><a href="#object" class="headerlink" title="object"></a>object</h3><p>前面说的都是<strong>基本类型或者说是简单类型</strong>,而 object 是<strong>复杂类型</strong>,但是所谓的复杂类型也是由简单类型组成的<br><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">'frank'</span></span><br><span class="line"><span class="keyword">var</span> age = <span class="number">18</span></span><br><span class="line"><span class="keyword">var</span> gender = <span class="string">'male'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    <span class="string">'name'</span>: <span class="string">'frank'</span>,</span><br><span class="line">    <span class="string">'age'</span>: <span class="number">18</span>,</span><br><span class="line">    <span class="string">'gender'</span>: <span class="string">'male'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">语法</span><br><span class="line"><span class="comment">// 声明定义</span></span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name: <span class="string">'frank'</span>,</span><br><span class="line">    age: <span class="string">'18'</span>,</span><br><span class="line">    <span class="keyword">self</span>: person,</span><br><span class="line">    <span class="string">''</span>: <span class="string">'frank'</span>, <span class="comment">// 这个是可以成立的</span></span><br><span class="line">    <span class="number">9</span>a: <span class="string">'frank'</span>, <span class="comment">// 这样写不行</span></span><br><span class="line">    <span class="string">'9a'</span>: <span class="string">'frank'</span>, <span class="comment">// 这样是行的</span></span><br><span class="line">    <span class="string">'a b'</span>: <span class="string">'frank'</span>, <span class="comment">// 这样也是可以的</span></span><br><span class="line">    <span class="string">'中文'</span>: <span class="string">'frank'</span>,<span class="comment">// 中文是可以的</span></span><br><span class="line">    <span class="comment">// 如果不加引号，那么就 按照标识符来判断是否符合语法</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line">person[<span class="string">'name'</span>]</span><br><span class="line"><span class="comment">// 下面的语法成立么</span></span><br><span class="line">person.<span class="keyword">self</span>.<span class="keyword">self</span>.<span class="keyword">self</span>.<span class="keyword">self</span>.name</span><br><span class="line"><span class="comment">// 调用空字符串成立</span></span><br><span class="line">person[<span class="string">''</span>]</span><br></pre></td></tr></table></figure></p>
<h3 id="其他操作符"><a href="#其他操作符" class="headerlink" title="其他操作符"></a>其他操作符</h3><h4 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h4><table>
<thead>
<tr>
<th>xxx 的类型</th>
<th>string</th>
<th>number</th>
<th>boolean</th>
<th>null</th>
<th>undefined</th>
<th>symbol</th>
<th>object</th>
<th>function</th>
</tr>
</thead>
<tbody>
<tr>
<td>typeof xxx</td>
<td>‘string’</td>
<td>‘number’</td>
<td>‘boolean’</td>
<td><strong>‘object’</strong></td>
<td>‘undefined’</td>
<td>‘symbol’</td>
<td>‘object’</td>
<td>‘function’</td>
</tr>
</tbody>
</table>
<h4 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h4><p>delete 操作符用来删除对象的某个属性，若没有指向这个属性的引用，那它最终会被释放<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Employee = &#123;</span><br><span class="line">  age: <span class="number">28</span>,</span><br><span class="line">  name: <span class="string">'abc'</span>,</span><br><span class="line">  designation: <span class="string">'developer'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">delete</span> Employee.name);   <span class="comment">// returns true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">delete</span> Employee.age);    <span class="comment">// returns true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 当试着删除一个不存在的属性时</span></span><br><span class="line"><span class="comment">// 同样会返回true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">delete</span> Employee.salary); <span class="comment">// returns true</span></span><br></pre></td></tr></table></figure></p>
<h4 id="in"><a href="#in" class="headerlink" title="in"></a>in</h4><p>若指定的属性在其指定的对象或原型链中，则 in 运算符返回 true<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 数组</span></span><br><span class="line"><span class="keyword">var</span> trees = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="string">"redwood"</span>, <span class="string">"bay"</span>, <span class="string">"cedar"</span>, <span class="string">"oak"</span>, <span class="string">"maple"</span>);</span><br><span class="line"><span class="number">0</span> <span class="keyword">in</span> trees        <span class="comment">// 返回true</span></span><br><span class="line"><span class="number">3</span> <span class="keyword">in</span> trees        <span class="comment">// 返回true</span></span><br><span class="line"><span class="number">6</span> <span class="keyword">in</span> trees        <span class="comment">// 返回false</span></span><br><span class="line"><span class="string">"bay"</span> <span class="keyword">in</span> trees    <span class="comment">// 返回false (必须使用索引号,而不是数组元素的值)</span></span><br><span class="line"></span><br><span class="line"><span class="string">"length"</span> <span class="keyword">in</span> trees <span class="comment">// 返回true (length是一个数组属性)</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Symbol</span>.iterator <span class="keyword">in</span> trees <span class="comment">// 返回true (数组可迭代，只在ES2015+上有效)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 内置对象</span></span><br><span class="line"><span class="string">"PI"</span> <span class="keyword">in</span> <span class="built_in">Math</span>          <span class="comment">// 返回true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义对象</span></span><br><span class="line"><span class="keyword">var</span> mycar = &#123;<span class="attr">make</span>: <span class="string">"Honda"</span>, <span class="attr">model</span>: <span class="string">"Accord"</span>, <span class="attr">year</span>: <span class="number">1998</span>&#125;;</span><br><span class="line"><span class="string">"make"</span> <span class="keyword">in</span> mycar  <span class="comment">// 返回true</span></span><br><span class="line"><span class="string">"model"</span> <span class="keyword">in</span> mycar <span class="comment">// 返回true</span></span><br></pre></td></tr></table></figure></p>
<h4 id="for-in"><a href="#for-in" class="headerlink" title="for in"></a>for in</h4><p>for…in 语句可以以任意顺序遍历一个<strong>对象的可枚举属性</strong>,对于每个不同的属性，语句都会执行<br><figure class="highlight stata"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;a:1, b:2, c:3&#125;;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> <span class="keyword">prop</span> <span class="keyword">in</span> obj) &#123;</span><br><span class="line">  console.<span class="built_in">log</span>(<span class="string">"obj."</span> + <span class="keyword">prop</span> + <span class="string">" = "</span> + obj[<span class="keyword">prop</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line"><span class="comment">// "obj.a = 1"</span></span><br><span class="line"><span class="comment">// "obj.b = 2"</span></span><br><span class="line"><span class="comment">// "obj.c = 3"</span></span><br></pre></td></tr></table></figure></p>
<h4 id="for-of"><a href="#for-of" class="headerlink" title="for of"></a>for of</h4><p>for…of 语句在可迭代的对象 (array, string, map, set…) 上创建一个迭代循环，也是为不同的属性值执行语句<br><figure class="highlight ceylon"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> iterable = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> <span class="keyword">value</span> <span class="keyword">of</span> iterable) &#123;</span><br><span class="line">    <span class="keyword">value</span> += <span class="number">1</span>;</span><br><span class="line">    console.log(<span class="keyword">value</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 11</span></span><br><span class="line"><span class="comment">// 21</span></span><br><span class="line"><span class="comment">// 31</span></span><br></pre></td></tr></table></figure></p>
<h4 id="for-in-和-for-of-的区别"><a href="#for-in-和-for-of-的区别" class="headerlink" title="for in 和 for of 的区别"></a>for in 和 for of 的区别</h4><p>首先，上代码!<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype.objCustom = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;; </span><br><span class="line"><span class="built_in">Array</span>.prototype.arrCustom = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> iterable = [<span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>];</span><br><span class="line">iterable.foo = <span class="string">'hello'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> iterable) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i); <span class="comment">// logs 0, 1, 2, "foo", "arrCustom", "objCustom"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> iterable) &#123;</span><br><span class="line">  <span class="keyword">if</span> (iterable.hasOwnProperty(i)) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i); <span class="comment">// logs 0, 1, 2, "foo"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> iterable) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i); <span class="comment">// logs 3, 5, 7</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面代码我们可以看到区别了</p>
<ul>
<li>‘hello’ 3 5 7 这些是属性对应的值，它<strong>不是可枚举属性</strong><br>-<code>for in</code> 在遍历对象时，若不加条件，它会一直<strong>沿着原型链</strong>遍历这个对象<strong>新加的可枚举属性</strong><br>-<code>for of</code> 在遍历对象时，它会遍历该对象定义的<strong>迭代值</strong>,<strong>而不是任何对象的属性</strong></li>
</ul>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://zhuanlan.zhihu.com/p/22652486" target="_blank" rel="noopener">知乎 JS 中的 Symbol 是什么？</a><br><a href="http://es6.ruanyifeng.com/#docs/symbol" target="_blank" rel="noopener">阮一峰 Symbol</a></p>
]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>JS里的数组</title>
    <url>/2019/02/20/JS%E9%87%8C%E7%9A%84%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h2 id="window-Array-和-window-Function"><a href="#window-Array-和-window-Function" class="headerlink" title="window.Array 和 window.Function"></a>window.Array 和 window.Function</h2><p>5 个 falsy 值: 0 NaN ‘’ undefined null<br>7 种数据结构: number string boolean null undefined symbol object(object 中函数和数组都是对象)</p>
<h3 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h3><p>js 中的 <code>Array</code> 对象是用于构造数组的全局对象，数组是类似于列表的高阶对象</p>
<ol>
<li><p>当写 var a = Array(3) 时<br>这个是执行 var a = Array(3) 后的内存图<br><img src="./img1.png" alt></p>
</li>
<li><p>var a = Array(3, 3)<br>这个时候就变成这样<br><img src="./img2.png" alt></p>
</li>
<li><p>加不加 new 对 Array 都一样<br><img src="./img3.png" alt></p>
</li>
</ol>
<h3 id="Function"><a href="#Function" class="headerlink" title="Function"></a>Function</h3><p><code>Function</code> 构造函数创建一个新的 Function 对象，在 js 中，每个函数实际上都是一个 Function 对象<br><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span><span class="params">(a, b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a+b</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 等价于如下</span></span><br><span class="line"><span class="keyword">var</span> f = <span class="keyword">new</span> <span class="function"><span class="keyword">Function</span><span class="params">(<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'return a+b'</span>)</span></span></span><br></pre></td></tr></table></figure></p>
<p>这里需要注意的是 function 是 js 的关键字，它可以用来声明一个函数，而 Function 则是 window 的一个对象</p>
<p>具名函数(有具体函数名称的函数)<br><figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">undefined</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>匿名函数(没有名称的函数)<br><figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> f</span><br><span class="line">f = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="什么是数组-amp-a-forEach"><a href="#什么是数组-amp-a-forEach" class="headerlink" title="什么是数组 &amp; a.forEach"></a>什么是数组 &amp; a.forEach</h2><p>见下图<br><img src="./img4.png" alt></p>
<p>从上图中可以看到，本质上数组还是多了一个 <code>Array.prototype</code> 来指向最后的 <code>Object.prototype</code>,这个跟 <code>obj</code> 对象而言还是不一样的</p>
<p>有两种遍历方式<br><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">var</span> <span class="string">obj</span> <span class="string">=</span> <span class="string">&#123;</span></span><br><span class="line"><span class="number">0</span><span class="string">:1,</span> <span class="number">1</span><span class="string">:2,</span> <span class="number">2</span><span class="string">:3,</span> <span class="number">3</span><span class="string">:4,</span> <span class="attr">length:</span> <span class="number">4</span><span class="string">;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="string">for</span> <span class="string">(let</span> <span class="string">i=0;</span> <span class="string">i</span> <span class="string">&lt;</span> <span class="string">obj.length;</span> <span class="string">i++)</span> <span class="string">&#123;</span></span><br><span class="line">    <span class="string">console.log(obj[i]);</span></span><br><span class="line"><span class="string">&#125;</span> <span class="string">//</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"><span class="string">for</span> <span class="string">(let</span> <span class="string">i</span> <span class="string">in</span> <span class="string">obj)</span> <span class="string">&#123;</span></span><br><span class="line">    <span class="string">console.log(obj[i]);</span></span><br><span class="line"><span class="string">&#125;</span> <span class="string">//</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span><span class="string">(4会被打印两次，因为它只会遍历</span> <span class="string">obj</span> <span class="string">的</span> <span class="string">hash)</span></span><br></pre></td></tr></table></figure></p>
<h3 id="伪数组"><a href="#伪数组" class="headerlink" title="伪数组"></a>伪数组</h3><p>原型链中没有 Array.prototype 的叫伪数组(没有 push 和 pop 方法)</p>
<h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">a = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>]</span><br><span class="line">a.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">x, y</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'value'</span>, x);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'key'</span>, y);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>函数里面接受参数<br><figure class="highlight ada"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title">f</span>(x, y) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">x+y</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>函数里面接受一个函数<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'我接收到了一个函数'</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">undefined</span></span><br><span class="line">&#125;</span><br><span class="line">f2 (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">x</span>(<span class="params">y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> y !== <span class="string">'function'</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'滚'</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'我接收到了一个函数'</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">x(<span class="number">1</span>) <span class="comment">// 滚</span></span><br><span class="line">x(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;) <span class="comment">// 我接收到了一个函数</span></span><br></pre></td></tr></table></figure></p>
<p>函数里面接受一个函数并执行<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">x</span>(<span class="params">y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> y !== <span class="string">'function'</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'滚'</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'我接收到了一个函数'</span>);</span><br><span class="line">        y()</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'并且我执行了这个函数'</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">x(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="built_in">console</span>.log(<span class="number">2</span>)&#125;)</span><br><span class="line"><span class="comment">// 我接收到了一个函数</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 并且我执行了这个函数</span></span><br></pre></td></tr></table></figure></p>
<p>函数里面接受一个函数并执行同时传参给另一个函数<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">x</span>(<span class="params">y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> y !== <span class="string">'function'</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'滚'</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'我接收到了一个函数'</span>);</span><br><span class="line">        y(<span class="number">666</span>)</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'并且我执行了这个函数'</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">x(<span class="function"><span class="keyword">function</span>(<span class="params">xxx</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(xxx);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 我接收到了一个函数</span></span><br><span class="line"><span class="comment">// 666</span></span><br><span class="line"><span class="comment">// 并且我执行了这个函数</span></span><br></pre></td></tr></table></figure></p>
<p>所以 <code>a.forEach</code> 的流程就是<br><figure class="highlight zephir"><table><tr><td class="code"><pre><span class="line"><span class="comment">// array 是一个数组，而 f 是一个函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">forEach</span><span class="params">(array, f)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="keyword">array</span>.length; i++) &#123;</span><br><span class="line">        <span class="comment">// 执行这个函数</span></span><br><span class="line">        f(<span class="keyword">array</span>[i], i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">forEach</span>([<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>], <span class="function"><span class="keyword">function</span><span class="params">(value, key)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 这个函数中就打印这句话</span></span><br><span class="line">    <span class="comment">// 第一个参数一定是 value. 第二个参数一定是 key</span></span><br><span class="line">    console.log(value, key);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>有一点需要注意的是，for 循环可以 break 和 continue；Array.prototype.forEach 不支持 break 和 continue</p>
<h2 id="forEach-和-sort-的原理"><a href="#forEach-和-sort-的原理" class="headerlink" title="forEach 和 sort 的原理"></a>forEach 和 sort 的原理</h2><h3 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h3><p><code>a.forEach(function(){})</code> 之所以这里不传 a 的参数，是因为这里已经执行到了 <code>a.forEach.call(a, function(){})</code><br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;<span class="number">0</span>: <span class="string">'a'</span>, <span class="number">1</span>: <span class="string">'b'</span>, <span class="attr">length</span>:<span class="number">2</span>&#125;;</span><br><span class="line"><span class="comment">// 这里调用到了 this</span></span><br><span class="line">obj.forEach = <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.length; i++) &#123;</span><br><span class="line">        x(<span class="keyword">this</span>[i], i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">obj.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">value, key</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value, key);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>在传三个参数时,比如如下<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">a = [<span class="string">'fff'</span>, <span class="string">'jjj'</span>, <span class="string">'kkk'</span>];</span><br><span class="line">a.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">b, c, d</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(b, c, d);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果是</span></span><br><span class="line">fff <span class="number">0</span></span><br><span class="line"><span class="built_in">Array</span>(<span class="number">3</span>) [ <span class="string">"fff"</span>, <span class="string">"jjj"</span>, <span class="string">"kkk"</span> ]</span><br><span class="line">jjj <span class="number">1</span></span><br><span class="line"><span class="built_in">Array</span>(<span class="number">3</span>) [ <span class="string">"fff"</span>, <span class="string">"jjj"</span>, <span class="string">"kkk"</span> ]</span><br><span class="line">kkk <span class="number">2</span></span><br><span class="line"><span class="built_in">Array</span>(<span class="number">3</span>) [ <span class="string">"fff"</span>, <span class="string">"jjj"</span>, <span class="string">"kkk"</span> ]</span><br></pre></td></tr></table></figure></p>
<h3 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h3><p>sort 就是排序 api<br><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">a</span> <span class="string">=</span> <span class="string">[5,</span> <span class="number">6</span><span class="string">,</span> <span class="number">3</span><span class="string">,</span> <span class="number">4</span><span class="string">,</span> <span class="number">1</span><span class="string">,</span> <span class="number">2</span><span class="string">]</span></span><br><span class="line"><span class="string">a.sort()</span> <span class="string">//</span> <span class="number">1</span><span class="string">,</span> <span class="number">2</span><span class="string">,</span> <span class="number">3</span><span class="string">,</span> <span class="number">4</span><span class="string">,</span> <span class="number">5</span><span class="string">,</span> <span class="number">6</span></span><br><span class="line"><span class="string">a.sort(function(x,</span> <span class="string">y)</span> <span class="string">&#123;return</span> <span class="string">x-y&#125;);</span> <span class="string">//</span> <span class="number">1</span><span class="string">,</span> <span class="number">2</span><span class="string">,</span> <span class="number">3</span><span class="string">,</span> <span class="number">4</span><span class="string">,</span> <span class="number">5</span><span class="string">,</span> <span class="number">6</span></span><br><span class="line"><span class="string">a.sort(function(x,</span> <span class="string">y)</span> <span class="string">&#123;return</span> <span class="string">y-x&#125;);</span> <span class="string">//</span> <span class="number">6</span><span class="string">,</span> <span class="number">5</span><span class="string">,</span> <span class="number">4</span><span class="string">,</span> <span class="number">3</span><span class="string">,</span> <span class="number">2</span><span class="string">,</span> <span class="number">1</span></span><br><span class="line"><span class="string">a</span> <span class="string">=</span> <span class="string">['a',</span> <span class="string">'b'</span><span class="string">,</span> <span class="string">'c'</span><span class="string">]</span></span><br><span class="line"><span class="string">hash</span> <span class="string">=</span> <span class="string">&#123;</span></span><br><span class="line">    <span class="string">'a'</span> <span class="string">:</span> <span class="number">2</span><span class="string">,</span></span><br><span class="line">    <span class="string">'b'</span> <span class="string">:</span> <span class="number">1</span><span class="string">,</span></span><br><span class="line">    <span class="string">'c'</span> <span class="string">:</span> <span class="number">3</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">a.sort(function(x,</span> <span class="string">y)</span> <span class="string">&#123;return</span> <span class="string">hash[x]</span> <span class="bullet">-</span> <span class="string">hash[y]&#125;)</span></span><br></pre></td></tr></table></figure></p>
<h3 id="join"><a href="#join" class="headerlink" title="join"></a>join</h3><p>在字符串中加入一段字符串<br><figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line"><span class="keyword">a</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">a</span>.join(<span class="string">'hello'</span>)<span class="comment"> // '1hello2hello3'</span></span><br><span class="line"><span class="keyword">a</span>.join(<span class="string">','</span>)<span class="comment"> // '1, 2, 3'</span></span><br><span class="line"><span class="keyword">a</span> + <span class="string">''</span><span class="comment"> // '1, 2, 3' 这个只是巧合</span></span><br></pre></td></tr></table></figure></p>
<h3 id="concat"><a href="#concat" class="headerlink" title="concat"></a>concat</h3><p>用来连接字符串<br><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">var</span> <span class="selector-tag">a</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="selector-tag">var</span> <span class="selector-tag">b</span> = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">var</span> c = <span class="selector-tag">a</span>.concat(b) <span class="comment">// [1, 2, 3, 4, 5, 6]</span></span><br><span class="line"><span class="selector-tag">var</span> <span class="selector-tag">b</span> = <span class="selector-tag">a</span>.concat([]) <span class="comment">// b =&gt; [1, 2, 3] 一般用来复制这个数组</span></span><br></pre></td></tr></table></figure></p>
<h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><p>map 就是把函数返回的值组成一个新数组，并返回<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="comment">// 与 forEach 差不多，只不过有个返回值</span></span><br><span class="line"><span class="comment">// a.forEach(function()&#123;&#125;) // undefined</span></span><br><span class="line">a.map(<span class="function"><span class="keyword">function</span>(<span class="params">value, key</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value * <span class="number">2</span>;</span><br><span class="line">&#125;) <span class="comment">// [2, 4, 6]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 上面的等价于箭头函数表示</span></span><br><span class="line">a.map(<span class="function"><span class="params">value</span> =&gt;</span> value * <span class="number">2</span>) <span class="comment">// [2, 4, 6]</span></span><br></pre></td></tr></table></figure></p>
<h3 id="fiter"><a href="#fiter" class="headerlink" title="fiter"></a>fiter</h3><figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line"><span class="keyword">a</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line"><span class="keyword">a</span>.<span class="built_in">filter</span>(<span class="function"><span class="keyword">function</span>(<span class="title">value</span>, <span class="title">key</span>) &#123;</span></span><br><span class="line">    <span class="literal">return</span> <span class="built_in">value</span> &gt;= <span class="number">5</span></span><br><span class="line">&#125;)<span class="comment"> // 5, 6, 7, 8, 9</span></span><br><span class="line"></span><br><span class="line">// 链式操作</span><br><span class="line"><span class="keyword">a</span>.<span class="built_in">filter</span>(<span class="function"><span class="keyword">function</span>(<span class="title">value</span>, <span class="title">key</span>) &#123;</span></span><br><span class="line">    <span class="literal">return</span> <span class="built_in">value</span> &gt;= <span class="number">5</span></span><br><span class="line">&#125;).map(<span class="function"><span class="keyword">function</span>(<span class="title">value</span>) &#123;</span></span><br><span class="line">    <span class="literal">return</span> <span class="built_in">value</span> * <span class="built_in">value</span></span><br><span class="line">&#125;)<span class="comment"> // 25, 36, 49, 64, 81</span></span><br></pre></td></tr></table></figure>
<h3 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h3><p>遍历这个数组，每一次取一个结果，然后把这个结果放在下一项的身上<br><figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">var <span class="keyword">a</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">a</span>.reduce(<span class="function"><span class="keyword">function</span>(<span class="title">sum</span>, <span class="title">n</span>)&#123;</span></span><br><span class="line">    <span class="literal">return</span> <span class="built_in">sum</span> + n</span><br><span class="line">&#125;, <span class="number">0</span>)<span class="comment"> // 最后一个参数表示初始值</span></span><br><span class="line"></span><br><span class="line">// 箭头函数表示</span><br><span class="line"><span class="keyword">a</span>.reduce((<span class="built_in">sum</span>, n) =&gt; <span class="built_in">sum</span> + n, <span class="number">0</span>)</span><br></pre></td></tr></table></figure></p>
<h3 id="最后一个例子"><a href="#最后一个例子" class="headerlink" title="最后一个例子"></a>最后一个例子</h3><p>map 可以用 reduce 表示<br><figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line"><span class="keyword">a</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">a</span>.reduce(<span class="function"><span class="keyword">function</span>(<span class="title">arr</span>, <span class="title">n</span>) &#123;</span></span><br><span class="line">    arr.push(n * <span class="number">2</span>)</span><br><span class="line">    <span class="literal">return</span> arr</span><br><span class="line">&#125;, [])</span><br></pre></td></tr></table></figure></p>
<p>filter 可以用 reduce 表示<br><figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>]</span><br><span class="line">a.reduce(function(arr, n)&#123;</span><br><span class="line">    if (n % <span class="number">2</span> === <span class="number">0</span>) &#123;</span><br><span class="line">        arr.push(n)</span><br><span class="line">    &#125;</span><br><span class="line">    return arr</span><br><span class="line">&#125;, [])</span><br></pre></td></tr></table></figure></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="创造数组"><a href="#创造数组" class="headerlink" title="创造数组"></a>创造数组</h3><ul>
<li>Array()</li>
</ul>
<h3 id="其他类型转换成数组"><a href="#其他类型转换成数组" class="headerlink" title="其他类型转换成数组"></a>其他类型转换成数组</h3><ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/from" target="_blank" rel="noopener">Array.from()</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/of" target="_blank" rel="noopener">Array.of()</a></li>
</ul>
<h3 id="增"><a href="#增" class="headerlink" title="增"></a>增</h3><ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/concat" target="_blank" rel="noopener">Array.prototype.concat()</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/push" target="_blank" rel="noopener">Array.prototype.push()</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/unshift" target="_blank" rel="noopener">Array.prototype.unshift()</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/splice" target="_blank" rel="noopener">Array.prototype.splice()</a></li>
</ul>
<h3 id="删"><a href="#删" class="headerlink" title="删"></a>删</h3><ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/pop" target="_blank" rel="noopener">Array.prototype.pop()</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/pop" target="_blank" rel="noopener">Array.prototype.shift()</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/splice" target="_blank" rel="noopener">Array.prototype.splice()</a></li>
</ul>
<h3 id="改"><a href="#改" class="headerlink" title="改"></a>改</h3><ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin" target="_blank" rel="noopener">Array.prototype.copyWithin()</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/fill" target="_blank" rel="noopener">Array.prototype.fill()</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/pop" target="_blank" rel="noopener">Array.prototype.pop()</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/push" target="_blank" rel="noopener">Array.prototype.push()</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/pop" target="_blank" rel="noopener">Array.prototype.shift()</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/unshift" target="_blank" rel="noopener">Array.prototype.unshift()</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reverse" target="_blank" rel="noopener">Array.prototype.reverse()</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort" target="_blank" rel="noopener">Array.prototype.sort()</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/splice" target="_blank" rel="noopener">Array.prototype.splice()</a></li>
</ul>
<h3 id="查"><a href="#查" class="headerlink" title="查"></a>查</h3><ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/every" target="_blank" rel="noopener">Array.prototype.every()</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/some" target="_blank" rel="noopener">Array.prototype.some()</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter" target="_blank" rel="noopener">Array.prototype.filter()</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find" target="_blank" rel="noopener">Array.prototype.find()</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/findIndex" target="_blank" rel="noopener">Array.prototype.findIndex()</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/includes" target="_blank" rel="noopener">Array.prototype.includes()</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf" target="_blank" rel="noopener">Array.prototype.indexOf()</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/lastIndexOf" target="_blank" rel="noopener">Array.prototype.lastIndexOf()</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/some" target="_blank" rel="noopener">Array.prototype.some()</a></li>
</ul>
<h3 id="拷"><a href="#拷" class="headerlink" title="拷"></a>拷</h3><ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/slice" target="_blank" rel="noopener">Array.prototype.slice()</a></li>
</ul>
<h3 id="全能"><a href="#全能" class="headerlink" title="全能"></a>全能</h3><ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map" target="_blank" rel="noopener">Array.prototype.map()</a> 基于给予的数组创造一个新数组</li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce" target="_blank" rel="noopener">Array.prototype.reduce()</a> 遍历数组，将两两元素做一些操作</li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/ReduceRight" target="_blank" rel="noopener">Array.prototype.reduceRight()</a> 同上，从右到左</li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach" target="_blank" rel="noopener">Array.prototype.forEach()</a> 对数组每一个元素做一些操作</li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/from" target="_blank" rel="noopener">Array.from()</a> 新建数组后，再使用map.</li>
</ul>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array" target="_blank" rel="noopener">Array MDN</a></p>
]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>JS里的类型</title>
    <url>/2019/02/19/JS%E9%87%8C%E7%9A%84%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p>见下图</p>
<p><img src="./img1.png" alt></p>
<h3 id="如何转为-string"><a href="#如何转为-string" class="headerlink" title="如何转为 string"></a>如何转为 string</h3><p>就是其他类型变成字符串的一些操作,虽然是用 toString 这个 API， 但是更常用的是与 ‘’ 符号相加以及全局函数 window.String()<br><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> + <span class="string">''</span>      <span class="regexp">//</span> <span class="string">"1"</span></span><br><span class="line">true + <span class="string">''</span>   <span class="regexp">//</span> <span class="string">"true"</span></span><br><span class="line">var obj = &#123;&#125; <span class="regexp">//</span> undefined</span><br><span class="line">obj + <span class="string">''</span>     <span class="regexp">//</span> <span class="string">"[object Object]"</span></span><br><span class="line"><span class="string">''</span> + null    <span class="regexp">//</span> <span class="string">"null"</span></span><br><span class="line"><span class="string">''</span> + undefined <span class="regexp">//</span> <span class="string">"undefined"</span></span><br></pre></td></tr></table></figure></p>
<p>然而有<br><figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="symbol">1 </span>+ <span class="comment">'1' // "11"</span></span><br></pre></td></tr></table></figure></p>
<p>原因是<br><figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line">(<span class="number">1</span>).toString() + '<span class="number">1</span>'</span><br></pre></td></tr></table></figure></p>
<h3 id="如何转为-Boolean"><a href="#如何转为-Boolean" class="headerlink" title="如何转为 Boolean"></a>如何转为 Boolean</h3><p>其他类型转变成 Boolean 的一些操作，就是调用 Boolean() 或者用 !!<br><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">Boolean</span><span class="params">(类型值)</span></span></span><br><span class="line">!! 类型值</span><br></pre></td></tr></table></figure></p>
<p>注意这里有 5 个 falsy 值，就是转成 Boolean 值的时候为 false 的几个值</p>
<ul>
<li>0</li>
<li>NAN</li>
<li>‘’</li>
<li>null</li>
<li>undefined</li>
</ul>
<p>google 搜索 MDN + Falsy，有真相</p>
<h3 id="如何转为-number"><a href="#如何转为-number" class="headerlink" title="如何转为 number"></a>如何转为 number</h3><p>以 ‘1’ 转换成 1 为例</p>
<ul>
<li>Number(‘1’) === 1</li>
<li>parseInt(‘1’, 10) === 1</li>
<li>parseFloat(‘1.23’) === 1.23</li>
<li>‘1’ - 0 === 1</li>
<li>+’1’ === 1(取正)</li>
</ul>
<p>paseInt 这里需要注意的<br><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">parseInt</span><span class="params">(<span class="string">'011'</span>)</span></span> <span class="comment">// 11</span></span><br><span class="line"><span class="function"><span class="title">parseInt</span><span class="params">(<span class="string">'011'</span>, <span class="number">10</span>)</span></span> <span class="comment">// 11</span></span><br><span class="line"><span class="function"><span class="title">parseInt</span><span class="params">(<span class="string">'011'</span>, <span class="number">8</span>)</span></span> <span class="comment">// 9</span></span><br></pre></td></tr></table></figure></p>
<p>后面传的参数代表的是进制数</p>
<h2 id="内存图"><a href="#内存图" class="headerlink" title="内存图"></a>内存图</h2><p>见下图</p>
<p><img src="./img2.png" alt></p>
<p>以下面这一串代码为例<br><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">var</span> <span class="selector-tag">a</span> = <span class="number">1</span></span><br><span class="line"><span class="selector-tag">var</span> <span class="selector-tag">b</span> = <span class="number">2</span></span><br><span class="line"><span class="selector-tag">var</span> o = &#123;</span><br><span class="line">    name: <span class="string">'frank'</span>,</span><br><span class="line">    age: <span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">var</span> c = true</span><br><span class="line">o<span class="selector-class">.gender</span> = <span class="string">'male'</span></span><br></pre></td></tr></table></figure></p>
<p>代码在运行之前需要做一次<strong>变量提升</strong>，为什么需要进行变量提升，因为考虑到对象后面会自己加属性值，而按照图中 stack 栈内存来存储数据的方式，整个栈数据需要进行上移或下移的操作，这样会极大的影响性能，为了解决这个 bug，引入了 heap 堆内存，栈内存中只存放对象的地址，这样只需要取到其地址对应的值就可以了</p>
<h2 id="有关-JS-内存的一些的问题"><a href="#有关-JS-内存的一些的问题" class="headerlink" title="有关 JS 内存的一些的问题"></a>有关 JS 内存的一些的问题</h2><p>见如下代码<br><figure class="highlight delphi"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line"><span class="keyword">var</span> b = a</span><br><span class="line">b = <span class="number">2</span></span><br><span class="line">a = ? <span class="comment">// a = 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="comment">&#123;name: 'a'&#125;</span></span><br><span class="line">b = a</span><br><span class="line">b = <span class="comment">&#123;name: 'b'&#125;</span> <span class="comment">// 这里声明了一个匿名对象,这个匿名对象自己也有个地址</span></span><br><span class="line">a.<span class="keyword">name</span> = ? <span class="comment">// a.name = 'a'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="comment">&#123;name: 'a'&#125;</span></span><br><span class="line"><span class="keyword">var</span> b = a</span><br><span class="line">b.<span class="keyword">name</span> = <span class="string">'b'</span></span><br><span class="line">a.<span class="keyword">name</span> = ? <span class="comment">// a.name = 'b'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="comment">&#123;name: 'a'&#125;</span></span><br><span class="line"><span class="keyword">var</span> b = a</span><br><span class="line">b = null</span><br><span class="line">a = ? <span class="comment">// a = &#123;name: 'a'&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>另起一行<br><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">var</span> <span class="selector-tag">a</span> = &#123;&#125;</span><br><span class="line"><span class="selector-tag">a</span><span class="selector-class">.self</span> = a</span><br><span class="line"><span class="selector-tag">a</span><span class="selector-class">.self</span><span class="selector-class">.self</span><span class="selector-class">.self</span> <span class="comment">// 这里被循环指向了</span></span><br></pre></td></tr></table></figure></p>
<p>关系见下图<br><img src="./img3.png" alt></p>
<h2 id="相关面试题"><a href="#相关面试题" class="headerlink" title="相关面试题"></a>相关面试题</h2><p>引用类型<br><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">var</span> <span class="selector-tag">a</span> = &#123;n: <span class="number">1</span>&#125;</span><br><span class="line"><span class="selector-tag">var</span> <span class="selector-tag">b</span> = a</span><br><span class="line"><span class="selector-tag">a</span><span class="selector-class">.x</span> = <span class="selector-tag">a</span> = &#123;n: <span class="number">2</span>&#125; <span class="comment">// 这里最左边的 a 地址没变，中间 a 地址变了</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">alert</span><span class="params">(a.x)</span></span> <span class="comment">// --&gt; undefined // 这里是求变了地址的 a.x</span></span><br><span class="line"><span class="function"><span class="title">alert</span><span class="params">(b.x)</span></span> <span class="comment">// ---&gt; [object Object]</span></span><br></pre></td></tr></table></figure></p>
<p>为什么会出现上面的情况?原因见内存图<br><img src="./img4.png" alt></p>
<h2 id="GC-垃圾回收"><a href="#GC-垃圾回收" class="headerlink" title="GC 垃圾回收"></a>GC 垃圾回收</h2><p>如果一个对象没有被引用，它就是垃圾，它将会被回收。如下所见一个典型的垃圾回收代码<br><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">var</span> <span class="selector-tag">a</span> = &#123;name: <span class="string">'a'</span>&#125;</span><br><span class="line"><span class="selector-tag">var</span> <span class="selector-tag">b</span> = &#123;name: <span class="string">'b'</span>&#125;</span><br><span class="line"><span class="selector-tag">a</span> = <span class="selector-tag">b</span> <span class="comment">// 这样原来 a 指向的那片内存就成了垃圾</span></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">var</span> fn = function() &#123;&#125;</span><br><span class="line">document<span class="selector-class">.body</span><span class="selector-class">.onclick</span> = fn</span><br><span class="line">fn = null <span class="comment">// fn 不是垃圾回收对象</span></span><br></pre></td></tr></table></figure></p>
<p>见下图<br><img src="./img5.png" alt></p>
<p>那假如把页面关掉，那么 fn 就是垃圾，因为 document 就没有了，其他那些指向都没了。但是 IE6 无法在页面关闭的时候把那些 onclick 标记为垃圾，从而导致内存泄露</p>
<h2 id="所谓浅拷贝和深拷贝"><a href="#所谓浅拷贝和深拷贝" class="headerlink" title="所谓浅拷贝和深拷贝"></a>所谓浅拷贝和深拷贝</h2><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">var</span> <span class="selector-tag">a</span> = <span class="number">1</span></span><br><span class="line"><span class="selector-tag">var</span> <span class="selector-tag">b</span> = a</span><br><span class="line"><span class="selector-tag">b</span> = <span class="number">2</span></span><br><span class="line"><span class="selector-tag">a</span> = <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>b 变化不影响 a，那么就是深拷贝,一般基本类型的赋值都是深拷贝<br><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">var</span> <span class="selector-tag">a</span> = &#123;name:<span class="string">'a'</span>&#125;</span><br><span class="line"><span class="selector-tag">var</span> <span class="selector-tag">b</span> = a</span><br><span class="line"><span class="selector-tag">b</span><span class="selector-class">.name</span> = <span class="string">'b'</span></span><br><span class="line"><span class="selector-tag">a</span>.name</span><br></pre></td></tr></table></figure></p>
<p>见下图<br><img src="./img6.png" alt></p>
<p>以上代码其实就是浅拷贝了</p>
]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>JS里的类型转换</title>
    <url>/2019/02/20/JS%E9%87%8C%E7%9A%84%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</url>
    <content><![CDATA[<h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p>js 相关的类型转换见下图</p>
<p><img src="./img1.png" alt></p>
<p>如图所示，与其 symbol 类型以及其之后的转换并不常见，所以本文优先考虑的是前面几种类型的转换</p>
<h3 id="如何转为-string"><a href="#如何转为-string" class="headerlink" title="如何转为 string"></a>如何转为 string</h3><p>其实就是其他类型变成字符串的一些操作<br>虽然是用 toString 方法,但是更常用的是与 ‘’(空字符串) 相加<br>以及全局函数 window.String()<br><figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> + <span class="string">''</span></span><br><span class="line"><span class="string">"1"</span></span><br><span class="line"><span class="literal">true</span> + <span class="string">''</span></span><br><span class="line"><span class="string">"true"</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;&#125;</span><br><span class="line"><span class="literal">undefined</span></span><br><span class="line">obj + <span class="string">''</span></span><br><span class="line"><span class="string">"[object Object]"</span></span><br><span class="line"><span class="string">''</span> + <span class="literal">null</span></span><br><span class="line"><span class="string">"null"</span></span><br><span class="line"><span class="string">''</span> + <span class="literal">undefined</span></span><br><span class="line"><span class="string">"undefined"</span></span><br></pre></td></tr></table></figure></p>
<p>然而有下面的情况<br><figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="symbol">1 </span>+ <span class="comment">'1'</span></span><br><span class="line"><span class="string">"11"</span></span><br></pre></td></tr></table></figure></p>
<p>原因是<br><figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line">(<span class="number">1</span>).toString() + '<span class="number">1</span>'</span><br></pre></td></tr></table></figure></p>
<h3 id="如何转为-Boolean"><a href="#如何转为-Boolean" class="headerlink" title="如何转为 Boolean"></a>如何转为 Boolean</h3><p>其他类型转变成 Boolean 的一些操作，就是调用 <code>Boolean()</code> 或者用 <code>!!</code><br><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">Boolean</span><span class="params">(类型值)</span></span></span><br><span class="line">!! 类型值</span><br></pre></td></tr></table></figure></p>
<p>这里有 5 个 falsy 值，就是转成 Boolean 值的时候为 false 的几个值</p>
<ul>
<li>0</li>
<li>NaN</li>
<li>‘’ (空字符串)</li>
<li>null</li>
<li>undefined</li>
</ul>
<p>同样可以搜索 <code>MDN + Falsy</code></p>
<h3 id="如何转为-number"><a href="#如何转为-number" class="headerlink" title="如何转为 number"></a>如何转为 number</h3><p>像这样 ‘1’ —&gt; 1</p>
<ul>
<li>Number(‘1’) === 1</li>
<li>parseInt(‘1’, 10) === 1</li>
<li>parseFloat(‘1.23’) === 1.23</li>
<li>‘1’ - 0 === 1</li>
<li>+’1’ === 1(取正)</li>
</ul>
<p>parseInt 语法如下<br><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="built_in">string</span>, radix);</span><br></pre></td></tr></table></figure></p>
<p>这里需要注意的是，<code>string</code> 表式要被解析的值，而 <code>radix</code> 需要转换的基数，这个基数默认是 10,也就是 10 进制<br><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">parseInt</span><span class="params">(<span class="string">'011'</span>)</span></span></span><br><span class="line"><span class="number">11</span></span><br><span class="line"><span class="function"><span class="title">parseInt</span><span class="params">(<span class="string">'011'</span>, <span class="number">10</span>)</span></span></span><br><span class="line"><span class="number">11</span></span><br><span class="line"><span class="function"><span class="title">parseInt</span><span class="params">(<span class="string">'011'</span>, <span class="number">8</span>)</span></span></span><br><span class="line"><span class="number">9</span></span><br></pre></td></tr></table></figure></p>
<h2 id="内存图"><a href="#内存图" class="headerlink" title="内存图"></a>内存图</h2><p>如下图所示<br><img src="./img2.png" alt><br>stack 栈内存负责存储声明的变量地址，而 heap 堆内存负责存放相应地址对应的内容,即 hash</p>
<p>以下面这一串代码为例<br><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">var</span> <span class="selector-tag">a</span> = <span class="number">1</span></span><br><span class="line"><span class="selector-tag">var</span> <span class="selector-tag">b</span> = <span class="number">2</span></span><br><span class="line"><span class="selector-tag">var</span> o = &#123;</span><br><span class="line">    name: <span class="string">'frank'</span>,</span><br><span class="line">    age: <span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">var</span> c = true</span><br><span class="line">o<span class="selector-class">.gender</span> = <span class="string">'male'</span></span><br></pre></td></tr></table></figure></p>
<p>代码在运行之前需要做一次<strong>变量提升</strong>，为什么需要进行变量提升，因为考虑到对象后面会自己加属性值，而按照图中 stack 栈内存来存储数据的方式，整个栈数据需要进行上移或下移的操作，这样会极大的影响性能，为了解决这个 bug，引入了 heap 堆内存，栈内存中只存放对象的地址，这样只需要取到其地址对应的值就可以了</p>
<p>有关 JS 内存的一些的问题<br><figure class="highlight delphi"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line"><span class="keyword">var</span> b = a</span><br><span class="line">b = <span class="number">2</span></span><br><span class="line">a = ? <span class="comment">// a = 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="comment">&#123;name: 'a'&#125;</span></span><br><span class="line">b = a</span><br><span class="line">b = <span class="comment">&#123;name: 'b'&#125;</span> <span class="comment">// 这里声明了一个匿名对象,这个匿名对象自己也有个地址</span></span><br><span class="line">a.<span class="keyword">name</span> = ? <span class="comment">// a.name = 'a'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="comment">&#123;name: 'a'&#125;</span></span><br><span class="line"><span class="keyword">var</span> b = a</span><br><span class="line">b.<span class="keyword">name</span> = <span class="string">'b'</span></span><br><span class="line">a.<span class="keyword">name</span> = ? <span class="comment">// a.name = 'b'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="comment">&#123;name: 'a'&#125;</span></span><br><span class="line"><span class="keyword">var</span> b = a</span><br><span class="line">b = null</span><br><span class="line">a = ? <span class="comment">// a = &#123;name: 'a'&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>还有个循环指向的问题<br><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">var</span> <span class="selector-tag">a</span> = &#123;&#125;</span><br><span class="line"><span class="selector-tag">a</span><span class="selector-class">.self</span> = a</span><br><span class="line"><span class="selector-tag">a</span><span class="selector-class">.self</span><span class="selector-class">.self</span><span class="selector-class">.self</span> <span class="comment">// 这里被循环指向了</span></span><br></pre></td></tr></table></figure></p>
<p>关系见下图<br><img src="./img3.png" alt></p>
<p>引用类型<br><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">var</span> <span class="selector-tag">a</span> = &#123;n: <span class="number">1</span>&#125;</span><br><span class="line"><span class="selector-tag">var</span> <span class="selector-tag">b</span> = a</span><br><span class="line"><span class="selector-tag">a</span><span class="selector-class">.x</span> = <span class="selector-tag">a</span> = &#123;n: <span class="number">2</span>&#125; <span class="comment">// 这里最左边的 a 地址没变，中间 a 地址变了</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">alert</span><span class="params">(a.x)</span></span> <span class="comment">// --&gt; undefined // 这里是求变了地址的 a.x</span></span><br><span class="line"><span class="function"><span class="title">alert</span><span class="params">(b.x)</span></span> <span class="comment">// ---&gt; [object Object]</span></span><br></pre></td></tr></table></figure></p>
<p>原因见内存图<br><img src="./img4.png" alt></p>
<p>GC 垃圾回收问题<br>如果一个对象没有被引用，它就是垃圾，它将会被回收</p>
<p>一个典型的垃圾回收<br><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">var</span> <span class="selector-tag">a</span> = &#123;name: <span class="string">'a'</span>&#125;</span><br><span class="line"><span class="selector-tag">var</span> <span class="selector-tag">b</span> = &#123;name: <span class="string">'b'</span>&#125;</span><br><span class="line"><span class="selector-tag">a</span> = <span class="selector-tag">b</span> <span class="comment">// 这样原来 a 指向的那片内存就成了垃圾</span></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">var</span> fn = function() &#123;&#125;</span><br><span class="line">document<span class="selector-class">.body</span><span class="selector-class">.onclick</span> = fn</span><br><span class="line">fn = null <span class="comment">// fn 不是垃圾回收对象</span></span><br></pre></td></tr></table></figure></p>
<p>见下图<br><img src="./img5.png" alt></p>
<p>那假如把页面关掉，那么 fn 就是垃圾，因为 document 就没有了，其他那些指向都没了<br>但是 IE6 无法在页面关闭的时候把那些 onclick 标记为垃圾，从而导致内存泄露</p>
<h2 id="浅拷贝和深拷贝"><a href="#浅拷贝和深拷贝" class="headerlink" title="浅拷贝和深拷贝"></a>浅拷贝和深拷贝</h2><figure class="highlight nix"><table><tr><td class="code"><pre><span class="line">var <span class="attr">a</span> = <span class="number">1</span></span><br><span class="line">var <span class="attr">b</span> = a</span><br><span class="line"><span class="attr">b</span> = <span class="number">2</span></span><br><span class="line"><span class="attr">a</span> = <span class="number">1</span></span><br><span class="line"><span class="attr">a</span> === b // <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<p>对 b 的操作不影响 a，那么就是深拷贝</p>
<p><strong>对于简单类型的数据来说都是深拷贝</strong><br><strong>对于复杂类型的数据(对象)来说，才区分浅拷贝和深拷贝</strong><br><figure class="highlight delphi"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="comment">&#123;name:'a'&#125;</span></span><br><span class="line"><span class="keyword">var</span> b = a</span><br><span class="line">b.<span class="keyword">name</span> = <span class="string">'b'</span></span><br><span class="line">a.<span class="keyword">name</span> === <span class="string">'a'</span> <span class="comment">// false</span></span><br></pre></td></tr></table></figure></p>
<p>以上是浅拷贝，因为对 b 的操作影响到 a 了<br><figure class="highlight delphi"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="comment">&#123;name:'a'&#125;</span></span><br><span class="line"><span class="keyword">var</span> b = deepclone(a) <span class="comment">// 这里是深拷贝的相关函数，对 heap 堆内存的完全拷贝</span></span><br><span class="line">b.<span class="keyword">name</span> = <span class="string">'b'</span></span><br><span class="line">a.<span class="keyword">name</span> === <span class="string">'a'</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p>
<p>以上是深拷贝，因为对 b 的操作没有影响到 a</p>
<p>见下图<br><img src="./img6.png" alt></p>
]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>JS里的面向对象</title>
    <url>/2019/02/20/JS%E9%87%8C%E7%9A%84%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<blockquote>
<p>面向对象，即 OO(Object Oriented)</p>
</blockquote>
<h2 id="理解面向对象"><a href="#理解面向对象" class="headerlink" title="理解面向对象"></a>理解面向对象</h2><p>面向对象有如下的概念</p>
<ul>
<li>Class 类<br>  定义对象的特征，它是对象的属性和方法的模板定义</li>
<li>Object 对象<br>  类的一个实例</li>
<li>Property 属性<br>  对象的特征，比如颜色</li>
<li>Method 方法<br>  对象的能力，比如行走</li>
<li>Constructor 构造函数<br>  函数初始化瞬间被调用，通常它的名字与包含它的类名相同</li>
<li>Inheritance 继承<br>  一个类可以继承另一个类的特征</li>
<li>Encapsulation 封装<br>  一种把数据和方法绑定在一起使用的方式</li>
<li>Abstraction 抽象<br>  结合复杂的继承、方法、属性的对象能够模拟现实的模型</li>
<li>Polymophsim 多态<br>  ‘许多形态’, 表示不同的类可以定义相同的方法和属性</li>
</ul>
<h2 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h2><p>如下代码<br><figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">var MYAPP</span> = MYAPP || &#123;&#125;;</span><br></pre></td></tr></table></figure></p>
<p>这段代码是什么意思，为何一个变量的定义要用它自身来与上一个对象？这里就牵扯到 JS 的 5 个 ‘falsy’ 值，即</p>
<ul>
<li>NaN、0</li>
<li>‘’(空字符串)</li>
<li>false</li>
<li>null</li>
<li>undefined</li>
</ul>
<p>在 JS 中，<code>&amp;&amp;</code> 与 <code>||</code> 符号是这样使用的</p>
<ul>
<li><p>对于 <code>&amp;&amp;</code> 来说，它会从左往右一直寻找一个 <strong>‘falsy’ 值</strong>，找到之后直接返回这个 ‘falsy’ 值，剩下的就不管它</p>
  <figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="symbol">1 </span>&amp;&amp; <span class="number">0</span> // <span class="number">0</span></span><br><span class="line"><span class="symbol">1 </span>&amp;&amp; <span class="number">0</span> &amp;&amp; <span class="number">2</span> &amp;&amp; <span class="number">3</span> // <span class="number">0</span></span><br><span class="line"><span class="symbol">1 </span>&amp;&amp; console.<span class="keyword">log</span>(<span class="number">3</span>) // undefined, 因为 console.<span class="keyword">log</span>() 的返回值就是 undefined</span><br></pre></td></tr></table></figure>
</li>
<li><p>对于 <code>||</code> 来说，它会从左往右一直寻找一个<strong>非 ‘falsy’ 值</strong>，找到之后直接返回这个 ‘falsy’ 值，剩下的就不管它</p>
  <figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="symbol">0 </span>|| <span class="number">1</span> // <span class="number">1</span></span><br><span class="line"><span class="symbol">1 </span>|| <span class="number">0</span> || <span class="number">2</span> || <span class="number">3</span> // <span class="number">1</span></span><br><span class="line"><span class="symbol">0 </span>|| undefined || null || <span class="number">1</span> // <span class="number">1</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>这其实很好理解，对于 <code>&amp;&amp;</code>，只要其中条件有一个不成立(falsy)就全不成立; 而对于 <code>||</code>,只要其中条件有一个成立(trusy)就全成立。于是浏览器就根据符号找到相应的值就返回。</p>
<p>上面说到的代码就相当于<br><figure class="highlight gauss"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (MYAPP) &#123;</span><br><span class="line">    ; <span class="comment">// 不做</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    MYAPP = &#123;&#125;; <span class="comment">// 等于一个对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="再来谈下-this"><a href="#再来谈下-this" class="headerlink" title="再来谈下 this"></a>再来谈下 this</h2><p>有如下代码<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">button.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line">button.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// jQuery</span></span><br><span class="line">$(<span class="string">'ul'</span>).on(<span class="string">'click'</span>, <span class="string">'li'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>代码中的 <code>this</code> 是什么,前两个中的 <code>this</code> 在 MDN 的文档中表示是 “触发事件的元素”,亦即 <code>button</code>,后一个在 jQuery 的文档中表示是 “与 Selector 相匹配的元素” ,亦即 <code>li</code></p>
<p>但是，有一种特殊情况如下<br><figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">button.onclick = <span class="function"><span class="keyword">function</span><span class="params">()</span></span> &#123;</span><br><span class="line">    console.<span class="built_in">log</span>(this);</span><br><span class="line">&#125;</span><br><span class="line">button.onclick.<span class="keyword">call</span>(&#123;<span class="keyword">name</span>: <span class="string">'frank'</span>&#125;);</span><br></pre></td></tr></table></figure></p>
<p>那么这个时候 <code>this</code> 是什么，<strong>就是 call 后面传的第一个参数</strong>,亦即 <code>{name: &#39;frank&#39;}</code> 这个对象</p>
<p>还有一个例子<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">function X() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">object</span> = &#123;</span><br><span class="line">        name: <span class="string">'object'</span>,</span><br><span class="line">        options: <span class="literal">null</span>,</span><br><span class="line">        f1(x) &#123;</span><br><span class="line">            <span class="keyword">this</span>.options = x;</span><br><span class="line">            <span class="keyword">this</span>.f2();</span><br><span class="line">        &#125;,</span><br><span class="line">        f2() &#123;</span><br><span class="line">            <span class="keyword">this</span>.options.f2.call(<span class="keyword">this</span>); <span class="comment">// 这里的 this 都是指向 object</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> options = &#123;</span><br><span class="line">    name: <span class="string">'options'</span>,</span><br><span class="line">    f1() &#123;&#125;,</span><br><span class="line">    f2() &#123;</span><br><span class="line">        console.log(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> x = X();</span><br><span class="line">x.f1(options);</span><br></pre></td></tr></table></figure></p>
<p>以上最终代码打印的是 <code>object</code> 这个对象</p>
<h2 id="new-这个关键字"><a href="#new-这个关键字" class="headerlink" title="new 这个关键字"></a>new 这个关键字</h2><p>假设有一个 person 对象，它的实现是这样<br><figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">person</span><span class="params">(options)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = options.name;</span><br><span class="line">    <span class="keyword">this</span>.age = options.age;</span><br><span class="line">&#125;</span><br><span class="line">person.prototype = &#123;</span><br><span class="line">    getAge: <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.age;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们知道，我们在 new 一个对象的时候，时常会这么做<br><figure class="highlight ceylon"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> frank = <span class="keyword">new</span> person(&#123;</span><br><span class="line">    name: <span class="string">'frank'</span>,</span><br><span class="line">    age: <span class="number">18</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>然后调用它的函数<br><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">frank</span><span class="selector-class">.getAge</span>(); <span class="comment">// 18</span></span><br></pre></td></tr></table></figure></p>
<p>但是你有没有想过，如果我不用 new 和 this 呢? 我该怎么做?<br>不用 new 以及 this 的情况下，你可以这样写代码<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">person</span>(<span class="params">options</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> temp = &#123;&#125;;</span><br><span class="line">    temp.name = options.name;</span><br><span class="line">    temp.age = options.age;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这句话很重要，如果不指向就调用不到 getAge</span></span><br><span class="line">    temp.__proto__ = person.prototype;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line">person.prototype = &#123;</span><br><span class="line">    getAge: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.age;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后你才可以这样使用<br><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">let</span> <span class="string">frank</span> <span class="string">=</span> <span class="string">person(&#123;</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">'frank'</span><span class="string">,</span></span><br><span class="line">    <span class="attr">age:</span> <span class="number">18</span></span><br><span class="line"><span class="string">&#125;);</span></span><br><span class="line"><span class="string">frank.getAge();</span> <span class="string">//</span> <span class="number">18</span></span><br></pre></td></tr></table></figure></p>
<p>由以上我们可以看到，我们是不是省略了一些代码?我们省略的是哪些代码呢?<br>用了 new 之后</p>
<ol>
<li>我们不用分配一个临时对象了, JS 帮我们创建了这个临时对象</li>
<li>我们不用 return 这个临时对象了，JS 帮我们 return</li>
<li>我们不用指向自己定义的对象的原型(prototype)了, JS 帮我们自己指向</li>
<li>因为指向原型的关系，所以我们用 this 就可以访问到这个临时变量</li>
</ol>
<p>换言之， 我们终于可以不用那么费劲心思的去定义一个对象，new 都帮我们弄好了</p>
<p>以下是使用 new 的时候的一些注意点</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> object = <span class="keyword">new</span> <span class="built_in">Object</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自有属性 空</span></span><br><span class="line">object.__proto__ === <span class="built_in">Object</span>.prototype <span class="comment">//false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> array = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自有属性 0:'a' 1:'b' 2:'c',length:3</span></span><br><span class="line">array.__proto__ === <span class="built_in">Array</span>.prototype</span><br><span class="line"><span class="built_in">Array</span>.prototype.__proto__ === <span class="built_in">Object</span>.prototype</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fn = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">'x'</span>, <span class="string">'y'</span>, <span class="string">'return x+y'</span>)</span><br><span class="line"><span class="comment">// 自有属性 length:2, 不可见的函数体: 'return x+y'</span></span><br><span class="line">fn.__proto__ === <span class="built_in">Function</span>.prototype</span><br><span class="line"></span><br><span class="line"><span class="comment">// Array is a function</span></span><br><span class="line"><span class="built_in">Array</span> = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;...&#125;</span><br><span class="line"><span class="built_in">Array</span>.__proto__ === <span class="built_in">Function</span>.prototype</span><br><span class="line"></span><br><span class="line"><span class="comment">// Object is a function</span></span><br><span class="line"><span class="built_in">Object</span> = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;...&#125;</span><br><span class="line"><span class="built_in">Object</span>.__proto__ === <span class="built_in">Function</span>.prototype</span><br></pre></td></tr></table></figure>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://zhuanlan.zhihu.com/p/23987456" target="_blank" rel="noopener">JS new 到底是干嘛的</a></p>
]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>VSCode使用一般方法</title>
    <url>/2019/01/06/VSCode%E4%BD%BF%E7%94%A8%E4%B8%80%E8%88%AC%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h3 id="写-html"><a href="#写-html" class="headerlink" title="写 html"></a>写 html</h3><p>新建 html 文件，然后输入 “! + tab键”，记住勾选“自动保存”的选项<br>一般是使用 tab 键来提示输入,或者 “html:5 + tab”</p>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">输入 <span class="keyword">div</span>.red + <span class="literal">tab</span> <span class="comment"># 快捷键</span></span><br><span class="line">输入 <span class="keyword">div</span>.red*<span class="number">10</span> + <span class="literal">tab</span> <span class="comment"># 写 10 个 div 标签</span></span><br><span class="line">输入 <span class="keyword">div</span>.red&gt;<span class="keyword">a</span> + <span class="literal">tab</span>  <span class="comment"># div 中有 a 标签</span></span><br><span class="line">输入 <span class="keyword">div</span>.red*<span class="number">10</span>&gt;<span class="keyword">a</span> + <span class="literal">tab</span>  <span class="comment"># 10 个 div ,每个 div 中有 a 标签</span></span><br><span class="line"></span><br><span class="line">**其实上面的语法就是 CSS3 语法**</span><br><span class="line"></span><br><span class="line">输入 <span class="keyword">div</span>.red*<span class="number">10</span>&gt;<span class="keyword">a</span>[href=<span class="comment">#xxx] + tab</span></span><br><span class="line">输入 <span class="keyword">div</span>.red*<span class="number">10</span>&gt;<span class="keyword">a</span>[href=<span class="comment">#page$] + tab</span></span><br><span class="line">输入 <span class="keyword">div</span>.red*<span class="number">10</span>&gt;<span class="keyword">a</span>[href=<span class="comment">#page$]&#123;链接$&#125; + tab</span></span><br></pre></td></tr></table></figure>
<h3 id="装插件"><a href="#装插件" class="headerlink" title="装插件"></a>装插件</h3><ul>
<li>open in browser</li>
</ul>
<h3 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ctrl + <span class="built_in">shift</span> + p 输入命令</span><br><span class="line">ctrl + p 搜索所有的文件</span><br><span class="line">ctrl + <span class="built_in">shift</span> + f 快速搜索</span><br></pre></td></tr></table></figure>
<p>同时也可以修改键盘快捷方式</p>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>几个设置关键字可以在首选项中查找</p>
<ul>
<li>fontsize</li>
<li>sidebar(侧边栏)</li>
<li>fontfamily(字体)</li>
<li>tabsize(tab键的宽度)</li>
</ul>
<h3 id="换肤"><a href="#换肤" class="headerlink" title="换肤"></a>换肤</h3><p>请查看首选项</p>
<h3 id="git操作"><a href="#git操作" class="headerlink" title="git操作"></a>git操作</h3><p>创建 github 帐号<br>在远程创建一个 git 仓库<br>然后是常用 git 命令<br>但是之前远程服务器需要一个本地的 ssh-key</p>
<h3 id="VSCode-操作-git"><a href="#VSCode-操作-git" class="headerlink" title="VSCode 操作 git"></a>VSCode 操作 git</h3><p>注意侧边栏的功能按钮(按钮是个树形有节点的图)<br>push 之前记得自动保存</p>
<p>如何预览自己写的 html ??<br>在 github 自己创建的仓库上，选择 Setttings —&gt; 选择 Github Pages —&gt; 选择 source 中<br>的 master 然后点击 save ,然后 github 会自动给你一个地址,想要预览的话，就在浏览器中输入<br> 地址 + xxx.html</p>
<h3 id="还需要注意的地方"><a href="#还需要注意的地方" class="headerlink" title="还需要注意的地方"></a>还需要注意的地方</h3><p>  npm 安装 fanyi, 安装是可以的但是不能使用，若使用时出现 “throw er” 之类的报错，可能是这个 fanyi 工具缺少语音包造成的，解决办法可以直接在其 Github issue 上找，也可以在 bash 中执行以下命令 </p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">sudo apt-<span class="builtin-name">get</span> update</span><br><span class="line">sudo apt-<span class="builtin-name">get</span> install festival festvox-kallpc16k -y # 安装这个语音包</span><br></pre></td></tr></table></figure>
<p><strong>特别感谢 @Leo 以及 @暗淡蓝点 提供的解决方法</strong></p>
]]></content>
      <categories>
        <category>编辑器</category>
      </categories>
      <tags>
        <tag>vscode</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue全家桶之Vue-Router</title>
    <url>/2019/03/17/Vue%E5%85%A8%E5%AE%B6%E6%A1%B6%E4%B9%8BVue-Router/</url>
    <content><![CDATA[<blockquote>
<p>这是 Vue 全家桶组件系列的文章，梳理一下比较难懂的几个点，此篇文章要说的就是 Vue-Router</p>
</blockquote>
<a id="more"></a>
<h2 id="什么是路由"><a href="#什么是路由" class="headerlink" title="什么是路由"></a>什么是路由</h2><p>在 web 领域，我们可以将 <strong>路由</strong> 简单的理解为 <strong>控制器</strong>, 这个控制器主要做什么呢？它能将输入到浏览器中的 url 导向至对应页面的组件，然后浏览器就将这个组件渲染出来。这个过程就是 <strong>路由</strong> 。</p>
<h2 id="什么是-Vue-Router"><a href="#什么是-Vue-Router" class="headerlink" title="什么是 Vue-Router"></a>什么是 Vue-Router</h2><p>以下是官方说明:</p>
<blockquote>
<p>Vue Router 是 Vue.js 官方的 <strong>路由管理器</strong><br>其实跟 Vuex 的思想是很像的，它通过一个全局的 <code>router</code>,来对浏览器中的 url 进行管理，最后导向不同的页面。</p>
</blockquote>
<h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><p>主要有几大核心概念</p>
<ul>
<li>动态路由匹配</li>
<li>重定向和别名</li>
<li>路由组件传参</li>
<li>History 模式</li>
<li>导航守卫</li>
<li>路由懒加载</li>
</ul>
<h3 id="动态路由匹配"><a href="#动态路由匹配" class="headerlink" title="动态路由匹配"></a>动态路由匹配</h3><p>什么是动态路由匹配？比如我输入的 url 中有 <code>/user/foo</code> 和 <code>/user/bar</code>,我们希望在输入这两个 url 后导向的是同一个页面的同一个组件，那么我们可以这么写(类似于用个变量代替 <code>/user/</code> 后面的参数，然后就往这个变量丢参数就完事儿了，因为不写死，所以就是动态的)<br><figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// User 组件</span></span><br><span class="line"><span class="keyword">const</span> User = &#123;</span><br><span class="line">  template: <span class="string">'&lt;div&gt;User&lt;/div&gt;'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 路由</span></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    <span class="comment">// 动态路径参数 以冒号开头</span></span><br><span class="line">    &#123; path: <span class="string">'/user/:id'</span>, component: User &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>同时在 <code>path</code> 中也可以设置多段 <em>路径的参数</em>,比如我想要输入 <code>/user/foo/post/100</code>,你可以这样写<br><figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line">/user/<span class="symbol">:id/post/</span><span class="symbol">:post_id</span></span><br></pre></td></tr></table></figure></p>
<p>当然了，动态路径的参数名字是可以随便取的，我们可以在 <code>$route.params</code> 中看到这个<br><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">console.log(<span class="variable">$route</span>.params); <span class="regexp">//</span> &#123;id: <span class="string">'foo'</span>, post_id: <span class="string">'100'</span>&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意一下这里的匹配优先级，若存在多个路径匹配同一个路由的情况，如<br><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">const router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line"><span class="symbol">  routes:</span> [</span><br><span class="line">    <span class="comment">// 动态路径参数 以冒号开头</span></span><br><span class="line">    &#123; <span class="string">path:</span> <span class="string">'/xxx'</span>, <span class="string">component:</span> User1 &#125;,</span><br><span class="line">    &#123; <span class="string">path:</span> <span class="string">'/xxx'</span>, <span class="string">component:</span> User2 &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>那么会优先匹配先定义的，也就是输入 <code>/xxx</code> ,会匹配到 <code>User1</code></p>
<h3 id="重定向和别名"><a href="#重定向和别名" class="headerlink" title="重定向和别名"></a>重定向和别名</h3><p>Vue-Router 的这个功能可以实现一个逻辑，这个逻辑是什么呢？拿知乎来举例，若我是未登录的状态，那么当访问个人信息页面时，应该重定向到登录页面，如下<br><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">const router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line"><span class="symbol">  routes:</span> [</span><br><span class="line">    &#123; <span class="string">path:</span> <span class="string">'/login'</span>, <span class="string">component:</span> Login &#125;</span><br><span class="line">    &#123; <span class="string">path:</span> <span class="string">'/userInfo'</span>, <span class="string">redirect:</span> <span class="string">'/login'</span> &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>也可以是一个已经命名过的路由<br><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">const router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line"><span class="symbol">  routes:</span> [</span><br><span class="line">    &#123; <span class="string">path:</span> <span class="string">'/login'</span>, <span class="string">name:</span> <span class="string">'login'</span>, <span class="string">component:</span> Login &#125;,</span><br><span class="line">    &#123; <span class="string">path:</span> <span class="string">'/userInfo'</span>, <span class="string">redirect:</span> &#123; <span class="string">name:</span> <span class="string">'login'</span> &#125;&#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>也可以是一个方法<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">'/userInfo'</span>, <span class="attr">redirect</span>: <span class="function"><span class="params">to</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 方法接收 目标路由 作为参数</span></span><br><span class="line">      <span class="comment">// return 重定向的 字符串路径/路径对象</span></span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">          path: <span class="string">'/login'</span>,</span><br><span class="line">          name: <span class="string">'login'</span>,</span><br><span class="line">          component: Login</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;&#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>同样，你可以用 <strong>别名</strong> 的方式，什么是别名？比如在浏览器中输入的是 <code>/bar</code>,但实际上访问的是 <code>/foo</code><br><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">const router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line"><span class="symbol">  routes:</span> [</span><br><span class="line">    &#123; <span class="string">path:</span> <span class="string">'/foo'</span>, <span class="string">component:</span> Foo, <span class="string">alias:</span> <span class="string">'/bar'</span> &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<h3 id="路由组件传参"><a href="#路由组件传参" class="headerlink" title="路由组件传参"></a>路由组件传参</h3><p>什么是路由组件传参？我们可以这么理解，其实就是在浏览器输入一串 url ,然后渲染的对应组件能够接受到这串 url 中的某些参数，这就是<br><figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">      参数</span><br><span class="line">路由 <span class="comment">------&gt; 组件</span></span><br></pre></td></tr></table></figure></p>
<p>路由组件传参有 3 种方式: 布尔模式、对象模式、函数模式</p>
<ul>
<li>布尔模式</li>
</ul>
<p>其实就是通过 <code>props</code> 传参，比如我输入 <code>/user/foo</code> 这个 url,我想把 url 中 <code>foo</code> 这个参数传给组件，可以这么写<br><figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">// <span class="keyword">User</span> <span class="title">组件</span></span><br><span class="line"><span class="title">const</span> <span class="keyword">User</span> <span class="title">= &#123;</span></span><br><span class="line"><span class="title">  props</span>: ['id'],</span><br><span class="line">  template: '<span class="tag">&lt;div&gt;</span><span class="keyword">User</span> <span class="title">&#123;&#123; id</span> &#125;&#125;<span class="tag">&lt;/div&gt;</span>'</span><br><span class="line">&#125;</span><br><span class="line">// 路由</span><br><span class="line">const router = new VueRouter(&#123;</span><br><span class="line">    routes: [</span><br><span class="line">        &#123; path: '/user/:id', component: User, props: <span class="literal">true</span> &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>前提条件是要设置对应匹配路由的 <code>props</code> 为 <code>true</code><br>如果你在使用 <code>router-view</code> 时使用到了 <code>name</code> 这个属性，比如<br><figure class="highlight cos"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 渲染 user</span></span><br><span class="line">&lt;router-<span class="keyword">view</span>&gt;&lt;/router-<span class="keyword">view</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 渲染 sidebar</span></span><br><span class="line">&lt;router-<span class="keyword">view</span> name=<span class="string">"sidebar"</span>&gt;&lt;/router-<span class="keyword">view</span>&gt;</span><br></pre></td></tr></table></figure></p>
<p>你就需要为每个对应的 <code>命名视图</code> 添加 <code>props</code><br><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">const</span> <span class="string">router</span> <span class="string">=</span> <span class="string">new</span> <span class="string">VueRouter(&#123;</span></span><br><span class="line">  <span class="attr">routes:</span> <span class="string">[</span></span><br><span class="line">    <span class="string">&#123;</span></span><br><span class="line">      <span class="attr">path:</span> <span class="string">'/user/:id'</span><span class="string">,</span></span><br><span class="line">      <span class="attr">components:</span> <span class="string">&#123;</span> <span class="attr">default:</span> <span class="string">User,</span> <span class="attr">sidebar:</span> <span class="string">Sidebar</span> <span class="string">&#125;,</span></span><br><span class="line">      <span class="attr">props:</span> <span class="string">&#123;</span> <span class="attr">default:</span> <span class="literal">true</span><span class="string">,</span> <span class="attr">sidebar:</span> <span class="literal">false</span> <span class="string">&#125;</span></span><br><span class="line">    <span class="string">&#125;</span></span><br><span class="line">  <span class="string">]</span></span><br><span class="line"><span class="string">&#125;)</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li>对象模式</li>
</ul>
<p>比如组件中 <code>props</code> 是个对象<br><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">// User 组件</span></span><br><span class="line">const User = &#123;</span><br><span class="line"><span class="symbol">  props:</span> &#123;</span><br><span class="line"><span class="symbol">      name:</span> <span class="string">''</span></span><br><span class="line">  &#125;,</span><br><span class="line"><span class="symbol">  template:</span> <span class="string">'&lt;div&gt;User &#123;&#123; name &#125;&#125;&lt;/div&gt;'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 路由</span></span><br><span class="line">const router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line"><span class="symbol">    routes:</span> [</span><br><span class="line">        &#123; <span class="string">path:</span> <span class="string">'/user/new-name'</span>, <span class="string">component:</span> User, <span class="string">props:</span> &#123; <span class="string">name:</span> <span class="string">'strugglebak'</span> &#125; &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<ul>
<li>函数模式</li>
</ul>
<p>其实本质上这个函数返回的还是一个对象，比如在浏览器中输入 <code>/search?name=strugglebak</code> 表示查询，可以这么写<br><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">// User 组件</span></span><br><span class="line">const User = &#123;</span><br><span class="line"><span class="symbol">  props:</span> &#123;</span><br><span class="line"><span class="symbol">      name:</span> <span class="string">''</span></span><br><span class="line">  &#125;,</span><br><span class="line"><span class="symbol">  template:</span> <span class="string">'&lt;div&gt;User &#123;&#123; name &#125;&#125;&lt;/div&gt;'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 路由</span></span><br><span class="line">const router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line"><span class="symbol">  routes:</span> [</span><br><span class="line">    &#123; <span class="string">path:</span> <span class="string">'/search'</span>, <span class="string">component:</span> User, <span class="string">props:</span> (route) =&gt; (&#123; <span class="string">query:</span> route.query.name &#125;) &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p><code>router.query.name</code> 返回的就是 <code>strugglebak</code> 这个字符串</p>
<h3 id="History-模式"><a href="#History-模式" class="headerlink" title="History 模式"></a>History 模式</h3><p>什么是 History 模式？我们知道，网易云的 url 一般来说是这种形式<br><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">http:<span class="regexp">//mu</span>sic.<span class="number">163</span>.com<span class="regexp">/#/my</span><span class="regexp">/m/mu</span>sic<span class="regexp">/playlist?id=121597667</span></span><br></pre></td></tr></table></figure></p>
<p>在播放歌曲时，每个 url 下都有一个 <code>#</code> 符号，我们知道这个符号是 url 的 hash 部分，这个符号后面那一大串不会传递到服务端，那么它有什么用？它的作用就是 <strong>通过这个 hash 来模拟传统的后端路由器，判断哪些请求可以直接导向哪个组件，进而渲染出这个组件</strong>,这就是前端路由器的作用。但是带个 <code>#</code> 号的 url 看起来比较丑，你看哪些传统的 web 应用的 url 就没有，那么有没有一种办法来去掉这个 <code>#</code> 号呢？<br>有的，Vue-Router 提供了这个 <strong>History模式</strong>,你只需要做如下设置<br><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">const router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  <span class="keyword">mode</span>: <span class="string">'history'</span>,</span><br><span class="line">  route<span class="variable">s:</span> [...]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>url 就会和正常的 url 一样没有 <code>#</code> 号，就对 url <strong>进行了美化处理</strong><br>但是这个还需要后端配置，官方文档是这么说的</p>
<blockquote>
<p>不过这种模式要玩好，还需要后台配置支持。因为我们的应用是个单页客户端应用，如果后台没有正确的配置，当用户在浏览器直接访问 <a href="http://oursite.com/user/id" target="_blank" rel="noopener">http://oursite.com/user/id</a> 就会返回 404，这就不好看了。<br>所以呢，你要在服务端增加一个覆盖所有情况的候选资源：如果 URL 匹配不到任何静态资源，则应该返回同一个 index.html 页面，这个页面就是你 app 依赖的页面。</p>
</blockquote>
<h3 id="导航守卫"><a href="#导航守卫" class="headerlink" title="导航守卫"></a>导航守卫</h3><p>什么是导航守卫呢？这其实就相当于一个 <strong>拦截器</strong>,在路由发生变化的之中通过这层拦截来实现一些业务需求。一般来说，我们认为当你点击 a 链接进行 <strong>重定向式跳转</strong> 时路由就产生 <strong>变化</strong> 了。<br>但是这里需要注意，<strong>params 或者 query 的变化并不会触发 enter/leave 这类路由拦截器</strong>,你可以通过<br><figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> User = &#123;</span><br><span class="line">  template: <span class="string">'...'</span>,</span><br><span class="line">  watch: &#123;</span><br><span class="line">    <span class="string">'$route'</span> (to, <span class="keyword">from</span>) &#123;</span><br><span class="line">      <span class="comment">// 对路由变化作出响应...</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>或者<br><figure class="highlight autoit"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> User = &#123;</span><br><span class="line">  template: <span class="string">'...'</span>,</span><br><span class="line">  beforeRouteUpdate (<span class="keyword">to</span>, from, <span class="keyword">next</span>) &#123;</span><br><span class="line">      // 对路由变化作出响应...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样的方式来监听以上的变化</p>
<p>导航守卫有几个 api，分别是 </p>
<ul>
<li>全局的守卫 <code>beforeEach</code>,<code>beforeResolve</code>,<code>afterEach</code></li>
<li>路由独享守卫 <code>beforeEnter</code></li>
<li>组件内的守卫 <code>beforeRouterEnter</code>,<code>beforeRouterUpdate</code>,<code>beforeRouterLeave</code></li>
</ul>
<p>首先我们应该先看看一个完整的导航解析过程是怎样的<br><figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line">           (失活组件)<span class="keyword">beforeRouterLeave</span></span><br><span class="line"><span class="keyword">1. </span>导航触发 ---------------------------&gt; <span class="keyword">beforeEach</span></span><br><span class="line"><span class="keyword"> </span>          (复用组件)<span class="keyword">beforeRouterUpdate</span></span><br><span class="line"><span class="keyword">2. </span>        ---------------------------&gt; <span class="keyword">beforeEnter</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">3. </span>        ---------------------------&gt; 解析组件</span><br><span class="line">           (激活组件)<span class="keyword">beforeEnter</span></span><br><span class="line"><span class="keyword">4. </span>        ---------------------------&gt; <span class="keyword">beforeResolve</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">5. </span>导航确认 ---------------------------&gt; afterEach</span><br><span class="line"></span><br><span class="line"><span class="number">6</span>. 触发 DOM 更新</span><br></pre></td></tr></table></figure></p>
<p>基本上解析过程就代表了它们之间的区别了<br>注意 <code>beforeEnter</code> 是 <strong>可以</strong> 在路由配置上定义<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123;</span><br><span class="line">      path: <span class="string">'/foo'</span>,</span><br><span class="line">      component: Foo,</span><br><span class="line">      beforeEnter: <span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>以及组件内的路由用法如下<br><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="regexp">//</span> Foo 组件</span><br><span class="line">const foo = &#123;</span><br><span class="line">  template: `...`,</span><br><span class="line">  beforeRouteEnter (to, from, <span class="keyword">next</span>) &#123;</span><br><span class="line">    <span class="regexp">//</span> 在渲染该组件的对应路由被 confirm 前调用</span><br><span class="line">    <span class="regexp">//</span> 不！能！获取组件实例 `this`</span><br><span class="line">    <span class="regexp">//</span> 因为当守卫执行前，组件实例还没被创建</span><br><span class="line">  &#125;,</span><br><span class="line">  beforeRouteUpdate (to, from, <span class="keyword">next</span>) &#123;</span><br><span class="line">    <span class="regexp">//</span> 在当前路由改变，但是该组件被复用时调用</span><br><span class="line">    <span class="regexp">//</span> 举例来说，对于一个带有动态参数的路径 <span class="regexp">/foo/</span>:id，在 <span class="regexp">/foo/</span><span class="number">1</span> 和 <span class="regexp">/foo/</span><span class="number">2</span> 之间跳转的时候，</span><br><span class="line">    <span class="regexp">//</span> 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。</span><br><span class="line">    <span class="regexp">//</span> 可以访问组件实例 `this`</span><br><span class="line">  &#125;,</span><br><span class="line">  beforeRouteLeave (to, from, <span class="keyword">next</span>) &#123;</span><br><span class="line">    <span class="regexp">//</span> 导航离开该组件的对应路由时调用</span><br><span class="line">    <span class="regexp">//</span> 可以访问组件实例 `this`</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="路由懒加载"><a href="#路由懒加载" class="headerlink" title="路由懒加载"></a>路由懒加载</h3><p>路由的懒加载是什么呢？一般我们使用 webpack 进行打包时，js 代码会变得很大，这样会对页面加载的性能造成影响，如何提升性能呢？就是 <strong>按需加载</strong>，当路由被访问的时候才加载对应组件。具体要怎么做呢？就是分离组件代码。<br>这里需要分两步来做</p>
<ol>
<li><p>将异步组件定义为返回一个 Promise 的工厂函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Foo = <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">Promise</span>.resolve(&#123; <span class="comment">/* 组件定义对象 */</span> &#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>在 webpack 中 import</p>
<figure class="highlight coffeescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span>(<span class="string">'./Foo.vue'</span>).<span class="keyword">then</span>(<span class="function"><span class="params">(<span class="built_in">module</span>)</span>=&gt;</span> &#123;</span><br><span class="line">    <span class="regexp">//</span>...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="还有其他常用-API"><a href="#还有其他常用-API" class="headerlink" title="还有其他常用 API"></a>还有其他常用 API</h3><p>常用 API 有 <code>router-link</code>/<code>router-view</code>/<code>this.$router.push</code>/<code>this.$router.replace</code>/<code>this.$route.params</code></p>
<ul>
<li><code>router-link</code></li>
</ul>
<p>一般写在需要进行路由跳转的地方，它最终渲染的是一个 a 标签<br><figure class="highlight dust"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="comment">&lt;!-- 使用字符串 --&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">"xxx"</span>&gt;</span>xxx<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="comment">&lt;!-- 使用 v-bind 绑定变量 --&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">:to</span>=<span class="string">"xxx"</span>&gt;</span>xxx<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="comment">&lt;!-- 绑定对象 --&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">:to</span>=<span class="string">"</span></span></span><span class="template-variable">&#123;</span></span><br><span class="line"><span class="template-variable">    path: 'xxx'</span></span><br><span class="line"><span class="template-variable">&#125;</span><span class="xml">"&gt;xxx<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="comment">&lt;!-- 绑定命名的路由 --&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">:to</span>=<span class="string">"</span></span></span><span class="template-variable">&#123;</span></span><br><span class="line"><span class="template-variable">    name: 'user',</span></span><br><span class="line"><span class="template-variable">    params: &#123; userId: 123 &#125;</span></span><br><span class="line"><span class="xml">&#125;"&gt;User<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="comment">&lt;!-- 带查询参数，下面的结果为 /register?plan=private --&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">:to</span>=<span class="string">"</span></span></span><span class="template-variable">&#123;</span></span><br><span class="line"><span class="template-variable">    path: 'register',</span></span><br><span class="line"><span class="template-variable">    query: &#123; plan: 'private' &#125;</span></span><br><span class="line"><span class="xml">&#125;"&gt;Register<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span></span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>router-view</code></li>
</ul>
<p>如果 <code>router-view</code> 设置了名称，则会渲染对应的路由配置中 <code>components</code> 下的相应组件,一般我们是这么写<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 渲染一个 name 为 main 的组件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-view</span> <span class="attr">name</span>=<span class="string">"main"</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 渲染一个 name 为 slidebar 的组件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-view</span> <span class="attr">name</span>=<span class="string">"slidebar"</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>然后在路由中有如下配置<br><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">const router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">    route<span class="variable">s:</span> [</span><br><span class="line">        &#123;</span><br><span class="line">            name:<span class="string">'post'</span>,</span><br><span class="line">            path:<span class="string">'/post'</span>,</span><br><span class="line">            component<span class="variable">s:</span>&#123;</span><br><span class="line">                main: Article,</span><br><span class="line">                slidebar: SlideBar</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>this.$router.push</code></li>
</ul>
<p>一个 <code>router-link</code> 的替代品,作用就是 <strong>向 history 添加记录</strong>,可以有如下用法<br><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 字符串</span></span><br><span class="line"><span class="selector-tag">router</span><span class="selector-class">.push</span>(<span class="string">'home'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象</span></span><br><span class="line"><span class="selector-tag">router</span><span class="selector-class">.push</span>(&#123; <span class="attribute">path</span>: <span class="string">'home'</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 命名的路由</span></span><br><span class="line"><span class="selector-tag">router</span><span class="selector-class">.push</span>(&#123; <span class="attribute">name</span>: <span class="string">'user'</span>, <span class="attribute">params</span>: &#123; <span class="attribute">userId</span>: <span class="string">'123'</span> &#125;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 带查询参数，变成 /register?plan=private</span></span><br><span class="line"><span class="selector-tag">router</span><span class="selector-class">.push</span>(&#123; <span class="attribute">path</span>: <span class="string">'register'</span>, <span class="attribute">query</span>: &#123; <span class="attribute">plan</span>: <span class="string">'private'</span> &#125;&#125;)</span><br></pre></td></tr></table></figure></p>
<p>注意，若写了 <code>path</code> ,则 <code>params</code> 会被忽略掉(<code>query</code> 除外),所以你应该这么写<br><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">const userId = <span class="string">'123'</span></span><br><span class="line">router.push(&#123; name: <span class="string">'user'</span>, params: &#123; userId &#125;&#125;) <span class="regexp">//</span> -&gt; <span class="regexp">/user/</span><span class="number">123</span></span><br><span class="line">router.push(&#123; path: `<span class="regexp">/user/</span><span class="variable">$&#123;userId&#125;</span>` &#125;) <span class="regexp">//</span> -&gt; <span class="regexp">/user/</span><span class="number">123</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>this.$router.replace</code></li>
</ul>
<p>跟上面的 <code>push</code> 方法很像,不过作用是 <strong>替换掉当前的 history 记录</strong>,用法跟上面的相同</p>
<ul>
<li><code>this.$router.params</code></li>
</ul>
<p>就是一个 <code>key/value</code> 对象，之前在 <a href="#动态路由匹配">动态路由匹配</a> 中说过，它里面保存的就是路由参数</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Vue-Router 是前端 SPA 项目的利器，它可以提升用户的体验，增加开发效率。本文只是简单梳理了一下 Vue-Router 开发经常会用到的东西，其他小细节还得多去翻翻 <a href="https://router.vuejs.org/zh/" target="_blank" rel="noopener">官方文档</a></p>
]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>Vue-Router</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue全家桶之Vuex</title>
    <url>/2019/03/16/Vue%E5%85%A8%E5%AE%B6%E6%A1%B6%E4%B9%8BVuex/</url>
    <content><![CDATA[<blockquote>
<p>这是 Vue 全家桶组件系列的文章，梳理一下比较难懂的几个点，此篇文章要说的就是 Vuex</p>
</blockquote>
<a id="more"></a>
<div align="center"><br><img src="https://i.loli.net/2019/03/17/5c8e3c3102799.png" width="400"><br></div>

<h2 id="Vuex-是个啥"><a href="#Vuex-是个啥" class="headerlink" title="Vuex 是个啥"></a>Vuex 是个啥</h2><p>官方说明: Vuex 是一个专为 Vue.js 应用程序开发的 <strong>状态管理模式</strong> ,它采用 <em>集中式存储</em> 来管理应用中所有组件的状态，并以相应的规则保证 <em>状态</em> 以一种可预测的方式发生变化。</p>
<p>好了，道理我都懂，可是这段话究竟是什么意思呢？注意一个词: <strong>状态管理</strong> ,好了，什么是状态，它要怎么去管理？</p>
<p>Vuex 的官网上，有这么段简单的代码说明<br><figure class="highlight axapta"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  <span class="comment">// state</span></span><br><span class="line">  data () &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="keyword">count</span>: <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// view</span></span><br><span class="line">  template: `</span><br><span class="line">    &lt;<span class="keyword">div</span>&gt;&#123;&#123; <span class="keyword">count</span> &#125;&#125;&lt;/<span class="keyword">div</span>&gt;</span><br><span class="line">  `,</span><br><span class="line">  <span class="comment">// actions</span></span><br><span class="line">  methods: &#123;</span><br><span class="line">    increment () &#123;</span><br><span class="line">      <span class="keyword">this</span>.<span class="keyword">count</span>++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>从中我们可以看到</p>
<ul>
<li>所谓的 <code>state</code>,其实就是 <code>data</code></li>
<li>所谓的 <code>view</code>,其实就是模板 <code>template</code></li>
<li>所谓的 <code>actions</code>, 其实就是 <code>methods</code></li>
</ul>
<p>好了，我们现在想想，假如在一个页面中，多个组件需要进行通信，或者说需要一些数据的共享，我们应该怎么做？封装过组件的人都知道，组件通信一般有两种方式</p>
<ul>
<li>对于父子通信,可以使用 props 传递数据，使用 v-on 绑定自定义事件</li>
<li>对于爷孙、兄弟通信，可以使用 eventBus</li>
</ul>
<p>以上都是基于单向数据流的原则，非常之简洁。但是在 <strong>多个组件需要共享数据</strong> 这个情况下，上面两种方式就不适用了，为什么？</p>
<p>因为你会遇到如下两种情况</p>
<ul>
<li>多个 <code>view</code> 依赖同一个 <code>data</code></li>
<li>多个 <code>view</code> 要改变同一个 <code>data</code></li>
</ul>
<p>对于第一种情况来说，举个栗子，假如我 <code>data</code> 里面有个 <code>count</code>,只有当 <code>count</code> 大于 0 时，页面上的几个组件才能显示，但是假如有这么个奇葩的需求，就是有个组件它是 <strong>嵌套的</strong>,必须要最里面那个先显示，外层的才一个个跟着显示，那这里最里面的子组件就必须维护一个 <code>count</code>,然后父组件就通过 <code>$children</code> 来判断，假如这个嵌套很深，难道你不觉得这样做很 <strong>繁琐</strong> 很不优雅吗？</p>
<p>对于第二种情况来说，也举个栗子，假如有个极端的需求，子组件里面有个 <code>count</code>,有个 <code>button</code>,点击 <code>button</code> 后 <code>count</code> 会变，然后父组件上有三个这样的子组件，需求是当点击任何一个子组件的 <code>button</code>, 每个子组件的 <code>count</code> 都会变化，请问这种情况下该怎么做？要是后面需求将 <code>count</code> 改成 <code>apple</code> 怎么办？要是后面还增加了一个 <code>xxx</code> 的数据怎么办？这样就不好做代码维护吧。</p>
<h2 id="Vuex-是怎么做的"><a href="#Vuex-是怎么做的" class="headerlink" title="Vuex 是怎么做的"></a>Vuex 是怎么做的</h2><p>好了，既然大家都跟这个 <strong>状态</strong> 有关系，那么为什么不把它抽取出来做一个统一管理呢？其实在 js 中，我们可以很容易的想到用一个 <code>window</code> 来存一个全局变量，比如使用 <code>window.xxx</code>,那么其他模块就可以访问到这个 <code>xxx</code> 变量了。可是能访问到也不行啊， 要知道 <code>xxx</code> 这个变量是会变的，那么我们怎么能 <strong>动态地知道</strong> 这个变量的变化呢?很简单，就去 <strong>造个事件</strong> ,就是当 <code>xxx</code> 变量有变化的时候通知一下各个模块。</p>
<p>Vuex 做了啥？其实大致就做了上面的事</p>
<h2 id="开始认识-Vuex"><a href="#开始认识-Vuex" class="headerlink" title="开始认识 Vuex"></a>开始认识 Vuex</h2><p>一个 Vuex 中，有个叫 <code>Store</code> 的对象,这个对象中，平常用的多的就是如下几个<br><figure class="highlight autohotkey"><table><tr><td class="code"><pre><span class="line">const store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line"><span class="built_in">    state,</span></span><br><span class="line"><span class="built_in">    mutations,</span></span><br><span class="line"><span class="built_in">    getters,</span></span><br><span class="line"><span class="built_in">    actions,</span></span><br><span class="line">&#125;)<span class="comment">;</span></span><br></pre></td></tr></table></figure></p>
<h3 id="Store"><a href="#Store" class="headerlink" title="Store"></a>Store</h3><p><code>Store</code> 是个啥呢,你可以把它理解为一个数据管理中心，在这个数据管理中心里，有</p>
<ul>
<li>管理的数据，我们叫它 <code>state</code></li>
<li>管理数据的相关操作，你可以理解为 CUD 都在这里面，我们叫它 <code>mutations</code></li>
<li>获取数据的操作,你可以理解为数据库的 R 操作在这里面，我们叫他 <code>getters</code></li>
<li><strong>通知数据库要管理数据库了</strong>,这个操作我们叫它 <code>actions</code></li>
</ul>
<h3 id="state"><a href="#state" class="headerlink" title="state"></a>state</h3><p><code>state</code> 就是我们所说的数据了,注意，这里由于使用的是 <strong>单一状态树</strong>,也就是 <strong>唯一数据源</strong>, 所以每个应用就也只包含一个 <code>Store</code> 实例，所以它们才能共享这个实例里面的数据，也就是 <code>state</code>, 比如我们在 <code>state</code> 中有个 <code>count</code> 数据<br><figure class="highlight pf"><table><tr><td class="code"><pre><span class="line">const store = new Vuex.Store(&#123;</span><br><span class="line">    <span class="keyword">state</span>: &#123;</span><br><span class="line">        count: <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>在根组件中注入 <code>store</code> 实例<br><figure class="highlight coffeescript"><table><tr><td class="code"><pre><span class="line">const app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line">  <span class="regexp">//</span> 把 store 对象提供给 “store” 选项，这可以把 store 的实例注入所有的子组件</span><br><span class="line">  store,</span><br><span class="line">  components: &#123; Counter &#125;,</span><br><span class="line">  template: `</span><br><span class="line"><span class="javascript">    &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line"><span class="javascript">      &lt;counter&gt;&lt;<span class="regexp">/counter&gt;</span></span></span><br><span class="line"><span class="javascript">    &lt;<span class="regexp">/div&gt;</span></span></span><br><span class="line"><span class="javascript">  </span>`</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>然后在组件中访问它<br><figure class="highlight pf"><table><tr><td class="code"><pre><span class="line">const Counter = &#123;</span><br><span class="line">  template: `<span class="variable">&lt;div&gt;</span>&#123;&#123; count &#125;&#125;&lt;/div&gt;`,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    count () &#123;</span><br><span class="line">      return this.<span class="variable">$store</span>.<span class="keyword">state</span>.count // 通过 this.<span class="variable">$store</span>.<span class="keyword">state</span> 访问</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="getters"><a href="#getters" class="headerlink" title="getters"></a>getters</h3><p>获取数据的操作，我们同样可以不使用 <code>this.$store.state</code> 这种方式，而使用 <code>getters</code> 来代替，个人认为这是对前者的一种封装，当然 <code>getters</code> 的特点不止于此，你可以认为它是 <code>Store</code> 的计算属性，所以 <code>getter</code> 是有返回值的(废话),但是这个返回值会被 <strong>缓存</strong> 起来,只有其依赖发生改变才会重新计算<br><figure class="highlight pf"><table><tr><td class="code"><pre><span class="line">const store = new Vuex.Store(&#123;</span><br><span class="line">    <span class="keyword">state</span>: &#123;</span><br><span class="line">        count: <span class="number">0</span></span><br><span class="line">    &#125;,</span><br><span class="line">    getters: &#123;</span><br><span class="line">        doneCount: <span class="keyword">state</span> =&gt; &#123;</span><br><span class="line">            return <span class="keyword">state</span>.count;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>然后在组件中使用<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">computed: &#123;</span><br><span class="line">    count() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.$store.getters.doneCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<h3 id="mutations"><a href="#mutations" class="headerlink" title="mutations"></a>mutations</h3><p>我们要更改数据，就不要直接通过 <code>this.$store.state</code> 去修改了， Vuex 在这里提供了一个方式 <code>mutations</code>, 当我触发 <code>commit</code> 某个 <code>type</code> 事件，就会调用 <code>mutations</code> 中已经定义好的 <code>handler</code> 回调函数<br><figure class="highlight pf"><table><tr><td class="code"><pre><span class="line">const store = new Vuex.Store(&#123;</span><br><span class="line">  <span class="keyword">state</span>: &#123;</span><br><span class="line">    count: <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  mutations: &#123;</span><br><span class="line">    increment (<span class="keyword">state</span>) &#123;</span><br><span class="line">      // 变更状态</span><br><span class="line">      <span class="keyword">state</span>.count++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>在组件中你可以通过这样的方式触发<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.$store.commit(<span class="string">'increament'</span>);</span><br></pre></td></tr></table></figure></p>
<p><code>commit</code> 还可以传一个额外的参数，这个参数叫 <strong>payload 载荷</strong><br><figure class="highlight pf"><table><tr><td class="code"><pre><span class="line">mutations: &#123;</span><br><span class="line">  increment (<span class="keyword">state</span>, n) &#123;</span><br><span class="line">    <span class="keyword">state</span>.count += n</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后你可以在组件中这样触发<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.$store.commit(<span class="string">'increment'</span>, <span class="number">10</span>);</span><br></pre></td></tr></table></figure></p>
<p>你也可以采用对象的方式<br><figure class="highlight pf"><table><tr><td class="code"><pre><span class="line">mutations: &#123;</span><br><span class="line">  increment (<span class="keyword">state</span>, payload) &#123;</span><br><span class="line">    <span class="keyword">state</span>.count += payload.amount;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后你可以在组件中这样触发<br><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.$store.commit(<span class="string">'increament'</span>, &#123;<span class="string">amount:</span> <span class="number">10</span>&#125;);</span><br></pre></td></tr></table></figure></p>
<p>或者写成这样<br><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.$store.commit(&#123;<span class="string">type:</span> <span class="string">'increament'</span>, <span class="string">amount:</span> <span class="number">10</span>&#125;);</span><br></pre></td></tr></table></figure></p>
<h3 id="actions"><a href="#actions" class="headerlink" title="actions"></a>actions</h3><p>就像我之前所说，<code>actions</code> 的作用就是通知 <code>mutations</code> 该去处理数据了，至于处理数据的具体事宜，<code>actions</code> 并不关心，因为那个是 <code>mutations</code> 来负责的，接下来简单写一个 <code>actions</code><br><figure class="highlight pf"><table><tr><td class="code"><pre><span class="line">const store = new Vuex.Store(&#123;</span><br><span class="line">  <span class="keyword">state</span>: &#123;</span><br><span class="line">    count: <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  mutations: &#123;</span><br><span class="line">    increment (<span class="keyword">state</span>) &#123;</span><br><span class="line">      <span class="keyword">state</span>.count++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  actions: &#123;</span><br><span class="line">    increment (context) &#123;</span><br><span class="line">      context.commit('increment')</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>然后你就可以在组件对应的 <code>methods</code> 属性中这样写<br><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">    <span class="builtin-name">add</span>() &#123;</span><br><span class="line">        this.<span class="variable">$store</span>.dispatch(<span class="string">'increament'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意，这里 <code>actions</code> 函数中的 <code>context</code> 对象虽然能够使用 <code>commit</code> 方法，但它 <strong>并不是</strong> <code>store</code> 实例， 并且 <code>actions</code> 需要通过 <code>store.dispatch</code> 方法来触发</p>
<h2 id="其他的注意点"><a href="#其他的注意点" class="headerlink" title="其他的注意点"></a>其他的注意点</h2><ul>
<li><code>mutations</code> 里的函数必须是 <strong>同步执行</strong> 的，而 <code>actions</code> 里的函数 <strong>可以执行异步操作</strong></li>
</ul>
<figure class="highlight coffeescript"><table><tr><td class="code"><pre><span class="line">actions: &#123;</span><br><span class="line">  actionA (&#123; commit &#125;) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Promise(<span class="function"><span class="params">(resolve, reject)</span> =&gt;</span> &#123;</span><br><span class="line">      setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        commit(<span class="string">'someMutation'</span>)</span><br><span class="line">        resolve()</span><br><span class="line">      &#125;, <span class="number">1000</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后你就可以这样使用<br><figure class="highlight coffeescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.$store.dispatch(<span class="string">'actionA'</span>).<span class="keyword">then</span>(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="regexp">//</span> ...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>同样这里也支持 <code>async/await</code><br><figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 假设 getData() 和 getOtherData() 返回的是 Promise</span></span><br><span class="line"></span><br><span class="line">actions: &#123;</span><br><span class="line">  <span class="function"><span class="keyword">async</span> <span class="title">actionA</span> (<span class="params">&#123; commit &#125;</span>)</span> &#123;</span><br><span class="line">    commit(<span class="string">'gotData'</span>, <span class="keyword">await</span> getData())</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="keyword">async</span> <span class="title">actionB</span> (<span class="params">&#123; dispatch, commit &#125;</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">await</span> dispatch(<span class="string">'actionA'</span>) <span class="comment">// 等待 actionA 完成</span></span><br><span class="line">    commit(<span class="string">'gotOtherData'</span>, <span class="keyword">await</span> getOtherData())</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>对于表单来说，你可以使用带有 setter 的双向绑定计算属性</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// html</span></span><br><span class="line">&lt;input v-model=<span class="string">"message"</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">computed: &#123;</span><br><span class="line">  message: &#123;</span><br><span class="line">    <span class="keyword">get</span> () &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.$store.state.obj.message</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">set</span> (value) &#123;</span><br><span class="line">      <span class="keyword">this</span>.$store.commit(<span class="string">'updateMessage'</span>, value)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>actions</code> 提交的是 <code>mutation</code>,而不是直接变更状态</li>
</ul>
<h2 id="关于辅助函数-mapXXX"><a href="#关于辅助函数-mapXXX" class="headerlink" title="关于辅助函数 mapXXX"></a>关于辅助函数 mapXXX</h2><p>个人认为， Vuex 中 map 函数的作用就是为了 <strong>简化代码</strong>,比如使用 <code>mapState</code> 函数可以帮你生成计算属性<br><figure class="highlight pf"><table><tr><td class="code"><pre><span class="line">import &#123; mapState &#125; <span class="keyword">from</span> 'vuex'</span><br><span class="line"></span><br><span class="line">export <span class="keyword">default</span> &#123;</span><br><span class="line">  // ...</span><br><span class="line">  computed: mapState(&#123;</span><br><span class="line">    // 箭头函数可使代码更简练</span><br><span class="line">    count: <span class="keyword">state</span> =&gt; <span class="keyword">state</span>.count,</span><br><span class="line"></span><br><span class="line">    // 传字符串参数 'count' 等同于 `<span class="keyword">state</span> =&gt; <span class="keyword">state</span>.count`</span><br><span class="line">    countAlias: 'count',</span><br><span class="line"></span><br><span class="line">    // 为了能够使用 `this` 获取局部状态，必须使用常规函数</span><br><span class="line">    countPlusLocalState (<span class="keyword">state</span>) &#123;</span><br><span class="line">      return <span class="keyword">state</span>.count + this.localCount</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>也可以写成<br><figure class="highlight pf"><table><tr><td class="code"><pre><span class="line">computed: mapState([</span><br><span class="line">  // 映射 this.count 为 store.<span class="keyword">state</span>.count</span><br><span class="line">  'count',</span><br><span class="line">])</span><br></pre></td></tr></table></figure></p>
<p>同时若想将属性混入(mixin) <code>computed</code>,你可以使用 <code>...</code> 对象展开运算符<br><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="attribute">computed</span>: &#123;</span><br><span class="line">  localComputed () &#123; <span class="comment">/* ... */</span> &#125;,</span><br><span class="line">  <span class="comment">// 使用对象展开运算符将此对象混入到外部对象中</span></span><br><span class="line">  ..<span class="selector-class">.mapState</span>(&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>至于其他的 <code>mapGetters</code>、<code>mapMutaions</code>、<code>mapActions</code> 用法都差不多，详细还请查询 <a href="https://vuex.vuejs.org/zh/guide/" target="_blank" rel="noopener">官方文档</a>，这里就不再过多赘述</p>
]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>Vuex</tag>
      </tags>
  </entry>
  <entry>
    <title>jQuery初探</title>
    <url>/2019/02/20/jQuery%E5%88%9D%E6%8E%A2/</url>
    <content><![CDATA[<blockquote>
<p>前情提要: 2018 年 7 月 26 日，Github 前端团队的 Mislav Marohnić 在 Twitter 发布了一则消息，表明在 GitHub 网站重构过程中放弃了 jQuery，没有再次使用其他任何框架去代替它，而是使用了原生的 JS，这标志着 jQuery 一个时代的结束</p>
</blockquote>
<p>好，那么问题来了，我们还有必要学 jQuery 嘛？<br>当然有必要(废话，要不怎么会有这篇文章???),可以领会一下 jQuery 的封装思想，以后在封装代码的时候可以学着点</p>
<h2 id="jQuery"><a href="#jQuery" class="headerlink" title="jQuery"></a>jQuery</h2><p>先看看阮一峰怎么说, <a href="http://www.ruanyifeng.com/blog/2011/07/jquery_fundamentals.html" target="_blank" rel="noopener">jQuery 设计思想</a></p>
<p>库实际上是特定种类的 api</p>
<h2 id="封装函数"><a href="#封装函数" class="headerlink" title="封装函数"></a>封装函数</h2><p>写代码</p>
<figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line">&lt;<span class="built_in">li</span> id=<span class="string">"item1"</span>&gt;选项<span class="number">1</span>&lt;/<span class="built_in">li</span>&gt;</span><br><span class="line">&lt;<span class="built_in">li</span> id=<span class="string">"item1"</span>&gt;选项<span class="number">2</span>&lt;/<span class="built_in">li</span>&gt;</span><br><span class="line">&lt;<span class="built_in">li</span> id=<span class="string">"item1"</span>&gt;选项<span class="number">3</span>&lt;/<span class="built_in">li</span>&gt;</span><br><span class="line">&lt;<span class="built_in">li</span> id=<span class="string">"item1"</span>&gt;选项<span class="number">4</span>&lt;/<span class="built_in">li</span>&gt;</span><br><span class="line">&lt;<span class="built_in">li</span> id=<span class="string">"item1"</span>&gt;选项<span class="number">5</span>&lt;/<span class="built_in">li</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="built_in">var</span> allchildren = iterm3.parentnode.children</span><br><span class="line"><span class="built_in">var</span> <span class="built_in">array</span> = &#123;<span class="built_in">length</span>: <span class="number">0</span>&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">let</span> i=<span class="number">0</span>; i&lt;allchildren.<span class="built_in">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (allchildren[i] !== item3) &#123;</span><br><span class="line">        <span class="built_in">array</span>[<span class="built_in">array</span>.<span class="built_in">length</span>] = allchildren[i]</span><br><span class="line">        <span class="built_in">array</span>.<span class="built_in">length</span> += <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">console.<span class="built_in">log</span>(<span class="built_in">array</span>)</span><br></pre></td></tr></table></figure>
<p>然后对以上代码进行封装</p>
<figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line">// 得到该节点的兄弟姐妹</span><br><span class="line">function getSiblings(node) &#123; <span class="comment">/* API */</span></span><br><span class="line">    <span class="built_in">var</span> allChildren = node.parentNode.children</span><br><span class="line">    <span class="built_in">var</span> <span class="built_in">array</span> = &#123;<span class="built_in">length</span>: <span class="number">0</span>&#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">let</span> i=<span class="number">0</span>; i&lt;allChildren.<span class="built_in">length</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (allChildren[i] !== node) &#123;</span><br><span class="line">            <span class="built_in">array</span>[<span class="built_in">array</span>.<span class="built_in">length</span>] = allChildren[i]</span><br><span class="line">            <span class="built_in">array</span>.<span class="built_in">length</span> += <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> <span class="built_in">array</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再封装一个</p>
<figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> classes = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]</span><br><span class="line">classes.forEach((<span class="keyword">value</span>) =&gt; item3.classList.<span class="keyword">add</span>(<span class="keyword">value</span>))</span><br></pre></td></tr></table></figure>
<p>变</p>
<figure class="highlight xquery"><table><tr><td class="code"><pre><span class="line">var classes = &#123;<span class="string">'a'</span>:<span class="built_in"> true</span>, <span class="string">'b'</span>:<span class="built_in"> false</span>, <span class="string">'c'</span>:<span class="built_in"> true</span>&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span><span class="built_in"> key</span> <span class="keyword">in</span> classes) &#123;</span><br><span class="line">    var <span class="keyword">value</span> = classes<span class="built_in">[key</span>]</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">value</span>) &#123;</span><br><span class="line">        item3.classList.add<span class="built_in">(key</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        item3.classList<span class="built_in">.remove</span><span class="built_in">(key</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>封装一下</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">fucntion addClass(<span class="keyword">node</span><span class="title">, classes</span>) &#123;</span><br><span class="line">    for (let key <span class="keyword">in</span> classes) &#123;</span><br><span class="line">        var value = classes[key]</span><br><span class="line">        if (value) &#123;</span><br><span class="line">            <span class="keyword">node</span>.<span class="title">classList</span>.add(key)</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            <span class="keyword">node</span>.<span class="title">classList</span>.remove(key)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用就是如下<br><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">addClass(item3, &#123;<span class="string">a:</span> <span class="literal">true</span>, <span class="string">b:</span><span class="literal">false</span>, <span class="string">c:</span><span class="literal">true</span>&#125;)</span><br></pre></td></tr></table></figure></p>
<h2 id="命名空间-amp-Node-prototype"><a href="#命名空间-amp-Node-prototype" class="headerlink" title="命名空间 &amp; Node.prototype"></a>命名空间 &amp; Node.prototype</h2><p>代码优化的原则,如果存在类似的代码,就有优化的可能<br>就比如像如下</p>
<figure class="highlight xquery"><table><tr><td class="code"><pre><span class="line">fucntion addClass(<span class="type">node</span>, classes) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span><span class="built_in"> key</span> <span class="keyword">in</span> classes) &#123;</span><br><span class="line">        var <span class="keyword">value</span> = classes<span class="built_in">[key</span>]</span><br><span class="line">        var methodName = <span class="keyword">value</span> ? <span class="string">'add'</span> : <span class="string">'remove'</span></span><br><span class="line">        <span class="type">node</span>.classList[methodName]<span class="built_in">(key</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后声明变量, 命名空间就是区分库的名字,以下声明的 <code>ffdom</code> 就是其命名空间</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">window.ffdom</span> <span class="string">=</span> <span class="string">&#123;&#125;</span></span><br><span class="line"><span class="string">ffdom.getSiblings</span> <span class="string">=</span> <span class="string">getSiblings</span></span><br><span class="line"><span class="string">ffdom.addClass</span> <span class="string">=</span> <span class="string">addClass</span></span><br><span class="line"></span><br><span class="line"><span class="string">ffdom.getSiblings(item3)</span></span><br><span class="line"><span class="string">ffdom.addClass(item3,</span> <span class="string">&#123;a:</span> <span class="literal">true</span><span class="string">,</span> <span class="attr">b:</span> <span class="literal">false</span><span class="string">,</span> <span class="attr">c:</span> <span class="literal">true</span><span class="string">&#125;)</span></span><br></pre></td></tr></table></figure>
<p>弄个缩写 alias<br><figure class="highlight coffeescript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.$ = jQuery</span><br></pre></td></tr></table></figure></p>
<p>最终优化的代码为<br><figure class="highlight zephir"><table><tr><td class="code"><pre><span class="line">window.ffdom = &#123;&#125; <span class="comment">/*yui*/</span></span><br><span class="line">ffdom.getSiblings = <span class="function"><span class="keyword">function</span> <span class="params">(node)</span> </span>&#123; <span class="comment">/* API */</span></span><br><span class="line">  <span class="keyword">var</span> allChildren = node.parentNode.children</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> <span class="keyword">array</span> = &#123;</span><br><span class="line">    length: <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; allChildren.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (allChildren[i] !== node) &#123;</span><br><span class="line">      <span class="keyword">array</span>[<span class="keyword">array</span>.length] = allChildren[i]</span><br><span class="line">      <span class="keyword">array</span>.length += <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">array</span></span><br><span class="line">&#125;</span><br><span class="line">ffdom.addClass = <span class="function"><span class="keyword">function</span> <span class="params">(node, classes)</span> </span>&#123;</span><br><span class="line">  classes.<span class="keyword">forEach</span>( (value) =&gt; node.classList.add(value) )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后使用就是<br><figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="variable">$.</span>getSiblings(item3)</span><br><span class="line"><span class="variable">$.</span>addClass(item3, [<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>])</span><br></pre></td></tr></table></figure></p>
<p>那么如何将 <code>ffdom.addClass(item3, [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;])</code> 转化成 <code>item3.addClass([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;])</code> 来使用呢</p>
<p>尝试在 <code>Node</code> 原型链中加入 <code>getSiblings</code> 函数<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Node.prototype.getSiblings = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(item3.getSiblings()) <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.dir(item3)</span><br></pre></td></tr></table></figure></p>
<p>可以在控制台看到在 <code>Node</code> 原型中出现了 <code>getSiblings</code> 函数,并且控制台打印出来的数为 1,通过这样的方式我们可以直接在 <code>Node</code> 原型中加函数,然后所有继承自 <code>Node</code> 的元素都可以调用到这个方法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Node.prototype.getSiblings = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// item3 会传给 this 参数</span></span><br><span class="line">    <span class="keyword">var</span> allChildren = <span class="keyword">this</span>.parentNode.children</span><br><span class="line">    <span class="keyword">var</span> array = &#123;<span class="attr">length</span>: <span class="number">0</span>&#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; allChildren.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (allChildren[i] !== <span class="keyword">this</span>) &#123;</span><br><span class="line">            array[array.length] = allChildren[i]</span><br><span class="line">            array.length += <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> array</span><br><span class="line">&#125;</span><br><span class="line">Node.prototype.addClass = <span class="function"><span class="keyword">function</span>(<span class="params">classes</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 这里注意下标就是 key, 对应的 'a' 'b' 'c' 就是 value</span></span><br><span class="line">    classes.forEach(<span class="function">(<span class="params">value</span>) =&gt;</span> <span class="keyword">this</span>.classList.add(value))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(item3.getSiblings())</span><br><span class="line">item3.addClass([<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用 call , 显式指定 this</span></span><br><span class="line"><span class="built_in">console</span>.log(item3.getSiblings.call(item3))</span><br><span class="line">item3.addclass.call(item3, [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>])</span><br></pre></td></tr></table></figure>
<h2 id="this-是个啥-amp-Node2"><a href="#this-是个啥-amp-Node2" class="headerlink" title="this 是个啥 &amp; Node2"></a>this 是个啥 &amp; Node2</h2><p>首先我们记得是如何调用函数的</p>
<figure class="highlight autoit"><table><tr><td class="code"><pre><span class="line">f.<span class="built_in">call</span>(asThis, input1, input2)</span><br></pre></td></tr></table></figure>
<p>其中 <code>asThis</code> 会被当做 this, [input1, input2] 会被当做 arguments<br>以后还是尽量少使用类似 <code>f(input1, input2)</code> 吧</p>
<p><strong>实际上 this 就是 call 的第一个参数</strong></p>
<p>往 <code>Node</code> 里面添加函数的时候容易导致一个问题, 就是函数有可能被覆盖掉,那么有什么方法可以避免这个问题呢?<br>思路是再写一个 “Node2” ,在这个 “Node2” 中去调用原来的 Node,代码如下所示</p>
<figure class="highlight zephir"><table><tr><td class="code"><pre><span class="line">window.Node2 = <span class="function"><span class="keyword">function</span><span class="params">(node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        getSiblings: <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> allChildren = node.parentNode.children</span><br><span class="line">            <span class="keyword">var</span> <span class="keyword">array</span> = &#123;length: <span class="number">0</span>&#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; allChildren.length; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (allChildren[i] !== node) &#123;</span><br><span class="line">                    <span class="keyword">array</span>[<span class="keyword">array</span>.length] = allChildren[i]</span><br><span class="line">                    <span class="keyword">array</span>.length += <span class="number">1</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">array</span></span><br><span class="line">        &#125;,</span><br><span class="line">        addClass: <span class="function"><span class="keyword">function</span><span class="params">(classes)</span> </span>&#123;</span><br><span class="line">            classes.<span class="keyword">forEach</span>((value) =&gt; node.classList.add(value))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这样就可以调用了</span></span><br><span class="line"><span class="keyword">var</span> node2 = Node2(item3)</span><br><span class="line">node2.getSiblings() <span class="comment">// 这里不用传参的原因是在构造时已经传了 item3 这个 node 参数给它了</span></span><br><span class="line">node2.addClass([<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>])</span><br></pre></td></tr></table></figure>
<h2 id="开始认识-jQuery"><a href="#开始认识-jQuery" class="headerlink" title="开始认识 jQuery"></a>开始认识 jQuery</h2><p>好了,将 Node2 变成 jQuery ,就是如下</p>
<figure class="highlight zephir"><table><tr><td class="code"><pre><span class="line">window.jQuery = <span class="function"><span class="keyword">function</span><span class="params">(node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        getSiblings: <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> allChildren = node.parentNode.children</span><br><span class="line">            <span class="keyword">var</span> <span class="keyword">array</span> = &#123;length: <span class="number">0</span>&#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; allChildren.length; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (allChildren[i] !== node) &#123;</span><br><span class="line">                    <span class="keyword">array</span>[<span class="keyword">array</span>.length] = allChildren[i]</span><br><span class="line">                    <span class="keyword">array</span>.length += <span class="number">1</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">array</span></span><br><span class="line">        &#125;,</span><br><span class="line">        addClass: <span class="function"><span class="keyword">function</span><span class="params">(classes)</span> </span>&#123;</span><br><span class="line">            classes.<span class="keyword">forEach</span>((value) =&gt; node.classList.add(value))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这样就可以调用了</span></span><br><span class="line"><span class="keyword">var</span> node2 = jQuery(item3)</span><br><span class="line">node2.getSiblings() <span class="comment">// 这里不用传参的原因是在构造时已经传了 item3 这个 node 参数给它了</span></span><br><span class="line">node2.addClass([<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>])</span><br></pre></td></tr></table></figure>
<p>所以 jQuery 的初步印象就是这样,给一个旧的对象,然后返回一个新的对象以及这个新对象的 api,但实际上这个新的 api 还是调用了旧的 api<br><strong>所以 JQuery 实际上是一个构造函数,这个构造函数接受一个参数,这个参数可能是一个节点,这个构造函数被调用后返回一个对象,通过操作这个对象里的方法去操作节点</strong></p>
<p>但是 JQuery 会更加聪明,假如传的是一个字符串(一个css选择器),它在代码里会做类型检查</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">window.jQuery = function(nodeOrSelector) &#123;</span><br><span class="line">    let <span class="keyword">node</span><span class="title"></span></span><br><span class="line"><span class="title">    if</span> (typeof nodeOrSelector === '<span class="keyword">string</span>') &#123;</span><br><span class="line">        <span class="keyword">node</span> <span class="title">= document</span>.querySelector(nodeOrSelector)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        <span class="keyword">node</span> <span class="title">= nodeOrSelector</span></span><br><span class="line">    &#125;</span><br><span class="line">    //... 下面的代码是一致的</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面也同时使用到了闭包,因为 <code>addClass</code> 这个函数,里面使用到了 <code>node</code>变量 , 而这个 node 是在该函数的外面进行声明的,我们对这个变量 <code>node</code> 和 这个匿名函数统称为 <strong>闭包</strong>,闭包的好处在于,它维持住了 <code>node</code> 这个变量,只要有 <code>addClass</code> 被调用的场合,它就不会消失,并且外面的代码也不能直接访问到 <code>node</code> 这个变量,因为作用域在 <code>function(nodeOrSelector)</code> 里面</p>
<h2 id="操作多节点"><a href="#操作多节点" class="headerlink" title="操作多节点"></a>操作多节点</h2><p>那么如何操作多个节点呢?</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.jQuery = <span class="function"><span class="keyword">function</span>(<span class="params">nodeOrSelector</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> nodes = &#123;&#125; <span class="comment">// 先声明一个多节点的伪数组</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> nodeOrSelector === <span class="string">'string'</span>) &#123; <span class="comment">// 假如传进来的参数是一个 string</span></span><br><span class="line">        <span class="comment">// 得到多个节点</span></span><br><span class="line">        <span class="keyword">let</span> temp = <span class="built_in">document</span>.querySelectorAll(nodeOrSelector)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>; i &lt; temp.length; i++) &#123;</span><br><span class="line">            nodes[i] = temp[i] <span class="comment">// 赋值</span></span><br><span class="line">            nodes.length = temp.length;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nodeOrSelector <span class="keyword">instanceof</span> Node) &#123; <span class="comment">// 假如传进来的是一个 Node 值</span></span><br><span class="line">        nodes = &#123;<span class="number">0</span>: nodeOrSelector, <span class="attr">length</span>: <span class="number">1</span>&#125; <span class="comment">// 也返回一个伪数组,保持返回值的统一</span></span><br><span class="line">    &#125;</span><br><span class="line">    nodes.getSiblings = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 为得到的每个节点增加 class</span></span><br><span class="line">    nodes.addClass = <span class="function"><span class="keyword">function</span>(<span class="params">classes</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> classes === <span class="string">'string'</span>) &#123;</span><br><span class="line">            <span class="keyword">let</span> temp = classes;</span><br><span class="line">            classes = <span class="built_in">Array</span>(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 注意这里 nodes 已经变成伪数组了,所以需要遍历</span></span><br><span class="line">        classes.forEach(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>; i &lt; nodes.length; i++) &#123;</span><br><span class="line">                nodes[i].classList.add(value)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 得到每个节点的 text</span></span><br><span class="line">    nodes.getText = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> texts = []</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>; i &lt; nodes.length; i++) &#123;</span><br><span class="line">            texts.push(nodes[i].textContent)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> texts</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置每个节点的 text</span></span><br><span class="line">    nodes.setText = <span class="function"><span class="keyword">function</span>(<span class="params">text</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>; i &lt; nodes.length; i++) &#123;</span><br><span class="line">            nodes[i].textContent = text</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    nodes.text = <span class="function"><span class="keyword">function</span>(<span class="params">text</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (text === <span class="literal">undefined</span>) &#123;</span><br><span class="line">            nodes.getText()</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            nodes.setText(text)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nodes</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="keyword">var</span> node2 = jQuery(<span class="string">'ul &gt; li'</span>)</span><br><span class="line">node2.addClass([<span class="string">'blue'</span>])</span><br><span class="line">node2.text()</span><br><span class="line">node2.text(<span class="string">'h1'</span>);</span><br></pre></td></tr></table></figure>
<h2 id="jQuery-使用举例"><a href="#jQuery-使用举例" class="headerlink" title="jQuery 使用举例"></a>jQuery 使用举例</h2><p>中文文档参见 <a href="cndevdocs.com">cndevdocs</a></p>
<p>html 代码<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>选项1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>选项2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>选项3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>选项4<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>选项5<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"x"</span>&gt;</span>X<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>css 代码<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.red</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>js 代码<br><figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> nodes = jQuery(<span class="string">'ul &gt; li'</span>)</span><br><span class="line">x.onclick = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    nodes.toggleClass(<span class="string">'red'</span>) <span class="comment">// toggle 开关 切换</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>或者还可以链式操作</p>
<p>html 代码<br><figure class="highlight stata"><table><tr><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">    &lt;<span class="keyword">li</span> <span class="keyword">class</span>=<span class="string">"red"</span>&gt;选项1&lt;/<span class="keyword">li</span>&gt;</span><br><span class="line">    &lt;<span class="keyword">li</span> <span class="keyword">class</span>=<span class="string">"red"</span>&gt;选项2&lt;/<span class="keyword">li</span>&gt;</span><br><span class="line">    &lt;<span class="keyword">li</span> <span class="keyword">class</span>=<span class="string">"red"</span>&gt;选项3&lt;/<span class="keyword">li</span>&gt;</span><br><span class="line">    &lt;<span class="keyword">li</span> <span class="keyword">class</span>=<span class="string">"red"</span>&gt;选项4&lt;/<span class="keyword">li</span>&gt;</span><br><span class="line">    &lt;<span class="keyword">li</span> <span class="keyword">class</span>=<span class="string">"red"</span>&gt;选项5&lt;/<span class="keyword">li</span>&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">&lt;button id=<span class="string">"x"</span>&gt;X&lt;/button&gt;</span><br></pre></td></tr></table></figure></p>
<p>css 代码<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.red</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.green</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: green;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>js 代码<br><figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> nodes = jQuery(<span class="string">'ul &gt; li'</span>)</span><br><span class="line">x.onclick = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    nodes.removeClass(<span class="string">'red'</span>).addClass(<span class="string">'green'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>还有个 <code>addClass</code></p>
<p>html 代码<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>选项1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>选项2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>选项3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>选项4<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>选项5<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"x"</span>&gt;</span>X<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>css 代码<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.red</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.blue</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: blue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.green</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: green;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.yellow</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: yellow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.black</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: black;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>js 代码<br><figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> nodes = jQuery(<span class="string">'ul &gt; li'</span>)</span><br><span class="line"><span class="keyword">var</span> classes = [<span class="string">'red'</span>, <span class="string">'blue'</span>, <span class="string">'green'</span>, <span class="string">'yellow'</span>, <span class="string">'black'</span>]</span><br><span class="line">x.onclick = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    nodes.addClass(<span class="function"><span class="keyword">function</span><span class="params">(index, currentClass)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> classes[index]</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>jQuery 兼容性方面做的很好, 1.7 版本兼容到 IE6,但是现在 3 版本已经不做 IE 的兼容了</li>
<li>jQuery 还有动画 AJAX 等模块,不止 DOM 操作</li>
<li>jQuery 功能更丰富</li>
<li>jQuery 使用了 prototype 以及 new</li>
</ul>
<p>小技巧:<br>如果用的是 jQuery,声明变量最好这样写<br><figure class="highlight gams"><table><tr><td class="code"><pre><span class="line">var <span class="symbol">$</span>nodes = <span class="symbol">$</span>(<span class="string">'ul&gt;li'</span>)</span><br><span class="line"><span class="meta"><span class="meta-keyword">$nodes</span>.classList</span></span><br></pre></td></tr></table></figure></p>
<p>这样可以提醒自己用的是 jQuery 的 api<br>以上为大概对 jQuery 的初步理解</p>
]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title>watermelon-clock:基于TypeScript+React的西瓜闹钟项目的实践总结</title>
    <url>/2020/03/17/watermelon-clock-%E5%9F%BA%E4%BA%8ETypeScript-React%E7%9A%84%E8%A5%BF%E7%93%9C%E9%97%B9%E9%92%9F%E9%A1%B9%E7%9B%AE%E7%9A%84%E5%AE%9E%E8%B7%B5%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<blockquote>
<p>注意，本项目是基于 <code>create-react-app</code> 搭建，但是使用了 <code>--typescript</code> 选项，所以是基于 <code>TypeScript</code> 写的。另外，<a href="https://github.com/strugglebak/watermelon-clock" target="_blank" rel="noopener">项目地址在这里，求各位大佬看到了如果喜欢还请点个小星星(拜托啦这真的对我很重要 QAQ)</a></p>
</blockquote>
<a id="more"></a>
<h2 id="项目实现-Feature"><a href="#项目实现-Feature" class="headerlink" title="项目实现 Feature"></a>项目实现 Feature</h2><ul>
<li><p>小巧的用户验证</p>
<p>  这一部分主要是用来注册/登陆的验证用的，注册/登陆后会自动跳转至首页，所以这边也做了一个简单的路由鉴权功能</p>
</li>
<li><p>西瓜闹钟</p>
<p>  点击开始闹钟时，会显示 25 分钟的倒计时，计时结束后若没有打断则会生成一个西瓜</p>
</li>
<li><p>待办 todo 任务</p>
<p>  新建待办任务和完成待办任务后都会出现任务的列表，而且是不同的列表展示</p>
</li>
<li><p>数据统计</p>
<p>  主要有 3 个</p>
<ul>
<li>月度统计：统计每个月任务总量的累计/增长率/平均值</li>
<li>西瓜历史统计：主要是一个长达 25 分钟的西瓜量，表示自己长时间的执行完某个任务的量化显示，可编辑/删除/恢复，同时也可以手动增加西瓜记录</li>
<li>待办 todo 历史统计：表示自己短时间内执行完的小任务的量化表示，可编辑/删除/恢复，同时可以查看已经删除的任务</li>
</ul>
</li>
</ul>
<h2 id="项目主要技术栈"><a href="#项目主要技术栈" class="headerlink" title="项目主要技术栈"></a>项目主要技术栈</h2><ul>
<li>React 16.12</li>
<li>Antd 4.0.1</li>
<li>Axios 库</li>
<li>React-Router-DOM 5.1.2</li>
<li>React-Redux 7.1.3</li>
<li>Redux 4.0.5</li>
<li>TypeScript 3.8.3</li>
<li>History 4.10.1</li>
<li>Lodash 4.14</li>
<li>Stylus</li>
</ul>
<p>这里需要说明的是目前的 antd 用的是比较新的版本，但是由于组件目前并不涉及到非常复杂的结构，所以可以使用其升级工具进行无痛升级</p>
<p>在配置 <code>stylus</code> 时应该在项目对应的 <code>config-overrides.js</code> 目录做如下的配置</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">const</span> stylus = <span class="function"><span class="params">()</span> =&gt;</span> <span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> stylusLoader = &#123;</span><br><span class="line">    test: <span class="regexp">/\.styl$/</span>,</span><br><span class="line">    use: [</span><br><span class="line">      &#123;</span><br><span class="line">        loader: <span class="string">'style-loader'</span></span><br><span class="line">      &#125;, &#123;</span><br><span class="line">        loader: <span class="string">'css-loader'</span>,</span><br><span class="line">      &#125;, &#123;</span><br><span class="line">        loader: <span class="string">'stylus-loader'</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> oneOf = config.module.rules.find(<span class="function"><span class="params">rule</span> =&gt;</span> rule.oneOf).oneOf</span><br><span class="line">  oneOf.unshift(stylusLoader)</span><br><span class="line">  <span class="keyword">return</span> config</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = override(</span><br><span class="line">  ...</span><br><span class="line">  stylus()</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>这里的作用相当于找出原有配置中的 <code>oneOf</code> 然后将 <code>stylus</code> 的配置加入其中，很好理解(因为我目前使用的时 cra 所以在某些配置方面能省则省了，目的是体验并上手 React 结合 TypeScript 的开发)</p>
<h2 id="项目实现技术细节"><a href="#项目实现技术细节" class="headerlink" title="项目实现技术细节"></a>项目实现技术细节</h2><h3 id="部分组件使用-hooks"><a href="#部分组件使用-hooks" class="headerlink" title="部分组件使用 hooks"></a>部分组件使用 hooks</h3><p>主要是倒计时组件这里使用了 <code>useEffect</code> 以及 <code>useState</code> 这两个 hooks</p>
<p>原来的倒计时组件用类组件来写的话就比较繁琐</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/components/waterMelon/countDown.tsx</span></span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">countDown</span> <span class="keyword">extends</span> <span class="title">Component</span>&lt;<span class="title">ICountDownProps</span>, <span class="title">ICountDownState</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span>(props: ICountDownProps) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props)</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      countDown: <span class="keyword">this</span>.props.time,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">get</span> countDown() &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">get</span> progressWidth() &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentWillUnmount() &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (...)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>本质上就是使用了一个生命周期的形式来实现效果，代码分散在多处不好做统一管理，但是使用了 hooks 之后代码量减少很多，减小了很多心智负担</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> CountDown:FunctionComponent&lt;ICountDownProps&gt; = <span class="function">(<span class="params">props: ICountDownProps</span>) =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> [countDown, setCountDown] = useState(props.time)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 时间换算显示</span></span><br><span class="line">  <span class="keyword">const</span> min = <span class="built_in">Math</span>.floor(countDown/<span class="number">1000</span>/<span class="number">60</span>)</span><br><span class="line">  <span class="keyword">const</span> sec = <span class="built_in">Math</span>.floor(countDown/<span class="number">1000</span>%<span class="number">60</span>)</span><br><span class="line">  <span class="keyword">const</span> time = <span class="string">`<span class="subst">$&#123;min &lt; <span class="number">10</span> ? <span class="string">`0<span class="subst">$&#123;min&#125;</span>`</span> : min&#125;</span>:<span class="subst">$&#123;sec &lt; <span class="number">10</span> ? <span class="string">`0<span class="subst">$&#123;sec&#125;</span>`</span> : sec&#125;</span>`</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// progress bar 进度条长度计算显示</span></span><br><span class="line">  <span class="keyword">const</span> &#123; duration &#125; = props</span><br><span class="line">  <span class="keyword">const</span> progressWidth = (<span class="number">100</span> - (countDown - <span class="number">1000</span>) * <span class="number">100</span> / duration).toFixed(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span>=&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">document</span>.title = <span class="string">`<span class="subst">$&#123;time&#125;</span> - 西瓜闹钟 App`</span></span><br><span class="line">    timerId = setInterval(<span class="function"><span class="params">()</span>=&gt;</span> &#123;</span><br><span class="line">      setCountDown(countDown - <span class="number">1000</span>)</span><br><span class="line">      <span class="keyword">if</span> (countDown &lt; <span class="number">1000</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(countDown)</span><br><span class="line">        props.onEnd()</span><br><span class="line">        <span class="built_in">window</span>.clearInterval(timerId)</span><br><span class="line">        <span class="built_in">document</span>.title = <span class="string">'西瓜闹钟 App'</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 组件销毁时</span></span><br><span class="line">      <span class="built_in">window</span>.clearInterval(timerId)</span><br><span class="line">      <span class="built_in">document</span>.title = <span class="string">'西瓜闹钟 App'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (...)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用 <code>useEffect</code> 可以统一处理副作用以及组件销毁时的逻辑，而使用 <code>useState</code> 就可以统一状态的管理，这样就可以最大程度的减小代码量，可以将一些比较重要的逻辑统一起来管理，使得组件代码更加明了</p>
<h3 id="axios-配置"><a href="#axios-配置" class="headerlink" title="axios 配置"></a>axios 配置</h3><p>这里的配置比较简单，主要是通过使用 axios 的拦截器去拦截验证从后端发过来的 token 有没有，配置主要有以下两点</p>
<ul>
<li><p>发送请求前需要在请求头中加 token 方便后端验证</p>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/config/http.ts</span></span><br><span class="line">instance.interceptors.request.use(</span><br><span class="line">  config =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> xToken = localStorage.getItem(<span class="string">'x-token'</span>)</span><br><span class="line">    <span class="keyword">if</span> (xToken) config.headers[<span class="string">'Authorization'</span>] = <span class="string">`Bearer <span class="subst">$&#123;xToken&#125;</span>`</span></span><br><span class="line">    <span class="keyword">return</span> config</span><br><span class="line">  &#125;,</span><br><span class="line">  e =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'request error: '</span>, e)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(e)</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
</li>
<li><p>接受响应之前设置下 token</p>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">instance.interceptors.response.use(</span><br><span class="line">  res =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (res.headers[<span class="string">'x-token'</span>]) localStorage.setItem(<span class="string">'x-token'</span>, res.headers[<span class="string">'x-token'</span>])</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">  &#125;,</span><br><span class="line">  e =&gt; &#123;</span><br><span class="line">    <span class="comment">// eslint-disable-next-line</span></span><br><span class="line">    <span class="keyword">if</span> (e.response &amp;&amp; e.response.status === <span class="number">401</span> || e.response.status &gt;= <span class="number">500</span>) &#123;</span><br><span class="line">      <span class="comment">// 一般是如果鉴权失败，需要做重定向跳转到登录页</span></span><br><span class="line">      <span class="built_in">console</span>.log(history.location.pathname)</span><br><span class="line">      <span class="keyword">if</span> (history.location.pathname === <span class="string">'/'</span>) history.push(<span class="string">'/login'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(e)</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>这里做了一个简单的路由鉴权，不过更加详细的鉴权我写在了 redux 的 <code>userActions</code> 中，不过留着下面来说</p>
<h3 id="redux-以及-redux-thunk-这个中间件"><a href="#redux-以及-redux-thunk-这个中间件" class="headerlink" title="redux 以及 redux-thunk 这个中间件"></a>redux 以及 redux-thunk 这个中间件</h3><ul>
<li><p>模块划分<br>  说到模块划分，基本是如下的结构</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">redux/</span><br><span class="line">├── actionTypes.ts</span><br><span class="line">├── actions</span><br><span class="line">│   ├── todosActions.ts</span><br><span class="line">│   ├── userActions.ts</span><br><span class="line">│   └── waterMelonActions.ts</span><br><span class="line">├── reducers</span><br><span class="line">│   ├── indexReducer.ts</span><br><span class="line">│   ├── todosReducer.ts</span><br><span class="line">│   ├── userReducer.ts</span><br><span class="line">│   └── waterMelonReducer.ts</span><br><span class="line">└── store.ts</span><br></pre></td></tr></table></figure>
<p>  因为这里的各种 <code>type</code> 都比较简单，所以这里就没有分各个模块文件了，只是就大概的 <code>actions</code> 以及 <code>reducers</code> 分了一下，<code>store.ts</code> 模块主要就是 <code>creatStore</code> 以及 <code>applyMiddleware</code> 中间件。这里还用了一个 <code>redux-devtools-extension</code> redux 的调试工具，在 debug 环境调试用的。</p>
</li>
<li><p>用户登陆/注册的鉴权</p>
<p>  其实在用户登陆和注册之前可以先调用下 <code>getUserInfo</code> 获取下用户的信息，先判断是否会得到错误，如果没错那么本来没有在 <code>/</code> 路由的就跳转到 <code>/</code>，如果出错了那么在判断其是否在 <code>/</code> 路由，在的话就强制跳转至 <code>/login</code> 路由页面</p>
<p>  登陆和注册的逻辑基本就是如下</p>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">await</span> http.post(url, params)</span><br><span class="line">  <span class="keyword">const</span> response = <span class="keyword">await</span> http.get(<span class="string">'/me'</span>)</span><br><span class="line">  <span class="keyword">const</span> userInfo = response.data</span><br><span class="line">  dispatch(&#123;</span><br><span class="line">    type: VERIFY_USER_SUCCESS,</span><br><span class="line">    payload: userInfo</span><br><span class="line">  &#125;)</span><br><span class="line">  history.push(<span class="string">'/'</span>)</span><br><span class="line">&#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e.response)</span><br><span class="line">  <span class="keyword">let</span> errorInfo</span><br><span class="line">  <span class="keyword">if</span>(!e.response)&#123;</span><br><span class="line">    errorInfo = <span class="string">'请检查网络是否正常'</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; errors &#125; = e.response.data</span><br><span class="line">    errorInfo = errors.account</span><br><span class="line">    ? errors.account</span><br><span class="line">    : errors</span><br><span class="line">  &#125;</span><br><span class="line">  dispatch(&#123;</span><br><span class="line">    type: VERIFY_USER_FAILURE,</span><br><span class="line">    error: errorInfo</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>为什么使用 <code>redux-thunk</code> 来 <code>dispatch</code> 数据</p>
<p>  因为用到了异步，而我们这里的异步比较简单，实际上用 <code>redux-thunk</code> 这个中间件就能解决问题了。那么这里的 <code>actions</code> 的写法也比较简单，只是需要返回一个 <code>async</code> 的带有 <code>dispatch</code> 函数参数的一个函数即可，<code>redux-thunk</code> 会自己帮你 enhance 这个 <code>dispatch</code></p>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> xxx = <span class="keyword">async</span> (dispatch: any) =&gt; &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  dispatch(&#123;</span><br><span class="line">    type: <span class="string">'YYY'</span>,</span><br><span class="line">    payload: &#123;...&#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>react-redux</code> 中的 <code>connect</code> 组件</p>
<p>  首先我不认同只有父级组件用 <code>connect</code> 而其他组件就被动传 <code>props</code> 的这种用法。因为尽管是比较简单的一个项目，但是在某个功能模块上依然存在层级嵌套比较深的情况。有一般而言传个三级就觉得很麻烦了，这个时候子组件使用 <code>connect</code> 是很有必要的(虽然可能写起来依然麻烦了点，但是的确能省点心思思考我的父级组件到底给我传了个啥)</p>
</li>
</ul>
<h3 id="封装的-history-配置"><a href="#封装的-history-配置" class="headerlink" title="封装的 history 配置"></a>封装的 <code>history</code> 配置</h3><p>这部分的代码也并不是特别复杂，如下所示</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createBrowserHistory &#125; <span class="keyword">from</span> <span class="string">'history'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ENV = process.env.NODE_ENV</span><br><span class="line"><span class="keyword">let</span> publicUrl: string = <span class="string">''</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ENV === <span class="string">'development'</span>) &#123;</span><br><span class="line">  publicUrl = <span class="string">'/'</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (ENV === <span class="string">'production'</span>) &#123;</span><br><span class="line">  publicUrl = <span class="string">'/watermelon-clock'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> history = createBrowserHistory(&#123;</span><br><span class="line">  basename: publicUrl</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> history</span><br></pre></td></tr></table></figure>
<p>虽然在 <code>App.tsx</code> 中使用过 <code>BrowserRouter</code>，但是不如自己封装来的快，因为这块很多地方都要用到，比如如上所述的鉴权的位置，用于登陆验证过后的跳转</p>
<h2 id="数据统计图"><a href="#数据统计图" class="headerlink" title="数据统计图"></a>数据统计图</h2><p>这次的数据统计图没有使用诸如 <code>echart.js</code> 和 <code>highchart.js</code> 的原因部分是因为觉得没有多大必要，觉得自己使用 <code>svg</code> 来实现或许会更加好一点，有点造轮子的意思，不过还是挺有趣的。当然这次也没有选中 <code>canvas</code> 的原因是 <code>svg</code> 有个好处就是不依赖 <strong>分辨率</strong>，因为它生成的图像是基于<strong>矢量位图</strong> 的，你放大缩小都不会失真。</p>
<h3 id="折线图"><a href="#折线图" class="headerlink" title="折线图"></a>折线图</h3><p>折线图就是下图这玩意儿</p>
<p><img src="./1.png" alt></p>
<p>我这边是先实现的折线图，所以先说一下大概是怎么实现的，代码如下所示</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">// src/components/statistics/polyline.tsx</span><br><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">className</span>=<span class="string">"polyline peity"</span> <span class="attr">width</span>=<span class="string">"100%"</span> <span class="attr">height</span>=<span class="string">"60"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">polygon</span></span></span><br><span class="line"><span class="tag">    <span class="attr">fill</span>=<span class="string">"rgba(215,78,78,0.1)"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">points</span>=<span class="string">&#123;this.points()&#125;</span></span></span><br><span class="line"><span class="tag">  /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">polygon</span></span></span><br><span class="line"><span class="tag">    <span class="attr">fill</span>=<span class="string">"none"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">stroke</span>=<span class="string">"rgba(215,78,78,0.5)"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">strokeWidth</span>=<span class="string">"1"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">strokeLinecap</span>=<span class="string">"square"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">points</span>=<span class="string">&#123;this.points()&#125;</span></span></span><br><span class="line"><span class="tag">  /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这里有几个属性，说明一下</p>
<ul>
<li><code>fill</code>: 表示填充进 <code>svg</code> 框住的那部分，取值是颜色</li>
<li><code>points</code>: 就是描线，线的坐标</li>
<li><code>stroke</code>: 表示 <code>fill</code> 外层的那条线，取值也是颜色</li>
<li><code>strokeWidth</code>: 表示线宽</li>
<li><code>strokeLinecap</code>: 表示从起点到终点的线它两边的形状，可以是 <code>butt | round | square | inherit</code></li>
</ul>
<p>这里的逻辑很好理解，就是 <code>svg</code> 包 <code>polygon</code> 画线并填充颜色，然后是坐标点的计算</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">points = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> &#123; data, finishedCount, width &#125; = <span class="keyword">this</span>.props</span><br><span class="line">  <span class="comment">// 首先传入的 data 是一个类似 &#123;'时间1': &#123;...&#125;, '时间2': &#123;...&#125;&#125; 这样的对象</span></span><br><span class="line">  <span class="comment">// 这里首先要做的就是根据时间大小排序</span></span><br><span class="line">  <span class="comment">// 得到一个 ['时间1', '时间2', ...] 的数组</span></span><br><span class="line">  <span class="keyword">const</span> datesKeys = <span class="built_in">Object</span>.keys(data).sort(</span><br><span class="line">    (a, b) =&gt; &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Date</span>.parse(a) - <span class="built_in">Date</span>.parse(b)</span><br><span class="line">    &#125;</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 计算起始点和终止点的坐标</span></span><br><span class="line">  <span class="keyword">const</span> firstDay = datesKeys[<span class="number">0</span>]</span><br><span class="line">  <span class="keyword">const</span> startPoints = <span class="string">'0,60'</span></span><br><span class="line">  <span class="keyword">const</span> lastPoints = <span class="string">`<span class="subst">$&#123;width&#125;</span>,60`</span></span><br><span class="line">  <span class="keyword">if</span> (!firstDay) <span class="keyword">return</span> [<span class="string">`<span class="subst">$&#123;startPoints&#125;</span>`</span>, <span class="string">`<span class="subst">$&#123;lastPoints&#125;</span>`</span>].join(<span class="string">' '</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> lastDay = datesKeys[datesKeys.length - <span class="number">1</span>]</span><br><span class="line">  <span class="comment">// 若是同一天有很多任务，并且只有这一天的情况下，dayRange 有可能是 0</span></span><br><span class="line">  <span class="keyword">const</span> dayRange = <span class="built_in">Date</span>.parse(lastDay) - <span class="built_in">Date</span>.parse(firstDay) || <span class="number">1</span></span><br><span class="line">  <span class="keyword">let</span> count = <span class="number">0</span></span><br><span class="line">  <span class="keyword">let</span> lastY</span><br><span class="line">  <span class="comment">// 画折线图需要 x y 坐标</span></span><br><span class="line">  <span class="comment">// 有断点的折线图每个 x y 都是有范围的</span></span><br><span class="line">  <span class="comment">// 所以这里需要除一个 range</span></span><br><span class="line">  <span class="keyword">const</span> pointsArray = datesKeys.map(<span class="function">(<span class="params">datesKey: any</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> x = (<span class="built_in">Date</span>.parse(datesKey) - <span class="built_in">Date</span>.parse(firstDay)) / dayRange * (width || <span class="number">320</span>)</span><br><span class="line">    count += <span class="keyword">this</span>.props.data[datesKey].length</span><br><span class="line">    <span class="keyword">const</span> y = (<span class="number">1</span> -  (count / finishedCount)) * <span class="number">60</span></span><br><span class="line">    lastY = y</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;x&#125;</span>,<span class="subst">$&#123;y&#125;</span>`</span></span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> [<span class="string">`<span class="subst">$&#123;startPoints&#125;</span>`</span>, ...pointsArray, <span class="string">`<span class="subst">$&#123;width&#125;</span>,<span class="subst">$&#123;lastY&#125;</span>`</span>, <span class="string">`<span class="subst">$&#123;lastPoints&#125;</span>`</span>].join(<span class="string">' '</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里本质上就是求出一个多边形每个点 x 和 y 的坐标，然后求出 range 范围有个对应的关系，基本上就能搞定了</p>
<h3 id="条形柱状图"><a href="#条形柱状图" class="headerlink" title="条形柱状图"></a>条形柱状图</h3><p>条形柱状图就是下面这玩意儿</p>
<p><img src="./2.png" alt></p>
<p>这个逻辑就是在 <code>svg</code> 中渲染 <code>rect</code></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">className</span>=<span class="string">"bar-chart"</span> <span class="attr">width</span>=<span class="string">'100%'</span> <span class="attr">height</span>=<span class="string">&#123;height&#125;</span>&gt;</span></span><br><span class="line">&#123;</span><br><span class="line">  this.points().map((point, index) =&gt; (</span><br><span class="line">    <span class="tag">&lt;<span class="name">rect</span> <span class="attr">key</span>=<span class="string">&#123;index&#125;</span> <span class="attr">fill</span>=<span class="string">"rgba(215,78,78,0.5)"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">x</span>=<span class="string">&#123;point[0]&#125;</span> <span class="attr">y</span>=<span class="string">&#123;point[1]&#125;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">width</span>=<span class="string">&#123;16&#125;</span> <span class="attr">height</span>=<span class="string">&#123;height</span> <span class="attr">-</span> <span class="attr">point</span>[<span class="attr">1</span>] || <span class="attr">0</span>&#125;</span></span><br><span class="line"><span class="tag">    /&gt;</span></span><br><span class="line">  ))</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>width</code>: 柱子的宽度</li>
<li><code>height</code>: 柱子的高度</li>
<li><code>fill</code>: 颜色填充，之前说过</li>
<li><code>x</code>: <code>x</code> 坐标值</li>
<li><code>y</code>: <code>y</code> 坐标值</li>
<li><code>key</code>: 就是 <code>key</code>，一个 key 值，因为要渲染多个，所以需要这个指明每个 <code>rect</code> 元素的 id</li>
</ul>
<p>坐标点计算逻辑如下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/components/statistics/barChart.tsx</span></span><br><span class="line">points = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; data, finishedCount &#125; = <span class="keyword">this</span>.props</span><br><span class="line">  <span class="keyword">const</span> xRange = <span class="number">10</span></span><br><span class="line">  <span class="comment">// 利用 reduce 找出数据中7天中完成西瓜数最多的数</span></span><br><span class="line">  <span class="comment">// data 传进来就是周一到周日的数据</span></span><br><span class="line">  <span class="comment">// &#123;0: [...], 1: [...], ...&#125;</span></span><br><span class="line">  <span class="keyword">const</span> yRange = data.reduce(</span><br><span class="line">    (acc, cur) =&gt; &#123;</span><br><span class="line">      <span class="keyword">return</span> acc &gt; cur.length ? acc : cur.length</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="number">0</span></span><br><span class="line">  )</span><br><span class="line">  <span class="comment">// 这里用的就是计数法，哪个上面 length 大说明这个柱子 y 坐标越大</span></span><br><span class="line">  <span class="keyword">return</span> data.map(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> x = (index + gap) / xRange * finishedCount - <span class="number">8</span></span><br><span class="line">    <span class="keyword">let</span> y = (<span class="number">1</span> - item.length / (yRange || <span class="number">1</span>)) * height</span><br><span class="line">    y &gt;= height &amp;&amp; (y = height - <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> [x, y]</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="点线图"><a href="#点线图" class="headerlink" title="点线图"></a>点线图</h3><p>点线图就是下面这玩意儿</p>
<p><img src="./3.png" alt></p>
<p>分析下，首先是背景的那个灰色的矩形框，就用 <code>rect</code> 绘制，然后使用 <code>path</code> 画线，用 <code>circle</code> 画圆圈，用 <code>text</code> 表示下面的点</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">width</span>=<span class="string">'100%'</span> <span class="attr">height</span>=<span class="string">'200'</span>&gt;</span></span><br><span class="line">  // 灰色背景图</span><br><span class="line">  <span class="tag">&lt;<span class="name">rect</span> <span class="attr">x</span>=<span class="string">&#123;0&#125;</span> <span class="attr">y</span>=<span class="string">&#123;0&#125;</span> <span class="attr">width</span>=<span class="string">'100%'</span> <span class="attr">height</span>=<span class="string">&#123;170&#125;/</span>&gt;</span></span><br><span class="line">  // 描线</span><br><span class="line">  <span class="tag">&lt;<span class="name">path</span></span></span><br><span class="line"><span class="tag">    <span class="attr">d</span>=<span class="string">&#123;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">this.points</span>()<span class="attr">.reduce</span>(</span></span><br><span class="line"><span class="tag">        // <span class="attr">M</span>,<span class="attr">x</span>,<span class="attr">y</span>,<span class="attr">x1</span>,<span class="attr">y1</span> 的形式画直线</span></span><br><span class="line"><span class="tag">        (<span class="attr">acc</span>, <span class="attr">cur</span>) =&gt;</span> acc.concat(`$&#123;cur.slice(0,2).join(',')&#125;,`),</span><br><span class="line">        'M'</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">   /&gt;</span><br><span class="line">  &#123;</span><br><span class="line">    // x 坐标轴上的值显示 1 2 3 4...</span><br><span class="line">    this.points().map(</span><br><span class="line">      // 隔一个显示一个</span><br><span class="line">      (point, index) =&gt; (</span><br><span class="line">        index % 2 === 0</span><br><span class="line">        ? <span class="tag">&lt;<span class="name">text</span> <span class="attr">key</span>=<span class="string">&#123;index&#125;</span> <span class="attr">x</span>=<span class="string">&#123;point[0]</span> <span class="attr">-</span> <span class="attr">5</span>&#125; <span class="attr">y</span>=<span class="string">"200"</span>&gt;</span></span><br><span class="line">            &#123;index + 1&#125;</span><br><span class="line">          <span class="tag">&lt;/<span class="name">text</span>&gt;</span></span><br><span class="line">        : null</span><br><span class="line">    ))</span><br><span class="line">  &#125;</span><br><span class="line">  &#123;</span><br><span class="line">    this.points().map((point, index) =&gt; (</span><br><span class="line">      <span class="tag">&lt;<span class="name">Tooltip</span></span></span><br><span class="line"><span class="tag">        <span class="attr">key</span>=<span class="string">&#123;index&#125;</span> <span class="attr">placement</span>=<span class="string">"top"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">title</span>=<span class="string">&#123;</span>`$&#123;<span class="attr">point</span>[<span class="attr">2</span>]&#125;`&#125; <span class="attr">overlayClassName</span>=<span class="string">'daily_tips'</span>&gt;</span></span><br><span class="line">        &#123;/* 坐标点对应的⚪ */&#125;</span><br><span class="line">        <span class="tag">&lt;<span class="name">circle</span> <span class="attr">r</span>=<span class="string">&#123;this.circleRadius&#125;</span> <span class="attr">cx</span>=<span class="string">&#123;point[0]&#125;</span> <span class="attr">cy</span>=<span class="string">&#123;point[1]&#125;</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">Tooltip</span>&gt;</span></span><br><span class="line">    ))</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>注意这里使用了 <code>Tooltip</code> 组件， 表示鼠标悬浮上去之后会有一个提示冒出来</p>
<p>点坐标的计算就是如下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">points = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; data, xRange, width &#125; = <span class="keyword">this</span>.props</span><br><span class="line">  <span class="comment">// data 同样是一个类似 &#123;0: [...], 1: [...]&#125; 的对象</span></span><br><span class="line">  <span class="comment">// 这里用 reduce 找出 y 的最大范围值，好用来定高度</span></span><br><span class="line">  <span class="keyword">let</span> yRange = <span class="built_in">Object</span>.keys(data).reduce(</span><br><span class="line">    (acc, cur) =&gt; &#123;</span><br><span class="line">      <span class="keyword">return</span> acc &gt; data[cur].length ? acc : data[cur].length</span><br><span class="line">    &#125;</span><br><span class="line">  , <span class="number">0</span>)</span><br><span class="line">  yRange === <span class="number">0</span> &amp;&amp; (yRange = <span class="number">5</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Object</span>.keys(data).map(</span><br><span class="line">    date =&gt; &#123;</span><br><span class="line">      <span class="keyword">const</span> x = (<span class="keyword">new</span> <span class="built_in">Date</span>(date).getDate() - <span class="number">0.5</span>) / xRange * (width - xBias)</span><br><span class="line">      <span class="keyword">const</span> y = (<span class="number">1</span> - data[date].length / yRange) * <span class="number">160</span> + yBias</span><br><span class="line">      <span class="comment">// 这里需要返回一个 [x, y, 一个数] 是为了 Tooltip 做兼容用的</span></span><br><span class="line">      <span class="keyword">return</span> [x, y, data[date].length]</span><br><span class="line">    &#125;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="项目难点"><a href="#项目难点" class="headerlink" title="项目难点"></a>项目难点</h2><p>项目难点有 2</p>
<h3 id="使用-svg-矢量图的大小缩放的问题"><a href="#使用-svg-矢量图的大小缩放的问题" class="headerlink" title="使用 svg 矢量图的大小缩放的问题"></a>使用 svg 矢量图的大小缩放的问题</h3><p><img src="./4.png" alt></p>
<p>因为在项目中还稍微用媒体查询做了下小屏幕的适配，但是在小屏幕适配下图形就显得不是很好看了，为了兼容这个小屏幕，花了点心思，首先使用 <code>css</code> 这种自适应适配的方式是不行的，不管是 <code>flex</code> 还是 <code>100%</code> 这种方式都不能使其适应小屏幕的宽度，所以最后采用 js 来解决，怎么解决的呢，一般来说分为以下几步</p>
<ul>
<li>获取到其中一个 <code>li</code> 的宽度<br>  因为其实三个宽度都一样，只要获取到其中一个就可以了</li>
<li>将其加入点坐标的计算</li>
<li>完</li>
</ul>
<p>加入点坐标计算上面已经说过了，现在说下宽度是怎么搞的</p>
<p>首先在 <code>statistics</code> 组件中引入两个变量</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/components/statistics/statistics.tsx</span></span><br><span class="line"><span class="keyword">this</span>.state = &#123;</span><br><span class="line">  liWidth: <span class="keyword">this</span>.liRef.current?.offsetWidth || <span class="number">0</span>,</span><br><span class="line">  ulWidth: <span class="keyword">this</span>.ulRef.current?.offsetWidth || <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对应的 <code>liRef</code> 和 <code>ulRef</code> 为</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">ulRef = React.createRef&lt;HTMLUListElement&gt;()</span><br><span class="line">liRef = React.createRef&lt;HTMLLIElement&gt;()</span><br></pre></td></tr></table></figure>
<p>然后需要设定一个 <code>updateSize</code> 函数，就是当其宽度变时就要调用的</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">updateSize = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> liWidth = <span class="keyword">this</span>.liRef.current?.offsetWidth || <span class="number">0</span></span><br><span class="line">  <span class="keyword">let</span> ulWidth = <span class="keyword">this</span>.ulRef.current?.offsetWidth || <span class="number">0</span></span><br><span class="line">  ulWidth &lt; <span class="number">0</span> &amp;&amp; (ulWidth = <span class="number">0</span>)</span><br><span class="line">  <span class="keyword">this</span>.state.liWidth !== liWidth &amp;&amp; (</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; liWidth &#125;)</span><br><span class="line">  )</span><br><span class="line">  <span class="keyword">this</span>.state.ulWidth !== ulWidth &amp;&amp; (</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; ulWidth &#125;)</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到其实这里就是初始化的操作，利用 dom 的 <code>current.offsetWidth</code> 的属性确定宽度</p>
<p>然后在组件挂载时需要监听 <code>resize</code> 事件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">componentDidMount() &#123;</span><br><span class="line">  <span class="keyword">this</span>.updateSize()</span><br><span class="line">  <span class="built_in">window</span>.addEventListener(<span class="string">'resize'</span>, <span class="keyword">this</span>.updateSize)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在组件销毁时需要取消监听 <code>resize</code> 事件避免内存泄露</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">componentWillUnmount() &#123;</span><br><span class="line">  <span class="built_in">window</span>.removeEventListener(<span class="string">'resize'</span>, <span class="keyword">this</span>.updateSize)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后在把这两个 <code>ref</code> 定位到对应的 dom 上即可</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">className</span>=<span class="string">"statistics"</span> <span class="attr">ref</span>=<span class="string">&#123;this.ulRef&#125;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">className</span>=<span class="string">&#123;monthlyTitleClasses&#125;</span> <span class="attr">ref</span>=<span class="string">&#123;this.liRef&#125;</span> /&gt;</span></span><br><span class="line">  ...</span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure>
<p>这样通过 <code>resize</code> 就拿到了该组件的 <code>width</code>，在下面计算图形的宽度时就可以代入加参数计算了，一般来说这里就是计算一个 range 即可。</p>
<h3 id="有关一个组件通信的功能"><a href="#有关一个组件通信的功能" class="headerlink" title="有关一个组件通信的功能"></a>有关一个组件通信的功能</h3><p>就是西瓜闹钟在运行时，本来是想让 <code>waterMelon</code> 组件和 <code>todos</code> 组件有个通信的过程的，比如将正在计时中的 <code>waterMelon</code> 和 <code>todos</code> 关联起来，如果此时有完成的 <code>todos</code> 任务，那么在计时后，完成的 <code>todos</code> 几个任务的 “合体” <code>description</code> 就是西瓜闹钟的 <code>description</code>，比如我完成了 <code>todo1</code> 和 <code>todo2</code> 和 <code>todo3</code>，那么在 <code>watermelon</code> 结束计时后其 <code>description</code> 就是 <code>todo1 + todo2 + todo3</code> 这种形式做自动填充。不过这个地方有些难度，主要在于代码实现比较难看所以我没继续添加了。我想了下有几种方案</p>
<ol>
<li>每次完成一个 <code>todos</code>，都向后端发送一个请求记录当前的 <code>todos</code> 到 <code>waterMelon</code> 中</li>
<li>将 <code>todos</code> 的数据用 <code>props</code> 传给 <code>waterMelon</code> 组件，只要 <code>todos</code> 有变化就改变 <code>waterMelon</code> 中的 <code>state.description</code></li>
<li>将 <code>description</code> 提升到 <code>redux</code> 中，每次完成一个 <code>todos</code>，发送一个 <code>actionType</code>，<code>waterMelon</code> 接受这个并不属于它的 <code>actionType</code>，将 <code>todo</code> 的 <code>description</code> 合并到 <code>waterMelon</code> 中</li>
<li>搞一个 window 全局变量存 <code>description</code>…</li>
</ol>
<p>首先我想要说明的是，这里我尽量想做到 <strong>高内聚低耦合</strong>，然而这里的尴尬之处在于要实现这样的功能，这两个组件在这点上居然是强耦合的，以致于说以上的方案虽然可行一点点，但是在代码上就非常的不整洁，因为</p>
<ol>
<li>每次发请求处理相当的麻烦，而且也不是一种优化，要知道请求一多也容易降低 app 的性能</li>
<li>这样做只能是在 <code>componentDidUpdate</code> 这个生命周期里面来 <code>setState</code>，处理一不小心就无限循环了，这还能行???</li>
<li>这样也不好，耦合了，而且这个功能并不是一开始就想出来的，而是后面加的，如果要该则需要改动代码的范围大，只能是重构有时间的情况下弄弄。代码一旦庞大就不好出手了，这也是很重要的一点。</li>
<li>这个想都不要想，全局变量污染的问题不应该再犯了…</li>
</ol>
<p>综上，由于这个功能十分的的蛋疼(因为点击完成一个 todo 既要更新 <code>todos</code> 的数据又要更新 <code>waterMelon</code> 的数据简单使用 <code>actionType</code> 来做区分是不现实的)，而且目前也没有找到一个更加优雅的解决方案，故先搁置(或许如果各位感兴趣了我可以重构的((<em>^_^</em>)), 先别慌老铁)</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总之 TypeScript 是真香，少了自由度但是多了类型检查，能够不太费力的解决编程中因为静态视力导致的一些超级低级的 bug，以及 react 也真香，函数即UI这种思想很棒，而且天然支持 TypeScript，社区活跃并且轮子很多，也不乏优秀的插件，也许这就是是我转向 react 的原因之一吧哈哈。</p>
<h2 id="文档参考"><a href="#文档参考" class="headerlink" title="文档参考"></a>文档参考</h2><p><a href="https://ant.design/docs/react/use-in-typescript-cn" target="_blank" rel="noopener">在 TypeScript 中使用</a><br><a href="https://ant.design/docs/react/migration-v4-cn" target="_blank" rel="noopener">从 V3 到 V4</a></p>
]]></content>
      <categories>
        <category>TypeScript</category>
        <category>React</category>
      </categories>
      <tags>
        <tag>TypeScript</tag>
        <tag>React</tag>
        <tag>WaterMelon-clock</tag>
      </tags>
  </entry>
  <entry>
    <title>txios-基于TypeScript的http库的实践总结</title>
    <url>/2020/03/14/txios-%E5%9F%BA%E4%BA%8ETypeScript%E7%9A%84http%E5%BA%93%E7%9A%84%E5%AE%9E%E8%B7%B5%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<blockquote>
<p>本次项目是对自己用 TypeScript 造的一个轮子的总结，麻雀虽小，但已经尽量五脏俱全，希望各位能多多 star(摩多摩多~)，<a href="https://github.com/strugglebak/txios" target="_blank" rel="noopener">毕竟项目地址都在这儿了各位 QAQ</a></p>
</blockquote>
<a id="more"></a>
<h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><h3 id="使用的工具库"><a href="#使用的工具库" class="headerlink" title="使用的工具库"></a>使用的工具库</h3><p>这里罗列下使用到的一些工具库吧</p>
<ul>
<li><p>rollupjs</p>
<p>  这是一个帮助 txios 项目打包的库，打包方面没有选择 Webpack 的原因是因为这个比较好配置, <strong>API 简单</strong>。并且由于其<strong>基于 ES2015 模块</strong>，比 Webpack 使用的 CommonJS 模块机制更加高效，同时也更加容易执行 <strong><code>tree-shaking</code></strong></p>
</li>
<li><p>prettier/tslint</p>
<p>  这两个是比较重要的代码风格检查工具库了，在写一些工具库的时候尤其需要注意配合使用的</p>
</li>
<li><p>typeDoc</p>
<p>  文档生成工具，毕竟写一个库需要自动生成文档给开发者看，并且这个库也能帮忙部署到 Github page 上</p>
</li>
<li><p>commitizen</p>
<p>  主要用来规范 commit 提交信息，这个是很有好处的，清晰和规范的提交可以看出你对修改过的文件做了什么，这个是很重要的</p>
</li>
<li><p>Semantic-release</p>
<p>  这个库主要用来处理自动化版本管理和包发布用的。</p>
</li>
<li><p>husky</p>
<p>  使用这个工具，可以在每次的 git commit 之前执行已经定义好的 hook 脚本，可以用来自动化的检查代码质量</p>
</li>
<li><p>conventional-changelog</p>
<p>  当写完一个工具库，你做了啥修改，使用这个配合 Commitizen ，在生成 release 包时会自动将你所修改的 changeLog 发布出来</p>
</li>
<li><p>jest</p>
<p>  著名的测试工具库，主要是用于一些工具库或者 UI 组件库的测试。一般而言是配合 <code>chai</code>、<code>sion</code> 使用</p>
</li>
</ul>
<blockquote>
<p>⚠: 1.如果搭建环境过程中碰到了 <code>permission denied</code> 之类的字样，请<strong>关闭 vscode 试试</strong></p>
</blockquote>
<blockquote>
<p>⚠: 2.如果在项目中执行 <code>semantic-release</code> 时遇到了类似这样的错误 <code>SemanticReleaseError: No GitHub token specified</code>，请首先去你的 github 账号的 settings 那里的 Developer settings 里新建一个 Personal access tokens ( <a href="https://strugglebak.github.io/2020/03/11/%E9%85%8D%E7%BD%AE%E4%BB%A3%E7%A0%81%E8%A6%86%E7%9B%96%E7%8E%87%E5%BE%BD%E6%A0%87%E7%9A%84%E9%97%AE%E9%A2%98/">具体可参考我写的一篇博客</a> )，然后再到<strong>本地</strong>执行 <code>export GITHUB_TOKEN=&quot;你的 token&quot;</code>，最后再执行 <code>semantic-release</code> 即可。我想了下这可能是由于 <code>semantic-release</code> 是读取系统当前用户的环境变量所导致的，本地的 travis 并没有将其设置进环境变量中，而只是设置到项目的 <code>.travis.yml</code> 配置文件中了</p>
</blockquote>
<h3 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h3><p>一般来说，这里是先建立 <code>src</code> 以及 <code>test</code> 文件夹，<code>src</code> 就存放源码部分，<code>test</code> 就存放测试代码部分, <code>examples</code> 就存放代码的用例，当然这个用例跟测试用例是不一样的，这个只是方便写出了功能做调试用。你可以理解为 <code>examples</code> 就是这个库的一个应用了，可以在 <code>examples</code> 目录下新建一个 <code>webpack.config.js</code>，里面利用 webpack 的 <code>HotModuleReplacementPlugin</code> 插件建立模块热替换，当更改了模块之后就可以进行局部更新了。</p>
<p>这里还要强调的部分是对 <code>entry</code> 做了处理，因为 <code>examples</code> 下面有多个 demo 目录，而每个 demo 目录下都有 <code>app.ts</code> 文件作为这个 webpack 的入口文件, 因此 <code>entries</code> 需要收集 <code>examples</code> 下的这些个 <code>app.ts</code>，因为每个入口又引入了一个用于热更新的文件，所以看到的 <code>entry</code> 的配置基本如下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"></span><br><span class="line">entry: fs.readdirSync(__dirname).reduce(<span class="function">(<span class="params">entries, dir</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> fullDir = path.join(__dirname, dir);</span><br><span class="line">  <span class="keyword">const</span> entryFile = path.join(fullDir, <span class="string">'app.ts'</span>);</span><br><span class="line">  <span class="keyword">if</span> (fs.statSync(fullDir).isDirectory() &amp;&amp; fs.existsSync(entryFile)) &#123;</span><br><span class="line">    entries[dir] = [<span class="string">'webpack-hot-middleware/client'</span>, entryFile];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> entries;</span><br><span class="line">&#125;, &#123;&#125;),</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>而基本上可以看到这里就是典型的多入口配置，代码的逻辑其实很简单</p>
<ul>
<li>读取当前目录下的各个 demo 目录的 <code>app.ts</code></li>
<li>构建诸如 <code>{&#39;demo&#39;: [&#39;webpack-hot-middleware/client&#39;, &#39;./demo/app.ts&#39;]}</code> 这样的 <code>entries</code> 对象</li>
<li>返回这个 <code>entries</code> 对象</li>
</ul>
<p>那么为何要加上这个 <code>webpack-hot-middleware/client</code> 呢？先别急，我们先在 <code>examples</code> 目录下构建这样一个 <code>server.js</code> 文件，然后引入 <code>webpack</code> 以及 <code>webpack.config.js</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>);</span><br><span class="line"><span class="keyword">const</span> middleware = <span class="built_in">require</span>(<span class="string">'webpack-dev-middleware'</span>);</span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>);</span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"><span class="keyword">const</span> complier = webpack(webpackConfig);</span><br><span class="line"></span><br><span class="line">app.use(</span><br><span class="line">  middleware(compiler, &#123;</span><br><span class="line">    <span class="comment">// webpack-dev-middleware options</span></span><br><span class="line">  &#125;)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>, () =&gt; <span class="built_in">console</span>.log(<span class="string">'Example app listening on port 3000!'</span>));</span><br></pre></td></tr></table></figure>
<p>这里我们是通过 <code>node server.js</code> 来启动这个应用，然后引入 <code>webpack</code> 以及 <code>webpack.config.js</code> 来打包这个应用，然而这里我们还要引入一个包叫 <code>webpack-hot-middleware</code>，如果需要做热更新的话，需要在每个入口文件处引入 <code>hot middleware client</code>，具体的做法就是上面说的，在入口文件处添加 <code>webpack-hot-middleware/client</code> 就好</p>
<p>添加完后，在 <code>server.js</code> 中添加</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> webpackHotMiddleware = <span class="built_in">require</span>(<span class="string">'webpack-hot-middleware'</span>);</span><br><span class="line">...</span><br><span class="line">app.use(webpackHotMiddleware(complier));</span><br></pre></td></tr></table></figure>
<p><code>examples</code> 目录下应用 <code>demo</code> 的目录基本是这样的形式，<code>demo</code> 有两个文件</p>
<ul>
<li><code>app.ts</code></li>
<li><code>index.html</code></li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// demo/app.ts</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> txios <span class="keyword">from</span> <span class="string">'../../src/index'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行 txios 相关的操作</span></span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">// demo/index.html</span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Demo example<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  // 注意这里引入了生成好的 demo.js，也就是被编译好的当前目录下的 app.ts !!!</span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"/__build__/demo.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="其他工具的配置"><a href="#其他工具的配置" class="headerlink" title="其他工具的配置"></a>其他工具的配置</h3><p>说几个比较重要的</p>
<h4 id="非工作流工具配置"><a href="#非工作流工具配置" class="headerlink" title="非工作流工具配置"></a>非工作流工具配置</h4><ul>
<li><p>编辑器的配置，用于规范团队代码、文档在 vscode 上的统一编辑以及显示的 <code>.editorconfig</code></p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// .editorconfig</span><br><span class="line"><span class="comment">#root = true</span></span><br><span class="line">[*] <span class="comment"># 表示匹配所有文件</span></span><br><span class="line">end_of_line = lf <span class="comment">#  当一行文字被回车时，对应的回车字符为 lf</span></span><br><span class="line">charset = utf-8 <span class="comment"># 使用 utf-8 编码</span></span><br><span class="line">trim_trailing_whitespace = <span class="literal">false</span> <span class="comment"># 不从行尾删除空白</span></span><br><span class="line">insert_final_newline = <span class="literal">true</span> <span class="comment"># 文件以换行结束</span></span><br><span class="line">indent_style = space <span class="comment"># 以空格作为 tab</span></span><br><span class="line">indent_size = 2 <span class="comment"># tab 间距为 2 个 space 宽度</span></span><br><span class="line"></span><br><span class="line">[&#123;*.yml,*.json&#125;] <span class="comment"># 匹配 .yml .json 文件</span></span><br><span class="line">indent_style = space <span class="comment"># 以空格作为 tab</span></span><br><span class="line">indent_size = 2 <span class="comment"># tab 间距为 2 个 space 宽度</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>检查正在编辑的代码的语法的 <code>.eslintrc</code></p>
  <figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">// .eslintrc</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"parserOptions"</span>: &#123; <span class="comment">// 解析选项</span></span><br><span class="line">    <span class="attr">"ecmaVersion"</span>: <span class="number">2017</span> <span class="comment">// 使用 es2017</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"env"</span>: &#123;</span><br><span class="line">    <span class="attr">"es6"</span>: <span class="literal">true</span> <span class="comment">// 支持 es6 以及新的 es6 全局变量</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>用于检查编写的 js 代码中的可疑部分的 <code>.jshintrc</code></p>
  <figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">// .jshitrc</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"esversion"</span>: <span class="number">6</span> <span class="comment">// 指定代码必须遵循 es6 版本</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>用于指定 TypeScript 编译选项的 <code>tsconfig.json</code></p>
  <figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">// tsconfig.json</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"compilerOptions"</span>: &#123; <span class="comment">// 编译选项配置</span></span><br><span class="line">    <span class="attr">"moduleResolution"</span>: <span class="string">"node"</span>, <span class="comment">// 以 Nodejs 方式 resolve 模块</span></span><br><span class="line">    <span class="attr">"target"</span>: <span class="string">"es5"</span>, <span class="comment">// 指定 es 的目标版本，其默认是 es3</span></span><br><span class="line">    <span class="attr">"module"</span>:<span class="string">"es2015"</span>, <span class="comment">// 指定模块代码以 es2015 的方式生成</span></span><br><span class="line">    <span class="attr">"lib"</span>: [<span class="string">"es2015"</span>, <span class="string">"es2016"</span>, <span class="string">"es2017"</span>, <span class="string">"dom"</span>], <span class="comment">// 指定要包含在编译中的库文件列表(编译时要包含进 es5/6/7 以及 DOM 的一些 API)</span></span><br><span class="line">    <span class="attr">"strict"</span>: <span class="literal">true</span>, <span class="comment">// 启用所有的严格类型检查选项</span></span><br><span class="line">    <span class="attr">"sourceMap"</span>: <span class="literal">true</span>, <span class="comment">// 编译后要生成 .map 源码映射文件</span></span><br><span class="line">    <span class="attr">"declaration"</span>: <span class="literal">true</span>, <span class="comment">// 编译后要生成 .d.ts 声明文件</span></span><br><span class="line">    <span class="attr">"allowSyntheticDefaultImports"</span>: <span class="literal">true</span>, <span class="comment">// 默认允许 import 那些没有进行 default export 的模块(这不影响代码的 export，只是会影响到类型检查)</span></span><br><span class="line">    <span class="attr">"experimentalDecorators"</span>: <span class="literal">true</span>, <span class="comment">// 启用对 es 装饰器语法的支持</span></span><br><span class="line">    <span class="attr">"emitDecoratorMetadata"</span>: <span class="literal">true</span>, <span class="comment">// 启用对 reflect-metadata 库的支持</span></span><br><span class="line">    <span class="attr">"declarationDir"</span>: <span class="string">"dist/types"</span>, <span class="comment">// 定义编译后生成的声明文件的输出目录为 dist/types</span></span><br><span class="line">    <span class="attr">"outDir"</span>: <span class="string">"dist/lib"</span>, <span class="comment">// 定义编译后代码文件的输出目录为 dist/lib</span></span><br><span class="line">    <span class="attr">"typeRoots"</span>: [ <span class="comment">// 编译过程中只考虑编译 node_modules/@types 下的包</span></span><br><span class="line">      <span class="string">"node_modules/@types"</span></span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"include"</span>: [ <span class="comment">// 只编译 src 下的源码文件</span></span><br><span class="line">    <span class="string">"src"</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>用于检查编写的 ts 代码中可读性、可维护性和功能错误的 <code>tslint.json</code></p>
  <figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">// tslint.json</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"extends"</span>: [ <span class="comment">// 指定使用 tslint-config-standard 和 tslint-config-prettier 来检查</span></span><br><span class="line">    <span class="string">"tslint-config-standard"</span>,</span><br><span class="line">    <span class="string">"tslint-config-prettier"</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>用于测试代码的 <code>jest.config.js</code></p>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// jest.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="string">"verbose"</span>: <span class="literal">true</span>, <span class="comment">// 指定在运行期间需要报告测试结果</span></span><br><span class="line">  <span class="string">"transform"</span>: &#123; <span class="comment">// 转换器</span></span><br><span class="line">    <span class="string">".(ts|tsx)"</span>: <span class="string">"ts-jest"</span> <span class="comment">// 使用 ts-jest 对 .ts/.tsx 文件代码进行测试</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"testEnvironment"</span>: <span class="string">"jsdom"</span>, <span class="comment">// 使用 jsdom 来作为测试环境</span></span><br><span class="line">  <span class="string">"testRegex"</span>: <span class="string">"(/__tests__/.*|\\.(test|spec))\\.(ts|tsx|js)$"</span>, <span class="comment">// 测试 __test__ 目录下所有的以 .test/.spec 作为中间名的、以 .ts/.tsx/.js 结尾的文件</span></span><br><span class="line">  <span class="string">"moduleFileExtensions"</span>: [ <span class="comment">// 模块文件拓展，测试文件中引入的模块支持 .ts/.tsx/.js 模块</span></span><br><span class="line">    <span class="string">"ts"</span>,</span><br><span class="line">    <span class="string">"tsx"</span>,</span><br><span class="line">    <span class="string">"js"</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="string">"coveragePathIgnorePatterns"</span>: [ <span class="comment">// 执行测试时需要过滤掉的一些目录 node_modules 和 test</span></span><br><span class="line">    <span class="string">"/node_modules/"</span>,</span><br><span class="line">    <span class="string">"/test/"</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="string">"coverageThreshold"</span>: &#123; <span class="comment">// 代码测试覆盖率设定</span></span><br><span class="line">    <span class="string">"global"</span>: &#123; <span class="comment">// 指定一个全局的设定</span></span><br><span class="line">      <span class="string">"branches"</span>: <span class="number">90</span>, <span class="comment">// 测试能覆盖到 90% 的代码分支</span></span><br><span class="line">      <span class="string">"functions"</span>: <span class="number">95</span>, <span class="comment">// 测试能覆盖到 95% 的函数</span></span><br><span class="line">      <span class="string">"lines"</span>: <span class="number">95</span>, <span class="comment">// 测试能覆盖到 95% 的代码行数</span></span><br><span class="line">      <span class="string">"statements"</span>: <span class="number">95</span> <span class="comment">// 测试能覆盖到 95% 的声明</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"collectCoverageFrom"</span>: [ <span class="comment">// 从以下文件中收集测试代码覆盖率的信息</span></span><br><span class="line">    <span class="string">"src/*.&#123;js,ts&#125;"</span>, <span class="comment">// src 下的当前目录的 .js 或者 .ts 文件</span></span><br><span class="line">    <span class="string">"src/**/*.&#123;js,ts&#125;"</span> <span class="comment">// src 下的子目录的 .js 或者 .ts 文件</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="string">"setupFilesAfterEnv"</span>: [ <span class="comment">// 在测试之前需要运行的一些启动或者配置文件</span></span><br><span class="line">    <span class="string">"&lt;rootDir&gt;/test/boot.ts"</span> <span class="comment">// 项目根目录下的 test/boot.ts</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  在 <code>boot.ts</code> 中写了什么呢</p>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// test/boot.ts</span></span><br><span class="line"><span class="keyword">const</span> JasmineCore = <span class="built_in">require</span>(<span class="string">'jasmine-core'</span>)</span><br><span class="line"><span class="comment">// @ts-ignore</span></span><br><span class="line">global.getJasmineRequireObj = <span class="function"><span class="params">()</span> =&gt;</span> JasmineCore</span><br><span class="line"><span class="built_in">require</span>(<span class="string">'jasmine-ajax'</span>)</span><br></pre></td></tr></table></figure>
<p>  因为这里需要测试 ajax，所以这里用到了 <code>jasmine-ajax</code>，而这个库依赖于 <code>jasmine-core</code>。而为了能让 <code>jasmine-ajax</code> 这个插件运行成功，需要手动添加全局的 <code>getJasmineRequireObj</code> 方法，这样每次在启动测试的时候都会去加载这个插件，那么在测试时就可以使用 <code>jasmine-ajax</code> 了</p>
</li>
<li><p>用于整理和打包库的 <code>rollup.config.js</code></p>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// rollup.config.js</span></span><br><span class="line"><span class="keyword">import</span> resolve <span class="keyword">from</span> <span class="string">'rollup-plugin-node-resolve'</span></span><br><span class="line"><span class="keyword">import</span> commonjs <span class="keyword">from</span> <span class="string">'rollup-plugin-commonjs'</span></span><br><span class="line"><span class="keyword">import</span> sourceMaps <span class="keyword">from</span> <span class="string">'rollup-plugin-sourcemaps'</span></span><br><span class="line"><span class="keyword">import</span> camelCase <span class="keyword">from</span> <span class="string">'lodash.camelcase'</span></span><br><span class="line"><span class="keyword">import</span> typescript <span class="keyword">from</span> <span class="string">'rollup-plugin-typescript2'</span></span><br><span class="line"><span class="keyword">import</span> json <span class="keyword">from</span> <span class="string">'rollup-plugin-json'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> pkg = <span class="built_in">require</span>(<span class="string">'./package.json'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> libraryName = <span class="string">'txios'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  input: <span class="string">`src/index.ts`</span>, <span class="comment">// 入口文件</span></span><br><span class="line">  output: [ <span class="comment">// 出口文件</span></span><br><span class="line">    <span class="comment">// 一个用来打包成 umd</span></span><br><span class="line">    &#123; <span class="attr">file</span>: pkg.ain, <span class="attr">name</span>: camelCase(libraryName), <span class="attr">format</span>: <span class="string">'umd'</span>, <span class="attr">sourcemap</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">    <span class="comment">// 一个用来打包成 es5</span></span><br><span class="line">    &#123; <span class="attr">file</span>: pkg.module, <span class="attr">format</span>: <span class="string">'es'</span>, <span class="attr">sourcemap</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">  ],</span><br><span class="line">  <span class="comment">// 指定不会被打包的源码目录</span></span><br><span class="line">  external: [],</span><br><span class="line">  watch: &#123; <span class="comment">// 如果 include 配置下的 src/ 目录下的某个模块源码变更，则自动进行打包</span></span><br><span class="line">    include: <span class="string">'src/**'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [ <span class="comment">// rollup 插件</span></span><br><span class="line">    <span class="comment">// 允许 resolve json 文件</span></span><br><span class="line">    json(),</span><br><span class="line">    <span class="comment">// 编译 TypeScript 文件</span></span><br><span class="line">    <span class="comment">// 并且编译的声明文件将在 tsconfig 中指定的目录中发出</span></span><br><span class="line">    typescript(&#123; <span class="attr">useTsconfigDeclarationDir</span>: <span class="literal">true</span> &#125;),</span><br><span class="line">    <span class="comment">// 允许打包 commonjs 模块</span></span><br><span class="line">    commonjs(),</span><br><span class="line">    <span class="comment">// 允许 resolve node_modules 下的文件，可以使用 'external' 属性去控制</span></span><br><span class="line">    <span class="comment">// 哪个 external 模块是被包含进打包后的文件中的</span></span><br><span class="line">    <span class="comment">// https://github.com/rollup/rollup-plugin-node-resolve#usage</span></span><br><span class="line">    resolve(),</span><br><span class="line"></span><br><span class="line">    <span class="comment">// resolve 对应源码的源码映射文件</span></span><br><span class="line">    sourceMaps(),</span><br><span class="line">  ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="工作流工具配置"><a href="#工作流工具配置" class="headerlink" title="工作流工具配置"></a>工作流工具配置</h4><p>最后再讲讲这个 git commit 以及自动发布 release 如何形成一个 flow 流的。首先我们前面提到了几个工具</p>
<ul>
<li>husky</li>
<li>commitizen</li>
<li>jest</li>
<li>conventional-changelog</li>
<li>semantic-release</li>
</ul>
<p>然后看看 <code>package.json</code> 里面是怎么写的，几个相关的配置如下</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">// package.json</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="attr">"scripts"</span>: &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="attr">"test"</span>: <span class="string">"jest --coverage --config ./jest.config.js"</span>,</span><br><span class="line">    <span class="attr">"test:watch"</span>: <span class="string">"jest --coverage --watch --config ./jest.config.js"</span>,</span><br><span class="line">    <span class="attr">"test:prod"</span>: <span class="string">"npm run lint &amp;&amp; npm run test -- --no-cache"</span>,</span><br><span class="line">    <span class="attr">"commit"</span>: <span class="string">"git-cz"</span>,</span><br><span class="line">    <span class="attr">"sr"</span>: <span class="string">"semantic-release"</span>,</span><br><span class="line">    <span class="attr">"srp"</span>: <span class="string">"ts-node tools/semantic-release-prepare"</span>,</span><br><span class="line">    <span class="attr">"pre-commit"</span>: <span class="string">"lint-staged"</span>,</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"lint-staged"</span>: &#123;</span><br><span class="line">    <span class="attr">"&#123;src,test&#125;/**/*.ts"</span>: [</span><br><span class="line">      <span class="string">"prettier --write"</span>,</span><br><span class="line">      <span class="string">"git add"</span></span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"husky"</span>: &#123;</span><br><span class="line">    <span class="attr">"hooks"</span>: &#123;</span><br><span class="line">      <span class="attr">"commit-msg"</span>: <span class="string">"commitlint -E HUSKY_GIT_PARAMS"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"config"</span>: &#123;</span><br><span class="line">    <span class="attr">"commitizen"</span>: &#123;</span><br><span class="line">      <span class="attr">"path"</span>: <span class="string">"node_modules/cz-conventional-changelog"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"prettier"</span>: &#123;</span><br><span class="line">    <span class="attr">"semi"</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">"singleQuote"</span>: <span class="literal">true</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"commitlint"</span>: &#123;</span><br><span class="line">    <span class="attr">"extends"</span>: [</span><br><span class="line">      <span class="string">"@commitlint/config-conventional"</span></span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当 <code>src</code> 下或者 <code>test</code> 目录下的代码文件产生变动后，执行 <code>yarn commit</code>时 ，会先触发 <code>lint-staged</code><br>，<code>lint-staged</code> 里面会先执行 <code>prettier</code> 将代码进行格式化，然后执行 <code>git add</code>。这个执行完之后，就可以执行 <code>git-cz</code> 了，<code>git-cz</code> 是 <code>commitizen</code> 包里面的一个工具，它就会找到 <code>cz-cli</code> 以及 <code>cz-conventional-changelog</code> 这两个工具并执行，执行后会生成如下的命令行界面</p>
<p><img src="./1.png" alt></p>
<p>格式都做好了，其他的就是自己选择自己根据提示来 commit message 就好</p>
<p>在输入的信息完成之后，就会交给 <code>husky</code> 去拦截 git 的 hooks，它一旦发现有 <code>commit msg</code> 要提交了就去拦截，然后执行操作 <code>commitlint -E HUSKY_GIT_PARAMS</code>，<code>commitlint</code> 是一个检查 <code>commit msg</code> 是否符合要求的一个库，这句话的意思是通过 <code>commitlint</code> 这个工具与它自己定义的 <code>HUSKY_GIT_PARAMS</code> 变量结合起来，若 commit 不符合要求，则此次 commit 算作失败</p>
<p>一般而言，符合 <code>commitlint</code> 要求的 commit 是像下面这样的</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">chore: run tests on travis ci</span><br><span class="line">fix(server): send cors headers</span><br><span class="line">feat(blog): add comment section</span><br></pre></td></tr></table></figure>
<p>其实这些都是根据 <a href="https://www.conventionalcommits.org/en/v1.0.0/" target="_blank" rel="noopener">传统提交格式</a> 来的。</p>
<p>总结一下这个工作流，简单而言就是如下</p>
<ol start="0">
<li>代码变更了，我要提交代码，执行 <code>yarn commit</code></li>
<li><code>lint-staged</code> –&gt; <code>prettier</code> –&gt; <code>git add</code>(格式化代码)</li>
<li><code>git-cz</code> –&gt; <code>cz-cli</code> –&gt; <code>cz-conventional-changelog</code>(生成选择 commit 格式的界面并记录 changelog)</li>
<li><code>husky</code>(提供 commit 钩子并触发 <code>commitlint</code>)</li>
<li><code>commitlint</code>(检查 commit 是否满足要求)</li>
</ol>
<p>对于发布一个 release 包而言，其实逻辑都差不多。在执行 <code>yarn sr</code> 时，会执行 <code>semantic-release</code>，这里不做配置会直接校验 npm 的 token 和 github 的 token，校验过后它就会分析你的 commit 然后生成一个 changelog 并上传至 github 。如果想在这条命令之前执行代码测试直接在前面加上 <code>yarn test</code> 即可</p>
<h2 id="Feature-实现"><a href="#Feature-实现" class="headerlink" title="Feature 实现"></a>Feature 实现</h2><p>这里就大体实现的有一些功能做个总结吧。在 <a href="https://github.com/strugglebak/txios/blob/master/README.md" target="_blank" rel="noopener">txios 的文档</a> 上也有说明</p>
<ul>
<li>支持使用 XMLHttpRequest 对象通信</li>
<li>支持 Promise API</li>
<li>支持请求/响应拦截以及其过程中的数据转换</li>
<li>支持取消请求</li>
<li>支持自动转换 JSON 数据</li>
<li>客户端支持 XSRF 防御</li>
</ul>
<h3 id="支持使用-XMLHttpRequest-对象通信"><a href="#支持使用-XMLHttpRequest-对象通信" class="headerlink" title="支持使用 XMLHttpRequest 对象通信"></a>支持使用 XMLHttpRequest 对象通信</h3><p>其实这里面就是对 <code>XMLHttpRequest</code> 对象的封装。这里整体封装的逻辑是，先写一个大体的逻辑，就是封装一个函数，然后再在其他地方引入这个函数做测试。这个大体的框架是什么呢，就是如下的代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">xhr</span>(<span class="params">config: TxiosRequestConfig</span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; data = <span class="literal">null</span>, url, method = <span class="string">'get'</span> &#125; = config</span><br><span class="line">  <span class="keyword">const</span> request = <span class="keyword">new</span> XMLHttpRequest()</span><br><span class="line">  request.open(method.toUpperCase(), url, <span class="literal">true</span>)</span><br><span class="line">  request.send(data)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最开始其只有一个 <code>open</code> 跟 <code>send</code>，功能极为简陋，所以需要在上面添砖加瓦。<br>一般来说需要处理的东西包括</p>
<ul>
<li>请求的 url 数据</li>
<li>请求的 body 数据</li>
<li>请求的 header 数据</li>
<li>响应的数据</li>
<li>响应的 header 数据</li>
</ul>
<p>所以在这里面，除了要对请求的数据做处理之外，还需要对响应的数据做处理。这一部分主要的操作就是需要定义 <code>TxiosRequestConfig</code> 的类型，因为请求配置的参数很重要，所以在这里可以看到一堆的类型声明。这里有一个比较特别的声明叫做 <strong>字符串索引</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/types/index.ts</span></span><br><span class="line"><span class="keyword">export</span> interface TxiosRequestConfig &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  [propName: string]: any</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种就是字符串索引签名了，一般会在 <code>xxx[key]</code> 这种方式去访问一个对象内部 <code>key</code> 对应的 <code>value</code> 时用上。</p>
<p>这里需要注意的一下就是，在对处理请求的 body 数据时(因为要转换成 JSON 字符串发送出去)，会用到一个判断其是不是”普通”的对象的函数，如下所式</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">isNormalObject</span> (<span class="params">val: any</span>): <span class="title">val</span> <span class="title">is</span> <span class="title">Object</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> toString.call(val) === <span class="string">'[object Object]'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于 <code>val !== null &amp;&amp; typeof val === &#39;object&#39;</code> 这种方式虽然也能判断一个数是否为对象，但是其已经包括了 <code>FormData</code> 或者 <code>ArrayBuffer</code> 这样的类型了。而这些类型在 body 中是不需要处理成 JSON 字符串的(<code>JSON.stringify</code>)，如果是 <code>FormData</code> 类似这种类型的直接返回 data 就好不需要做处理</p>
<p>在处理 url 参数上需要注意的情况比较多，一般而言有如下几种</p>
<ul>
<li>参数值为数组的</li>
<li>参数值为对象的</li>
<li>参数值为 Date 类型的</li>
<li>还有一些特殊字符的</li>
<li>一些空值如 null 或者 undefined</li>
<li>有 hash 参数的比如 # 后面的</li>
<li>已经有参数的</li>
</ul>
<p>需要对这些参数遍历之后重新建立新的 url，对这些条件判断后拼接字符串</p>
<p>在对异常处理的方面，有两个要注意的点</p>
<ul>
<li>使用 TypeScript 继承一个内置对象时，需要使用在你继承的类中使用 <code>Object.setPrototypeOf(this, 你的类.prototype)</code> 才能做到正确的继承</li>
<li>为了使得代码更加简化，可以为类对外暴露一个 <strong>工厂方法</strong></li>
</ul>
<p>什么是工厂方法？工厂方法指的是<strong>一个函数</strong>接受参数并返回一个 <code>new</code> 过的对象，这样在下次使用时就不必频繁的 <code>new</code> 了，直接调用这个方法即可</p>
<h3 id="支持-Promise-API"><a href="#支持-Promise-API" class="headerlink" title="支持 Promise API"></a>支持 Promise API</h3><p>首先需要构建一个 <code>TxiosPromise</code> 的接口，这个接口继承自 Promise</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/types/index.ts</span></span><br><span class="line"><span class="keyword">export</span> interface TxiosPromise extends <span class="built_in">Promise</span>&lt;TxiosResponse&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意这里的 <code>Promise</code> 在返回后其 <code>resolve</code> 或者 <code>reject</code> 中的 <code>data</code> 就是 <code>TxiosResponse</code> 类型的</p>
<p>然后需要在 <code>Txios</code> 这个接口中的每个扩展方法的后面都要加上 <code>TxiosPromise</code> 作为返回值的声明</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/types/index.ts</span></span><br><span class="line"><span class="keyword">export</span> interface Txios &#123;</span><br><span class="line">  <span class="keyword">get</span>&lt;T = any&gt;(url: string, config?: TxiosRequestConfig): TxiosPromise</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在封装 <code>XMLHttpRequest</code> 那块的代码上也需要加上 <code>TxiosPromise</code> 的声明并返回一个 <code>new Promise</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/core/xhr.ts</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">xhr</span>(<span class="params">config: TxiosRequestConfig</span>): <span class="title">TxiosPromise</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么这里还有个问题，即如何让响应的数据支持泛型呢？首先需要对 <code>TxiosResponse</code> 做改造</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/types/index.ts</span></span><br><span class="line"><span class="keyword">export</span> interface TxiosResponse&lt;T = any&gt; &#123;</span><br><span class="line">  data: T</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样 <code>data</code> 就是泛型的数据了，接下来还要对上文中出现的 <code>TxiosPromise</code> 做一个改造，使其也变成一个泛型的接口</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/types/index.ts</span></span><br><span class="line"><span class="keyword">export</span> interface TxiosPromise&lt;T = any&gt; extends <span class="built_in">Promise</span>&lt;TxiosResponse&lt;T&gt;&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样在 <code>Promise</code> 中 <code>resolve</code> 或者 <code>reject</code> 的 <code>data</code> 就是 <code>TxiosResponse&lt;T&gt;</code> 类型的了，需要注意的是这个 <code>data</code> 中还有个 <code>data</code>(这个是在 <code>TxiosResponse</code> 中定义过的) 是 <code>T</code> 类型。<code>TxiosPromise&lt;T = any&gt;</code> 这个表示 <code>resolve</code> 或 <code>reject</code> 的 <code>data</code> 可以是 <code>T</code> 类型的数据</p>
<h3 id="支持请求-响应拦截以及其过程中的数据转换"><a href="#支持请求-响应拦截以及其过程中的数据转换" class="headerlink" title="支持请求/响应拦截以及其过程中的数据转换"></a>支持请求/响应拦截以及其过程中的数据转换</h3><p>首先拦截器的工作原理可以用一张图来描述</p>
<p><img src="./2.png" alt></p>
<p>一般我们使用 <code>txios.interceptors.request.use</code> 来添加请求拦截器，使用 <code>txios.interceptors.response.use</code> 来添加响应拦截器。由上图可以知道，拦截器的执行顺序是 <strong>链式调用的</strong>，并且每个拦截器都支持 <strong>同步和异步</strong>的处理。所以这里最终还是采用 <code>Promise</code> 链式调用去实现这个功能。</p>
<p>实现的逻辑大概是这样的</p>
<ul>
<li><p>首先定义个拦截器的总体的管理类，它里面有两个方法: <code>use</code>(添加拦截器) 和 <code>eject</code>(删除拦截器)。</p>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/types/index.ts</span></span><br><span class="line"><span class="keyword">export</span> interface TxiosInterceptorManager&lt;T&gt; &#123;</span><br><span class="line">  use(resolved: ResolvedFn&lt;T&gt;, rejected?: RejectedFn): number</span><br><span class="line">  eject(id: number): <span class="keyword">void</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>use</code> 方法里面有 <code>resolve</code> 和 <code>reject</code> 方法，所以这俩也是要定义的</p>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/types/index.ts</span></span><br><span class="line"><span class="keyword">export</span> interface ResolvedFn&lt;T = any&gt; &#123;</span><br><span class="line">  (value: T): T | <span class="built_in">Promise</span>&lt;T&gt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> interface RejectedFn &#123;</span><br><span class="line">  (error: any): any</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>接下来去实现这个管理类的时候，基本上就是去实现 <code>use</code> 和 <code>eject</code>。注意这个类里面维护了一个私有的 <code>interceptors</code> 数组</p>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/core/interceptor.ts</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">InterceptorManager</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// use 就是将 resolve 和 reject push 进这个数组中并返回一个位置 id</span></span><br><span class="line">  use(resolved: ResolvedFn&lt;T&gt;, rejected?: RejectedFn): number &#123;</span><br><span class="line">    <span class="keyword">this</span>.interceptors.push(&#123; resolved, rejected &#125;)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.interceptors.length - <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// eject 就是拿到位置 id 然后删除拦截器</span></span><br><span class="line">  eject(id: number): <span class="keyword">void</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.interceptors[id]) <span class="keyword">this</span>.interceptors[id] = <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这里还写了个 forEach 函数用来遍历拦截器并执行它传入的拦截器</span></span><br><span class="line">  forEach(fn: <span class="function">(<span class="params">interceptor: Interceptor&lt;T&gt;</span>) =&gt;</span> <span class="keyword">void</span>): <span class="keyword">void</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.interceptors.forEach(<span class="function"><span class="params">interceptor</span> =&gt;</span> &#123;</span><br><span class="line">      interceptor &amp;&amp; fn(interceptor)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>需要在发送请求的逻辑中构建 <code>Promise</code> 链，这个链的接口定义是这样的</p>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/core/txios-core.ts</span></span><br><span class="line">interface PromiseChain &#123;</span><br><span class="line">  resolved: ResolvedFn | <span class="function">(<span class="params">(config: TxiosRequestConfig</span>) =&gt;</span> TxiosPromise)</span><br><span class="line">  rejected?: RejectedFn</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在 <code>TxiosCore</code> 这个方法中构造 <code>interceptors</code></p>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/core/txios-core.ts</span></span><br><span class="line"><span class="keyword">constructor</span>(initConfig: TxiosRequestConfig) &#123;</span><br><span class="line">  <span class="keyword">this</span>.interceptors = &#123;</span><br><span class="line">    request: <span class="keyword">new</span> InterceptorManager&lt;TxiosRequestConfig&gt;(),</span><br><span class="line">    response: <span class="keyword">new</span> InterceptorManager&lt;TxiosResponse&gt;()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>然后在 <code>request</code> 这个请求方法中开始构建这个 <code>Promise Chain</code></p>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/core/txios-core.ts</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">TxiosCore</span> </span>&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  request(url: any, config?: any): TxiosPromise &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">const</span> chain: PromiseChain[] = [</span><br><span class="line">      &#123;</span><br><span class="line">        resolved: dispatchRequest,</span><br><span class="line">        rejected: <span class="literal">undefined</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关键代码!!!</span></span><br><span class="line">    <span class="keyword">this</span>.interceptors.request.forEach(<span class="function"><span class="params">interceptor</span> =&gt;</span> &#123;</span><br><span class="line">      chain.unshift(interceptor) <span class="comment">// 插入到 chain 前面</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">this</span>.interceptors.response.forEach(<span class="function"><span class="params">interceptor</span> =&gt;</span> &#123;</span><br><span class="line">      chain.push(interceptor) <span class="comment">// 插入到 chain 后面</span></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> promise = <span class="built_in">Promise</span>.resolve(config)</span><br><span class="line">    <span class="comment">// 循环这个 chain 拿到每个拦截器对象</span></span><br><span class="line">    <span class="comment">// 将其 resolved 以及 rejected 函数添加到 promise.then 的参数中</span></span><br><span class="line">    <span class="comment">// 通过 Promise 链式调用方式，可实现拦截器一层一层链式调用效果</span></span><br><span class="line">    <span class="keyword">while</span> (chain.length) &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123; resolved, rejected &#125; = chain.shift()!</span><br><span class="line">      promise = promise.then(resolved, rejected)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> promise</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  这里链式调用的直接效果，就是其执行完了拦截器之后的代码逻辑之后再发送请求。但是这里需要注意，<strong>拦截响应的逻辑同时也执行了</strong>，也就是说如果你在拦截响应的逻辑中对其 response 的 data 做了什么赋值操作的话，那么最终返回结果就是你拦截之后的结果。其实很好理解，要实现拦截器的真正效果，其核心就是 <strong>优先执行拦截器中的代码逻辑</strong></p>
</li>
</ul>
<h3 id="支持取消请求"><a href="#支持取消请求" class="headerlink" title="支持取消请求"></a>支持取消请求</h3><p>这个功能的适用场景是这样的，一般而言在搜索框输入的时候，如果第一次输入发出请求了，紧接着第二次输入也发出请求了，但是万一第二次输入的请求服务端反应比较快，一下子就返回了，而第一次请求服务端的反应比较慢，等很久之后才返回。这样就会出现一种情况，<strong>前面请求结果把后面的请求结果给覆盖了</strong>，这是用户极为不愿意看到的。所以如果在这种情况下，如果前面的请求响应很慢或者已经没办法响应了，就直接取消掉它就能解决这个问题了</p>
<p>实现的思路是这样的</p>
<ul>
<li>要取消请求，需要为该请求配置一个 <code>CancelToken</code> 来表示取消这次请求的操作，然后在外部调用一个 <code>cancel</code> 方法来取消</li>
<li><code>cancel</code> 方法本质上是通过执行 <code>XMLHttpRequest</code> 的 <code>abort</code> 方法来取消请求的</li>
<li>但是由于请求是异步的，而且取消请求操作是用户设置的，并且用户是访问不到这个 <code>XMLHttpRequest</code> 对象的。那么用什么方法才能做到，我外部调用一个 <code>cancel</code> 方法，就能通知到其内部的 <code>XMLHttpRequest</code> 对象，自动执行 <code>abort</code> 终止请求操作呢？</li>
<li>有个办法是这样的，在 <code>CancelToken</code> 内部维护一个 <code>Promise</code> 的对象，最开始设定这个 <code>Promise</code> 对象内部的 <code>state</code> 为 <code>pending</code> 状态。当我们外部调用了 <code>cancel</code> 方法后，会将这个 <code>CancelToken</code> 内部的 <code>Promise</code> 对象的 <code>state</code> 转变成 <code>fulfilled</code> 状态，这样的话如果之前就写了 <code>CancelToken.promise.then</code>，那么它就会<strong>自动执行</strong> <code>then</code> 里面的逻辑，在 <code>then</code> 里面直接调用 <code>abort</code> 就可以了</li>
</ul>
<p>调用是这么调用的</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 该请求通过 cancel() 方式取消</span></span><br><span class="line"><span class="keyword">let</span> cancel: Canceler;</span><br><span class="line">txios.get(<span class="string">'/cancel/get'</span>, &#123;</span><br><span class="line">  cancelToken: <span class="keyword">new</span> CancelToken(<span class="function"><span class="params">c</span> =&gt;</span> &#123; cancel = c &#125;)</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (txios.isCancel(e)) <span class="built_in">console</span>.log(<span class="string">'Request canceled'</span>);</span><br><span class="line">&#125;);</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123; cancel() &#125;, <span class="number">200</span>);</span><br></pre></td></tr></table></figure>
<p>然后基于 <code>XMLHttpRequest</code> 对象封装下的 <code>xhr</code> 的内部是这样子判断的</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/core/xhr.ts</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// 设置取消请求</span></span><br><span class="line"><span class="keyword">if</span> (cancelToken) &#123;</span><br><span class="line">  cancelToken.promise</span><br><span class="line">    .then(<span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">      request.abort()</span><br><span class="line">      reject(reason)</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// TODO</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有了使用例子和以上的说明，核心代码就很好理解了</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/cancel/cancelToken.ts</span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">CancelToken</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">constructor</span>(executor: CancelExecutor) &#123; <span class="comment">// executor 是一个 callback !!!</span></span><br><span class="line">    <span class="keyword">let</span> resolvePromise: ResolvePromise <span class="comment">// resolvePromise 是一个函数 !!!</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// this.promise 用来表示一个 pending 状态的 Promise 对象</span></span><br><span class="line">    <span class="keyword">this</span>.promise = <span class="keyword">new</span> <span class="built_in">Promise</span>&lt;Cancel&gt;(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">      resolvePromise = resolve <span class="comment">// 注意这里将这个 resolve 函数保存起来了 !!!</span></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行传入的 executor 函数, 传的参数是一个 cancel 函数</span></span><br><span class="line">    <span class="comment">// 此时 executor === (c) =&gt; &#123; cancel = c &#125;</span></span><br><span class="line">    <span class="comment">// c 是 executor 的参数</span></span><br><span class="line">    <span class="comment">// 此时 c === (message) =&gt; &#123;...&#125;</span></span><br><span class="line">    <span class="comment">// 因为此时参数是一个函数</span></span><br><span class="line">    executor(<span class="function"><span class="params">message</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">      <span class="comment">// 此时 this.promise 会从 pending 状态变为 resolved 状态</span></span><br><span class="line">      <span class="comment">// 便于外部可以做 xxx.promise.then 的调用</span></span><br><span class="line">      resolvePromise(<span class="keyword">this</span>.reason)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意此时 <code>c === (message) =&gt; {...}</code>，而外部变量 <code>cancel === c</code>，所以当外部变量 <code>cancel()</code> 调用时，就会调用 <code>(message) =&gt; {...}</code> 这个函数，调用 <code>resolvePromise</code>，这会把 <code>CancelToken</code> 里面的 <code>this.promise</code> 的 <code>state</code> 从 <code>pending</code> 变为 <code>fulfilled</code> 状态。在程序的外部如果之前<strong>已经写好了 then</strong> ，那么它就会 <strong>自动执行 then</strong>，调用 <code>abort</code> 取消请求，从而达到异步分离的目的</p>
<blockquote>
<p>如果上面的函数调用的逻辑看不懂， <a href="https://jsbin.com/yacezusohu/edit?html,js,output" target="_blank" rel="noopener">请点击这个链接</a>相信可以帮助理解</p>
</blockquote>
<h3 id="支持自动转换-JSON-数据"><a href="#支持自动转换-JSON-数据" class="headerlink" title="支持自动转换 JSON 数据"></a>支持自动转换 JSON 数据</h3><p>这个逻辑实现就很简单了，在 <code>src/helper/data-helper.ts</code> 文件中，有如下的两个专门用于数据处理的函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">transformRequest</span>(<span class="params">data: any</span>): <span class="title">any</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (isNormalObject(data)) <span class="keyword">return</span> <span class="built_in">JSON</span>.stringify(data)</span><br><span class="line">  <span class="keyword">return</span> data</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">transformResponse</span>(<span class="params">data: any</span>): <span class="title">any</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> data === <span class="string">'string'</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      data = data &amp;&amp; <span class="built_in">JSON</span>.parse(data)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">      <span class="comment">// TODO</span></span><br><span class="line">      <span class="comment">// console.log(error)</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> data</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在请求数据之前先把数据做一个处理，将数据转换成 JSON 字符串(transformRequest)；在处理响应数据之前先把数据转成 JSON 对象处理(transformResponse)，分别就是调用如上的两个帮助函数实现</p>
<h3 id="客户端支持-XSRF-防御"><a href="#客户端支持-XSRF-防御" class="headerlink" title="客户端支持 XSRF 防御"></a>客户端支持 XSRF 防御</h3><p>XSRF 又叫 Cross-site request forgery，跨站请求伪造，一种前端老生长谈的攻击方式了，简单点来说你通过一个陌生的链接打开一个恶意的网站，这个网站利用你之前登陆其他网站的登陆状态发起一个跨站点的网络请求，从而伪造身份来攻击</p>
<p>所以解决这种攻击的一种方式，就是服务端生成一个 token，客户端收到后存为 cookie，每次访问时就带上这个 token，而这个 token 在客户端每次访问站点时都生成，算是一个服务端的验证，这样有了唯一性验证这种攻击方式就弱小了很多。</p>
<p>所以实现这种功能就是每次发送请求时，自动从 cookie 中读取 token，然后添加进请求头中，一般来说是这么调用</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> instance = txios.create(&#123;</span><br><span class="line">  xsrfCookieName: <span class="string">'XSRF-TOKEN-D'</span>,</span><br><span class="line">  xsrfHeaderName: <span class="string">'X-XSRF-TOKEN-D'</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">instance.get(<span class="string">'/more/get'</span>)</span><br><span class="line">  .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>
<p>核心代码如下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/core/xhr.ts</span></span><br><span class="line"><span class="comment">// 设置 cookie</span></span><br><span class="line"><span class="keyword">if</span> ((withCredentials || isUrlSameOrigin(url!)) &amp;&amp; xsrfCookieName) &#123;</span><br><span class="line">  <span class="keyword">const</span> token = cookie.getToken(xsrfCookieName)</span><br><span class="line">  <span class="keyword">if</span> (token) headers[xsrfHeaderName!] = token</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>逻辑是这样的</p>
<ol>
<li>若 withCredentials = true | <strong>同源</strong>请求，在 headers 中添加 xsrf 相关字段</li>
<li>判断成功,则从 cookie 中读取 xsrf 的 token</li>
<li>若能读到，则将其添加到请求 headers 的 xsrf 相关字段中</li>
</ol>
<blockquote>
<p>注意跨域请求中若要请求域中携带 cookie 则需要设置 <code>XMLHttpRequest</code> 对象的 <code>withCredentials</code> 为 true</p>
</blockquote>
<p>那么 <code>getToken</code> 干了什么事情呢</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//src/helpers/cookie-helper.ts</span></span><br><span class="line">getToken(name: string): string | <span class="literal">null</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> match = <span class="built_in">document</span>.cookie.match(</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">'(^|;\\s*)('</span> + name + <span class="string">')=([^;]*)'</span>)</span><br><span class="line">  )</span><br><span class="line">  <span class="keyword">return</span> match ? <span class="built_in">decodeURIComponent</span>(match[<span class="number">3</span>]) : <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里就是利用正则表达式解析到 <code>name</code> 对应的值，如果有的话就取 <code>match[3]</code> 也就是 token 的值了，这里再稍微解释下过程，比如你的 <code>document.cookie</code> 值为 <code>XSRF-TOKEN-D=1234abc</code>，本质上是需要将 <code>1234abc</code> 拿出来，那么实际上你的正则就是 <code>(^|;\s*)(XSRF-TOKEN-D)=([^;]*)</code></p>
<ul>
<li><code>(^|;\s*)</code> 表示匹配字符串开头的 <code>;</code> 或者是 <code>;空格</code> 的字符串或者是其他字符串(<code>;</code> 可有可无)</li>
<li><code>(XSRF-TOKEN-D)</code> 表示匹配 <code>XSRF-TOKEN-D</code> 这样的字符串</li>
<li><code>=</code> 表示匹配 <code>=</code> 这样的字符</li>
<li><code>([^;]*)</code> 表示匹配除了 <code>;</code> 这样的字符的其他字符串</li>
</ul>
<p>那么连起来就很明了了，就是匹配 <code>XSRF-TOKEN-D=</code> 这样的字符串，匹配到了后 <code>match</code> 伪数组结果长这样</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="number">0</span>: <span class="string">"XSRF-TOKEN-D=1234abc"</span></span><br><span class="line">  <span class="number">1</span>: <span class="string">""</span></span><br><span class="line">  <span class="number">2</span>: <span class="string">"XSRF-TOKEN-D"</span></span><br><span class="line">  <span class="number">3</span>: <span class="string">"1234abc"</span></span><br><span class="line">  index: <span class="number">0</span></span><br><span class="line">  input: <span class="string">"XSRF-TOKEN-D=1234abc"</span></span><br><span class="line">  groups: <span class="literal">undefined</span></span><br><span class="line">  length: <span class="number">4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>于是 <code>match[3]</code> 就是结果，直接取它就行</p>
<blockquote>
<p>若这里不懂也可以点击这个 <a href="https://github.com/ziishaned/learn-regex/blob/master/translations/README-cn.md" target="_blank" rel="noopener">正则参考链接</a></p>
</blockquote>
<h2 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h2><p>单元测试其实是个比较蛋疼的话题，说实话要做到一个比较高的代码覆盖率，需要自己写很多的代码取做验证，其核心的逻辑就是验证输入跟输出的对比，使用 jest 这个测试框架的 expert 断言去写，利用 <code>jasmine</code> 去做 <code>ajax</code> 异步的请求 mock，基本上就是这么个套路了。</p>
<p>而如果要做到很高的代码测试覆盖率，需要自己深入到函数里面，理清楚它的每个判断，然后对相应的代码走向编写测试代码就行。这是比较累的地方，但却是最能保证代码质量的地方。</p>
<h2 id="比较难实现的地方"><a href="#比较难实现的地方" class="headerlink" title="比较难实现的地方"></a>比较难实现的地方</h2><p>除了上面提及到的<a href="#支持-Promise-API">支持 Promise API</a> 以及<a href="#支持取消请求">支持取消请求</a>比较难实现外，还有一个就是合并配置功能的实现。<br>在合并配置时需要注意默认配置和用户在调用 <code>txios</code> 时的自定义配置，优先级比较高的是用户自定义的配置，这部分的配置包括 <code>headers</code> 以及一些 <code>config</code>。但是合并不是简单的合并覆盖属性就完了，对于不同的字段的合并，需要不同的策略</p>
<p>这里的合并策略主要有3个</p>
<ul>
<li><p>默认合并策略</p>
<p>  如果自定义配置中有某个属性，就采用自定义的，反之采用默认</p>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defaultPolicy</span>(<span class="params">defaultValue: any, customValue: any</span>): <span class="title">any</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> customValue !== <span class="string">'undefined'</span> ? customValue : defaultValue</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>只接受自定义的配置策略</p>
<p>  这是对于 url params data 的合并策略</p>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onlyCustomPolicy</span>(<span class="params">defaultValue: any, customValue: any</span>): <span class="title">any</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> customValue !== <span class="string">'undefined'</span>) <span class="keyword">return</span> customValue</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>复杂对象合并策略</p>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepMergePolicy</span>(<span class="params">defaultValue: any, customValue: any</span>): <span class="title">any</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 优先检测自定义配置</span></span><br><span class="line">  <span class="keyword">if</span> (isNormalObject(customValue)) &#123;</span><br><span class="line">    <span class="comment">// 自定义配置 value 是普通对象</span></span><br><span class="line">    <span class="keyword">return</span> deepMerge(defaultValue, customValue)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> customValue !== <span class="string">'undefined'</span>) &#123; <span class="comment">// 这里判断踩了个坑</span></span><br><span class="line">    <span class="comment">// 自定义配置 value 是其他对象</span></span><br><span class="line">    <span class="keyword">return</span> customValue</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isNormalObject(defaultValue)) &#123;</span><br><span class="line">    <span class="comment">// 默认配置是普通对象</span></span><br><span class="line">    <span class="keyword">return</span> deepMerge(defaultValue)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 默认配置是其他对象</span></span><br><span class="line">    <span class="keyword">return</span> defaultValue</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>之前在复杂策略判断这里踩了个坑，原来的判断是少个 <code>typeof</code> 的，也就是说那条语句变成了 <code>else if (customValue !== &#39;undefined&#39;)</code>，然后单元测试老是过不去，弄了很久，逐行打印分析还以为是 <code>deepMerge</code> 函数那里写错了，后面定位问题才逐渐定位到这里，删除了代码又添加代码之后才发现的。看来使用 TypesSript 也有眼瞎的时候，虽然它已经能够帮你解决 80% 的低端 bug 了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这次的项目算是使用 TypeScript 对 axios 库功能的一次仿写，由代码测试来看，部分功能还算是比较成功的。同时也了解到了 TypeScript 这一门语言的强大之处，比起 js 来说，用的人都应该感觉算蛮香的。虽然类型定义有些奇怪，但用习惯之后觉得还好。另外，若大家有兴趣，还请 <a href="https://github.com/strugglebak/txios" target="_blank" rel="noopener">star 下我的 txios 库</a> ，各位有问题也可以直接 <a href="https://github.com/strugglebak/txios/pulls" target="_blank" rel="noopener">PR</a>，我通通合并(开玩笑哈哈)</p>
]]></content>
      <categories>
        <category>TypeScript</category>
        <category>Axios</category>
      </categories>
      <tags>
        <tag>Txios</tag>
        <tag>Promise</tag>
        <tag>TypeScript-Http</tag>
      </tags>
  </entry>
  <entry>
    <title>一个jQuery面试题</title>
    <url>/2019/02/20/%E4%B8%80%E4%B8%AAjQuery%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<h2 id="面试题一览"><a href="#面试题一览" class="headerlink" title="面试题一览"></a>面试题一览</h2><p>代码如下</p>
<figure class="highlight mel"><table><tr><td class="code"><pre><span class="line"><span class="keyword">window</span>.jQuery = ???</span><br><span class="line"><span class="keyword">window</span>.$ = jQuery</span><br><span class="line"></span><br><span class="line">var $div = $(<span class="string">'div'</span>)</span><br><span class="line">$div.addClass(<span class="string">'red'</span>) <span class="comment">// 可将所有 div 的 class 添加一个 red</span></span><br><span class="line">$div.setText(<span class="string">'hi'</span>) <span class="comment">// 可将所有 div 的 textContent 变为 hi</span></span><br></pre></td></tr></table></figure>
<p>首先在 JSBbin 上写一个简单 html</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>JS Bin<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"x"</span>&gt;</span>x<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"x"</span>&gt;</span>x<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"x"</span>&gt;</span>x<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>然后 CSS 如下</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.x</span><span class="selector-class">.red</span> &#123;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>初始效果图<br><img src="./img1.png" alt></p>
<h2 id="坑一-没-return-值"><a href="#坑一-没-return-值" class="headerlink" title="坑一 (没 return 值)"></a>坑一 (没 return 值)</h2><p>首先手撸 js 代码如下</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"> <span class="built_in">window</span>.jQuery = <span class="function"><span class="keyword">function</span>(<span class="params">nodeOrSelector</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> nodes = &#123;&#125;;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> nodeOrSelector === <span class="string">'string'</span>) &#123;</span><br><span class="line">            <span class="keyword">let</span> temp = <span class="built_in">document</span>.querySelectorAll(nodeOrSelector);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;temp.length; i++) &#123;</span><br><span class="line">                nodes[i] = temp[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ( nodeOrSelector <span class="keyword">instanceof</span> Node ) &#123;</span><br><span class="line">            nodes = &#123;<span class="number">0</span>: nodeOrSelector, <span class="attr">length</span>: <span class="number">1</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        nodes.addClass = <span class="function"><span class="keyword">function</span>(<span class="params">classes</span>) </span>&#123;</span><br><span class="line">            classes.forEach(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">              <span class="built_in">console</span>.log(value);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>; i &lt; nodes.length; i++) &#123;</span><br><span class="line">                    nodes[i].classList.add(value);</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.$ = jQuery;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> $div = $(<span class="string">'div'</span>);</span><br><span class="line">$div.addClass(<span class="string">'red'</span>); <span class="comment">// 可将所有 div 的 class 添加一个 red</span></span><br><span class="line">$div.setText(<span class="string">'hi'</span>); <span class="comment">// 可将所有 div 的 textContent 变为 hi</span></span><br></pre></td></tr></table></figure>
<p>运行,但是出错<br><img src="./img2.png" alt></p>
<p><code>$div</code> 未定义??? 很是奇怪,于是逐行屏蔽代码至如下</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"> window.jQuery = <span class="keyword">function</span>(nodeOrSelector) &#123;</span><br><span class="line">        let nodes = &#123;&#125;;</span><br><span class="line">   console.log(nodeOrSelector);</span><br><span class="line"><span class="regexp">//</span>         <span class="keyword">if</span> (typeof nodeOrSelector === <span class="string">'string'</span>) &#123;</span><br><span class="line"><span class="regexp">//</span>             let temp = document.querySelectorAll(nodeOrSelector);</span><br><span class="line"><span class="regexp">//</span>             <span class="keyword">for</span> (let i=<span class="number">0</span>; i&lt;temp.length; i++) &#123;</span><br><span class="line"><span class="regexp">//</span>                 nodes[i] = temp[i];</span><br><span class="line"><span class="regexp">//</span>             &#125;</span><br><span class="line"><span class="regexp">//</span>         &#125; <span class="keyword">else</span> <span class="keyword">if</span> ( nodeOrSelector instanceof Node ) &#123;</span><br><span class="line"><span class="regexp">//</span>             nodes = &#123;<span class="number">0</span>: nodeOrSelector, length: <span class="number">1</span>&#125;;</span><br><span class="line"><span class="regexp">//</span>         &#125;</span><br><span class="line"><span class="regexp">//</span>         nodes.addClass = <span class="keyword">function</span>(classes) &#123;</span><br><span class="line"><span class="regexp">//</span>             classes.forEach((value) =&gt; &#123;</span><br><span class="line"><span class="regexp">//</span>               console.log(value);</span><br><span class="line"><span class="regexp">//</span>                 <span class="keyword">for</span> (let i=<span class="number">0</span>; i &lt; nodes.length; i++) &#123;</span><br><span class="line"><span class="regexp">//</span>                     nodes[i].classList.add(value);</span><br><span class="line"><span class="regexp">//</span>                 &#125;;</span><br><span class="line"><span class="regexp">//</span>             &#125;);</span><br><span class="line"><span class="regexp">//</span>         &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">window.$ = jQuery;</span><br><span class="line"></span><br><span class="line">var <span class="variable">$div</span> = $(<span class="string">'div'</span>);</span><br><span class="line"><span class="regexp">//</span> <span class="variable">$div</span>.addClass(<span class="string">'red'</span>); <span class="regexp">//</span> 可将所有 div 的 class 添加一个 red</span><br><span class="line"><span class="regexp">//</span> <span class="variable">$div</span>.setText(<span class="string">'hi'</span>); <span class="regexp">//</span> 可将所有 div 的 textContent 变为 hi</span><br></pre></td></tr></table></figure>
<p>打印出了 “div” ,说明函数的声明是没有问题的,想想是不是没有返回值,看了下构造函数果然没有,加返回解决,即</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"> <span class="built_in">window</span>.jQuery = <span class="function"><span class="keyword">function</span>(<span class="params">nodeOrSelector</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> nodes = &#123;&#125;;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> nodeOrSelector === <span class="string">'string'</span>) &#123;</span><br><span class="line">            <span class="keyword">let</span> temp = <span class="built_in">document</span>.querySelectorAll(nodeOrSelector);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;temp.length; i++) &#123;</span><br><span class="line">                nodes[i] = temp[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ( nodeOrSelector <span class="keyword">instanceof</span> Node ) &#123;</span><br><span class="line">            nodes = &#123;<span class="number">0</span>: nodeOrSelector, <span class="attr">length</span>: <span class="number">1</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        nodes.addClass = <span class="function"><span class="keyword">function</span>(<span class="params">classes</span>) </span>&#123;</span><br><span class="line">            classes.forEach(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">              <span class="built_in">console</span>.log(value);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>; i &lt; nodes.length; i++) &#123;</span><br><span class="line">                    nodes[i].classList.add(value);</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;;</span><br><span class="line">       <span class="keyword">return</span> nodes;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.$ = jQuery;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> $div = $(<span class="string">'div'</span>);</span><br><span class="line">$div.addClass(<span class="string">'red'</span>); <span class="comment">// 可将所有 div 的 class 添加一个 red</span></span><br><span class="line"><span class="comment">// $div.setText('hi'); // 可将所有 div 的 textContent 变为 hi</span></span><br></pre></td></tr></table></figure>
<h2 id="坑二-函数传参的判断"><a href="#坑二-函数传参的判断" class="headerlink" title="坑二 (函数传参的判断)"></a>坑二 (函数传参的判断)</h2><p>然而这个时候报错<br><img src="./img3.png" alt><br>就很奇怪,打印一下 <code>classes</code>,结果是 ‘red’, 哦智障了,字符串哪里有 <code>forEach</code> 这个函数呢, Array 才有嘛,于是想到加一个判断转化</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">nodes.addClass = <span class="function"><span class="keyword">function</span>(<span class="params">classes</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> classes === <span class="string">'string'</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> temp = classes;</span><br><span class="line">        classes = <span class="built_in">Array</span>(temp);</span><br><span class="line">    &#125;</span><br><span class="line">    classes.forEach(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>; i &lt; nodes.length; i++) &#123;</span><br><span class="line">            nodes[i].classList.add(value);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>问题解决</p>
<h2 id="坑三-没有-nodes-length"><a href="#坑三-没有-nodes-length" class="headerlink" title="坑三 (没有 nodes.length)"></a>坑三 (没有 nodes.length)</h2><p>想到应该可以了,运行代码发现 output 没变化,打开查看器看了下 html 源码发现没有把 ‘red’ 类加上去<br><img src="./img4.png" alt></p>
<p>说明是 <code>addClass</code> 函数的问题, <code>console.log</code> 一下 <code>nodes.length</code> 果然是 null,那么问题出在哪儿呢? 函数里声明的 nodes 应该是可以被访问到的,能被访问到为何没有 length ??? 看了下前面代码中</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (typeof nodeOrSelector === <span class="string">'string'</span>) &#123;</span><br><span class="line">    let temp = document.querySelectorAll(nodeOrSelector);</span><br><span class="line">    <span class="keyword">for</span> (let <span class="built_in">i</span>=<span class="number">0</span>; <span class="built_in">i</span>&lt;temp.<span class="built_in">length</span>; <span class="built_in">i</span>++) &#123;</span><br><span class="line">        nodes[<span class="built_in">i</span>] = temp[<span class="built_in">i</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>哦懂了,temp 数组中的 length 没有复制过去, 加上 <code>nodes.length = temp.length</code> 即可</p>
<h2 id="最终效果"><a href="#最终效果" class="headerlink" title="最终效果"></a>最终效果</h2><p>最终代码如下</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.jQuery = <span class="function"><span class="keyword">function</span>(<span class="params">nodeOrSelector</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> nodes = &#123;&#125;;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> nodeOrSelector === <span class="string">'string'</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> temp = <span class="built_in">document</span>.querySelectorAll(nodeOrSelector);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;temp.length; i++) &#123;</span><br><span class="line">      nodes[i] = temp[i];</span><br><span class="line">      nodes.length = temp.length;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> ( nodeOrSelector <span class="keyword">instanceof</span> Node ) &#123;</span><br><span class="line">    nodes = &#123;<span class="number">0</span>: nodeOrSelector, <span class="attr">length</span>: <span class="number">1</span>&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  nodes.addClass = <span class="function"><span class="keyword">function</span>(<span class="params">classes</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> classes === <span class="string">'string'</span>) &#123;</span><br><span class="line">      <span class="keyword">let</span> temp = classes;</span><br><span class="line">      classes = <span class="built_in">Array</span>(temp);</span><br><span class="line">    &#125;</span><br><span class="line">    classes.forEach(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>; i &lt; nodes.length; i++) &#123;</span><br><span class="line">        nodes[i].classList.add(value);</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  nodes.setText = <span class="function"><span class="keyword">function</span>(<span class="params">text</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;nodes.length; i++) &#123;</span><br><span class="line">      nodes[i].textContent = text;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> nodes;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.$ = jQuery;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> $div = $(<span class="string">'div'</span>);</span><br><span class="line">$div.addClass(<span class="string">'red'</span>); <span class="comment">// 可将所有 div 的 class 添加一个 red</span></span><br><span class="line">$div.setText(<span class="string">'hi'</span>); <span class="comment">// 可将所有 div 的 textContent 变为 hi</span></span><br></pre></td></tr></table></figure>
<p>output 效果如下</p>
<ul>
<li><p>添加 ‘red’<br><img src="./img5.png" alt></p>
</li>
<li><p>将 textContent 变成 ‘hi’<br><img src="./img6.png" alt></p>
</li>
</ul>
<p><a href="https://jsbin.com/qorinefaza/edit?html,js,output" target="_blank" rel="noopener">点击这里预览</a></p>
]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>jQuery</tag>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title>一些常见排序算法</title>
    <url>/2019/02/19/%E4%B8%80%E4%BA%9B%E5%B8%B8%E8%A7%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h2 id="5种排序"><a href="#5种排序" class="headerlink" title="5种排序"></a>5种排序</h2><p>大致上，平时需要用到的算法有如下几种:</p>
<ol>
<li>冒泡排序</li>
<li>选择排序</li>
<li>计数排序</li>
<li>快速排序</li>
<li>插入排序</li>
<li>归并排序</li>
</ol>
<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>这个排序的算法很简单，其实就是比较相邻两个元素的大小，然后交换,代码如下</p>
<figure class="highlight zephir"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 冒泡排序</span></span><br><span class="line"><span class="comment"> * 排序为从小到大</span></span><br><span class="line"><span class="comment"> * 输入的参数是一个包含正整数的一维数组</span></span><br><span class="line"><span class="comment"> * 返回的值也是一个一维数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>   &#123;Array&#125;  array  [数组]</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>  &#123;Array&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bubbleSort</span><span class="params">(array)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="keyword">array</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">let</span> indexOfLastUnsortedElement = <span class="keyword">array</span>.length - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">let</span> newArray = [];</span><br><span class="line">  <span class="keyword">let</span> isSwapped = <span class="keyword">true</span>;</span><br><span class="line">  <span class="keyword">while</span> (isSwapped) &#123;</span><br><span class="line">    isSwapped = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; indexOfLastUnsortedElement; ++i) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">array</span>[i] &gt; <span class="keyword">array</span>[i+<span class="number">1</span>]) &#123;</span><br><span class="line">        newArray = swap(<span class="keyword">array</span>, i, i+<span class="number">1</span>);</span><br><span class="line">        isSwapped = <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    --indexOfLastUnsortedElement;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> newArray;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">swap</span><span class="params">(array, preIndex, nextIndex)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> temp = <span class="keyword">array</span>[preIndex];</span><br><span class="line">  <span class="keyword">array</span>[preIndex] = <span class="keyword">array</span>[nextIndex];</span><br><span class="line">  <span class="keyword">array</span>[nextIndex] = temp;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">array</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中需要注意的地方就是 <code>isSwapped</code> 这个标识位，没有这个标识位的话，在一些情况下会做重复两两判断的操作，这里实际上就是一个优化,以下是其动图演示</p>
<p><img src="img1.gif" alt></p>
<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>每次选择这个数组的已经排好序的最后一个作为最大/小值(默认第一个是已经排好序的), 然后拿这个值依次与后面的值进行比较，比它大/小就记下它当时的下标，并且把这个值<strong>更新</strong> 为最大/小值，轮完一圈之后利用当时存的下标就可以与已经排好序的最后一个数交换，完成一轮排序操作，后面的以此类推</p>
<figure class="highlight zephir"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 选择排序</span></span><br><span class="line"><span class="comment"> * 排序为从小到大</span></span><br><span class="line"><span class="comment"> * 输入的参数是一个包含正整数的一维数组</span></span><br><span class="line"><span class="comment"> * 返回的值也是一个一维数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>   &#123;Array&#125;  array  [数组]</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>  &#123;Array&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">selectionSort</span><span class="params">(array)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="keyword">array</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">let</span> newArray = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="keyword">array</span>.length - <span class="number">1</span>; ++i) &#123; <span class="comment">// 从第 i 个开始</span></span><br><span class="line">    <span class="comment">// 重新对最小值以及最小下标进行赋值</span></span><br><span class="line">    <span class="keyword">let</span> minIndex = i;</span><br><span class="line">    <span class="keyword">let</span> minVal = <span class="keyword">array</span>[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = i + <span class="number">1</span>; j &lt; <span class="keyword">array</span>.length; ++j) &#123; <span class="comment">// 从第 i+1 个开始</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">array</span>[j] &lt; minVal) &#123;</span><br><span class="line">        minIndex = j; <span class="comment">// 记住最小值下标,为交换最准备</span></span><br><span class="line">        minVal = <span class="keyword">array</span>[j]; <span class="comment">// 啊，中央就决定，你是最小值了!</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 比完这一轮之后就 swap</span></span><br><span class="line">    newArray = swap(<span class="keyword">array</span>, minIndex, i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> newArray;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">swap</span><span class="params">(array, preIndex, nextIndex)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> temp = <span class="keyword">array</span>[preIndex];</span><br><span class="line">  <span class="keyword">array</span>[preIndex] = <span class="keyword">array</span>[nextIndex];</span><br><span class="line">  <span class="keyword">array</span>[nextIndex] = temp;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">array</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>算法动态显示如下</p>
<p><img src="./img2.gif" alt></p>
<h2 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h2><p>本质上这个就是用一个数组，将输入的数字作为这个数组的下标，然后当遇到一个相同数字的时候，对应这个下标的值就自增，最后再对这个已经按照顺序存放好数据的数组进行排序</p>
<figure class="highlight zephir"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 计数排序</span></span><br><span class="line"><span class="comment"> * 排序为从小到大</span></span><br><span class="line"><span class="comment"> * 输入的参数是一个包含正整数的一维数组</span></span><br><span class="line"><span class="comment"> * 返回的值也是一个一维数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>   &#123;Array&#125;  array  [数组]</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>  &#123;Array&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">countingSort</span><span class="params">(array)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!<span class="keyword">array</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将数据弄到 bucket 里面</span></span><br><span class="line">  <span class="comment">// 每个 bucket[index] 里面的值是 array[i] 重复出现的次数</span></span><br><span class="line">  <span class="keyword">let</span> bucket = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="keyword">array</span>.length; ++i) &#123;</span><br><span class="line">    <span class="keyword">let</span> index = <span class="keyword">array</span>[i];</span><br><span class="line">    <span class="keyword">if</span> (!bucket[index]) bucket[index] = <span class="number">0</span>;</span><br><span class="line">    bucket[index] ++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 然后取出来排序</span></span><br><span class="line">  <span class="keyword">let</span> newArray = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; bucket.length; ++i) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; bucket[i] &amp;&amp; j &lt; bucket[i]; ++j) &#123;</span><br><span class="line">      newArray.push(i);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> newArray;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>算法动态显示如下</p>
<p><img src="./img3.gif" alt></p>
<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>首先需要从这个数列中挑选出一个<strong>基准数</strong>,然后对这个数列做如下的排列</p>
<ul>
<li>所有大于该基准数的数都放在这个数列的右边</li>
<li>所有小于该基准数的数都放在这个数列的左边</li>
</ul>
<p>完成这样的分割之后，再递归的重复上述操作，直到排列好的数列的长度小于 2 就返回(return)</p>
<p>还有一个就是随机快速排序的改进版本，其实区别就在于<strong>挑选基准数这个规则上，它是随机的</strong></p>
<figure class="highlight zephir"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 快速排序</span></span><br><span class="line"><span class="comment"> * 从数列中挑出一个元素，称为“基准”（pivot），</span></span><br><span class="line"><span class="comment"> * 重新排序数列，所有比基准值小的元素摆放在基准前面，所有比基准值大的元素摆在基准后面（相同的数可以到任何一边）</span></span><br><span class="line"><span class="comment"> * 在这个分割结束之后，该基准就处于数列的中间位置。这个称为分割（partition）操作。</span></span><br><span class="line"><span class="comment"> * 递归地（recursively）把小于基准值元素的子数列和大于基准值元素的子数列排序</span></span><br><span class="line"><span class="comment"> * 排序为从小到大</span></span><br><span class="line"><span class="comment"> * 输入的参数是一个包含正整数的一维数组</span></span><br><span class="line"><span class="comment"> * 返回的值也是一个一维数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>   &#123;Array&#125;   array           [数组]</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>   &#123;Number&#125;  pivotIndex      [基准数下标]</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>   &#123;Number&#125;  rightMostIndex  [右边最远下标]</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>  &#123;Array&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">quickSort</span><span class="params">(array, pivotIndex, rightMostIndex)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="keyword">array</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">if</span> (pivotIndex &gt;= rightMostIndex) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置基准数</span></span><br><span class="line">  <span class="keyword">let</span> pivot = pivotIndex;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 先存一下基准下标</span></span><br><span class="line">  <span class="keyword">let</span> storeIndex = pivotIndex;</span><br><span class="line">  <span class="comment">// 向右找</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = pivotIndex + <span class="number">1</span>; i &lt;= rightMostIndex; ++i) &#123;</span><br><span class="line">    <span class="comment">// 若找到一个比基准数还小的数</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">array</span>[i] &lt; <span class="keyword">array</span>[pivot]) &#123;</span><br><span class="line">      <span class="comment">// 与这个数交换</span></span><br><span class="line">      <span class="keyword">array</span> = swap(<span class="keyword">array</span>, i, ++storeIndex);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 快排一个小于基准数的子集合已经弄在一起了，但还是需要交换顺序</span></span><br><span class="line">  <span class="keyword">array</span> = swap(<span class="keyword">array</span>, pivot, storeIndex);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 现在可以递归了</span></span><br><span class="line">  quickSort(<span class="keyword">array</span>, pivotIndex, storeIndex - <span class="number">1</span>);</span><br><span class="line">  quickSort(<span class="keyword">array</span>, storeIndex + <span class="number">1</span>, rightMostIndex);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">array</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">swap</span><span class="params">(array, preIndex, nextIndex)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> temp = <span class="keyword">array</span>[preIndex];</span><br><span class="line">  <span class="keyword">array</span>[preIndex] = <span class="keyword">array</span>[nextIndex];</span><br><span class="line">  <span class="keyword">array</span>[nextIndex] = temp;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">array</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>算法动态显示如下</p>
<p><img src="./img4.gif" alt></p>
<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>这个跟打牌的道理是一样的，它需要经历以下步骤</p>
<ol>
<li>默认取<strong>数列的第一个</strong>为已经为排好序的序列</li>
<li>然后取剩下的<strong>没有排好序的序列的第一个数</strong>，从<strong>已经排好序的序列的最后一位</strong>开始比较</li>
<li>如果 <strong>没有排好序列的第一个数</strong> 比较小,就移动数组将它插入到前面去</li>
<li>反复比较，最后插入</li>
</ol>
<figure class="highlight zephir"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 插入排序</span></span><br><span class="line"><span class="comment"> * 排序为从小到大</span></span><br><span class="line"><span class="comment"> * 输入的参数是一个包含正整数的一维数组</span></span><br><span class="line"><span class="comment"> * 返回的值也是一个一维数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>   &#123;Array&#125;  array  [数组]</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>  &#123;Array&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">insertionSort</span><span class="params">(array)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="keyword">array</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">let</span> val = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> j = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; <span class="keyword">array</span>.length; ++i) &#123; <span class="comment">// 数组第一个默认排序好</span></span><br><span class="line">    <span class="comment">// 取出元素 X</span></span><br><span class="line">    val = <span class="keyword">array</span>[i];</span><br><span class="line">    <span class="keyword">for</span> (j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span> &amp;&amp; (<span class="keyword">array</span>[j] &gt; val); --j) &#123; <span class="comment">// 已经排好序的前面的数列倒着与元素 X 比较</span></span><br><span class="line">      <span class="comment">// 先让排好序的元素后移</span></span><br><span class="line">      <span class="keyword">array</span>[j+<span class="number">1</span>] = <span class="keyword">array</span>[j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 让元素 X 插到前面去</span></span><br><span class="line">    <span class="keyword">array</span>[j+<span class="number">1</span>] = val;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">array</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>算法动态显示如下</p>
<p><img src="./img5.gif" alt></p>
<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>这种归并的算法就用到了”分治”的思想,就是指将两个已经排序的序列合并成一个序列的操作,该操作需要以下步骤</p>
<ol>
<li>先把长度为 n 的数组分成两半</li>
<li>然后把调用排序函数递归排序(merge sort)</li>
<li>最后将数组的左边和右边进行合并(merge)</li>
</ol>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 插入排序</span></span><br><span class="line"><span class="comment"> * 排序为从小到大</span></span><br><span class="line"><span class="comment"> * 输入的参数是一个包含正整数的一维数组</span></span><br><span class="line"><span class="comment"> * 返回的值也是一个一维数组</span></span><br><span class="line"><span class="comment"> * @param   &#123;Array&#125;  array  [数组]</span></span><br><span class="line"><span class="comment"> * @return  &#123;Array&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">function mergeSort(array) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!array) <span class="keyword">return</span> null;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (array.length === <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将数组分成两半</span></span><br><span class="line">  <span class="keyword">let</span> n = parseInt(array.length / <span class="number">2</span>);</span><br><span class="line">  <span class="keyword">let</span> <span class="keyword">left</span> = array.slice(<span class="number">0</span>, n);</span><br><span class="line">  <span class="keyword">let</span> <span class="keyword">right</span> = array.slice(n);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 递归排序</span></span><br><span class="line">  <span class="keyword">left</span> = mergeSort(<span class="keyword">left</span>);</span><br><span class="line">  <span class="keyword">right</span> = mergeSort(<span class="keyword">right</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将数组左半边和右半边合并</span></span><br><span class="line">  <span class="keyword">return</span> merge(<span class="keyword">left</span>, <span class="keyword">right</span>);</span><br><span class="line">&#125;</span><br><span class="line">function merge(<span class="keyword">left</span>, <span class="keyword">right</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="keyword">final</span> = [];</span><br><span class="line">  <span class="keyword">while</span> (<span class="keyword">left</span>.length &amp;&amp; <span class="keyword">right</span>.length) &#123;</span><br><span class="line">    <span class="comment">// 依次取出最小放到 final 里面</span></span><br><span class="line">    <span class="keyword">final</span>.push(<span class="keyword">left</span>[<span class="number">0</span>] &lt;= <span class="keyword">right</span>[<span class="number">0</span>] ? <span class="keyword">left</span>.shift() : <span class="keyword">right</span>.shift());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 剩下的 left.concat(right) 的值就是最大的</span></span><br><span class="line">  <span class="comment">// 然后再 final.concat(left.concat(right)) 将最后的这个最大数连接起来</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">final</span>.concat(<span class="keyword">left</span>.concat(<span class="keyword">right</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>算法动态显示如下</p>
<p><img src="./img6.gif" alt></p>
<h2 id="算法复杂度"><a href="#算法复杂度" class="headerlink" title="算法复杂度"></a>算法复杂度</h2><p>见下表</p>
<table>
<thead>
<tr>
<th>排序方法</th>
<th>时间复杂度(平均)</th>
<th>时间复杂度(最坏)</th>
<th>时间复杂度(最优)</th>
<th>空间复杂度</th>
<th>稳定性</th>
</tr>
</thead>
<tbody>
<tr>
<td>冒泡排序</td>
<td>O(n^2)</td>
<td>O(n^2)</td>
<td>O(n)</td>
<td>O(1)</td>
<td>稳定</td>
</tr>
<tr>
<td>选择排序</td>
<td>O(n^2)</td>
<td>O(n^2)</td>
<td>O(n^2)</td>
<td>O(1)</td>
<td>不稳定</td>
</tr>
<tr>
<td>计数排序</td>
<td>O(n+k)</td>
<td>O(n+k)</td>
<td>O(n+k)</td>
<td>O(n+k)</td>
<td>稳定</td>
</tr>
<tr>
<td>快速排序</td>
<td>O(nlogn)</td>
<td>O(n^2)</td>
<td>O(nlogn)</td>
<td>O(nlogn)</td>
<td>不稳定</td>
</tr>
<tr>
<td>插入排序</td>
<td>O(n^2)</td>
<td>O(n^2)</td>
<td>O(n)</td>
<td>O(1)</td>
<td>稳定</td>
</tr>
<tr>
<td>归并排序</td>
<td>O(nlogn)</td>
<td>O(nlogn)</td>
<td>O(nlogn)</td>
<td>O(n)</td>
<td>稳定</td>
</tr>
</tbody>
</table>
<h2 id="其他一些常用算法"><a href="#其他一些常用算法" class="headerlink" title="其他一些常用算法"></a>其他一些常用算法</h2><h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><p>二分查找是建立在被查找的数组是一个<strong>有序序列</strong>的基础上的，想法也是很朴素的，即找一个中间的数，若被查找的数小于这个中间的数，那么必然往数组更小的方向去找;若被查找的数大于这个中间的数，那么必然往数组更大的方向去找，然后在下一次找的时候取一个要查找范围的中间数，以此类推,这里尝试用递归的思路实现</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 二分查找算法</span></span><br><span class="line"><span class="comment"> * 方式是递归查找</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>   &#123;Array&#125;  array  [数组]</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>   &#123;Number&#125; low    [起始下标]</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>   &#123;Number&#125; high   [终点下标]</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>   &#123;Number&#125; target [查找目标数]</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>  &#123;Number&#125; mid    [查找到的数对应的下标]</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">binarySearch</span><span class="params">(array, low, high, target)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="keyword">array</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">if</span> (low &gt; high)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">var</span> mid = parseInt((high + low) / <span class="number">2</span>);</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">array</span>[mid] &gt; target)</span><br><span class="line">    <span class="keyword">return</span> binarySearch(<span class="keyword">array</span>, low, mid - <span class="number">1</span>, target);</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">array</span>[mid] &lt; target)</span><br><span class="line">    <span class="keyword">return</span> binarySearch(<span class="keyword">array</span>, mid + <span class="number">1</span>, high, target);</span><br><span class="line">  <span class="keyword">return</span> mid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="翻转二叉树"><a href="#翻转二叉树" class="headerlink" title="翻转二叉树"></a>翻转二叉树</h3><p>经常被人吐槽说若去面试 google,连这道面试题都答不出来的就可以滚了，2333。一个简单的实现就是递归翻转这个二叉树，然后将得到的这个递归出来的<strong>节点的左边指向它的右边</strong>,将得到的这个递归出来的<strong>节点的右边指向它的左边</strong>,代码如下</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 简单翻转二叉树算法</span><br><span class="line"> * @param   &#123;Object&#125;  <span class="keyword">node</span>  <span class="title">[一颗树的对象]</span></span><br><span class="line"><span class="title"> * @return</span>  &#123;Object&#125;  <span class="keyword">node</span>  <span class="title">[一颗树的对象]</span></span><br><span class="line"><span class="title"> */</span></span><br><span class="line"><span class="title">function</span> reverseBinaryTree(<span class="keyword">node</span><span class="title">) &#123;</span></span><br><span class="line"><span class="title">  if</span> (!<span class="keyword">node</span><span class="title">) &#123;</span></span><br><span class="line"><span class="title">    return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  let left = reverseBinaryTree(<span class="keyword">node</span>.<span class="title">left</span>);</span><br><span class="line">  let right = reverseBinaryTree(<span class="keyword">node</span>.<span class="title">right</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">node</span>.<span class="title">left</span> = right;</span><br><span class="line">  <span class="keyword">node</span>.<span class="title">right</span> = left;</span><br><span class="line"></span><br><span class="line">  return <span class="keyword">node</span><span class="title">;</span></span><br><span class="line"><span class="title">&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="打印二叉树"><a href="#打印二叉树" class="headerlink" title="打印二叉树"></a>打印二叉树</h3><p>用递归</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">function printTree(prefix, <span class="keyword">node</span><span class="title">, isLeft</span>) &#123;</span><br><span class="line">  if (<span class="keyword">node</span><span class="title">) &#123;</span></span><br><span class="line"><span class="title">    console</span>.log(prefix + (isLeft ? <span class="string">"|-- "</span> : <span class="string">"\\-- "</span>) + <span class="keyword">node</span>.<span class="title">value</span>);</span><br><span class="line">    printTree(prefix + (isLeft ? <span class="string">"|   "</span> : <span class="string">"    "</span>), <span class="keyword">node</span>.<span class="title">left</span>, <span class="literal">true</span>);</span><br><span class="line">    printTree(prefix + (isLeft ? <span class="string">"|   "</span> : <span class="string">"    "</span>), <span class="keyword">node</span>.<span class="title">right</span>, <span class="literal">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h3><p>桶排序是计数排序的升级版，比如像这样的数组</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">[<span class="number">0</span>, <span class="number">56</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">67</span>]</span><br></pre></td></tr></table></figure>
<p>桶排序算法相对于计数排序升级的地方主要在于其 hash 的存储方式，如下</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">hash:</span> <span class="string">&#123;</span></span><br><span class="line">    <span class="attr">0:</span> <span class="string">[0],</span></span><br><span class="line">    <span class="attr">1:</span> <span class="string">[1,1],</span></span><br><span class="line">    <span class="number">2</span><span class="string">:[],</span></span><br><span class="line">    <span class="number">3</span><span class="string">:[],</span></span><br><span class="line">    <span class="number">4</span><span class="string">:[],</span></span><br><span class="line">    <span class="number">5</span><span class="string">:[],</span></span><br><span class="line">    <span class="string">...,</span></span><br><span class="line">    <span class="number">56</span><span class="string">:[56],</span></span><br><span class="line">    <span class="number">67</span><span class="string">:[67],</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>
<p>其实可以看出来，就像是<strong>一个数组里面又存放了一个数组</strong>,很像<strong>二维数组</strong> 的存储方式<br>其本质上就是将数组中重复的数放到这个有限数量的桶里面，然后再次对这个桶里面的数组进行排序,具体实现在 <a href="https://github.com/strugglebak/common-algorithm/blob/master/sorting/bucket-sort.js" target="_blank" rel="noopener">代码链接</a></p>
<h3 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h3><p>就是根据 [基数] 来排序，比如有如下数组</p>
<figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="symbol">23 </span><span class="number">202</span> <span class="number">103</span> <span class="number">566</span> <span class="number">32</span> <span class="number">617</span> <span class="number">37</span></span><br></pre></td></tr></table></figure>
<p>hash 的存储情况如下</p>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line">hash: &#123;</span><br><span class="line">    <span class="string">'0'</span>: <span class="literal">undefined</span>,</span><br><span class="line">    <span class="string">'1'</span>: <span class="literal">undefined</span>,</span><br><span class="line">    <span class="string">'2'</span>: [<span class="number">202</span>,<span class="number">32</span>],</span><br><span class="line">    <span class="string">'3'</span>: [<span class="number">23</span>,<span class="number">103</span>],</span><br><span class="line">    <span class="string">'4'</span>: <span class="literal">undefined</span>,</span><br><span class="line">    <span class="string">'5'</span>: <span class="literal">undefined</span>,</span><br><span class="line">    <span class="string">'6'</span>: [<span class="number">566</span>],</span><br><span class="line">    <span class="string">'7'</span>: [<span class="number">617</span>,<span class="number">37</span>],</span><br><span class="line">    <span class="string">'8'</span>: <span class="literal">undefined</span>,</span><br><span class="line">    <span class="string">'9'</span>: <span class="literal">undefined</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>思路就是，第一次比较个位，第二次比较十位，第三次比较百位，第四次比较千位…,然后把排列好的序列从桶里面抽出来,放到原来的数组中去,然后再次重复上述操作,这里需要注意的是每个桶都是<strong>一个队列</strong>,可以利用队列先进先出的特性来排。所以基数排序是在在桶排序的基础上优化而来的，目的是解决桶排序中待排序数字跨度过大,需要使用很多桶空间的问题。桶排序很简单，但是很浪费桶资源,但是对于基数排序，桶的个数是固定的。<br>具体实现在 <a href="https://github.com/strugglebak/common-algorithm/blob/master/sorting/radix-sort.js" target="_blank" rel="noopener">代码链接</a></p>
<h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p>堆可以视为一颗完全的二叉树，完全二叉树的一个性质是，除了最底层之外，每一层都是满的，这使得<strong>堆可以用数组来表示</strong>,特点就是最大的数在最上面<br>这里有个关键的地方，叫做 最大堆调整<br>具体实现在 <a href="https://github.com/strugglebak/common-algorithm/blob/master/sorting/heap-sort.js" target="_blank" rel="noopener">代码链接</a></p>
<h2 id="算法特征归纳"><a href="#算法特征归纳" class="headerlink" title="算法特征归纳"></a>算法特征归纳</h2><ul>
<li>输入: 一个算法必须有零个或以上输入量</li>
<li>输出: 一个算法应有一个或以上输出量，输出量是算法计算的结果</li>
<li>明确性: 算法的描述必须无歧义，以保证算法的实际执行结果是精确地匹配要求或期望，通常要求实际运行结果是确定的</li>
<li>有限性: 一个算法是能够被任何图灵完备系统模拟的一串运算，而图灵机只有有限个状态，有限个输入符号和有限个转移函数(指令)</li>
<li>有效性: 可行性，算法中描述的操作都可以通过已经实现的基本运算执行有限次来实现</li>
</ul>
<h2 id="参考网站"><a href="#参考网站" class="headerlink" title="参考网站"></a>参考网站</h2><p>网站 <a href="http://visualgo.net" target="_blank" rel="noopener">排序可视化</a></p>
]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>一些常见数据结构</title>
    <url>/2019/02/19/%E4%B8%80%E4%BA%9B%E5%B8%B8%E8%A7%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<p>##数据结构</p>
<p>一般来说，对于问题，解决步骤有</p>
<ol>
<li>解决一个跟数据相关的问题</li>
<li>分析这个问题，想出对应的数据结构</li>
<li>分析数据结构，想出算法</li>
</ol>
<p>而对于算法的思想，则有如下的分类</p>
<ul>
<li>分治法</li>
<li>动态规划法</li>
<li>贪婪算法</li>
<li>线性规划法</li>
<li>简并法</li>
</ul>
<p>而我们的大前端则主要使用分治法</p>
<h2 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h2><p>算法中经常会用到哈希，那么什么是哈希(hash)呢?</p>
<figure class="highlight clean"><table><tr><td class="code"><pre><span class="line">a &lt;- &#123;</span><br><span class="line">    <span class="string">'0'</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="string">'1'</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="string">'key'</span>: <span class="string">'value'</span>,</span><br><span class="line">    <span class="string">'键'</span>: <span class="string">'值'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>像以上代码中拥有类似 <code>key-value</code> 的结构形式的就是所谓哈希(hash)</p>
<h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p>特点就是<strong>先进先出</strong>,可以用数组实现</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> q = []</span><br><span class="line">q.push(<span class="string">'张三'</span>)</span><br><span class="line">q.push(<span class="string">'李四'</span>)</span><br><span class="line">q.push(<span class="string">'王二麻子'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 出队</span></span><br><span class="line">q.shift() <span class="comment">// 张三</span></span><br><span class="line">q.shift() <span class="comment">// 李四</span></span><br><span class="line">q.shift() <span class="comment">// 王二麻子</span></span><br></pre></td></tr></table></figure>
<h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p>特点就是<strong>先进后出</strong>,也可以用数组实现</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> stack = []</span><br><span class="line">stack.push(<span class="string">'张三'</span>)</span><br><span class="line">stack.push(<span class="string">'李四'</span>)</span><br><span class="line">stack.push(<span class="string">'王二麻子'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 出栈</span></span><br><span class="line">stack.pop() <span class="comment">// 王二麻子</span></span><br><span class="line">stack.pop() <span class="comment">// 李四</span></span><br><span class="line">stack.pop() <span class="comment">// 张三</span></span><br></pre></td></tr></table></figure>
<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p>数组无法直接删除中间的某一项,如用 hash (JS 中用对象表示 hash)实现链表</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">    value:<span class="number">0</span>,</span><br><span class="line">    next:&#123;</span><br><span class="line">        value:<span class="number">2</span>,</span><br><span class="line">        next:&#123;</span><br><span class="line">            value:<span class="number">1</span>,</span><br><span class="line">            next: <span class="literal">undefined</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 从链表中删除掉第二个节点</span></span><br><span class="line">a.next = a.next.next</span><br></pre></td></tr></table></figure>
<h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><p>树的层级结构图如下所示</p>
<p><img src="./img1.png" alt></p>
<p>所以树是什么呢，树就是由 n 个节点组成的一个具有层次关系的集合(这里 n &gt; 0),我们之所以叫树是因为它看起来像树，一个倒着的树。由图中可以看出，一颗树有如下的特点</p>
<ol>
<li>每个爸爸节点有 0 个或多个儿子节点</li>
<li>根节点是没有爸爸节点的，如图中 A</li>
<li>每一个不是根节点的节点不可能有多个爸爸节点</li>
<li>除了根节点，每个儿子节点可以分为多个不相交的子树</li>
</ol>
<p>这里还有几个比较重要的概念:层数、深度、节点个数</p>
<ul>
<li>层数<br>就是根节点为第一层，根节点的儿子节点为第二层，根节点的儿子的儿子节点为第三层…</li>
<li>深度<br>对于任意的节点 X，X 的深度为根节点到 X 的唯一路径长,比如设 A 到 B 的路径是 1, B 到 D 的路径是 2 的话，那么 A 到 D 的深度就是 3</li>
<li>节点个数<br>就是一颗树有多少个节点，如上图所示的，一共有 16 个节点</li>
</ul>
<h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><p>树中很重要的一个概念就是二叉树，二叉树是什么？就是每个节点<strong>最多有两个儿子节点的树</strong>,如下图就是一颗二叉树</p>
<p><img src="./img2.png" alt></p>
<h3 id="满二叉树"><a href="#满二叉树" class="headerlink" title="满二叉树"></a>满二叉树</h3><p>什么是满二叉树？假设一颗树的深度为 n，且一共有 $2^{n+1} - 1$ 个节点的树就叫做满二叉树，如下图所示</p>
<p><img src="./img3.png" alt></p>
<p>满二叉树的特点就是每一层上的节点数都是最大节点数，看起来很满就是它了</p>
<h3 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h3><p>什么是完全二叉树？假设一颗树的深度为 n,至少有 $2^k$ 个节点，至多有 $2^{k+1} - 1$ 个节点的树就叫做完全二叉树。那么问题来了，完全二叉树如何与其他的树做区分呢？可以参考下图</p>
<p><img src="./img4.png" alt></p>
<p>其实有个小技巧，即</p>
<ol>
<li>先对一个满二叉树进行<strong>广度优先遍历</strong>,按照这个顺序进行编号</li>
<li>对要测试的树也进行广度有限遍历并按照顺序编号，然后与这颗满二叉树一一比对，若所有编号<strong>所在位置</strong>能和满二叉树对应，那么这个就是完全二叉树(如上图中的 c、d 就不是完全二叉树)</li>
</ol>
<p>完全二叉树和满二叉树可以用数组实现,方法如下</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 假如有这样的数组，存储树数据如下所示</span></span><br><span class="line">a = [<span class="number">1</span>,  <span class="number">2</span>,<span class="number">3</span>,  <span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,  <span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>,<span class="number">13</span>,<span class="number">14</span>,<span class="number">15</span>]</span><br><span class="line"><span class="comment">// 取树的第几层(layer)的第几个数(index)</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getValue</span>(<span class="params">array, layer, index</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> array[(<span class="number">2</span> ** (layer<span class="number">-1</span>) + index)]</span><br><span class="line">&#125;</span><br><span class="line">getValue(a, <span class="number">2</span>, <span class="number">2</span>) <span class="comment">// 3</span></span><br><span class="line">getValue(a, <span class="number">3</span>, <span class="number">1</span>) <span class="comment">// 4</span></span><br></pre></td></tr></table></figure>
<p>如上所示就通过一个公式就可以取数，但是用数组来存储树有个缺点，就是可能浪费数组空间，若这个树不是满二叉树或者是完全二叉树，比如如下</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">a = [<span class="number">1</span>,  <span class="number">2</span>,<span class="number">3</span>,  <span class="number">4</span>,<span class="number">5</span>,<span class="literal">undefined</span>,<span class="literal">undefined</span>,  <span class="literal">undefined</span>,<span class="literal">undefined</span>,<span class="number">6</span>,<span class="number">7</span>] <span class="comment">// 上图中 (c)</span></span><br><span class="line">a = [<span class="number">1</span>,  <span class="number">2</span>,<span class="number">3</span>,  <span class="number">4</span>,<span class="number">5</span>,<span class="literal">undefined</span>,<span class="number">6</span>] <span class="comment">// 上图中 (d)</span></span><br></pre></td></tr></table></figure>
<p>可以观察到在数组中虽然申请了空间，但是没有用到</p>
<p>其他树可以用 hash (对象)来实现</p>
<h3 id="B-树"><a href="#B-树" class="headerlink" title="B 树"></a>B 树</h3><p>// todo</p>
<h3 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h3><p>// todo</p>
<h3 id="AVL-树"><a href="#AVL-树" class="headerlink" title="AVL 树"></a>AVL 树</h3><p>// todo</p>
]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>一些面试题</title>
    <url>/2019/02/20/%E4%B8%80%E4%BA%9B%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<h2 id="问题1"><a href="#问题1" class="headerlink" title="问题1"></a>问题1</h2><p>请写出一个符合 W3C 规范的 HTML 文件，要求</p>
<ul>
<li>页面标题为「我的页面」</li>
<li>页面中引入了一个外部 CSS 文件，文件路径为 /style.css</li>
<li>页面中引入了另一个外部 CSS 文件，路径为 /print.css，该文件仅在打印时生效</li>
<li>页面中引入了另一个外部 CSS 文件，路径为 /mobile.css，该文件仅在设备宽度小于 500 像素时生效</li>
<li>页面中引入了一个外部 JS 文件，路径为 /main.js</li>
<li>页面中引入了一个外部 JS 文件，路径为 /gbk.js，文件编码为 GBK</li>
<li>页面中有一个 SVG 标签，SVG 里面有一个直径为 100 像素的圆圈，颜色随意</li>
<li>注意题目中的路径</li>
</ul>
<h2 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>我的页面<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"./style.css"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"./print.css"</span> <span class="attr">media</span>=<span class="string">"print"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"./mobile.css"</span> <span class="attr">media</span>=<span class="string">"(max-width: 500px)"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span></span><br><span class="line">      svg &#123;</span><br><span class="line">        width: 100px;height: 100px;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">svg</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">circle</span> <span class="attr">cx</span>=<span class="string">"50px"</span> <span class="attr">cy</span>=<span class="string">"50px"</span> <span class="attr">r</span>=<span class="string">"50px"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"./main.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"./gbk.js"</span> <span class="attr">charset</span>=<span class="string">"gbk"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="问题2"><a href="#问题2" class="headerlink" title="问题2"></a>问题2</h2><p><a href="https://github.com/Bless-L/MyBlog/blob/master/post/2016%E8%85%BE%E8%AE%AF%E5%AE%9E%E4%B9%A0%E7%94%9F%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%8E%86%E5%8F%8A%E6%80%BB%E7%BB%93%EF%BC%88%E4%BA%8C%EF%BC%89.md" target="_blank" rel="noopener">2016腾讯前端面试题</a><br>移动端是怎么做适配的?<br>提示:</p>
<ul>
<li>meta viewport</li>
<li>媒体查询(media query)</li>
<li>动态 rem 方案</li>
</ul>
<h2 id="答案-1"><a href="#答案-1" class="headerlink" title="答案"></a>答案</h2><p>主要是看页面的复杂度</p>
<ol>
<li>简单页面的做法是，设置高度为固定值，然后宽度为 100%</li>
<li>复杂一点的可以采用百分比布局,即利用百分比设置元素的大小进行适配</li>
<li>再复杂一点的就要用到媒体查询，即 media query, 依据页面的大小来写不同的 css 进行渲染</li>
</ol>
<p>而目前能做到兼容以上方案的就是动态 rem 方案,该方案需要用到以下几点</p>
<ul>
<li><p>meta viewport</p>
  <figure class="highlight nix"><table><tr><td class="code"><pre><span class="line">&lt;meta <span class="attr">name="viewport"</span> <span class="attr">content="width=device-width,</span> <span class="attr">user-scalable=no,</span> <span class="attr">initial-scale=1.0,</span> <span class="attr">maximum-scale=1.0,</span> <span class="attr">minimum-scale=1.0"&gt;</span></span><br></pre></td></tr></table></figure>
<p>  以上代码作用是防止手机页面模拟 980 像素宽度</p>
</li>
<li><p>媒体查询</p>
<p>  即 media query, 使用方式类似于</p>
  <figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@media</span> (条件) &#123;</span><br><span class="line">    <span class="comment">// 条件均满足时成立的 css 代码</span></span><br><span class="line">&#125;</span><br><span class="line">或者</span><br><span class="line"><span class="keyword">@media</span> (条件<span class="number">1</span>) <span class="keyword">and</span> (条件<span class="number">2</span>) &#123;</span><br><span class="line">    <span class="comment">// 条件均满足时成立的 css 代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  示例:</p>
  <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">  <span class="keyword">@media</span> (<span class="attribute">max-width:</span> <span class="number">800px</span>) &#123;</span></span><br><span class="line"><span class="css">    <span class="comment">/*若括号中条件成立的 css 代码*/</span></span></span><br><span class="line">    body &#123;</span><br><span class="line">      background: red;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>rem</p>
<p>  rem 即 <strong>font size of the root element</strong>，网页根元素的 font-size,<br>  本质上来说，就是将 rem 应用在 width 和 height 上,然后根据根元素的 font-size 值来改变元素宽高的大小,<br>  可以利用 sass 的function 功能，在 scss 文件中写入</p>
  <figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@function</span> px2rem(<span class="variable">$px</span>) &#123;</span><br><span class="line">    <span class="keyword">@return</span> <span class="variable">$px</span>/<span class="variable">$designWidth</span>*<span class="number">10</span> + rem;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$designWidth</span>: <span class="number">640</span>;</span><br></pre></td></tr></table></figure>
<p>  其中 $px 为传入的需要转换的像素值，$designWidth 为设计稿提供的宽度值</p>
</li>
</ul>
<h2 id="问题3"><a href="#问题3" class="headerlink" title="问题3"></a>问题3</h2><p><a href="https://earthsplitter.github.io/2017/03/31/2017腾讯实习经验总结/" target="_blank" rel="noopener">2017年腾讯前端实习面试题（二面）</a><br>用过 CSS3 么，实现圆角矩形和阴影怎么做?</p>
<h2 id="答案-2"><a href="#答案-2" class="headerlink" title="答案"></a>答案</h2><ol>
<li>圆角矩形<br>使用 <code>border-radius</code> 属性</li>
</ol>
<p><code>border-radius</code> 是一个简写属性,包含 <code>border-top-left-radius、border-top-right-radius、border-bottom-right-radius，和 border-bottom-left-radius</code></p>
<p>即包含 “左上、右上、右下、左下” 角</p>
<p>示例<br><figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line"><span class="built_in">border</span>-<span class="built_in">radius</span>: 10px; <span class="comment">/*半径为 10px 的圆角*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*或者*/</span></span><br><span class="line"><span class="built_in">border</span>-top-left-<span class="built_in">radius</span>: 10px;</span><br><span class="line"><span class="built_in">border</span>-top-right-<span class="built_in">radius</span>: 10px;</span><br><span class="line"><span class="built_in">border</span>-bottom-right-<span class="built_in">radius</span>: 10px;</span><br><span class="line"><span class="built_in">border</span>-bottom-left-<span class="built_in">radius</span>: 10px;</span><br></pre></td></tr></table></figure></p>
<ol start="2">
<li>阴影<br>使用 <code>box-shadow</code> 属性</li>
</ol>
<p><code>box-shadow</code> 的语法是 <code>box-shadow: &lt;inset&gt; &lt;offset-x&gt; &lt;offset-y&gt; &lt;blur-radius&gt; &lt;spread-radius&gt; &lt;color&gt;</code></p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="string">inset:</span> 使用这个，则使阴影在边框内; 若不使用，阴影在边框外</span><br><span class="line">offset-x, offset-<span class="string">y:</span> 阴影偏移量</span><br><span class="line">blur-<span class="string">radius:</span> 设置模糊效果，值越大越模糊</span><br><span class="line">spread-<span class="string">radius:</span> 设置阴影扩大和缩小的效果</span><br><span class="line"><span class="string">color:</span> 设置阴影的颜色</span><br></pre></td></tr></table></figure>
<p>示例<br><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">box-shadow:</span> <span class="number">0</span> <span class="number">0</span> <span class="string">7px</span> <span class="string">12px</span> <span class="string">rgba(255,</span> <span class="number">255</span><span class="string">,</span> <span class="number">255</span><span class="string">,</span> <span class="number">0.7</span><span class="string">);</span></span><br></pre></td></tr></table></figure></p>
<p>若设置多重阴影效果，可以用逗号 ‘,’ 隔开</p>
<h2 id="问题4"><a href="#问题4" class="headerlink" title="问题4"></a>问题4</h2><p>什么是闭包，闭包的用途是什么？</p>
<h2 id="答案-3"><a href="#答案-3" class="headerlink" title="答案"></a>答案</h2><ol>
<li><p>什么是闭包</p>
<p> 有如下代码</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeFunc1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> name = <span class="string">"Mozilla"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">displayName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        alert(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> displayName;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> myFunc = makeFunc1();</span><br><span class="line">myFunc();</span><br></pre></td></tr></table></figure>
<p> 在 <code>funtion dispalyName</code> 中, 函数 <code>dispalyName</code> 访问到了它作用域之外的变量 <code>name</code> ，这个就叫做 <strong>闭包</strong>, 即<br> <strong>闭包是由函数以及创建该函数的词法环境组合而成，而这个环境包含了这个闭包创建时所能访问的所有的局部变量</strong></p>
</li>
<li><p>闭包的用途是什么</p>
<p> 有如下代码</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myFunc = (<span class="function"><span class="keyword">function</span> <span class="title">makeFunc2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">changeBy</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">        num += val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        add: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            changeBy(<span class="number">1</span>);</span><br><span class="line">        &#125;,</span><br><span class="line">        sub: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            changeBy(<span class="number">-1</span>);</span><br><span class="line">        &#125;,</span><br><span class="line">        val: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> num;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).call();</span><br><span class="line"><span class="built_in">console</span>.log(myFunc.val()); <span class="comment">// 0</span></span><br><span class="line">myFunc.add();</span><br><span class="line"><span class="built_in">console</span>.log(myFunc.val()); <span class="comment">// 1</span></span><br><span class="line">myFunc.sub();</span><br><span class="line"><span class="built_in">console</span>.log(myFunc.val()); <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>
<p> 通过以上代码可以看出，闭包的作用就是 <strong>隐藏变量以及封装</strong>, 目的就是不直接对全局变量进行修改，<br> 用局部变量以及能访问这个局部变量的函数来替代，最后将这个函数接口暴露出来使用，即可达到目的</p>
</li>
</ol>
<h2 id="问题5"><a href="#问题5" class="headerlink" title="问题5"></a>问题5</h2><p>call、apply、bind 的用法是什么?</p>
<h2 id="答案-4"><a href="#答案-4" class="headerlink" title="答案"></a>答案</h2><ul>
<li><p>call 用法<br>  函数实例调用 <code>call</code> 方法，指定函数 <code>this</code> 内部的指向, 调用方式为 <code>func.call(thisValue)</code></p>
  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;;</span><br><span class="line">f() === <span class="built_in">window</span>; <span class="comment">// true</span></span><br><span class="line">f.call(obj) === obj; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>  若有多个参数要传,调用方式为 <code>func.call(thisValue, arg1, arg2, ...)</code></p>
  <figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span><span class="params">(a, b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line">f.call(<span class="literal">null</span>, <span class="number">1</span>, <span class="number">2</span>); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<p>  其中 <code>thisValue</code> 为 <code>this</code> 所要指向的对象</p>
</li>
<li><p>apply 用法<br>  与 <code>call</code> 方法类似，指定函数 <code>this</code> 内部指向，然后再调用该函数, 调用方式为 <code>func.call(thisValue, [arg1, arg2, ...])</code></p>
  <figure class="highlight delphi"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span><span class="params">(a, b)</span> <span class="comment">&#123;</span></span></span><br><span class="line"><span class="function"><span class="comment">    console.log(a + b);</span></span></span><br><span class="line"><span class="function"><span class="comment">&#125;</span></span></span><br><span class="line"><span class="function"><span class="title">f</span>.<span class="title">apply</span><span class="params">(null, [1, 2])</span>;</span> <span class="comment">// 这里第二个参数必须以数组形式添加</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>bind 用法<br>  bind 方法用于将函数体内的 <code>this</code> 绑定到某个对象,然后 <strong>返回一个新函数</strong>, 调用方式为 <code>func.bind(thisValue)</code></p>
  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">x</span>: <span class="number">3</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.x);</span><br><span class="line">&#125;;</span><br><span class="line">f(); <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">var</span> f2 = f.bind(obj); <span class="comment">// 绑定 this 到 obj 这个对象中</span></span><br><span class="line">f2(); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>另外,以上三种方式中，<code>thisValue</code> 如果设置为 <code>null</code> 或 <code>undefind</code>, 那么等同于指定的是全局对象,即 <code>window</code></p>
<h2 id="问题6"><a href="#问题6" class="headerlink" title="问题6"></a>问题6</h2><p>请说出至少 8 个 HTTP 状态码，并描述各状态码的意义</p>
<p>例如:</p>
<p>状态码 200 表示响应成功</p>
<h2 id="答案-5"><a href="#答案-5" class="headerlink" title="答案"></a>答案</h2><p>状态码类型如下</p>
<ul>
<li>1XX消息 – 表示请求已经被接收，需要继续处理<ul>
<li>100 Continue: 表示服务器已经接收到请求头，并且客户端应继续发送请求主体</li>
<li>101 Switching Protocols: 表示服务器已经理解了客户端的请求，并将通过 <code>Upgrade</code> 消息头通知客户端采用不同的协议来完成请求</li>
</ul>
</li>
<li>2XX成功 – 表示请求已经被服务器接收、理解<ul>
<li>200 OK: 表示响应成功</li>
<li>202 Accepted: 表示服务器已经接收请求，但尚未处理</li>
</ul>
</li>
<li>3XX重定向 – 表示需要客户端的后续操作才能完成请求<ul>
<li>301 Moved Permanently: 表示请求的资源已经被永久地移动到新的位置，并且将来对该资源的任何引用都应该使用本响应返回的若干个 URL 之一</li>
<li>302 Found: 要求客户端执行临时重定向,由于这个重定向是临时的，客户端应继续向原有地址发送以后的请求</li>
<li>304 Not Modified: 表示资源未被修改,由于客户端有之前下载的副本，所有不需要传输资源</li>
</ul>
</li>
<li>4XX客户端错误 – 请求含有词法错误或者无法被执行，通常表示客户端发送请求时出问题的情况<ul>
<li>400 Bad Request: 由于明显的客户端错误，服务器不会处理该请求</li>
<li>401 Unauthorized: 表示当前请求需要用户验证,类似于 403 Forbidden</li>
<li>403 Forbidden: 表示服务器已经理解请求，但是拒绝执行它</li>
<li>404 Not Found: 表示请求失败，请求所希望得到的资源未在服务器上发现，但允许用户的后续请求</li>
</ul>
</li>
<li>5XX服务器错误 – 表示服务器无法完成明显有效的请求<ul>
<li>500 Internal Server Error: 表示服务器遇到了一个未曾预料的情况，导致无法响应请求</li>
<li>501 Not Implemented: 表示服务器不支持当前请求所需要的某个功能</li>
<li>502 Bad Gateway: 作为网关或代理服务器尝试执行请求时，从上游服务器接收到无效的响应</li>
<li>503 Service Unavilable: 表示服务器当前因正在维护或过载，无法响应请求</li>
<li>504 Gateway Timeout: 作为网关或代理服务器尝试执行请求时,未能即时从上游服务器接收到响应</li>
</ul>
</li>
</ul>
<h2 id="问题7"><a href="#问题7" class="headerlink" title="问题7"></a>问题7</h2><p>请写出一个 HTTP post 请求的内容，包括四部分。</p>
<p>其中</p>
<p>第四部分的内容是 username=ff&amp;password=123</p>
<p>第二部分必须含有 Content-Type 字段</p>
<p>请求的路径为 /path</p>
<h2 id="答案-6"><a href="#答案-6" class="headerlink" title="答案"></a>答案</h2><figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/path</span> HTTP/1.1</span><br><span class="line"><span class="attribute">Host</span>: www.baidu.com</span><br><span class="line"><span class="attribute">User-Agent</span>: curl/7.58.0</span><br><span class="line"><span class="attribute">Accept</span>: */*</span><br><span class="line"><span class="attribute">Content-Length</span>: 24</span><br><span class="line"><span class="attribute">Content-Type</span>: application/x-www-form-urlencoded</span><br><span class="line"></span><br><span class="line">username=ff&amp;password=123</span><br></pre></td></tr></table></figure>
<h2 id="问题8"><a href="#问题8" class="headerlink" title="问题8"></a>问题8</h2><p>请说出至少三种排序的思路，这三种排序的时间复杂度分别为</p>
<ol>
<li>O(n*n)</li>
<li>O(n log2 n)</li>
<li>O(n + max)</li>
</ol>
<h2 id="答案-7"><a href="#答案-7" class="headerlink" title="答案"></a>答案</h2><ol>
<li>O(n*n)</li>
</ol>
<p>冒泡排序:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">对于一组数列来说，重复走过需要排序的部分，一次比较两个数列中的元素，依照大小规则交换它们的顺序，直到整个数列中不需要做交换的操作为止</span><br></pre></td></tr></table></figure></p>
<ol start="2">
<li>O(n log2 n)</li>
</ol>
<p>归并排序<br><figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line">先将数列中的这堆数分成一个个长度为 <span class="number">2</span> 的子数列，然后使每个子数列有序，然后两两合并, 继续两两合并剩下的已经弄好序的子数列，直到这些子数列合并成一个有序数列为止</span><br></pre></td></tr></table></figure></p>
<ol start="3">
<li>O(n + max)</li>
</ol>
<p>计数排序<br><figure class="highlight pf"><table><tr><td class="code"><pre><span class="line">先扫描一遍数列中，得到该数列的最大值 <span class="keyword">max</span>Value 和最小值 <span class="keyword">min</span>Value,然后增加一个长度为 [<span class="keyword">max</span>Value - <span class="keyword">min</span>Value + <span class="number">1</span>] 的数组, 这个数组的下标 index 对应着数列的值，</span><br><span class="line"></span><br><span class="line">然后统计数列的值出现的次数，记录在数组下标对应的值上,然后依据这个次数反向填充进原数列中</span><br></pre></td></tr></table></figure></p>
<h2 id="问题9"><a href="#问题9" class="headerlink" title="问题9"></a>问题9</h2><p>一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么?</p>
<h2 id="答案-8"><a href="#答案-8" class="headerlink" title="答案"></a>答案</h2><ol>
<li><p>URL 解析</p>
 <figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">从输入 <span class="built_in">URL</span> 开始，浏览器就开始开启线程解析这个 <span class="built_in">URL</span>(统一资源定位符)，<span class="built_in">URL</span> 的格式为: protocol://host:port/path?query<span class="comment">#fragment</span></span><br><span class="line">其中</span><br><span class="line">protocol: 代表 <span class="built_in">URL</span> 协议头，比如说 <span class="keyword">http</span> 或 <span class="keyword">ftp</span> 等</span><br><span class="line">host: 主机名或者 ip 地址</span><br><span class="line">port: 端口号</span><br><span class="line">path: 请求资源的目录路径</span><br><span class="line">query: 查询参数</span><br><span class="line">fragment: 就是锚点,与网页的定位显示有关</span><br><span class="line">对于端口号 port 来说，可有可无，一般使用协议的默认端口,如 <span class="keyword">http</span> 的 <span class="number">80</span> 端口，<span class="keyword">https</span> 的 <span class="number">443</span> 端口等</span><br></pre></td></tr></table></figure>
</li>
<li><p>检查 DNS 缓存</p>
 <figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">在 DNS 进行域名解析之前，会先检查 DNS 缓存是否与输入的 URL 有映射关系，若有就调用这个映射，没有查到则返回</span><br><span class="line">检查顺序依次为: 检查 HOST 文件、检查本地 DNS 缓存、检查浏览器缓存</span><br><span class="line">HOST 文件: 其实就是 <span class="regexp">/etc/</span>hosts</span><br><span class="line">本地 DNS 缓存: 以 Linux 系统来说，为 <span class="regexp">/etc/</span>resolv.conf</span><br><span class="line">浏览器缓存: 即浏览器中保存的 DNS 缓存，比如在 Chrome 浏览器中输入 <span class="string">chrome:</span><span class="comment">//dns/ 即可看到</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>DNS 域名解析</p>
 <figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">DNS 域名解析的本质就是将<span class="built_in"> DNS </span>域名解析成<span class="built_in"> IP </span>的过程，以解析 www.wh.hb.cn 为例</span><br><span class="line">在经过<span class="built_in"> DNS </span>缓存的检查之后，分别依次向这几个服务器进行迭代查询</span><br><span class="line"></span><br><span class="line">- 根域名服务器(顶级域)</span><br><span class="line">- 管理 cn 域的服务器(第二层域)</span><br><span class="line">- 管理 hb.cn 域的服务器(子域)</span><br><span class="line">- 管理 wh.hb.cn 域的服务器</span><br><span class="line"></span><br><span class="line">首先若本地没有缓存中没有对应域名对应 ip，则本地域名服务器会向根域名服务器发送查询请求，若根域名服务器不存在该域名，则本地域名服务器会向管理 cn 域的服务器发送一个查询请求，</span><br><span class="line">以此类推,最终的解析过程为 `. -&gt; .cn -&gt; hb.cn -&gt; wh.hb.cn -&gt; www.wh.hb.cn`</span><br></pre></td></tr></table></figure>
</li>
<li><p>建立 TCP/IP 连接</p>
 <figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">IP 地址获取到之后，就开始与目标服务器进行连接，这一过程靠 TCP 协议来完成,需要经过 3 次握手来完成连接</span><br><span class="line">第 1 次握手: 客户端发送连接请求报文，在这个报文中，设置 <span class="attribute">SYN</span>=1, <span class="attribute">seq</span>=x(起始序列号)</span><br><span class="line">第 2 次握手: 服务器接收到这个连接请求报文后，返回确认报文，设置 <span class="attribute">SYN</span>=1,ACK=1,seq=y(随机设置),ack=x+1(表示x已经收到，期待收到x+1)</span><br><span class="line">第 3 次握手: 客户端收到服务器返回的确认报文后，也要返回一个确认报文，设置 <span class="attribute">ACK</span>=1,seq=x+1,ack=y+1</span><br></pre></td></tr></table></figure>
<p> 其中</p>
<ul>
<li>SYN=1,ACK=0 表示连接请求报文</li>
<li>SYN=1,ACK=1 表示连接接收报文</li>
<li>seq 为序号字段，表示报文数据的第一个字节的序号</li>
<li>SYN=1 时,报文不能携带数据,并且需要消耗序号,如果不设置 SYN，则不携带数据也不消耗序号</li>
<li><p>ack 为确认号字段，表示期望收到对方下一个报文数据的第一个字节的序号</p>
<p>3 次握手完成之后，就可以传输数据了</p>
</li>
</ul>
</li>
<li><p>浏览器发起 HTTP 请求</p>
 <figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">发送</span> <span class="string">HTTP</span> <span class="string">请求的过程就是构建</span> <span class="string">HTTP</span> <span class="string">请求报文并通过</span> <span class="string">TCP</span> <span class="string">协议发送到服务器指定端口,</span> <span class="string">一个完整的</span> <span class="string">HTTP</span> <span class="string">请求包括三部分:</span> <span class="string">请求起始行、请求报头、请求正文</span></span><br><span class="line"><span class="string">格式如下:</span></span><br><span class="line"></span><br><span class="line"><span class="number">1</span> <span class="string">请求方法</span> <span class="string">路径</span> <span class="string">协议/版本</span></span><br><span class="line"><span class="attr">2 Key1:</span> <span class="string">value1</span></span><br><span class="line"><span class="attr">2 Key2:</span> <span class="string">value2</span></span><br><span class="line"><span class="attr">2 Key3:</span> <span class="string">value3</span></span><br><span class="line"><span class="attr">2 Content-Type:</span> <span class="string">application/x-www-form-urlencoded</span></span><br><span class="line"><span class="attr">2 Host:</span> <span class="string">www.baidu.com</span></span><br><span class="line"><span class="attr">2 User-Agent:</span> <span class="string">curl/7.54.0</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span> <span class="string">要上传的数据</span></span><br><span class="line"></span><br><span class="line"><span class="string">第</span> <span class="number">1</span> <span class="string">部分为请求起始行，第</span> <span class="number">2</span> <span class="string">部分为请求报头，第</span> <span class="number">3</span> <span class="string">部分为回车，第</span> <span class="number">4</span> <span class="string">部分为请求正文</span></span><br><span class="line"><span class="string">常用的请求方法有:</span> <span class="string">GET</span> <span class="string">POST</span> <span class="string">PUT</span> <span class="string">DELETE</span> <span class="string">OPTIONS</span> <span class="string">HEAD</span></span><br><span class="line"><span class="string">常见的请求报头有:</span> <span class="string">Accept,</span> <span class="string">Accept-Charset,</span> <span class="string">Content-Type,</span> <span class="string">Authorization,</span> <span class="string">Cookie</span> <span class="string">等</span></span><br><span class="line"><span class="string">在使用</span> <span class="string">POST</span> <span class="string">PUT</span> <span class="string">等方法时，通常就需要客户端向服务器传输数据,请求正文中内容的就是数据了</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>服务器接收 HTTP 请求，并返回 HTTP 响应</p>
 <figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">这个过程是，服务器会对</span> <span class="string">TCP</span> <span class="string">连接进行处理，会对</span> <span class="string">HTTP</span> <span class="string">协议进行解析，并按照报文格式进一步封装成</span> <span class="string">HTTPRequest</span> <span class="string">对象</span></span><br><span class="line"><span class="string">而一个完整的</span> <span class="string">HTTP</span> <span class="string">响应也包括三部分:</span> <span class="string">响应起始行、响应报头、响应正文</span></span><br><span class="line"><span class="string">格式如下:</span></span><br><span class="line"></span><br><span class="line"><span class="number">1</span> <span class="string">协议/版本号</span> <span class="string">状态码</span> <span class="string">状态解释</span></span><br><span class="line"><span class="attr">2 Key1:</span> <span class="string">value1</span></span><br><span class="line"><span class="attr">2 Key2:</span> <span class="string">value2</span></span><br><span class="line"><span class="attr">2 Content-Length:</span> <span class="number">17931</span></span><br><span class="line"><span class="attr">2 Content-Type:</span> <span class="string">text/html</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span> <span class="string">要下载的内容</span></span><br><span class="line"></span><br><span class="line"><span class="string">第</span> <span class="number">1</span> <span class="string">部分为响应起始行，第</span> <span class="number">2</span> <span class="string">部分为响应报头，第</span> <span class="number">3</span> <span class="string">部分为回车，第</span> <span class="number">4</span> <span class="string">部分为响应正文</span></span><br><span class="line"><span class="string">常见的响应报头有:</span> <span class="string">Server,</span> <span class="string">Connection</span> <span class="string">等</span></span><br><span class="line"><span class="string">而响应正文就是服务器要返回给浏览器的文本信息，通常返回的就是</span> <span class="string">HTML</span> <span class="string">CSS</span> <span class="string">JS</span> <span class="string">图片等资源文件</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>渲染页面</p>
 <figure class="highlight less"><table><tr><td class="code"><pre><span class="line">需要引入两个概念: <span class="selector-tag">Reflow</span>(回流) <span class="selector-tag">Repaint</span>(重绘)</span><br><span class="line"><span class="selector-tag">Reflow</span>: 若元素的内容、尺寸、位置等发生了变化，浏览器需要重新计算样式和渲染树，这个过程叫做回流</span><br><span class="line"><span class="selector-tag">Repaint</span>: 当盒模型的大小、位置以及其他属性(颜色、字体等)确定下来之后,浏览器开始绘制内容，这个过程叫做重绘</span><br><span class="line"></span><br><span class="line">渲染页面在浏览器这边是个边解析边绘制的过程,浏览器会解析 <span class="selector-tag">HTML</span> 文件来构建 <span class="selector-tag">DOM</span> 树，然后解析 <span class="selector-tag">CSS</span> 文件构建渲染树，这个过程弄好后，浏览器会布局渲染树然后绘制到屏幕上;</span><br><span class="line">而对于 <span class="selector-tag">JS</span> 来说，<span class="selector-tag">JS</span> 的相关解析是由浏览器中的 <span class="selector-tag">JS</span> 解析引擎完成的。整个过程中，页面加载都会进行回流和重绘，这两个操作都会使得页面变得卡顿。</span><br></pre></td></tr></table></figure>
</li>
<li><p>关闭 TCP/IP 连接</p>
 <figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">关闭 TCP<span class="built_in">/IP </span>连接是通过四次挥手来实现的</span><br><span class="line">第 1 次挥手: 客户端发送关闭连接请求，发送 <span class="attribute">FIN</span>=1,seq=u</span><br><span class="line">第 2 次挥手: 服务器接收到关闭连接请求，返回 <span class="attribute">ACK</span>=1,seq=v,ack=u+1(服务器关闭读通道，可以发送数据)</span><br><span class="line">第 3 次挥手: 服务器接着发送关闭连接的回应，发送 <span class="attribute">FIN</span>=1,ACK=1,seq=w,ack=u+1</span><br><span class="line">第 4 次挥手: 客户端接收到回应后，发送 <span class="attribute">ACK</span>=1,seq=u+1,ack=w+1(服务器接收到后会关闭写通道)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="问题10"><a href="#问题10" class="headerlink" title="问题10"></a>问题10</h2><p>如何实现数组去重？</p>
<p>假设有数组 array = [1,5,2,3,4,2,3,1,3,4]</p>
<p>你要写一个函数 unique，使得</p>
<p>unique(array) 的值为 [1,5,2,3,4]</p>
<p>也就是把重复的值都去掉，只保留不重复的值。</p>
<p>要求：</p>
<ol>
<li>不要做多重循环，只能遍历一次</li>
<li>请给出两种方案，一种能在 ES 5 环境中运行，一种能在 ES 6 环境中运行（提示 ES 6 环境多了一个 Set 对象）</li>
</ol>
<h2 id="答案-9"><a href="#答案-9" class="headerlink" title="答案"></a>答案</h2><ul>
<li><p>ES 5 方案</p>
<figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line">function <span class="built_in">unique</span>(<span class="built_in">array</span>) &#123;</span><br><span class="line">  <span class="built_in">let</span> obj = &#123;&#125;;</span><br><span class="line">  <span class="built_in">let</span> ret = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="built_in">let</span> i=<span class="number">0</span>; i &lt; <span class="built_in">array</span>.<span class="built_in">length</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">let</span> <span class="built_in">key</span> = <span class="built_in">array</span>[i];</span><br><span class="line">    <span class="keyword">if</span> (!obj[<span class="built_in">key</span>]) &#123;</span><br><span class="line">      obj[<span class="built_in">key</span>] = <span class="number">1</span>;</span><br><span class="line">      <span class="built_in">let</span> value = <span class="built_in">key</span>;</span><br><span class="line">      ret.<span class="built_in">push</span>(value);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">let</span> <span class="built_in">array</span> = [<span class="number">1</span>,<span class="number">5</span>,<span class="number">2</span>, <span class="string">"xxx"</span>, <span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>, <span class="string">"xxx"</span> , <span class="string">""</span>, NaN, undefined, NaN, <span class="string">""</span>, null ,<span class="number">3</span>,<span class="number">4</span>, undefined, null];</span><br><span class="line">console.<span class="built_in">log</span>(<span class="built_in">unique</span>(<span class="built_in">array</span>));</span><br></pre></td></tr></table></figure>
</li>
<li><p>ES 6 方案</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> array = [<span class="number">1</span>,<span class="number">5</span>,<span class="number">2</span>, <span class="string">"xxx"</span>, <span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>, <span class="string">"xxx"</span> , <span class="string">""</span>, <span class="literal">NaN</span>, <span class="literal">undefined</span>, <span class="literal">NaN</span>, <span class="string">""</span>, <span class="literal">null</span> ,<span class="number">3</span>,<span class="number">4</span>, <span class="literal">undefined</span>, <span class="literal">null</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> items = <span class="keyword">new</span> <span class="built_in">Set</span>(array);</span><br><span class="line"><span class="keyword">const</span> newArray = <span class="built_in">Array</span>.from(items);</span><br><span class="line"><span class="built_in">console</span>.log(newArray);</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title>从Promise本质开始(一):实现Promise前言</title>
    <url>/2020/03/09/%E4%BB%8EPromise%E6%9C%AC%E8%B4%A8%E5%BC%80%E5%A7%8B-%E4%B8%80-%E5%AE%9E%E7%8E%B0Promise%E5%89%8D%E8%A8%80/</url>
    <content><![CDATA[<blockquote>
<p>注意，由于本文讨论的是使用 TDD 方式实现一个 Promise，所以本文着重描述的是搭建 TDD 环境</p>
</blockquote>
<a id="more"></a>
<h2 id="Promise-能解决什么问题"><a href="#Promise-能解决什么问题" class="headerlink" title="Promise 能解决什么问题"></a>Promise 能解决什么问题</h2><p>先来看一段代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">fs.readdir(source, <span class="function"><span class="keyword">function</span> (<span class="params">err, files</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'Error finding files: '</span> + err)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        files.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">filename, fileIndex</span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(filename)</span><br><span class="line">            gm(source + filename).size(<span class="function"><span class="keyword">function</span> (<span class="params">err, values</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (err) &#123;</span><br><span class="line">                    <span class="built_in">console</span>.log(<span class="string">'Error identifying file size: '</span> + err)</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="built_in">console</span>.log(filename + <span class="string">' : '</span> + values)</span><br><span class="line">                    aspect = (values.width / values.height)</span><br><span class="line">                    widths.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">width, widthIndex</span>) </span>&#123;</span><br><span class="line">                        height = <span class="built_in">Math</span>.round(width / aspect)</span><br><span class="line">                        <span class="built_in">console</span>.log(<span class="string">'resizing '</span> + filename + <span class="string">'to '</span> + height + <span class="string">'x'</span> + height)</span><br><span class="line">                        <span class="keyword">this</span>.resize(width, height).write(dest + <span class="string">'w'</span> + width + <span class="string">'_'</span> + filename, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">                            <span class="keyword">if</span> (err) <span class="built_in">console</span>.log(<span class="string">'Error writing file: '</span> + err)</span><br><span class="line">                        &#125;)</span><br><span class="line">                    &#125;.bind(<span class="keyword">this</span>))</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>可以看到着里面产生了几个回调，也就是那个著名的 <code>callback hell</code>(回调地狱)</p>
<p>所以这有可能真的是回调地狱的问题么?来看看改善之后的代码吧</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">fs.readdir(source, (err, files) =&gt; &#123;</span><br><span class="line">  travalFiles = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">console</span>.log(<span class="string">'Error: 找不到目录'</span> + err)</span><br><span class="line">    &#125;</span><br><span class="line">    files.forEach(gmFile)</span><br><span class="line">  &#125;</span><br><span class="line">  gmFile = <span class="function">(<span class="params">filename</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(filename)</span><br><span class="line">    gm(source + filename).size(afterGetSize)</span><br><span class="line">  &#125;</span><br><span class="line">  afterGetSize = <span class="function">(<span class="params">err, values</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">return</span> <span class="built_in">console</span>.log(<span class="string">'无法读取文件尺寸: '</span> + err)</span><br><span class="line">    <span class="built_in">console</span>.log(filename + <span class="string">' : '</span> + values)</span><br><span class="line">    aspect = (values.width / values.height)</span><br><span class="line">    widths.forEach(<span class="function">(<span class="params">width, widthIndex</span>) =&gt;</span> resize(width, aspect))</span><br><span class="line">  &#125;</span><br><span class="line">  resize = <span class="function">(<span class="params">width, aspect</span>) =&gt;</span> &#123;</span><br><span class="line">    height = <span class="built_in">Math</span>.round(width / aspect)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'将'</span> + filename + <span class="string">'的尺寸变为'</span> + width + <span class="string">'x'</span> + height)</span><br><span class="line">    <span class="keyword">this</span>.resize(width, height).write(</span><br><span class="line">      dest + <span class="string">'w'</span> + width + <span class="string">'_'</span> + filename,</span><br><span class="line">      (err) =&gt; err &amp;&amp; <span class="built_in">console</span>.log(<span class="string">'Error writing file: '</span> + err)</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  travalFiles(err, files)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>上面的代码没有回调么？当然有，那么为什么看起来清晰了呢？是因为这里将 <strong>函数当作参数传给要调用的函数了</strong>，所以其实对于 <code>Promise</code> 而言也是一样的</p>
<h2 id="Promise-的优点"><a href="#Promise-的优点" class="headerlink" title="Promise 的优点"></a>Promise 的优点</h2><p>优点有俩</p>
<h3 id="减少缩进-在整体代码的意义上"><a href="#减少缩进-在整体代码的意义上" class="headerlink" title="减少缩进(在整体代码的意义上)"></a>减少缩进(在整体代码的意义上)</h3><p>将 <strong>函数套函数</strong> 的形式转变成 <strong>链式调用</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">f1(xxx, <span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">    f3(yyy, <span class="function"><span class="keyword">function</span> <span class="title">f4</span>(<span class="params">b</span>) </span>&#123;</span><br><span class="line">        f5(a+b, <span class="function"><span class="keyword">function</span> <span class="title">f6</span>(<span class="params"></span>) </span>&#123;&#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>转变成</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">f1(xxx)</span><br><span class="line">    .then(f2) <span class="comment">// f2 调用 f3，并同时将参数作为结果输出</span></span><br><span class="line">    .then(f4) <span class="comment">// f4 调用 f5，并同时接受到 f2 的结果(就是参数)，f5 就得到了 f2 以及 f4 的参数</span></span><br><span class="line">    .then(f6)</span><br></pre></td></tr></table></figure>
<h3 id="消灭-if-err-形式的代码"><a href="#消灭-if-err-形式的代码" class="headerlink" title="消灭 if(err) 形式的代码"></a>消灭 if(err) 形式的代码</h3><ul>
<li>关于错误的处理可以单独放到一个函数里面</li>
<li>如果不处理，则一直等到向后抛</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">f1(xxx)</span><br><span class="line">    .then(f2, error1)</span><br><span class="line">    .then(f4, error2)</span><br><span class="line">    .then(f6, error3)</span><br><span class="line">    .then(<span class="literal">null</span>, errorAll)</span><br><span class="line"><span class="comment">// 这里最后一句可以改成 catch, 意味着它可以处理所有的 error</span></span><br></pre></td></tr></table></figure>
<h2 id="如何使用-Promise"><a href="#如何使用-Promise" class="headerlink" title="如何使用 Promise"></a>如何使用 Promise</h2><p>对于一个异步的代码，以前是这么写</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        fn(<span class="string">'1 秒后调用'</span>) <span class="comment">// 这里相当于 fn.call(null, '1 秒后调用')</span></span><br><span class="line">    &#125; , <span class="number">1000</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test(<span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">'传入 fn'</span>) &#125;)</span><br></pre></td></tr></table></figure>
<p>如果使用 <code>Promise</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// new Promise 接受一个参数，返回一个 Promise 实例</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            resolve(<span class="string">'1 秒后调用'</span>)</span><br><span class="line">        &#125; , <span class="number">1000</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test(<span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">'传入 fn'</span>) &#125;)</span><br></pre></td></tr></table></figure>
<h2 id="Promise-有哪些-API"><a href="#Promise-有哪些-API" class="headerlink" title="Promise 有哪些 API"></a>Promise 有哪些 API</h2><ul>
<li><strong>Promise 是一个类</strong>(相当于一个特殊的函数)</li>
<li>类属性: <code>length</code></li>
<li>类方法: <code>all</code>, <code>allSettled</code>, <code>race</code>, <code>reject</code>, <code>resolve</code></li>
<li>对象属性: <strong><code>then</code></strong> , <code>finally</code>, <code>catch</code></li>
<li>对象内部属性: <strong><code>state</code></strong>(pending, fullfilled, rejected)</li>
</ul>
<p>这里注意，<code>state</code> 的 <code>pending</code> 状态的转变是单向的，即只有</p>
<ul>
<li>pending -&gt; fullfilled(成功)</li>
<li>pending -&gt; rejected(失败)</li>
</ul>
<p><strong>并且 fullfilled 以及 rejected 状态不能互相转变，也不能转化成 pending</strong></p>
<h2 id="Promise-API-怎么写"><a href="#Promise-API-怎么写" class="headerlink" title="Promise API 怎么写"></a>Promise API 怎么写</h2><ul>
<li>参考 <a href="https://promisesaplus.com/" target="_blank" rel="noopener">promise/A+ 规范</a> 或者其 <a href="https://juejin.im/post/5b6161e6f265da0f8145fb72" target="_blank" rel="noopener">翻译版文档</a></li>
<li>在写代码时根据文档<strong>写测试用例</strong>，规则都通过了说明 <code>Promise</code> 相关的逻辑也就完成了</li>
</ul>
<h2 id="使用测试工具"><a href="#使用测试工具" class="headerlink" title="使用测试工具"></a>使用测试工具</h2><h3 id="使用-chai"><a href="#使用-chai" class="headerlink" title="使用 chai"></a>使用 chai</h3><p>先全局安装两个包</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yarn add -g ts-node mocha</span><br></pre></td></tr></table></figure>
<p>然后创建项目 <code>promise-easy</code>，再执行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> promise-easy</span><br><span class="line">yarn init -y</span><br></pre></td></tr></table></figure>
<p>最后再次给项目安装包</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yarn add -D ts-node mocha chai @types/chai @types/mocha typescript</span><br></pre></td></tr></table></figure>
<p>然后创建 <code>test/index.ts</code></p>
<figure class="highlight irpf90"><table><tr><td class="code"><pre><span class="line"><span class="keyword">touch</span> test/<span class="built_in">index</span>.ts</span><br></pre></td></tr></table></figure>
<p>最后增加 <code>package.json</code> 的 <code>scripts</code></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">"scripts": &#123;</span><br><span class="line">    "test": "mocha -r ts-node/register test/**/*.ts" // mocha 使用 ts-node/register 模块来对 test 下的 ts 文件进行测试</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后执行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yarn <span class="built_in">test</span></span><br></pre></td></tr></table></figure>
<p>出现如下打印输出则算配置成功</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yarn run v1.21.1</span><br><span class="line">$ mocha -r ts-node/register <span class="built_in">test</span>/**/*.ts</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  0 passing (5ms)</span><br><span class="line"></span><br><span class="line">Done <span class="keyword">in</span> 3.18s.</span><br></pre></td></tr></table></figure>
<p>然后说下这几个包的作用</p>
<ul>
<li><code>chai</code>: chai 是一个 BDD/TDD 的断言库，我们经常使用其 <code>assert</code> api 来做测试种断言的操作</li>
<li><code>mocha</code>: mocha 是一个多功能的测试框架，我们经常使用其 <code>describe</code> 以及 <code>it</code> api 来做相关的测试</li>
<li><code>ts-node</code>, <code>typescript</code>: ts-node 是用来编译 node 中的 typescript 用的，使用 typescript 时需要安装 typescript</li>
<li><code>@types/chai</code>, <code>@types/mocha</code>: chai 和 mocha 的 typescript 版本，方便在 ts 文件中引入</li>
</ul>
<p>现在就可以在 <code>test/index.ts</code> 中写代码了</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; assert &#125; <span class="keyword">from</span> <span class="string">'chai'</span></span><br><span class="line"><span class="keyword">import</span> &#123; describe, it &#125; <span class="keyword">from</span> <span class="string">'mocha'</span></span><br><span class="line"></span><br><span class="line">describe(<span class="string">'测试 Chai 的使用'</span>, () =&gt; &#123;</span><br><span class="line"> it(<span class="string">'可以测试相等'</span>, () =&gt; &#123;</span><br><span class="line">    assert(<span class="number">1</span> === <span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>其中 <code>describe</code> 表示描述测试的场景，而 <code>it</code> 表示在该测试场景下的对象</p>
<blockquote>
<p>注意，若在断言的那段代码的上面加 <code>//@ts-ignore</code> 即可屏蔽掉 typescript 对这段代码的检查，那么代码在编译运行时就不会报错</p>
</blockquote>
<p>对于 <code>assert</code> 这个 api 来说，它里面有很多的函数比如经常使用到的有如下几个</p>
<ul>
<li><code>isXXX</code>: 判断对象或变量的类型用的，比如 <code>isFunction</code>，<code>isObject</code></li>
<li><code>throw</code>: 这个一般用于你想让其传入的回调函数中的代码报错</li>
</ul>
<h3 id="使用-sinon"><a href="#使用-sinon" class="headerlink" title="使用 sinon"></a>使用 sinon</h3><p>安装 <code>sinon</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yarn add -D sinon sinon-chai @types/sinon @types/sinon-chai</span><br></pre></td></tr></table></figure>
<p>然后说下这几个包都是啥</p>
<ul>
<li><code>sinon</code>: 适用于任何单元测试框架的测试库</li>
<li><code>sinon-chai</code>: 为 <code>sinon</code> 提供了一系列自自定义的断言 api，相当于 chai 的拓展</li>
<li><code>@types/sinon</code>, <code>@types/sinon-chai</code>: sinon 和 sinon-chai 的 typescript 版本</li>
</ul>
<p>在这里主要是使用 <code>sinon.fake()</code> 提供一个假函数，然后通过判断这个假函数的 <code>called</code> 属性来判断函数是否被调用</p>
<p>你需要这样引入</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> chai <span class="keyword">from</span> <span class="string">'chai'</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> sinon <span class="keyword">from</span> <span class="string">'sinon'</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> sinonChai <span class="keyword">from</span> <span class="string">'sinon-chai</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">chai.use(sinonChai)</span></span><br></pre></td></tr></table></figure>
<p>然后像这样使用</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">it(<span class="string">'new Promise(fn) 中的函数立即执行'</span>, () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> fn = sinon.fake()</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(fn)</span><br><span class="line">    assert(fn.called)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文主要介绍了如何搭建测试环境，以及如何使用测试框架来进行开发(TDD)。其中比较重要的还设计到了 <code>Promise</code> 的几个要点，即</p>
<ul>
<li>Promise 要解决什么问题 - why</li>
<li>Promise 是怎么解决它的 - how</li>
<li>Promise (对比其他技术)有什么有点 - pros</li>
<li>Promise有什么缺点 - cons</li>
<li>如何解决这些缺点</li>
</ul>
<p>框架和环境已经搭建完毕，接下来就是遵循 Promise/A+ 规范实现一个简易 Promise</p>
]]></content>
      <categories>
        <category>手写源码</category>
      </categories>
      <tags>
        <tag>Promise</tag>
      </tags>
  </entry>
  <entry>
    <title>从Webpack本质开始(一):手写一个Webpack</title>
    <url>/2020/02/23/%E4%BB%8EWebpack%E6%9C%AC%E8%B4%A8%E5%BC%80%E5%A7%8B-%E4%B8%80-%E6%89%8B%E5%86%99%E4%B8%80%E4%B8%AAWebpack/</url>
    <content><![CDATA[<blockquote>
<p>这个是探究 Webpack 本质的系列文章，会详细讲解如何手写一些源码如 Webpack, loader, plugin 等等，本文主要讲解的是如何手写一个 webpack</p>
</blockquote>
<a id="more"></a>
<h2 id="初始化项目"><a href="#初始化项目" class="headerlink" title="初始化项目"></a>初始化项目</h2><p>项目的目录如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">|-bin</span><br><span class="line">|  |-st-pack.js</span><br><span class="line">|-package-lock.json</span><br><span class="line">|-package.json</span><br><span class="line">|-README.md</span><br></pre></td></tr></table></figure>
<p>在 <code>package.json</code> 文件中追加</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="comment">// package.json</span></span><br><span class="line">"bin": &#123;</span><br><span class="line">  "st-pack": "./bin/st-pack.js"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个是方便在执行 <code>st-pack</code> 命令时 node 去找对应的 js 执行</p>
<p>然后是 <code>st-pack.js</code> 文件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// st-pack.js</span></span><br><span class="line"><span class="meta">#! /usr/bin/env node</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'hello world'</span>)</span><br></pre></td></tr></table></figure>
<p>开头的 shebang 表示是在 node 环境下执行 js 代码</p>
<p>然后在项目的主目录执行 <code>npm link</code>, 就会看到如下的信息</p>
<p><img src="./1.jpg" alt></p>
<p>这个就是方便你在调试的时候，在别的项目中执行 <code>npx st-pack</code> 时，系统会去对应的 <code>st-pack</code> 目录下去寻找 <code>st-pack.js</code> 文件，并用 node 去执行它，本质上来说就是建立了一个软链接</p>
<p>然后你在随便一个目录执行 <code>npx st-pack</code>，出现 <code>hello world</code> 就算项目初始化成功</p>
<p><img src="./2.jpg" alt></p>
<h2 id="webpack-分析以及处理"><a href="#webpack-分析以及处理" class="headerlink" title="webpack 分析以及处理"></a>webpack 分析以及处理</h2><p>首先说下流程，一般来说，我们在使用 webpack 时，webpack 会解析对应项目下的 <code>webpack.config.js</code> 文件，抽取里面的配置信息传递给一个 <strong>Compiler</strong> 编译，由这个 <strong>Compiler</strong> 来执行之后的代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// st-pack.js</span></span><br><span class="line"><span class="meta">#! /usr/bin/env node</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"><span class="keyword">const</span> config = <span class="built_in">require</span>(path.resolve(<span class="string">'webpack.config.js'</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 找到项目目录下的 webpack.config.js 然后通过一个 compiler 解析它</span></span><br><span class="line"><span class="keyword">const</span> Complier = <span class="built_in">require</span>(<span class="string">'../lib/compiler.js'</span>)</span><br><span class="line"><span class="keyword">const</span> complier = <span class="keyword">new</span> Complier(config)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用 compiler 的 run 方法执行代码</span></span><br><span class="line">complier.run()</span><br></pre></td></tr></table></figure>
<h2 id="创建依赖关系"><a href="#创建依赖关系" class="headerlink" title="创建依赖关系"></a>创建依赖关系</h2><p>新建一个 <code>lib</code> 目录，在这个目录下新建一个 <code>compiler.js</code> 文件<br>这个里面主要是构造一个 <code>Compiler</code> 的类，然后里面主要有两个方法: <code>bindModule</code>(创建模块间的依赖关系) 以及 <code>emitFile</code>(完成后发送最终的文件到某个目录下)</p>
<p><code>bindModule</code> 的逻辑是这样的，首先需要获取到模块的源码和名字，然后再将模块的源码和该模块的 <strong>父级路径</strong> 传给一个 <code>parse</code> 函数，由这个 <code>parse</code> 函数来解决源码以及依赖的问题。本质上就是将模块的源码进行改造，然后返回一个依赖的列表。比如将 <code>require(&#39;./a.js&#39;)</code> 变成 <code>_webpack_require_(&#39;./src/a.js&#39;)</code>，如果 <code>a.js</code> 中还有其他的依赖，则需要<strong>递归的去查找对应的包然后做 parse</strong>，最后再把模块的路径和模块中被改造后的源码对应起来</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// lib/complier.js</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complier</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(config) &#123;</span><br><span class="line">    <span class="comment">// 需要保存的入口文件的路径，如 ./src/index.js</span></span><br><span class="line">    <span class="keyword">this</span>.entryId </span><br><span class="line">    <span class="comment">// 需要保存的所有模块的依赖</span></span><br><span class="line">    <span class="keyword">this</span>.modules = &#123;&#125;</span><br><span class="line">    <span class="keyword">this</span>.config = config</span><br><span class="line">    <span class="keyword">this</span>.entry = config.entry <span class="comment">// 入口路径</span></span><br><span class="line">    <span class="keyword">this</span>.root = process.cwd() <span class="comment">// 项目工作的全局路径</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  run() &#123;</span><br><span class="line">    <span class="keyword">this</span>.bindModule(path.resolve(<span class="keyword">this</span>.root, <span class="keyword">this</span>.entry), <span class="literal">true</span>)</span><br><span class="line">    <span class="keyword">this</span>.emitFile()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建模块间的依赖关系</span></span><br><span class="line">  bindModule(modulePath, isEntry) &#123;</span><br><span class="line">    <span class="keyword">const</span> moduleSource = <span class="keyword">this</span>.getModuleSource(modulePath)</span><br><span class="line">    <span class="keyword">const</span> moduleName = <span class="string">'./'</span> + path.relative(<span class="keyword">this</span>.root, modulePath)</span><br><span class="line">    isEntry &amp;&amp; (<span class="keyword">this</span>.entryId = moduleName)</span><br><span class="line">    <span class="comment">// 将模块的源码进行改造，并且返回一个依赖的列表</span></span><br><span class="line">    <span class="comment">// 主要是将 require 变成 __webpack_require__</span></span><br><span class="line">    <span class="comment">// 然后将 require('./a.js') 变成 __webpack_require__('./src/a.js')</span></span><br><span class="line">    <span class="keyword">const</span> &#123; newModuleSource, dependencies &#125; = </span><br><span class="line">      <span class="keyword">this</span>.parse(moduleSource, path.dirname(moduleName))</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 把相对路径和模块中的内容对应起来</span></span><br><span class="line">    <span class="keyword">this</span>.modules[moduleName] = newModuleSource</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 发射一个打包后的文件</span></span><br><span class="line">  emitFile() &#123;</span><br><span class="line">  </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  getModuleSource(modulePath) &#123;</span><br><span class="line">    <span class="keyword">return</span> fs.readFileSync(modulePath, <span class="string">'utf8'</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 解析模块源码</span></span><br><span class="line">  parse(moduleSource, parentPath) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(moduleSource, parentPath)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = Complier</span><br></pre></td></tr></table></figure>
<h2 id="AST-递归解析"><a href="#AST-递归解析" class="headerlink" title="AST 递归解析"></a>AST 递归解析</h2><p>如果要从头开始自己写一个 ast 编译工具未免太麻烦了，这里直接用如下几个工具库</p>
<ul>
<li>babylon 主要将 code 转换成 ast</li>
<li>@babel/traverse 截取并更新 ast node</li>
<li>@babel/types 一个类似于 lodash 的用于处理 ast 的工具包</li>
<li>@babel/generator 将 ast node 转换成 code</li>
</ul>
<p>直接安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yarn add babylon @babel/traverse @babel/types @babel/generator</span><br></pre></td></tr></table></figure>
<p>由于 <code>traverse</code> 和 <code>generator</code> 是 es6 模块，所以这里用 <code>require</code> 引入时需要在后面加 <code>default</code> 才能拿到这个函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// babylon 主要将源码转成 AST</span></span><br><span class="line"><span class="keyword">const</span> babylon = <span class="built_in">require</span>(<span class="string">'babylon'</span>) </span><br><span class="line"><span class="comment">// 用来遍历以及更新 AST node</span></span><br><span class="line"><span class="keyword">const</span> traverse = <span class="built_in">require</span>(<span class="string">'@babel/traverse'</span>).default <span class="comment">// es6 模块</span></span><br><span class="line"><span class="comment">// 类似 lodash 的一个用于处理 AST node 的工具库</span></span><br><span class="line"><span class="keyword">const</span> t = <span class="built_in">require</span>(<span class="string">'@babel/types'</span>)</span><br><span class="line"><span class="comment">// 将 AST node 转换成 code</span></span><br><span class="line"><span class="keyword">const</span> generator = <span class="built_in">require</span>(<span class="string">'@babel/generator'</span>).default <span class="comment">// es6 模块</span></span><br></pre></td></tr></table></figure>
<p>这里递归解析的目的就是<strong>改名字</strong>，所以逻辑的流程就是</p>
<ol>
<li>将模块源码转成 ast</li>
<li>在 ast 内部修改 <code>require</code>，并且收集依赖关系</li>
<li>将修改过后的 ast 转换成新的 code</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// lib/compiler.js </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 解析模块源码</span></span><br><span class="line">parse(moduleSource, parentPath) &#123;</span><br><span class="line">  <span class="comment">// 将源码转换成 AST</span></span><br><span class="line">  <span class="keyword">let</span> ast = babylon.parse(moduleSource)</span><br><span class="line">  <span class="comment">// 遍历以及修改 AST node</span></span><br><span class="line">  <span class="keyword">const</span> dependencies = []</span><br><span class="line">  traverse(ast, &#123;</span><br><span class="line">    CallExpression(p) &#123; <span class="comment">// 调用表达式</span></span><br><span class="line">      <span class="keyword">const</span> &#123; node &#125; = p</span><br><span class="line">      <span class="keyword">let</span> &#123; name &#125; = node.callee</span><br><span class="line">      <span class="comment">// 修改调用名，即将 require -&gt; __webpack_require__</span></span><br><span class="line">      <span class="keyword">if</span> (name === <span class="string">'require'</span>) &#123;</span><br><span class="line">        node.callee.name = <span class="string">'__webpack_require__'</span></span><br><span class="line">        <span class="comment">// 修改模块名，将其变成 ./src/a.js</span></span><br><span class="line">        <span class="keyword">let</span> moduleName = node.arguments[<span class="number">0</span>].value</span><br><span class="line">        <span class="comment">// 自动添加后缀名</span></span><br><span class="line">        moduleName += path.extname(moduleName) ? <span class="string">''</span> : <span class="string">'.js'</span></span><br><span class="line">        <span class="comment">// 添加父级路径</span></span><br><span class="line">        moduleName = <span class="string">'./'</span> + path.join(parentPath, moduleName)</span><br><span class="line">        <span class="comment">// 添加进依赖列表</span></span><br><span class="line">        dependencies.push(moduleName)</span><br><span class="line">        <span class="comment">// 构建 Literal 对象</span></span><br><span class="line">        node.arguments = [t.stringLiteral(moduleName)]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// 将 AST 转换成源码</span></span><br><span class="line">  <span class="keyword">const</span> newModuleSource = generator(ast).code</span><br><span class="line">  <span class="keyword">return</span> &#123; newModuleSource, dependencies &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后在 <code>bindModule</code> 函数中递归的建立依赖</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 模块里面还有依赖的就要递归建立依赖关系</span></span><br><span class="line">dependencies.forEach(<span class="function"><span class="params">dp</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.bindModule(path.join(<span class="keyword">this</span>.root, dp), <span class="literal">false</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>在 <code>bindModule</code> 函数中打印 <code>newModuleSource</code> 和 <code>dependencies</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'code : '</span>, newModuleSource)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'denp : '</span>, dependencies)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'---------------------------'</span>)</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>在其他项目目录执行<code>npx st-pack</code> 结果可看到</p>
<p><img src="./3.jpg" alt></p>
<h2 id="生成打包结果"><a href="#生成打包结果" class="headerlink" title="生成打包结果"></a>生成打包结果</h2><p>在生成打包结果之前，必须先要一个模板，如果只是手动拼字符串太麻烦了，所以这里使用 <code>ejs</code> 来用于这次的模板工具</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yarn add ejs</span><br></pre></td></tr></table></figure>
<p>然后是模板代码, 在项目下新建目录 <code>template</code>，里面存放的是 <code>main.ejs</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main.ejs</span></span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">modules</span>) </span>&#123; <span class="comment">// webpackBootstrap</span></span><br><span class="line">  <span class="comment">// The module cache</span></span><br><span class="line">  <span class="keyword">var</span> installedModules = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// The require function</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">__webpack_require__</span>(<span class="params">moduleId</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check if module is in cache</span></span><br><span class="line">    <span class="keyword">if</span>(installedModules[moduleId]) &#123;</span><br><span class="line">      <span class="keyword">return</span> installedModules[moduleId].exports;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Create a new module (and put it into the cache)</span></span><br><span class="line">    <span class="keyword">var</span> <span class="built_in">module</span> = installedModules[moduleId] = &#123;</span><br><span class="line">      i: moduleId,</span><br><span class="line">      l: <span class="literal">false</span>,</span><br><span class="line">      exports: &#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Execute the module function</span></span><br><span class="line">    modules[moduleId].call(<span class="built_in">module</span>.exports, <span class="built_in">module</span>, <span class="built_in">module</span>.exports, __webpack_require__);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Flag the module as loaded</span></span><br><span class="line">    <span class="built_in">module</span>.l = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Return the exports of the module</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">module</span>.exports;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Load entry module and return exports</span></span><br><span class="line">  <span class="keyword">return</span> __webpack_require__(__webpack_require__.s = <span class="string">"&lt;%-entryId%&gt;"</span>);</span><br><span class="line">&#125;)</span><br><span class="line">(&#123;</span><br><span class="line">  &lt;%<span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> modules) &#123;%&gt;</span><br><span class="line">  <span class="string">"&lt;%-key%&gt;"</span>:</span><br><span class="line">  (<span class="function"><span class="keyword">function</span>(<span class="params">module, exports, __webpack_require__</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">eval</span>(<span class="string">`&lt;%-modules[key]%&gt;`</span>)</span><br><span class="line">  &#125;),</span><br><span class="line">  &lt;%&#125;%&gt;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里顺便说下 <code>ejs</code> 的一点语法，它是用 <code>&lt;%%&gt;</code> 来包裹代码块的, 如果要换行就要加上去，其中 <code>&lt;%-xxx%&gt;</code> 这种形式表示 <code>xxx</code> 是里面的一个 <strong>变量</strong>，需要注意前面的 <code>-</code> 号</p>
</blockquote>
<p>可以看到这里的原理是，我们构建了一个 <code>ejs</code> 的模板，然后在这个模板里面插入了变量 <code>entryId</code> 以及 <code>modules</code>。代码从整体上是一个 IIFE(立即执行函数)，代码最开始的 <code>modules</code> 这个 <strong>参数</strong> 被传入时是一个 <code>{&#39;模块路径&#39;: &#39;模块执行代码&#39;}</code> 的 hash，它经历了如下的步骤</p>
<ol>
<li>声明一个模块的缓存</li>
<li>定义一个 <code>__webpack_require__</code> 的函数<ul>
<li>检查模块是否有缓存，有缓存就直接返回 </li>
<li>没有缓存就直接创建一个模块，然后把它添加进缓存</li>
<li>执行模块里面的代码</li>
<li>标致模块已经加载</li>
<li>返回该模块的 exports 对象</li>
</ul>
</li>
<li>加载模块并返回 exports 对象</li>
</ol>
<p>比较需要注意的是两段代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">  <span class="comment">// 执行 module 对应的代码，并传一个 __webpack_require__ 这个参数过去</span></span><br><span class="line">  modules[moduleId].call(<span class="built_in">module</span>.exports, <span class="built_in">module</span>, <span class="built_in">module</span>.exports, __webpack_require__);</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// 最开始的传的参数是一个入口文件</span></span><br><span class="line">  <span class="keyword">return</span> _webpack_require__(__webpack_require__.s = <span class="string">"&lt;%-entryId%&gt;"</span>);</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>这两句代码应该来说是最核心的，因为有一个入口文件，它执行了对应入口文件的代码时，会首先去找依赖，传一个 <code>__webpack_require__</code> 回调函数过去，然后这个再次执行了 <code>__webpack_require__</code> 回调函数后，再去寻找依赖，相当于就是一个递归的过程，当所有的递归完成后，所有的代码包括有依赖关系的都将执行完成</p>
<p>接下来需要补充的就是代码的输出了，即 <code>emitFile</code> 函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// lib/complier.js</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 发射一个打包后的文件</span></span><br><span class="line">emitFile() &#123;</span><br><span class="line">  <span class="comment">// 输出文件路径</span></span><br><span class="line">  <span class="keyword">const</span> &#123; filename &#125; = <span class="keyword">this</span>.config.output</span><br><span class="line">  <span class="keyword">const</span> &#123; entryId, modules &#125; = <span class="keyword">this</span></span><br><span class="line">  <span class="keyword">const</span> outputFilePath = path.join(<span class="keyword">this</span>.config.output.path, filename)</span><br><span class="line">  <span class="keyword">const</span> template = <span class="keyword">this</span>.getModuleSource(path.join(__dirname, <span class="string">'../template/main.ejs'</span>))</span><br><span class="line">  <span class="keyword">const</span> outputFileCode = ejs.render(template, &#123; entryId, modules &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 保存输出文件路径</span></span><br><span class="line">  <span class="keyword">this</span>.assert[outputFilePath] = outputFileCode</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 写入对应路径</span></span><br><span class="line">  fs.writeFileSync(outputFilePath, <span class="keyword">this</span>.assert[outputFilePath])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码的逻辑很简单，就是 <strong>找出配置中的 <code>path</code> 和 <code>filename</code>，使用 ejs 渲染模板，将真正的 code 代码输出到指定的目录中</strong></p>
<p>完成后，到有配置 <code>webpack.config.js</code> 项目中执行 <code>npx st-pack</code>，出现如下效果</p>
<p><img src="./4.jpg" alt></p>
<h2 id="增加-loader-的解析机制"><a href="#增加-loader-的解析机制" class="headerlink" title="增加 loader 的解析机制"></a>增加 loader 的解析机制</h2><blockquote>
<p>为了简明扼要，这里用 css 的 loader 来做解析工作</p>
</blockquote>
<p>在测试项目的 <code>webpack.config.js</code> 配置文件中加上</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">  rules: [&#123;</span><br><span class="line">    test: <span class="regexp">/\.less$/</span>,</span><br><span class="line">    use: [</span><br><span class="line">      path.resolve(__dirname, <span class="string">'loader'</span>, <span class="string">'style-loader'</span>),</span><br><span class="line">      path.resolve(__dirname, <span class="string">'loader'</span>, <span class="string">'less-loader'</span>)</span><br><span class="line">    ]</span><br><span class="line">  &#125;]</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>这里需要注意的是 <code>loader</code> 的执行顺序是 <strong>先添加进去的后执行</strong>，所以这里的顺序是 <code>less-loader</code> 先于 <code>style-loader</code> 执行</p>
<p>然后在项目根目录新建目录 <code>loader</code>, 里面添加两个文件 <code>less-loader.js</code> 以及 <code>style-loader.js</code>，这两个 <code>loader</code> 可以自己写，由于 <code>less-loader</code> 文件需要 <code>less</code>，所以在那之前先执行</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">yarn <span class="keyword">add</span><span class="bash"> less</span></span><br></pre></td></tr></table></figure>
<p>执行完成后可以写 <code>less-loader</code> 了</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> less = <span class="built_in">require</span>(<span class="string">'less'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loader</span>(<span class="params">source</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> css = <span class="string">''</span></span><br><span class="line">  less.render(source, (err, c) =&gt; &#123;</span><br><span class="line">    <span class="comment">// source 转成 c.css</span></span><br><span class="line">    css = c.css</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// 将 css code 中的 \n 字符转换成 \\n ，不然浏览器会报错</span></span><br><span class="line">  css = css.replace(<span class="regexp">/\n/g</span>, <span class="string">'\\n'</span>)</span><br><span class="line">  <span class="keyword">return</span> css</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = loader</span><br></pre></td></tr></table></figure>
<p>这个 <code>loader</code> 的逻辑很简单，就是利用 <code>less</code> 将传入的 css 代码进行 <code>render</code>。这里要注意的是需要将代码中的 <code>\n</code> 字符转换成 <code>\\n</code>，不然浏览器会报错</p>
<p>然后是 <code>style-loader</code> 的代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loader</span>(<span class="params">source</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> style = <span class="string">`</span></span><br><span class="line"><span class="string">    let style = document.createElement('style')</span></span><br><span class="line"><span class="string">    style.innerHTML = <span class="subst">$&#123;<span class="built_in">JSON</span>.stringify(source)&#125;</span></span></span><br><span class="line"><span class="string">    document.head.appendChild(style)</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">  <span class="keyword">return</span> style</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = loader</span><br></pre></td></tr></table></figure>
<p>逻辑也很简单，就是简单插入一段 <code>style</code> 标签</p>
<blockquote>
<p>同时这里也可以看到，所谓的 <code>loader</code> 不过也只是一个 <strong>函数</strong> 而已。它只是个利用了其他的 <code>node</code> 的工具解析 code，然后再返回解析后的结果的这么一个 <strong>加载器</strong></p>
</blockquote>
<p>写好了 <code>loader</code> 之后，就应该在 <code>st-pack</code> 项目中的 <code>lib/compiler.js</code> 的 <code>getModuleSource</code> 函数中做处理了。为什么是这个函数？因为它是做 code 解析的时候会用到的啊</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">getModuleSource(modulePath) &#123;</span><br><span class="line">  <span class="keyword">let</span> source = fs.readFileSync(modulePath, <span class="string">'utf8'</span>)</span><br><span class="line">  <span class="keyword">const</span> &#123; rules &#125; = <span class="keyword">this</span>.config.module</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; rules.length; i++) &#123;</span><br><span class="line">    <span class="comment">// 处理对应 test 下的 use</span></span><br><span class="line">    <span class="keyword">const</span> rule = rules[i]</span><br><span class="line">    <span class="keyword">const</span> &#123; test, use &#125; = rule</span><br><span class="line">    <span class="keyword">let</span> len = use.length - <span class="number">1</span></span><br><span class="line">    <span class="comment">// 先匹配 test 正则</span></span><br><span class="line">    <span class="keyword">if</span> (test.test(modulePath)) &#123;</span><br><span class="line">      <span class="comment">// 匹配对了就处理 loader， 这个是倒着处理的</span></span><br><span class="line">      <span class="function"><span class="keyword">function</span> <span class="title">normalLoader</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 获取对应 loader</span></span><br><span class="line">        <span class="keyword">const</span> loader = <span class="built_in">require</span>(use[len--])</span><br><span class="line">        <span class="comment">// 转化代码</span></span><br><span class="line">        source = loader(source)</span><br><span class="line">        <span class="comment">// loader 没调用完之前就继续递归调用 loader 来解析代码</span></span><br><span class="line">        len &gt;= <span class="number">0</span> &amp;&amp; normalLoader()</span><br><span class="line">      &#125;</span><br><span class="line">      normalLoader()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> source</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的逻辑就是如下</p>
<ol>
<li>解析配置文件中的 <code>rules</code></li>
<li>处理每个 <code>rules</code> 中的规则</li>
<li>如果规则(test)匹配，说明找到对应的后缀的文件了，这个时候就可以拿出其 <code>use</code>，用 <code>loader</code> 去解析代码了</li>
<li>从 <code>use</code> 数组倒序加载 <code>loader</code> 去做解析，并且这个过程是递归的</li>
</ol>
<p>最后在测试项目的 <code>src</code> 目录下新建 <code>index.less</code>，内容为</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>并且在 <code>index.js</code> 中引入</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="built_in">require</span>(<span class="string">'./foo.js'</span>)</span><br><span class="line"><span class="built_in">require</span>(<span class="string">'./index.less'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(str)</span><br></pre></td></tr></table></figure>
<p>这个时候执行 <code>npx st-pack</code>，查看 <code>bundle.js</code></p>
<p><img src="./5.jpg" alt></p>
<p>然后在 <code>dist</code> 目录新建 <code>index.html</code>，引入 <code>bundle.js</code>，用浏览器打开 <code>index.html</code></p>
<p><img src="./6.jpg" alt></p>
<h2 id="增加-plugin-解析机制"><a href="#增加-plugin-解析机制" class="headerlink" title="增加 plugin 解析机制"></a>增加 plugin 解析机制</h2><p>webpack 的插件机制其实很简单，就是在对应的生命周期的位置<strong>发布</strong>信息，而原来<strong>订阅</strong>到这些信息的插件收到这些信息时，就会<strong>执行对应的回调</strong>，本质上就是利用 <strong>发布订阅模式</strong>来实现 webpack 到对应的生命周期时执行对应的代码</p>
<p>首先为了方便这里使用 <code>tapable</code> 这个库，<code>tapble</code> 是一个用于为 plugins 创建钩子的库，它里面暴露了很多 hooks 类，目前这里使用 <code>SyncHook</code> 这个类来进行开发</p>
<p>先是安装 <code>tapable</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yarn add tapable</span><br></pre></td></tr></table></figure>
<p>在 <code>lib/complier.js</code> 文件中引入 <code>tapable</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; SyncHook &#125; = <span class="built_in">require</span>(<span class="string">'tapable'</span>)</span><br></pre></td></tr></table></figure>
<p>在 <code>Compiler</code> 类中，增加了 <code>hooks</code> 钩子</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 插件的生命周期钩子，这里为了方便统一使用同步的方式</span></span><br><span class="line"><span class="keyword">this</span>.hooks = &#123;</span><br><span class="line">  entryOptions: <span class="keyword">new</span> SyncHook(),</span><br><span class="line">  afterPlugins: <span class="keyword">new</span> SyncHook(),</span><br><span class="line">  run: <span class="keyword">new</span> SyncHook(),</span><br><span class="line">  compile: <span class="keyword">new</span> SyncHook(),</span><br><span class="line">  afterCompile: <span class="keyword">new</span> SyncHook(),</span><br><span class="line">  emit: <span class="keyword">new</span> SyncHook(),</span><br><span class="line">  done: <span class="keyword">new</span> SyncHook()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后将 <code>config</code> 中的 <code>plugins</code> 配置中的 <code>plugin</code> 的 <code>apply</code> 函数中的 <code>this</code> 也就是 <code>Compiler</code> 传入，让插件可以得到 <code>Compiler</code> 对象并订阅事件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; plugins &#125; = <span class="keyword">this</span>.config</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(plugins)) &#123;</span><br><span class="line">    plugins.forEach(<span class="function"><span class="params">plugin</span> =&gt;</span> &#123;</span><br><span class="line">      plugin.apply(<span class="keyword">this</span>) <span class="comment">// 将 Compiler 这个类传入</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后 <code>call</code> 对应的生命周期钩子发布事件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="meta">#! /usr/bin/env node</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"><span class="keyword">const</span> config = <span class="built_in">require</span>(path.resolve(<span class="string">'webpack.config.js'</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 找到项目目录下的 webpack.config.js 然后通过一个 compiler 解析它</span></span><br><span class="line"><span class="keyword">const</span> Complier = <span class="built_in">require</span>(<span class="string">'../lib/compiler.js'</span>)</span><br><span class="line"><span class="keyword">const</span> complier = <span class="keyword">new</span> Complier(config)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 run 之前发布一个 entryOptions 的钩子</span></span><br><span class="line">complier.hooks.entryOptions.call()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用 compiler 的 run 方法执行代码</span></span><br><span class="line">complier.run()</span><br></pre></td></tr></table></figure>
<p><img src="./7.jpg" alt></p>
<p>在测试项目目录创建 <code>plugins</code> 目录，然后写两个 <code>plugin</code> 插件</p>
<p><code>demo1-plugin.js</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo1Plugin</span> </span>&#123;</span><br><span class="line">  apply(compiler) &#123;</span><br><span class="line">    compiler.hooks.emit.tap(<span class="string">'emit'</span>, () =&gt; &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'emit'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = Demo1Plugin</span><br></pre></td></tr></table></figure>
<p><code>demo2-plugin.js</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo2Plugin</span> </span>&#123;</span><br><span class="line">  apply(compiler) &#123;</span><br><span class="line">    compiler.hooks.afterPlugins.tap(<span class="string">'afterPlugins'</span>, () =&gt; &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'afterPlugins'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = Demo2Plugin</span><br></pre></td></tr></table></figure>
<p>在其 <code>webpack.config.js</code> 文件中引入并使用</p>
<p><img src="./8.jpg" alt></p>
<p><img src="./9.jpg" alt></p>
<p>这里要强调的一点是，对于同步的钩子(如 <code>SyncHook</code>) 而言, <code>tap</code> 是添加 <code>plugin</code> 的唯一有效的方法，当然还有其他的异步钩子，这里不详细说，详情可以去看 <a href="https://www.npmjs.com/package/tapable" target="_blank" rel="noopener">tapble 官方文档说明</a></p>
<p>在测试项目根目录执行 <code>npx st-pack</code> 可以看到</p>
<p><img src="./10.jpg" alt></p>
<p>可以看到其正确的打印出了生命周期的顺序</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>由以上的分析可以看到，一个最基本的 webpack 的流程是这样的</p>
<ol>
<li><code>webpack</code> 在拿到配置文件后，将文件的配置传给一个 <code>Compiler</code> 对象，由这个对象 <code>run</code> 来处理对应的打包逻辑</li>
<li><code>Compiler</code> 主要做的就是两件事，<strong>递归创建依赖关系</strong> 和 <strong>生成打包后的文件</strong></li>
<li>在创建依赖关系的过程中，需要将模块的源码转成 ast，然后再遍历这个 ast node, 在遍历的过程中修改源码，最后再生成源码返回，此时返回的是一个修改过后的模板，用 <code>ejs</code> 渲染</li>
<li>模板本身就是 IIFE(立即执行函数)，也就是一个闭包，它通过这个函数去递归的执行对应模块的源码，直到最后输出结果</li>
<li>在解析 <code>loader</code> ，越靠后的越先执行。<code>loader</code> 本质上也是解析对应的 <code>loader</code> 源码执行的产物，不同的地方在于<strong><code>loader</code>中的参数即源码 <code>source</code> 是一个接着一个传递下去的</strong>，即 <code>loader</code> 之间是有一个传承的关系，他们的参数是相关联的。所以 <code>loader</code> 作为加载器，它的目的就是 <strong>加载代码 -&gt; 修改代码 -&gt; 执行代码</strong></li>
<li>在解析 <code>plugin</code> 时，本质上就是通过 <code>webpack</code> 暴露出来的事件，<code>plugin</code> 监听这些事件，在截获到这些事件的时候就可以做事情了。主要利用了<strong>发布订阅</strong>这样的一种设计模式</li>
</ol>
<p>另，<a href="https://github.com/strugglebak/webpack-resource-test-demo.git" target="_blank" rel="noopener">👉项目测试仓库戳这里</a>，以及<a href="https://github.com/strugglebak/st-pack.git" target="_blank" rel="noopener">👉手写 webpack 源码仓库戳这里</a></p>
]]></content>
      <categories>
        <category>前端工程化</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>从Promise本质开始(二):TDD方式实现基于Promises/A+规范的简易Promise</title>
    <url>/2020/03/20/%E4%BB%8EPromise%E6%9C%AC%E8%B4%A8%E5%BC%80%E5%A7%8B-%E4%BA%8C-TDD%E6%96%B9%E5%BC%8F%E5%AE%9E%E7%8E%B0%E5%9F%BA%E4%BA%8EPromises-A-%E8%A7%84%E8%8C%83%E7%9A%84%E7%AE%80%E6%98%93Promise/</url>
    <content><![CDATA[<blockquote>
<p>之前我还讲过 <a href="https://strugglebak.github.io/2020/03/09/%E4%BB%8EPromise%E6%9C%AC%E8%B4%A8%E5%BC%80%E5%A7%8B-%E4%B8%80-%E5%AE%9E%E7%8E%B0Promise%E5%89%8D%E8%A8%80/">如何为实现 Promise 搭建 TDD 环境</a>，而本文的目的主要是探讨如何基于 TDD 这样的方式实现一个 Promise，并且描述了部分 Promises/A+ 规范，以此为基础实现的一个 Promise</p>
</blockquote>
<a id="more"></a>
<p><a href="https://github.com/strugglebak/promise-easy" target="_blank" rel="noopener">项目地址</a></p>
<h2 id="先实现一个最基础版本的-Promise"><a href="#先实现一个最基础版本的-Promise" class="headerlink" title="先实现一个最基础版本的 Promise"></a>先实现一个最基础版本的 Promise</h2><p>有了之前的准备，现在就可以进行 TDD(Test Driven Develop)测试驱动开发了，注意，以下的测试代码都写在测试文件 <code>test/index.ts</code> 中，并且文件大致的代码结构为如下所示</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; assert &#125; <span class="keyword">from</span> <span class="string">'chai'</span></span><br><span class="line"><span class="keyword">import</span> &#123; describe, it &#125; <span class="keyword">from</span> <span class="string">'mocha'</span></span><br><span class="line"><span class="keyword">import</span> <span class="built_in">Promise</span> <span class="keyword">from</span> <span class="string">'../src/promise'</span></span><br><span class="line"></span><br><span class="line">describe(<span class="string">'Promise'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="comment">// TODO</span></span><br><span class="line">  it(<span class="string">'TODO'</span>, () =&gt; &#123;</span><br><span class="line">    <span class="comment">// TODO</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>并且源码文件为 <code>src/promise.ts</code></p>
<h3 id="Promise-是一个类"><a href="#Promise-是一个类" class="headerlink" title="Promise 是一个类"></a>Promise 是一个类</h3><h4 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h4><p>测试用例是这样写</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">it(<span class="string">'是一个类'</span>, () =&gt; &#123;</span><br><span class="line">  assert.isFunction(<span class="built_in">Promise</span>)</span><br><span class="line">  assert.isObject(<span class="built_in">Promise</span>.prototype)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>即 <code>assert</code> 断言</p>
<ul>
<li>Promise 是一个 <code>function</code></li>
<li>Promise 的原型 <code>prototype</code> 是一个对象</li>
</ul>
<p>那么就可以证明 Promise 是一个类了</p>
<h4 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PromiseEasy</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="comment">// TODO</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>很简单吧，其实就是用 <strong>测试的需求</strong> 来推动 <strong>开发</strong></p>
<h3 id="new-Promise-如果接受的不是函数就报错"><a href="#new-Promise-如果接受的不是函数就报错" class="headerlink" title="new Promise() 如果接受的不是函数就报错"></a>new Promise() 如果接受的不是函数就报错</h3><p>这里的逻辑是 Promise 需要接受一个函数作为参数，所以测试用例应该这么写</p>
<h4 id="测试用例-1"><a href="#测试用例-1" class="headerlink" title="测试用例"></a>测试用例</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">it(<span class="string">'new Promise() 如果接受的不是函数就报错'</span>, () =&gt; &#123;</span><br><span class="line">  assert.throw(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// @ts-ignore</span></span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>()</span><br><span class="line">  &#125;)</span><br><span class="line">  assert.throw(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// @ts-ignore</span></span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="number">1</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  assert.throw(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// @ts-ignore</span></span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="literal">true</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里 <code>// @ts-ignore</code> 的意思就是 <strong>注释会忽略下一行中产生的所有错误</strong>，但是因为这里要是不通过就很麻烦，所以还是加上</p>
</blockquote>
<blockquote>
<p><code>assert.throw</code> 这个 API 的意思就是断言一段会报错的代码</p>
</blockquote>
<h4 id="源码-1"><a href="#源码-1" class="headerlink" title="源码"></a>源码</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PromiseEasy</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(fn) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> fn !== <span class="string">'function'</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'这里只接受函数'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>逻辑也很简单，对传入的参数做一个判断即可</p>
<h3 id="new-Promise-fn-会生成一个对象，该对象会有个-then-方法"><a href="#new-Promise-fn-会生成一个对象，该对象会有个-then-方法" class="headerlink" title="new Promise(fn) 会生成一个对象，该对象会有个 then 方法"></a>new Promise(fn) 会生成一个对象，该对象会有个 then 方法</h3><p>嗯，该往 Promise 里面添加 <code>then</code> 方法了，不过之前还是得写测试用例</p>
<h4 id="测试用例-2"><a href="#测试用例-2" class="headerlink" title="测试用例"></a>测试用例</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">it(<span class="string">'new Promise(fn) 会生成一个对象，该对象会有个 then 方法'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">()</span>=&gt;</span>&#123;&#125;)</span><br><span class="line">  assert.isFunction(promise.then)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="源码-2"><a href="#源码-2" class="headerlink" title="源码"></a>源码</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PromiseEasy</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(fn) &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">  then() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="new-Promise-fn-中的函数立即执行"><a href="#new-Promise-fn-中的函数立即执行" class="headerlink" title="new Promise(fn) 中的函数立即执行"></a>new Promise(fn) 中的函数立即执行</h3><p>这个的测试代码就很简单了</p>
<h4 id="测试用例-3"><a href="#测试用例-3" class="headerlink" title="测试用例"></a>测试用例</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">it(<span class="string">'new Promise(fn) 中的函数立即执行'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> called = <span class="literal">false</span></span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    called = <span class="literal">true</span></span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// @ts-ignore</span></span><br><span class="line">  assert(called === <span class="literal">true</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>判断是否被调用就是判断 <code>called</code> 这个变量有没有变化</p>
<h4 id="源码-3"><a href="#源码-3" class="headerlink" title="源码"></a>源码</h4><p>那就很简单了，直接调用构造函数里面传入的 <code>fn</code> 即可</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PromiseEasy</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(fn) &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    fn()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Promise-then-success-中的-success-会在-resolve-被调用后执行"><a href="#Promise-then-success-中的-success-会在-resolve-被调用后执行" class="headerlink" title="Promise.then(success) 中的 success 会在 resolve 被调用后执行"></a>Promise.then(success) 中的 success 会在 resolve 被调用后执行</h3><p>所以这里的核心就是需要验证 <code>then</code> 之后里面 <code>resolve</code> 的函数有没有被执行过了</p>
<h4 id="测试用例-4"><a href="#测试用例-4" class="headerlink" title="测试用例"></a>测试用例</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">it(<span class="string">'promise.then(success) 中的 success 会在 resolve 被调用后执行'</span>, done =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> called = <span class="literal">false</span></span><br><span class="line">  <span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    assert(called === <span class="literal">false</span>)</span><br><span class="line">    resolve()</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      assert(called === <span class="literal">true</span>)</span><br><span class="line">      done()</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// @ts-ignore</span></span><br><span class="line">  promise.then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    called = <span class="literal">true</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>注意这里在 <code>Promise</code> 中使用了 <code>setTimeout</code>,这是因为</p>
<ul>
<li>这里只有等一会才能断言 <code>called = true</code></li>
<li>因为顺序是先 then -&gt; 调用 fn -&gt; 调用 succeed</li>
<li>而 succeed 是放入了 setTimeout 中的</li>
</ul>
<p>并且还使用了 <code>done</code>，这是因为</p>
<ul>
<li>如果代码里面需要异步的测试，则需要加 <code>done</code></li>
<li>表示异步测试的完成，告诉 mocha 可以检查其测试结果了</li>
<li>不然很多个任务都是异步测试的话，mocha 就不知道哪个是先完成的(这里 mocha 对于测试用例是一个一个同步执行的)</li>
</ul>
<h4 id="源码-4"><a href="#源码-4" class="headerlink" title="源码"></a>源码</h4><p>首先需要在 <code>Promise</code> 里面声明两个变量 <code>succeed</code> 和 <code>fail</code> 分别保存成功和失败回调</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PromiseEasy</span> </span>&#123;</span><br><span class="line">  succeed = <span class="literal">null</span> <span class="comment">// 保存成功回调</span></span><br><span class="line">  fail = <span class="literal">null</span> <span class="comment">// 保存失败回调</span></span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>then</code> 函数执行时保存回调</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PromiseEasy</span> </span>&#123;</span><br><span class="line">  succeed = <span class="literal">null</span> <span class="comment">// 保存成功回调</span></span><br><span class="line">  fail = <span class="literal">null</span> <span class="comment">// 保存失败回调</span></span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">  then(succeed, fail) &#123;</span><br><span class="line">    <span class="keyword">this</span>.succeed = succeed</span><br><span class="line">    <span class="keyword">this</span>.fail = fail</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么什么时候这个 <code>succeed</code> 函数被调用呢，就是 <code>resolve</code> 的时候。众所周知 Promise 不仅仅有 <code>resolve</code>，还有 <code>reject</code>，并且在 <code>new Promise</code> 中使用 <code>resolve</code> 时并不会立刻调用成功回调，而是在执行 <code>then</code> 之后才调用，所以 <code>resolve</code> 和 <code>reject</code> 函数是异步的，这里仅就用 <code>setTimeout</code> 做一个简单的处理</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PromiseEasy</span> </span>&#123;</span><br><span class="line">  succeed = <span class="literal">null</span> <span class="comment">// 保存成功回调</span></span><br><span class="line">  fail = <span class="literal">null</span> <span class="comment">// 保存失败回调</span></span><br><span class="line"></span><br><span class="line">  resolve() &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.succeed()</span><br><span class="line">    &#125;, <span class="number">0</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  reject() &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.fail()</span><br><span class="line">    &#125;, <span class="number">0</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">  then(succeed, fail) &#123;</span><br><span class="line">    <span class="keyword">this</span>.succeed = succeed</span><br><span class="line">    <span class="keyword">this</span>.fail = fail</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后在构造函数中需要将 <code>resolve</code> 和 <code>reject</code> 传给 <code>fn</code> 当参数就可以了，当然这里需要 <code>bind</code> 下 <code>this</code>，不然 <code>resolve</code> 和 <code>reject</code> 函数中的 <code>this</code> 是访问不到的</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PromiseEasy</span> </span>&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="keyword">constructor</span>(fn) &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    fn(<span class="keyword">this</span>.resolve.bind(<span class="keyword">this</span>), <span class="keyword">this</span>.reject.bind(<span class="keyword">this</span>))</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Promise-then-null-fail-中的-fail-会在-reject-被调用后执行"><a href="#Promise-then-null-fail-中的-fail-会在-reject-被调用后执行" class="headerlink" title="Promise.then(null, fail) 中的 fail 会在 reject 被调用后执行"></a>Promise.then(null, fail) 中的 fail 会在 reject 被调用后执行</h3><p>这里的测试代码不用说了，和上面的基本差不多</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">it(<span class="string">'promise.then(null, fail) 中的 fail 会在 reject 被调用后执行'</span>, done =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> fail = sinon.fake()</span><br><span class="line">  <span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    assert.isFalse(fail.called)</span><br><span class="line">    reject()</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      assert.isTrue(fail.called)</span><br><span class="line">      done()</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// @ts-ignore</span></span><br><span class="line">  promise.then(<span class="literal">null</span>, fail)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>至此，一个基本的简单的 Promise 框架就算完成了，剩下就是按照 A+ 规范标准在上面添砖加瓦了</p>
<h2 id="遵循比较重要的-Promise-A-规范增加功能"><a href="#遵循比较重要的-Promise-A-规范增加功能" class="headerlink" title="遵循比较重要的 Promise/A+ 规范增加功能"></a>遵循比较重要的 Promise/A+ 规范增加功能</h2><h3 id="2-2-1-Both-onFulfilled-and-onRejected-are-optional-arguments"><a href="#2-2-1-Both-onFulfilled-and-onRejected-are-optional-arguments" class="headerlink" title="2.2.1 Both onFulfilled and onRejected are optional arguments"></a>2.2.1 Both onFulfilled and onRejected are optional arguments</h3><p><code>onFulfilled</code> 和 <code>onRejected</code> 都是可选的参数</p>
<h4 id="测试用例-5"><a href="#测试用例-5" class="headerlink" title="测试用例"></a>测试用例</h4><p>这里的测试用例很简单</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">it(<span class="string">'2.2.1 onFulfilled 和 onRejected 都是可选的参数'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resovle</span> =&gt;</span> &#123;</span><br><span class="line">    resovle()</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  promise.then(<span class="literal">false</span>, <span class="literal">null</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>参数可选什么意思，就是 <code>then</code> 传的俩参数都是可以传或者可以不传，所以这里的测试用例很简单</p>
<h4 id="源码-5"><a href="#源码-5" class="headerlink" title="源码"></a>源码</h4><p>所以这个时候就需要在 3 个地方对参数做判断了</p>
<ul>
<li><code>resolve</code> 函数</li>
<li><code>reject</code> 函数</li>
<li><code>then</code> 函数</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PromiseEasy</span> </span>&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  resolve() &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span>.succeed === <span class="string">'function'</span>) &#123; <span class="comment">// 添加判断</span></span><br><span class="line">        <span class="keyword">this</span>.succeed()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, <span class="number">0</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  reject() &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span>.fail === <span class="string">'function'</span>) &#123; <span class="comment">// 添加判断</span></span><br><span class="line">        <span class="keyword">this</span>.fail()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, <span class="number">0</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  then(succeed?, fail?) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> succeed === <span class="string">'function'</span>) &#123; <span class="comment">// 添加判断</span></span><br><span class="line">      <span class="keyword">this</span>.succeed = succeed</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> fail === <span class="string">'function'</span>) &#123; <span class="comment">// 添加判断</span></span><br><span class="line">      <span class="keyword">this</span>.fail = fail</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-2-2-If-onFulfilled-is-a-function"><a href="#2-2-2-If-onFulfilled-is-a-function" class="headerlink" title="2.2.2 If onFulfilled is a function"></a>2.2.2 If onFulfilled is a function</h3><p>2.2.2 这里有三点</p>
<ol>
<li>it must be called after promise is fulfilled, with promise’s value as its first argument</li>
<li>it must not be called before promise is fulfilled</li>
<li>it must not be called more than once</li>
</ol>
<p>总的来说，大意就是 <strong>此函数必须在 promise 完成(fulfilled) 后被调用,并把 promise 的 result 值作为它的第一个参数</strong></p>
<p>这里先在测试用例中将以上 3 点都测试一遍，但是为了方便起见就只用一个标题</p>
<h4 id="测试用例-6"><a href="#测试用例-6" class="headerlink" title="测试用例"></a>测试用例</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">it(<span class="string">'2.2.2.1 此函数必须在 promise 完成(fulfilled) 后被调用,并把 promise 的 result 值作为它的第一个参数'</span>, done =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> success = sinon.fake()</span><br><span class="line">  <span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    assert.isFalse(success.called) <span class="comment">// 测试第 2 点</span></span><br><span class="line">    resolve(<span class="string">'hi'</span>)</span><br><span class="line">    resolve(<span class="string">'hii'</span>) <span class="comment">// 调用两次</span></span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      assert(promise.state === <span class="string">'fulfilled'</span>) <span class="comment">// 测试第 1 点</span></span><br><span class="line">      assert.isTrue(success.calledOnce) <span class="comment">// 测试第 3 点</span></span><br><span class="line">      assert.isTrue(success.calledWith(<span class="string">'hi'</span>)) <span class="comment">// 测试第 1 点</span></span><br><span class="line">      done()</span><br><span class="line">    &#125;, <span class="number">0</span>)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  promise.then(success)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里使用了 <code>sinon.fake</code> 作为假函数，然后使用 <code>assert.isTrue/assert.isFalse</code> 判断 <code>sinon.fake.called</code> 是否为 <code>true</code>，为 <code>true</code> 说明其已经被调用了，使用 <code>sinon.fake.calledOnce</code> 判断其是否只被调用一次，使用 <code>sinon.fake.calledWith</code> 判断其是否在调用 <code>resolve</code> 时传了对应的参数</p>
</blockquote>
<p>所以要实现这一条规范，我们就需要在 Promise 内部维护一个 <code>state</code> 状态判断当前是否是处于 <code>初始状态</code>/<code>resolve</code>/<code>reject</code>，现在我们定义 <code>state</code> 有 3 种状态</p>
<ul>
<li><code>pending</code>: 表示初始状态</li>
<li><code>fulfilled</code>: 表示用户调用了 <code>resolve</code> 函数</li>
<li><code>rejected</code>: 表示用户调用了 <code>reject</code> 函数</li>
</ul>
<blockquote>
<p>这里还要说明的是，<code>state</code> 状态只能是单向的变化，即只能是 <code>pending</code> -&gt; <code>fulfilled</code> 或者 <code>pending</code> -&gt; <code>rejected</code>，而不能三者两两互相变化</p>
</blockquote>
<h4 id="源码-6"><a href="#源码-6" class="headerlink" title="源码"></a>源码</h4><p>所以源码应该是要对 <code>resolve</code> 以及 <code>reject</code> 做修改，并且还要增加一个 <code>state</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PromiseEasy</span> </span>&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  state = <span class="string">'pending'</span></span><br><span class="line">  resolve(result) &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.state !== <span class="string">'pending'</span>) <span class="keyword">return</span></span><br><span class="line">      <span class="keyword">this</span>.state = <span class="string">'fulfilled'</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span>.succeed === <span class="string">'function'</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.succeed(result)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, <span class="number">0</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  reject(reason) &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.state !== <span class="string">'pending'</span>) <span class="keyword">return</span></span><br><span class="line">      <span class="keyword">this</span>.state = <span class="string">'rejected'</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span>.fail === <span class="string">'function'</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.fail(reason)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, <span class="number">0</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在进入 <code>resolve</code>/ <code>reject</code> 之后，先判断其是否是在 <code>pending</code> 状态，否则就 <code>return</code>，即保证上述规范第3点，之后才将状态改变，并且对 <code>succeed</code>/<code>fail</code> 函数做判断，只有其是函数时才能被调用。其中还添加了 <code>resolve</code> 的参数 <code>result</code> 以及 <code>reject</code> 参数 <code>reason</code></p>
<h3 id="2-2-3-If-onRejected-is-a-function"><a href="#2-2-3-If-onRejected-is-a-function" class="headerlink" title="2.2.3 If onRejected is a function"></a>2.2.3 If onRejected is a function</h3><ul>
<li>it must be called after promise is rejected, with promise’s reason as its first argument</li>
<li>it must not be called before promise is rejected</li>
<li>it must not be called more than once</li>
</ul>
<p>这个跟 2.2.2 其实很像的，就是做 <code>reject</code> 之后的逻辑</p>
<h4 id="测试用例-7"><a href="#测试用例-7" class="headerlink" title="测试用例"></a>测试用例</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">it(<span class="string">'2.2.3.1 此函数必须在 promise 失败(rejected) 后被调用,并把 promise 的值作为它的第一个参数'</span>, done =&gt; &#123;</span><br><span class="line">   <span class="keyword">const</span> fail = sinon.fake()</span><br><span class="line">   <span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">     assert.isFalse(fail.called)</span><br><span class="line">     reject(<span class="string">'hi'</span>)</span><br><span class="line">     reject(<span class="string">'hii'</span>)</span><br><span class="line">     setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">       assert(promise.state === <span class="string">'rejected'</span>)</span><br><span class="line">       assert.isTrue(fail.calledOnce)</span><br><span class="line">       assert.isTrue(fail.calledWith(<span class="string">'hi'</span>))</span><br><span class="line">       done()</span><br><span class="line">     &#125;, <span class="number">0</span>)</span><br><span class="line">   &#125;)</span><br><span class="line"></span><br><span class="line">   promise.then(<span class="literal">null</span>, fail)</span><br><span class="line"> &#125;)</span><br></pre></td></tr></table></figure>
<h4 id="源码-7"><a href="#源码-7" class="headerlink" title="源码"></a>源码</h4><p><a href="#2.2.2-If-onFulfilled-is-a-function">参考 2.2.2 If onFulfilled is a function</a></p>
<h3 id="2-2-4-onFulfilled-or-onRejected-must-not-be-called-until-the-execution-context-stack-contains-only-platform-code"><a href="#2-2-4-onFulfilled-or-onRejected-must-not-be-called-until-the-execution-context-stack-contains-only-platform-code" class="headerlink" title="2.2.4 onFulfilled or onRejected must not be called until the execution context stack contains only platform code"></a>2.2.4 onFulfilled or onRejected must not be called until the execution context stack contains only platform code</h3><p>这句话给人很疑惑的感觉，因为官方的翻译就是</p>
<blockquote>
<p>在执行上下文堆栈（execution context）仅包含平台代码之前，不得调用 onFulfilled 和 onRejected</p>
</blockquote>
<p>再去看对应的解释(<a href="https://promisesaplus.com/#notes" target="_blank" rel="noopener">3.1</a>)</p>
<blockquote>
<p>Here “platform code” means engine, environment, and promise implementation code. In practice, this requirement ensures that <code>onFulfilled</code> and <code>onRejected</code> execute asynchronously, after the event loop turn in which <code>then</code> is called, and with a fresh stack. This can be implemented with either a “macro-task” mechanism such as <code>setTimeout</code> or <code>setImmediate</code>, or with a “micro-task” mechanism such as <code>MutationObserver</code> or <code>process.nextTick</code>. Since the promise implementation is considered platform code, it may itself contain a task-scheduling queue or “trampoline” in which the handlers are called.</p>
</blockquote>
<p>翻译一下，就是</p>
<blockquote>
<p>这里的 “platform code” 表示 (JS 的) 引擎，(JS 的)环境和 promise 执行的代码。实际上，这个(规范)要求能确保，<code>onFulfilled</code> 和 <code>onRejected</code> 在 eventLoop 之后调用 <code>then</code>，  它们可以(得到)异步地执行，然后(继续)使用新的堆栈。这里既可以使用 <code>setTimeout</code>/<code>setImmediate</code> 这样的 “宏任务” 机制实现，也可以使用 <code>MutationObserver</code>/<code>process.nextTick</code> 这样的 “微任务” 机制实现。由于 promise 的实现被看作是 platform code，所以它可能本身就包含一个任务调度队列或者用来处理调用(关系)的 “trampoline”</p>
</blockquote>
<p>还是不理解？我举个例子好了，比如有一个函数叫做 <code>XXX</code> 吧，一个 promise 做了如下的操作</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">promise.then(XXX)</span><br></pre></td></tr></table></figure>
<p>但是此时函数 <code>XXX</code> <strong>还没有执行</strong>哦，因为规范要求，<strong>一定要在调用 <code>then</code></strong> 之后执行。因为这才可以产生一个异步的操作，而这个异步的操作如何来？规范里面也写了，可以利用 <code>setTimeout</code>/<code>setImmediate</code> 这样的宏任务来解决，或者也可以使用 <code>MutationObserver</code>/<code>process.nextTick</code> 这样的微任务来解决。解决的关键点是什么呢？就是在 Promise 内部，其传入的函数里面执行的<strong>优先级</strong>比外面通过 <code>promise.then</code> 方式调用 <code>XXX</code> 的优先级 <strong>要高</strong>。那么怎么做到这种优先级要高呢？ <strong>就是在 <code>resolve</code>/<code>reject</code> 中加上 <code>setTimeout</code></strong>。当然了，这里只是简单的处理，比如我写如下的测试代码你大概就懂了</p>
<blockquote>
<p>如果实在不明白宏任务/微任务机制的可以<a href="https://github.com/strugglebak/front-end-daliy/issues/8" target="_blank" rel="noopener">点击参考我之前写的这篇</a></p>
</blockquote>
<h4 id="测试用例-8"><a href="#测试用例-8" class="headerlink" title="测试用例"></a>测试用例</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">it(<span class="string">'2.2.4 在我的代码执行完之前，不得调用 then 后面的两个函数'</span>, done =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> success = sinon.fake()</span><br><span class="line">  <span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    resolve()</span><br><span class="line">  &#125;)</span><br><span class="line">  promise.then(success)</span><br><span class="line">  <span class="comment">// 这个时候代码还没有执行完，success 函数还没有被调用</span></span><br><span class="line">  assert.isFalse(success.called)</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 这个时候代码执行完了，success 函数被调用了</span></span><br><span class="line">    assert.isTrue(success.called)</span><br><span class="line">    done()</span><br><span class="line">  &#125;, <span class="number">0</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">it(<span class="string">'2.2.4 失败回调'</span>, done =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> fail = sinon.fake()</span><br><span class="line">  <span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    reject()</span><br><span class="line">  &#125;)</span><br><span class="line">  promise.then(<span class="literal">null</span>, fail)</span><br><span class="line">  assert.isFalse(fail.called)</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    assert.isTrue(fail.called)</span><br><span class="line">    done()</span><br><span class="line">  &#125;, <span class="number">0</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>所以你可以看到，外面的 <code>setTimeout</code> 要 <strong>靠后 </strong> 执行了，为什么，因为 <code>success</code> 函数先进入了 Promise 内部，其内部有个 <code>setTimeout</code> 函数将其包裹了起来，eventLoop 时运行环境会将这个里面的代码放到了一个宏任务队列中，而这个外面调的 <code>setTimeout</code> 也将其紧随其后放到这个队列里面。执行时会优先执行先进去的任务，那么就是 <code>success</code> 先在里面执行了，然后外部的 <code>setTimeout</code> 自然就会觉察到 <code>success</code> 被调用了。</p>
<h4 id="源码-8"><a href="#源码-8" class="headerlink" title="源码"></a>源码</h4><p>参考最开始写的 <a href="#先实现一个最基础版本的-Promise">先实现一个最基础版本的 Promise</a></p>
<h3 id="2-2-5-onFulfilled-and-onRejected-must-be-called-as-functions-i-e-with-no-this-value"><a href="#2-2-5-onFulfilled-and-onRejected-must-be-called-as-functions-i-e-with-no-this-value" class="headerlink" title="2.2.5 onFulfilled and onRejected must be called as functions (i.e. with no this value)"></a>2.2.5 onFulfilled and onRejected must be called as functions (i.e. with no this value)</h3><p>这里的意思是 <code>onFulfilled</code> 和 <code>onRejected</code> 必须被当作函数调用(例如: 没有 <code>this</code>)</p>
<p>又懵逼了，啥玩意儿???还是看看<a href="https://promisesaplus.com/#notes" target="_blank" rel="noopener">说明 3.2</a>吧</p>
<blockquote>
<p>That is, in strict mode <code>this</code> will be <code>undefined</code> inside of them; in sloppy mode, it will be the global object</p>
</blockquote>
<p>意思就是说</p>
<blockquote>
<p>严格模式下，<code>this</code> 在 <code>onFulfilled</code> 以及 <code>onRejected</code> 内部是 <code>undefined</code>; 而在非严格模式下，<code>this</code> 在它们内部就是一个全局对象</p>
</blockquote>
<p>所以这里我们就选择严格模式就好了，因为本来就是由类封装起来的对象，在这种情况下，<code>this</code> 在 <code>onFulfilled</code> 以及 <code>onRejected</code> 内部只能是 <code>undefined</code>，那么测试用例应该这么写</p>
<h4 id="测试用例-9"><a href="#测试用例-9" class="headerlink" title="测试用例"></a>测试用例</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">it(<span class="string">'2.2.5 onFulfilled 和 onRejected 必须被当做函数调用(并且里面没有 this)'</span>, done =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    resolve()</span><br><span class="line">  &#125;)</span><br><span class="line">  promise.then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">    'use strict'</span></span><br><span class="line">    assert(<span class="keyword">this</span> === <span class="literal">undefined</span>) <span class="comment">// 断言这个函数里面的 this 为 undefined</span></span><br><span class="line">    done()</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">it(<span class="string">'2.2.5 失败回调'</span>, done =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    reject()</span><br><span class="line">  &#125;)</span><br><span class="line">  promise.then(<span class="literal">null</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">    'use strict'</span></span><br><span class="line">    assert(<span class="keyword">this</span> === <span class="literal">undefined</span>)</span><br><span class="line">    done()</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="源码-9"><a href="#源码-9" class="headerlink" title="源码"></a>源码</h4><p>源码就好改了，对应的 <code>resolve</code> 以及 <code>reject</code> 函数里面将对应的函数调用 <code>call</code> 一个 <code>undefined</code> 就好，如下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PromiseEasy</span> </span>&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  resovle(result) &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span>.succeed === <span class="string">'function'</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.succeed.call(<span class="literal">undefined</span>, result)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  reject(reason) &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span>.fail === <span class="string">'function'</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.fail.call(<span class="literal">undefined</span>, reason)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-2-6-then-may-be-called-multiple-times-on-the-same-promise"><a href="#2-2-6-then-may-be-called-multiple-times-on-the-same-promise" class="headerlink" title="2.2.6 then may be called multiple times on the same promise"></a>2.2.6 then may be called multiple times on the same promise</h3><p><code>then</code> 可以在同一个 Promise 里被多次调用。那么基本上测试代码可以这么写</p>
<h4 id="测试用例-10"><a href="#测试用例-10" class="headerlink" title="测试用例"></a>测试用例</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">it(<span class="string">'2.2.6 then可以在同一个promise里被多次调用'</span>, done =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    resolve()</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">const</span> callbacks = [sinon.fake(), sinon.fake(), sinon.fake()]</span><br><span class="line">  promise.then(callbacks[<span class="number">0</span>])</span><br><span class="line">  promise.then(callbacks[<span class="number">1</span>])</span><br><span class="line">  promise.then(callbacks[<span class="number">2</span>])</span><br><span class="line"></span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    assert(callbacks[<span class="number">0</span>].called)</span><br><span class="line">    assert(callbacks[<span class="number">1</span>].called)</span><br><span class="line">    assert(callbacks[<span class="number">2</span>].called)</span><br><span class="line">    <span class="comment">// 如果/当 promise 完成执行（fulfilled）,各个相应的onFulfilled回调 必须根据最原始的then 顺序来调用</span></span><br><span class="line">    assert(callbacks[<span class="number">1</span>].calledAfter(callbacks[<span class="number">0</span>]))</span><br><span class="line">    assert(callbacks[<span class="number">2</span>].calledAfter(callbacks[<span class="number">1</span>]))</span><br><span class="line">    done()</span><br><span class="line">  &#125;, <span class="number">0</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">it(<span class="string">'2.2.6 失败回调'</span>, done =&gt; &#123;</span><br><span class="line">   <span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">     reject()</span><br><span class="line">   &#125;)</span><br><span class="line">   <span class="keyword">const</span> callbacks = [sinon.fake(), sinon.fake(), sinon.fake()]</span><br><span class="line">   promise.then(<span class="literal">null</span>, callbacks[<span class="number">0</span>])</span><br><span class="line">   promise.then(<span class="literal">null</span>, callbacks[<span class="number">1</span>])</span><br><span class="line">   promise.then(<span class="literal">null</span>, callbacks[<span class="number">2</span>])</span><br><span class="line"></span><br><span class="line">   setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">     assert(callbacks[<span class="number">0</span>].called)</span><br><span class="line">     assert(callbacks[<span class="number">1</span>].called)</span><br><span class="line">     assert(callbacks[<span class="number">2</span>].called)</span><br><span class="line">     assert(callbacks[<span class="number">1</span>].calledAfter(callbacks[<span class="number">0</span>]))</span><br><span class="line">     assert(callbacks[<span class="number">2</span>].calledAfter(callbacks[<span class="number">1</span>]))</span><br><span class="line">     done()</span><br><span class="line">   &#125;, <span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里 <code>sinon.fake.calledAfter</code> 表示在某个目标函数之后被调用</p>
</blockquote>
<h4 id="源码-10"><a href="#源码-10" class="headerlink" title="源码"></a>源码</h4><p>这里的 <code>promise</code> 要求能够多次调用 <code>then</code>，而我们原来 Promise 的逻辑是 <code>then</code> 只是保存了一次 <code>succeed</code> 和 <code>fail</code>，这样的话多次 <code>then</code> 就只会覆盖掉之前传入的函数。要能通过测试用例中的代码，我们很容易想到，每次 <code>then</code> 时，用<strong>数组来保存 <code>succeed</code> 和 <code>fail</code></strong> 即可。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PromiseEasy</span> </span>&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  callbacks = [] <span class="comment">// 用来保存成功以及失败回调的数组</span></span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  then(succeed?, fail?) &#123;</span><br><span class="line">    <span class="keyword">const</span> handle = []</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> succeed === <span class="string">'function'</span>) &#123;</span><br><span class="line">      handle[<span class="number">0</span>] = succeed</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> fail === <span class="string">'function'</span>) &#123;</span><br><span class="line">      handle[<span class="number">1</span>] = fail</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.callbacks.push(handle)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么在调用的时候怎么办呢？只需要在 <code>resolve</code> 和 <code>reject</code> 中 <strong>遍历调用</strong> 即可</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PromiseEasy</span> </span>&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  resolve(result) &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">//...</span></span><br><span class="line">      <span class="keyword">this</span>.callbacks.forEach(<span class="function"><span class="params">handle</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> succeed = handle[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> succeed === <span class="string">'function'</span>) &#123;</span><br><span class="line">          succeed.call(<span class="literal">undefined</span>, result)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;, <span class="number">0</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  reject(reason) &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">//...</span></span><br><span class="line">      <span class="keyword">this</span>.callbacks.forEach(<span class="function"><span class="params">handle</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> fail = handle[<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> fail === <span class="string">'function'</span>) &#123;</span><br><span class="line">          fail.call(<span class="literal">undefined</span>, reason)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;, <span class="number">0</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，本质就是两步</p>
<ul>
<li>添加一个<strong>二维数组</strong>，<code>then</code> 时保存 <code>succeed</code> 和 <code>fail</code> 的数组</li>
<li>在 <code>resolve</code>/<code>reject</code> 时<strong>遍历</strong>，取出对应的 <code>succeed</code>/<code>fail</code>，并执行</li>
</ul>
<h2 id="与-Promises-A-规范的区别"><a href="#与-Promises-A-规范的区别" class="headerlink" title="与 Promises/A 规范的区别"></a>与 Promises/A 规范的区别</h2><p>至此，我们已经完成一个 Promise 的基本功能，这个功能包括了 Promise 的核心 API，即 <code>new Promise</code> 以及 <code>then</code> 和里面的成功以及失败回调，下面就来讲(fan)讲(yi) Promises/A+ 规范和 Promises/A 规范的几个<strong>比较重要</strong>的区别</p>
<h3 id="Omissions"><a href="#Omissions" class="headerlink" title="Omissions"></a>Omissions</h3><p>下面的几点都是 Promises/A 规范所遗漏的:</p>
<ol>
<li>进度处理: 实际上，它并未被指定，并且当前在实现 promise 的社区中没有形成一致的意见</li>
<li>可交互的 promises: 这被认为超出了可互操作保证所必需的最小 API 的范围</li>
<li>对于 <code>var promise2 = promise1.then(onFulfilled, onRejected)</code> 这样的代码，<code>promise1 !== promise2</code> 并不是必要的</li>
</ol>
<h3 id="Clarifications"><a href="#Clarifications" class="headerlink" title="Clarifications"></a>Clarifications</h3><p>Promises/A+ 规范与 Promises/A 规范使用不同的术语，这体现在 Promise 的实现过程中，它们已经成为事实(标准)意义上的词汇。 特别是如下:</p>
<ol>
<li>给定的 promise 的状态是 “pending”、”fulfilled”、”rejected”</li>
<li>当 promises 被 fulfilled 时，它们会有 “value”; 当 promises 被 rejected 时，它们会有 “reason”</li>
<li>它引入了与 “promises” 不同的术语叫 “thenable”，以便更准确地讨论实现互操作所必需的 duck 测试</li>
</ol>
<h3 id="Additions"><a href="#Additions" class="headerlink" title="Additions"></a>Additions</h3><p>Promises/A+ 规范另外指定:</p>
<ol>
<li>当 <code>onFulfilled</code> 或 <code>onRejected</code> 返回一个 <code>thenable</code> 的行为时，应包括解析过程的详细信息</li>
<li>传给 <code>onRejected</code> 的 <code>reason</code> 在处理 <code>throws</code> 必须要抛异常</li>
<li><code>onFulfilled</code> 和 <code>onRejected</code> 必须是被异步调用的</li>
<li><code>onFulfilled</code> 和 <code>onRejected</code> 必须是当作函数来调用</li>
<li>对 <code>onFulfilled</code> 和 <code>onRejected</code> 的调用的严格排序，以便在同一个 promise 上调用 <code>then</code></li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>一个基础的 Promises/A+ 规范的 Promise 的实现需要注意以下几点</p>
<ol>
<li>构造函数需要传一个函数，并在构造函数内部调用这个函数，而这个函数传了两个参数作为参数: <code>resolve</code> 和 <code>reject</code>，这两个函数都是 Promise 内部实现的函数</li>
<li>每次 <code>then</code> 时都将传入的 <code>succeed</code> 和 <code>fail</code> 函数 push 进一个数组当中，而这个数组是一个二维数组，用来维护这一堆 <code>succeed</code> 和 <code>fail</code> 函数</li>
<li>Promise 内部的 <code>resolve</code> 函数和 <code>reject</code> 函数中都做了如下的操作<ul>
<li>判断 <code>state</code> 是否为 <code>pending</code> 状态，不是就 return</li>
<li>修改状态为 <code>fulfilled</code>/ <code>rejected</code></li>
<li>遍历上述的二维数组，找到 <code>succeed</code>/<code>fail</code> 函数并调用(<code>.call(undefined, result/reason)</code>)</li>
</ul>
</li>
<li><code>resolve</code>/<code>reject</code> 函数里面使用 <code>setTimeout</code> 做异步执行</li>
</ol>
<blockquote>
<p>另外，对应的<a href="https://github.com/strugglebak/promise-easy" target="_blank" rel="noopener">项目链接在这里</a></p>
</blockquote>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://promisesaplus.com/" target="_blank" rel="noopener">Promises/A+</a></p>
<p><a href="https://promisesaplus.com/differences-from-promises-a" target="_blank" rel="noopener">Differences from Promises/A</a></p>
]]></content>
      <categories>
        <category>手写源码</category>
      </categories>
      <tags>
        <tag>Promise</tag>
      </tags>
  </entry>
  <entry>
    <title>从Promise本质开始(三):TDD方式实现基于Promises/A+规范的复杂Promise</title>
    <url>/2020/05/28/%E4%BB%8EPromise%E6%9C%AC%E8%B4%A8%E5%BC%80%E5%A7%8B-%E4%B8%89-TDD%E6%96%B9%E5%BC%8F%E5%AE%9E%E7%8E%B0%E5%9F%BA%E4%BA%8EPromises-A-%E8%A7%84%E8%8C%83%E7%9A%84%E5%A4%8D%E6%9D%82Promise/</url>
    <content><![CDATA[<blockquote>
<p>前情提要：之前<a href="https://strugglebak.github.io/2020/03/09/%E4%BB%8EPromise%E6%9C%AC%E8%B4%A8%E5%BC%80%E5%A7%8B-%E4%B8%80-%E5%AE%9E%E7%8E%B0Promise%E5%89%8D%E8%A8%80/">为手动实现 Promise 搭建了环境</a>，然后还<a href="https://strugglebak.github.io/2020/03/20/%E4%BB%8EPromise%E6%9C%AC%E8%B4%A8%E5%BC%80%E5%A7%8B-%E4%BA%8C-TDD%E6%96%B9%E5%BC%8F%E5%AE%9E%E7%8E%B0%E5%9F%BA%E4%BA%8EPromises-A-%E8%A7%84%E8%8C%83%E7%9A%84%E7%AE%80%E6%98%93Promise/">基于 Promises/A+ 规范实现了一个简单的 Promise</a>。这次本文就接着上面的补充，实现一个复杂的 Promise。</p>
</blockquote>
<a id="more"></a>
<p><a href="https://github.com/strugglebak/promise-complex" target="_blank" rel="noopener">项目链接</a></p>
<h2 id="2-2-7"><a href="#2-2-7" class="headerlink" title="2.2.7"></a>2.2.7</h2><blockquote>
<p>2.2.7 then must return a promise</p>
</blockquote>
<blockquote>
<p>2.2.7 promise2 = promise1.then(onFulfilled, onRejected);</p>
</blockquote>
<p>这里就是 <code>Promise.then</code> 必须返回一个 Promise</p>
<h3 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">it(<span class="string">'2.2.7 then必须返回一个promise'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    resolve()</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">const</span> promise2 = promise.then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;)</span><br><span class="line">  <span class="comment">// 断言 promise2 是一个 Promise</span></span><br><span class="line">  assert(promise2 <span class="keyword">instanceof</span> <span class="built_in">Promise</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PromiseComplex</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  then(succeed?, fail?) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 将函数 push 进 callbacks 中</span></span><br><span class="line">    <span class="keyword">this</span>.callbacks.push(handle)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> PromiseComplex(<span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> PromiseComplex</span><br></pre></td></tr></table></figure>
<p>这里需要做的操作就是 <code>then</code> 函数中需要返回一个 <code>Promise</code> 即可，注意这里的 <code>Promise</code> 是自己的写的 <code>PromiseComplex</code></p>
<h2 id="2-2-7-1"><a href="#2-2-7-1" class="headerlink" title="2.2.7.1"></a>2.2.7.1</h2><blockquote>
<p>2.2.7.1 If either <code>onFulfilled</code> or <code>onRejected</code> returns a value <code>x</code>, run the Promise Resolution Procedure <code>[[Resolve]](promise2, x)</code></p>
</blockquote>
<p>Promises/A+ 规范的 <strong>2.2.7.1</strong> 里面这句话什么意思？就是说，<strong>如果 <code>onFulfilled</code> 或者 <code>onRejected</code> 函数返回了一个 x 的值， 那么就运行 Promise 的 Resolution 步骤，即运行 <code>[[Resolve]](promise2, x)</code></strong></p>
<p>云里雾里的，其实这句话的意思就是，在 <code>promise</code> 内部执行 <code>resolve</code> 或者 <code>reject</code> 函数时，会调用一个成功或者失败的函数，这个函数会返回一个值叫 <code>x</code>，然后再把这个值 <code>x</code> 跟一个新的 <code>promise</code> 传给一个叫做 <code>Resolve</code> 的函数。这个叫做 <code>Resolve</code> 的函数干了什么事情呢，它会将这个值 <code>x</code> 变成 <code>then</code> 里面传的回调的参数。这么说可能不太直观，接着看下面的测试用例应该会明白一些。</p>
<h3 id="测试用例-1"><a href="#测试用例-1" class="headerlink" title="测试用例"></a>测试用例</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">it(<span class="string">`2.2.7.1 如果 then(success, fail) 中的 success 返回一个值 x,</span></span><br><span class="line"><span class="string">  运行 Promise Resolution Procedure [[Resolve]](promise2, x)`</span>, done =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    resolve()</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// 注意这里的返回值 x 为 '123'，在 then 的回调传的参数 result 中可以获取到</span></span><br><span class="line">  promise.then(<span class="function"><span class="params">()</span> =&gt;</span> <span class="string">'123'</span>).then(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">    assert.equal(result, <span class="string">'123'</span>)</span><br><span class="line">    done()</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">it(<span class="string">`2.2.7.1.2 x 是一个 promise 实例`</span>, done =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    resolve()</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">const</span> fn = sinon.fake()</span><br><span class="line">  promise</span><br><span class="line">    .then(<span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> resolve()))</span><br><span class="line">    .then(fn)</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    assert.isTrue(fn.called)</span><br><span class="line">    done()</span><br><span class="line">  &#125;, <span class="number">10</span>) <span class="comment">// 这里有个小 bug, 如果将延时时间改为 0 则不通过</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">it(<span class="string">`2.2.7.1.2 x 是一个 promise 实例, 测试第一个 then 的失败回调`</span>, done =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    resolve()</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">const</span> fn = sinon.fake()</span><br><span class="line">  promise</span><br><span class="line">    .then(<span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> reject()))</span><br><span class="line">    .then(<span class="literal">null</span>, fn)</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    assert.isTrue(fn.called)</span><br><span class="line">    done()</span><br><span class="line">  &#125;, <span class="number">0</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">it(<span class="string">`2.2.7.1.2 fail 的返回值是一个 promise 实例`</span>, done =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    reject()</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">const</span> fn = sinon.fake()</span><br><span class="line">  promise</span><br><span class="line">    .then(<span class="literal">null</span>, () =&gt; <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> resolve()))</span><br><span class="line">    .then(fn)</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 这里主要看 promise.then 里的 Promise</span></span><br><span class="line">    <span class="comment">// 如果是成功则调用 succeed 函数</span></span><br><span class="line">    <span class="comment">// 如果是失败则调用 fail 函数</span></span><br><span class="line">    assert(fn.called)</span><br><span class="line">    done()</span><br><span class="line">  &#125;, <span class="number">0</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">it(<span class="string">`2.2.7.1.2 fail 的返回值是一个 promise 实例, 且失败了`</span>, done =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    reject()</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">const</span> fn = sinon.fake()</span><br><span class="line">  promise</span><br><span class="line">    .then(<span class="literal">null</span>, () =&gt; <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> reject()))</span><br><span class="line">    .then(<span class="literal">null</span>, fn)</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    assert(fn.called)</span><br><span class="line">    done()</span><br><span class="line">  &#125;, <span class="number">0</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="源码-1"><a href="#源码-1" class="headerlink" title="源码"></a>源码</h3><p>那么测试用例有了，源码应该怎么考虑呢？答案很简单，跟着规范来写。首先我们这里因为是用类写的，所以我们可以使用 <code>Promise.Resovle(x)</code> 的方式来表达 <strong>2.2.7.1</strong> 规范中出现的调用方式。这里可以将 <code>Resolve</code> 这个函数的名字改动下，我们叫它 <code>resolveWith</code> 吧，然后在源码中定义 <code>resolveWith</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PromiseComplex</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  resolveWith(x) &#123;</span><br><span class="line">    <span class="comment">//TODO</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为定义调用 <code>resolveWith</code> 的方式是通过 <code>Promise.resolveWith</code> 的方式调用的，而这个 <code>Promise</code> 根据规范是一个 <code>promise2</code>，也就意味着这是一个新的 <code>Promise</code>，还记得之前源码中的 <code>then</code> 中的 <code>return new PromiseComplex(() =&gt; {})</code> 么，现在我们这么做</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PromiseComplex</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  then(succeed?, fail?) &#123;</span><br><span class="line">    <span class="keyword">const</span> handle = []</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> succeed === <span class="string">'function'</span>) &#123;</span><br><span class="line">      handle[<span class="number">0</span>] = succeed</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> fail === <span class="string">'function'</span>) &#123;</span><br><span class="line">      handle[<span class="number">1</span>] = fail</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将下一个 promise 放入 handle[2] 中</span></span><br><span class="line">    handle[<span class="number">2</span>] = <span class="keyword">new</span> PromiseComplex(<span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;)</span><br><span class="line">    <span class="comment">// 将函数 push 进 callbacks 中</span></span><br><span class="line">    <span class="keyword">this</span>.callbacks.push(handle)</span><br><span class="line">    <span class="keyword">return</span> handle[<span class="number">2</span>]</span><br><span class="line">  &#125;</span><br><span class="line">  resolveWith(x) &#123;</span><br><span class="line">    <span class="comment">//TODO</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里将这个新的 <code>Promise</code> 存在 <code>handle</code> 这个数组的第三个元素中，然后再返回就好。接下来就需要对 <code>resolve</code> 以及 <code>reject</code> 中改写下逻辑了</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PromiseComplex</span> </span>&#123;</span><br><span class="line">  resolve(result) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 遍历 callbacks, 调用所有的 handle</span></span><br><span class="line">    <span class="keyword">this</span>.callbacks.forEach(<span class="function"><span class="params">handle</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> succeed = handle[<span class="number">0</span>]</span><br><span class="line">      <span class="comment">// 注意这里拿到了规范中定义的 promise2</span></span><br><span class="line">      <span class="keyword">const</span> nextPromise = handle[<span class="number">2</span>]</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> succeed === <span class="string">'function'</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> x = succeed.call(<span class="literal">undefined</span>, result)</span><br><span class="line">        <span class="comment">// 2.2.7.1 如果onFulfilled或onRejected返回一个值x,</span></span><br><span class="line">        <span class="comment">// 运行 Promise Resolution Procedure [[Resolve]](promise2, x)</span></span><br><span class="line">        <span class="comment">// promise2 表示第二个 promise</span></span><br><span class="line">        nextPromise.resolveWith(x)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  reject(reason) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 遍历 callbacks, 调用所有的 handle</span></span><br><span class="line">    <span class="keyword">this</span>.callbacks.forEach(<span class="function"><span class="params">handle</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> fail = handle[<span class="number">1</span>]</span><br><span class="line">      <span class="keyword">const</span> nextPromise = handle[<span class="number">2</span>]</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> fail === <span class="string">'function'</span>) &#123;</span><br><span class="line">        <span class="comment">// 这里 reject 的逻辑也是一样的</span></span><br><span class="line">        <span class="keyword">const</span> x = fail.call(<span class="literal">undefined</span>, reason)</span><br><span class="line">        nextPromise.resolveWith(x)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来就是 <strong>重头戏</strong> 了，因为要实现这一条规范，或者说通过上面的测试用例，还需要结合 <strong>规范 2.3.x</strong> 来看，因为 2.3.x 的规范是教你怎么写上面说到的 <code>resolveWith</code> 函数的</p>
<h3 id="resolveWith"><a href="#resolveWith" class="headerlink" title="resolveWith"></a>resolveWith</h3><p>为了实现 <code>resolveWith</code>,必须遵循以下步骤(规范)</p>
<h4 id="2-3-1"><a href="#2-3-1" class="headerlink" title="2.3.1"></a>2.3.1</h4><blockquote>
<p>If promise and x refer to the same object, reject promise with a TypeError as the reason</p>
</blockquote>
<p><strong>如果 promise 和值 x 引用的是同一个对象，则用 TypeError 作为 reason 拒绝（reject）promise</strong>，因为之前 <code>resolveWith</code> 函数是通过 <code>nextPromise.resolveWith(x)</code> 这种方式调用的，所以这里规范说的 <strong>promise</strong> 就是指这个代码中的 <code>nextPromise</code>，而在 <code>resolveWith</code> 函数中，<code>nextPromise</code> 就是 <code>this</code>。即为了实现 2.3.1 规范， <code>resolveWith</code> 函数应该这么写</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">resolveWith(x) &#123;</span><br><span class="line">  <span class="keyword">if</span> (x === <span class="keyword">this</span>) &#123;</span><br><span class="line">    <span class="comment">// 2.3.1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.reject(<span class="keyword">new</span> <span class="built_in">TypeError</span>())</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-3-2"><a href="#2-3-2" class="headerlink" title="2.3.2"></a>2.3.2</h4><p>如果 x 是一个 promise，采取它的状态</p>
<blockquote>
<p>2.3.2.1 If x is pending, promise must remain pending until x is fulfilled or rejected.<br>2.3.2.2 If/when x is fulfilled, fulfill promise with the same value.<br>2.3.2.3 If/when x is rejected, reject promise with the same reason.</p>
</blockquote>
<p>上面的规范，说白了就是，<strong>如果 x 是一个 promise，就采取 promise 的状态</strong>，所以就在 <code>resolveWith</code> 函数中加判断条件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">resolveWith(x) &#123;</span><br><span class="line">  <span class="keyword">if</span> (x === <span class="keyword">this</span>) &#123;</span><br><span class="line">    <span class="comment">// 2.3.1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.reject(<span class="keyword">new</span> <span class="built_in">TypeError</span>())</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (x <span class="keyword">instanceof</span> PromiseComplex) &#123;</span><br><span class="line">    <span class="comment">// 2.3.2</span></span><br><span class="line">    x.then(</span><br><span class="line">      result =&gt; <span class="keyword">this</span>.resolve(result),</span><br><span class="line">      reason =&gt; <span class="keyword">this</span>.reject(reason)</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-3-3"><a href="#2-3-3" class="headerlink" title="2.3.3"></a>2.3.3</h4><p>否则，如果 x 是一个对象或者函数</p>
<blockquote>
<p>2.3.3.1 Let <code>then</code> be <code>x.then</code>.</p>
</blockquote>
<p>这句话的意思就是代码，即声明一个 <code>then</code> 变量，将 <code>x.then</code> 赋值给这个变量</p>
<blockquote>
<p>2.3.3.2 If retrieving the property <code>x.then</code> results in a thrown exception <code>e</code>, reject <code>promise</code> with <code>e</code> as the reason.</p>
</blockquote>
<p>如果 <code>x.then</code> 抛出一个异常，则使用 <code>e</code> 作为 reason 并 reject 这个 promise</p>
<blockquote>
<p>2.3.3.3 If <code>then</code> is a function, call it with <code>x</code> as <code>this</code>, first argument <code>resolvePromise</code>, and second argument <code>rejectPromise</code>, where:</p>
</blockquote>
<p>如果 <code>then</code> 是一个方法，把 <code>x</code> 当作 <code>this</code> 来调用它， 第一个参数为 <code>resolvePromise</code>，第二个参数为 <code>rejectPromise</code></p>
<blockquote>
<p>2.3.3.3.1 If/when <code>resolvePromise</code> is called with a value <code>y</code>, run <code>[[Resolve]](promise, y)</code>.</p>
</blockquote>
<p>如果 <code>resolvePromise</code> 调用时传了参数 <code>y</code>，则执行 <code>resolveWith(y)</code></p>
<blockquote>
<p>2.3.3.3.2 If/when <code>rejectPromise</code> is called with a reason <code>r</code>, reject <code>promise</code> with <code>r</code></p>
</blockquote>
<p>如果 <code>rejectPromise</code> 调用时传了参数 <code>r</code>，则执行 <code>resolveWith(r)</code>(这里也可以直接调用 <code>this.reject(r)</code> 函数，为了程序的统一性，这边改动成了 <code>resolveWith(r)</code>)</p>
<blockquote>
<p>2.3.3.3.3 If both <code>resolvePromise</code> and <code>rejectPromise</code> are called, or multiple calls to the same argument are made, the first call takes precedence, and any further calls are ignored</p>
</blockquote>
<p>如果 <code>resolvePromise</code> 和 <code>rejectPromise</code> 都被调用了，或者对同一个参数进行多次调用，则以第一次调用为优先级最高，其他未来的调用会被忽略掉。这里解释下这个情况，就是比方说如下的代码，可以说明 2.3.3.3.3 中所说的例子</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> PromiseComplex(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> resolve(&#123;</span><br><span class="line">  then: <span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">'123'</span>)</span><br><span class="line">    reject(<span class="string">'456'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;))</span><br><span class="line"></span><br><span class="line">promise.then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(res)) <span class="comment">// '123'</span></span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> PromiseComplex(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> resolve(&#123;</span><br><span class="line">  then: <span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">'123'</span>)</span><br><span class="line">    resolve(<span class="string">'456'</span>)</span><br><span class="line">    resolve(<span class="string">'789'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;))</span><br><span class="line"></span><br><span class="line">promise.then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(res)) <span class="comment">// '123'</span></span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> PromiseComplex(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  PromiseComplex.resolve(<span class="string">'123'</span>).then(<span class="function"><span class="params">result</span> =&gt;</span> resolve(result))</span><br><span class="line">  PromiseComplex.resolve(<span class="string">'456'</span>).then(<span class="function"><span class="params">result</span> =&gt;</span> resolve(result))</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">promise.then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(res)) <span class="comment">// '123'</span></span><br></pre></td></tr></table></figure>
<p>上面的代码，多次进行了 <code>resolve</code> 的操作，但是只取第一次的，所以最终打印出来的就是 <code>&#39;123&#39;</code>。由于该功能已经在<a href="https://strugglebak.github.io/2020/03/20/%E4%BB%8EPromise%E6%9C%AC%E8%B4%A8%E5%BC%80%E5%A7%8B-%E4%BA%8C-TDD%E6%96%B9%E5%BC%8F%E5%AE%9E%E7%8E%B0%E5%9F%BA%E4%BA%8EPromises-A-%E8%A7%84%E8%8C%83%E7%9A%84%E7%AE%80%E6%98%93Promise/">上一篇</a>博客文章中解决，所以这里的规则可以自动忽略掉</p>
<blockquote>
<p>2.3.3.3.4 if calling <code>then</code> throws an exception <code>e</code><br>2.3.3.3.4.1 If <code>resolvePromise</code> or <code>rejectPromise</code> have been called, ignore it.<br>2.3.3.3.4.2 Otherwise, reject <code>promise</code> with <code>e</code> as the reason.</p>
</blockquote>
<p>如果调用 <code>then</code> 的时候抛出异常了</p>
<ul>
<li>如果 <code>resolvePromise</code> 和 <code>rejectPromise</code> 的都被调用了，就忽略它</li>
<li>否则，reject 掉这个 <code>promise</code></li>
</ul>
<blockquote>
<p>2.3.3.4 If <code>then</code> is not a function, fulfill <code>promise</code> with <code>x</code>.</p>
</blockquote>
<p>如果 <code>then</code> 不是一个函数，则 resolve 掉这个 <code>promise</code></p>
<p>根据以上的描述，<code>resolveWith</code> 中的代码可以增加为</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">resolveWith(x) &#123;</span><br><span class="line">  <span class="keyword">if</span> (x === <span class="keyword">this</span>) &#123;</span><br><span class="line">    <span class="comment">// 2.3.1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.reject(<span class="keyword">new</span> <span class="built_in">TypeError</span>())</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (x <span class="keyword">instanceof</span> PromiseComplex) &#123;</span><br><span class="line">    <span class="comment">// 2.3.2</span></span><br><span class="line">    x.then(</span><br><span class="line">      result =&gt; <span class="keyword">this</span>.resolve(result),</span><br><span class="line">      reason =&gt; <span class="keyword">this</span>.reject(reason)</span><br><span class="line">    )</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (x <span class="keyword">instanceof</span> <span class="built_in">Object</span>) &#123;</span><br><span class="line">    <span class="comment">// 2.3.3 另外，如果 x 是个对象或者方法</span></span><br><span class="line">    <span class="keyword">let</span> then</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 2.3.3.1</span></span><br><span class="line">      then = x.then</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      <span class="comment">// 2.3.3.2 如果取回的 x.then 属性的结果为一个异常 e,用 e 作为原因 reject promise</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.reject(e)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2.3.3.3 如果 then 是一个方法，把 x 当作 this 来调用它， 第一个参数为 resolvePromise，第二个参数为 rejectPromise</span></span><br><span class="line">    <span class="keyword">if</span> (then <span class="keyword">instanceof</span> <span class="built_in">Function</span>) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 2.3.3.3.1/2.3.3.3.2/2.3.3.3.3</span></span><br><span class="line">        then.call(x, y =&gt; <span class="keyword">this</span>.resolveWith(y), r =&gt; <span class="keyword">this</span>.resolveWith(r))</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="comment">// 2.3.3.3.4</span></span><br><span class="line">        <span class="keyword">this</span>.reject(e)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 2.3.3.4 如果 then 不是一个函数，用 x 完成 (fulfill) promise</span></span><br><span class="line">      <span class="keyword">this</span>.resolve(x)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-2-7-2"><a href="#2-2-7-2" class="headerlink" title="2.2.7.2"></a>2.2.7.2</h2><blockquote>
<p>2.2.7.2 If either <code>onFulfilled</code> or <code>onRejected</code> throws an exception <code>e</code>, <code>promise2</code> must be rejected with <code>e</code> as the reason.</p>
</blockquote>
<p>如果在调用 <code>resolve</code> 或者 <code>reject</code> 时抛出了异常，则 <code>nextPromise</code> 必须调用 <code>reject</code>，并将这个 <code>e</code> 作为参数传入</p>
<h3 id="测试用例-2"><a href="#测试用例-2" class="headerlink" title="测试用例"></a>测试用例</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">it(<span class="string">'2.2.7.2 如果 success 或 fail 抛出一个异常 e, promise2 必须被拒绝'</span>, done =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    resolve()</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">const</span> error = <span class="keyword">new</span> <span class="built_in">Error</span>()</span><br><span class="line">  <span class="keyword">const</span> fn = sinon.fake()</span><br><span class="line">  promise</span><br><span class="line">    .then(<span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="keyword">throw</span> error &#125;)</span><br><span class="line">    .then(<span class="literal">null</span>, fn)</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    assert(fn.called)</span><br><span class="line">    assert(fn.calledWith(error))</span><br><span class="line">    done()</span><br><span class="line">  &#125;, <span class="number">0</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="源码-2"><a href="#源码-2" class="headerlink" title="源码"></a>源码</h3><p>由规范的定义可知，这里就需要在 <code>resolve</code> 以及 <code>reject</code> 函数中，在调用成功或者失败函数时，需要加个 <code>try catch</code>，因为在调用这些函数的时候，有可能会失败</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PromiseComplex</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  resolve(result) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> succeed === <span class="string">'function'</span>) &#123;</span><br><span class="line">      <span class="comment">// 这里调用的时候有可能报错</span></span><br><span class="line">      <span class="keyword">let</span> x</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        x = succeed.call(<span class="literal">undefined</span>, result)</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="comment">// 2.2.7.2 如果onFulfilled或onRejected抛出一个异常e</span></span><br><span class="line">        <span class="comment">// promise2 必须被拒绝（rejected）并把e当作原因</span></span><br><span class="line">        <span class="keyword">return</span> nextPromise.reject(e)</span><br><span class="line">      &#125;</span><br><span class="line">      nextPromise.resolveWith(x)</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">  &#125;,</span><br><span class="line">  reject(reason) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> fail === <span class="string">'function'</span>) &#123;</span><br><span class="line">      <span class="keyword">let</span> x</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        x = fail.call(<span class="literal">undefined</span>, reason)</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="keyword">return</span> nextPromise.reject(e)</span><br><span class="line">      &#125;</span><br><span class="line">      nextPromise.resolveWith(x)</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="API-实现"><a href="#API-实现" class="headerlink" title="API 实现"></a>API 实现</h2><p>以上，基本就是实现了一个复杂的符合 Promises/A+ 规范的 Promise 了，接下来就是实现该 Promise 的其他 API 的工作了</p>
<h3 id="resolve-reject"><a href="#resolve-reject" class="headerlink" title="resolve/reject"></a>resolve/reject</h3><p>真正的 Promise 中是能直接访问到这个方法的，而我们这里实现的 <code>PromiseComplex</code> 是一个类，如果要能访问到这个方法，则必须在方法上加上 <code>static</code> 属性</p>
<h4 id="测试用例-3"><a href="#测试用例-3" class="headerlink" title="测试用例"></a>测试用例</h4><p>这里另起一个 <code>describe</code>，专门用来测试该 <code>Promise</code> 的 API 用。之后的各种 API 相关的测试用例都在这个里面写</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">describe(<span class="string">'Promise API'</span>, () =&gt; &#123;</span><br><span class="line">  it(<span class="string">'测试 resolve'</span>, done =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> promise = <span class="built_in">Promise</span>.resolve2(<span class="number">123</span>)</span><br><span class="line">    assert(promise <span class="keyword">instanceof</span> <span class="built_in">Promise</span>)</span><br><span class="line">    promise.then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">      assert(result === <span class="number">123</span>)</span><br><span class="line">      done()</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">const</span> promise2 = <span class="built_in">Promise</span>.resolve2(<span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;))</span><br><span class="line">    assert(promise2 <span class="keyword">instanceof</span> <span class="built_in">Promise</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  it(<span class="string">'测试 resolve thenable'</span>, done =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> promise2 = <span class="built_in">Promise</span>.resolve2(&#123;</span><br><span class="line">      then(resolve, reject) &#123; resolve(<span class="string">'233'</span>) &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    assert(promise2 <span class="keyword">instanceof</span> <span class="built_in">Promise</span>)</span><br><span class="line">    promise2.then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">      assert(result === <span class="string">'233'</span>)</span><br><span class="line">      done()</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">  it(<span class="string">'测试 reject'</span>, done =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> promise = <span class="built_in">Promise</span>.reject2(<span class="number">123</span>)</span><br><span class="line">    assert(promise <span class="keyword">instanceof</span> <span class="built_in">Promise</span>)</span><br><span class="line">    promise.then(<span class="literal">null</span>, result =&gt; &#123;</span><br><span class="line">      assert(result === <span class="number">123</span>)</span><br><span class="line">      done()</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// reject thenable</span></span><br><span class="line">    <span class="keyword">const</span> promise2 = <span class="built_in">Promise</span>.reject2(&#123;</span><br><span class="line">      then(resolve, reject) &#123; reject(<span class="string">'233'</span>) &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    assert(promise2 <span class="keyword">instanceof</span> <span class="built_in">Promise</span>)</span><br><span class="line">    promise2.then(<span class="literal">null</span>, result =&gt; &#123;</span><br><span class="line">      assert(result === <span class="string">'233'</span>)</span><br><span class="line">      done()</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="源码-3"><a href="#源码-3" class="headerlink" title="源码"></a>源码</h4><blockquote>
<p>简便起见，这里直接使用 <code>resolve2</code> 和 <code>reject2</code> 来命名这两个方法</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PromiseComplex</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">static</span> resolve2(result) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> PromiseComplex(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (result &amp;&amp; result.then &amp;&amp; <span class="keyword">typeof</span> result.then === <span class="string">'function'</span>) &#123;</span><br><span class="line">        result.then(resolve, reject)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        resolve(result)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> reject2(reason) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> PromiseComplex(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      reject(reason)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，基本上就是调用了类里面的逻辑，new 一个 Promise，然后调用里面的 <code>resolve</code> 或者 <code>reject</code> 方法。但是对于 <code>resolve</code> 来说，如果 result 中有 then，并且这个 then 是一个函数，则需要继续调用这个 <code>result.then</code></p>
<h3 id="catch"><a href="#catch" class="headerlink" title="catch"></a>catch</h3><p>用来捕获 Promise reject 的错误用的，这里实现的逻辑也很简单</p>
<h4 id="测试用例-4"><a href="#测试用例-4" class="headerlink" title="测试用例"></a>测试用例</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">it(<span class="string">'测试 catch'</span>, done =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    resolve()</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">const</span> fn = sinon.fake()</span><br><span class="line">  promise</span><br><span class="line">    .then(<span class="function"><span class="params">result</span> =&gt;</span> &#123; <span class="keyword">throw</span> <span class="string">'233'</span> &#125;)</span><br><span class="line">    .catch(<span class="function">(<span class="params">e</span>) =&gt;</span> &#123; assert(e === <span class="string">'233'</span>) &#125;)</span><br><span class="line">    .then(fn)</span><br><span class="line"></span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    assert(fn.called)</span><br><span class="line">    done()</span><br><span class="line">  &#125;, <span class="number">0</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="源码-4"><a href="#源码-4" class="headerlink" title="源码"></a>源码</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PromiseComplex</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">catch</span>(reject) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.then(<span class="literal">null</span>, reject)</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意这里 <code>catch</code> 的参数 <code>reject</code> 是一个失败函数</p>
<h3 id="finally"><a href="#finally" class="headerlink" title="finally"></a>finally</h3><p>测试 <code>finally</code> 这个 API 的关键就是看 <code>finally</code> 中传的函数有没有得到执行，所以测试用例可以写成下面这样</p>
<h4 id="测试用例-5"><a href="#测试用例-5" class="headerlink" title="测试用例"></a>测试用例</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">it(<span class="string">'测试 finally'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    resolve()</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">const</span> callbacks = [sinon.fake(), sinon.fake(), sinon.fake()]</span><br><span class="line">  promise</span><br><span class="line">    .then(<span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="keyword">throw</span> <span class="string">'error'</span> &#125;)</span><br><span class="line">    .catch(callbacks[<span class="number">0</span>])</span><br><span class="line">    .finally(callbacks[<span class="number">1</span>])</span><br><span class="line">    .then(callbacks[<span class="number">2</span>])</span><br><span class="line"></span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    assert(callbacks[<span class="number">0</span>].called)</span><br><span class="line">    assert(callbacks[<span class="number">1</span>].called) <span class="comment">// 测试被调用</span></span><br><span class="line">    assert(callbacks[<span class="number">2</span>].called)</span><br><span class="line">    assert(callbacks[<span class="number">2</span>].calledAfter(callbacks[<span class="number">1</span>]))</span><br><span class="line">  &#125;, <span class="number">0</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="源码-5"><a href="#源码-5" class="headerlink" title="源码"></a>源码</h4><p>因为无论成功或者失败，都会走到 <code>finally</code> 中，所以 <code>finally</code> 都可以继续 <code>then</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PromiseComplex</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">finally</span>(callback) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.then(</span><br><span class="line">      (result) =&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> PromiseComplex.resolve2(callback()).then(<span class="function"><span class="params">()</span> =&gt;</span> result)</span><br><span class="line">      &#125;,</span><br><span class="line">      (error) =&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> PromiseComplex.resolve2(callback()).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;<span class="keyword">throw</span> error&#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里有个疑问，为何 <code>finally</code> 不能做如下的实现</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">finally</span>(callback) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.then(</span><br><span class="line">    callback,</span><br><span class="line">    callback</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>是因为假如我们想要再其调用失败函数的时候报错，比如需要做一个 <code>throw an error</code> 之类的操作，这个时候你只能通过 <code>Promise.resolve</code> 之类的方式去实现它。而为了能够跟失败函数被调用时代码逻辑一致，所以成功函数也写成跟失败函数类似的逻辑。</p>
<h3 id="all"><a href="#all" class="headerlink" title="all"></a>all</h3><p>all API 的逻辑看起来简单，就是遍历执行，但是内部是做了一些情况的判断的，不过测试用例还是很简单的，如下</p>
<h4 id="测试用例-6"><a href="#测试用例-6" class="headerlink" title="测试用例"></a>测试用例</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">it(<span class="string">'测试 all, 等待所有都完成(或第一个失败) '</span>, done =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> promise1 = <span class="built_in">Promise</span>.resolve2(<span class="number">3</span>)</span><br><span class="line">  <span class="keyword">const</span> promise2 = <span class="number">1337</span></span><br><span class="line">  <span class="keyword">const</span> promise3 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">'foo'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">let</span> ret</span><br><span class="line">  <span class="built_in">Promise</span>.all([promise1, promise2, promise3]).then(<span class="function"><span class="params">results</span> =&gt;</span> &#123;</span><br><span class="line">    ret = results</span><br><span class="line">  &#125;)</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    assert(ret[<span class="number">0</span>] === <span class="number">3</span>)</span><br><span class="line">    assert(ret[<span class="number">1</span>] === <span class="number">1337</span>)</span><br><span class="line">    assert(ret[<span class="number">2</span>] === <span class="string">'foo'</span>)</span><br><span class="line">    done()</span><br><span class="line">  &#125;, <span class="number">10</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="源码-6"><a href="#源码-6" class="headerlink" title="源码"></a>源码</h4><p>先说下实现 all API 需要注意的几个点</p>
<ul>
<li>如果传入的参数是一个空的可迭代对象，那么此 promise 对象回调完成(resolve), 只有此情况是同步执行的，其它都是异步返回</li>
<li>promises 中所有的 promise 都“完成”时，或参数中(result)不包含 promise 时回调完成。</li>
<li>如果传入的参数(promises[i])不包含任何 promise，则返回一个异步完成</li>
<li>如果参数中有一个 promise 失败，那么 Promise.all 返回的 promise 对象失败</li>
<li>在任何情况下，Promise.all 返回的 promise 的完成状态的结果都是一个数组</li>
</ul>
<p>所以实现的逻辑如下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PromiseComplex</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">static</span> all(promises) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> PromiseComplex(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> index = <span class="number">0</span></span><br><span class="line">      <span class="comment">// 5. 在任何情况下，Promise.all 返回的 promise 的完成状态的结果都是一个数组</span></span><br><span class="line">      <span class="keyword">let</span> resultArray = []</span><br><span class="line">      <span class="comment">// 1. 如果传入的参数是一个空的可迭代对象，</span></span><br><span class="line">      <span class="comment">// 那么此promise对象回调完成(resolve),</span></span><br><span class="line">      <span class="comment">// 只有此情况，是同步执行的，其它都是异步返回</span></span><br><span class="line">      <span class="keyword">if</span> (promises &amp;&amp; promises.length === <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> resolve(resultArray)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">const</span> processResult = <span class="function">(<span class="params">result, i</span>) =&gt;</span> &#123;</span><br><span class="line">        resultArray[i] = result</span><br><span class="line">        <span class="comment">// 2. promises 中所有的promise都“完成”时</span></span><br><span class="line">        <span class="comment">// 或参数中(result)不包含 promise 时回调完成。</span></span><br><span class="line">        <span class="keyword">if</span> (++index === promises.length) resolve(resultArray)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; promises.length; i++) &#123;</span><br><span class="line">        <span class="comment">// 3. 如果传入的参数(promises[i])不包含任何 promise，则返回一个异步完成</span></span><br><span class="line">        PromiseComplex.resolve2(promises[i])</span><br><span class="line">          .then(</span><br><span class="line">            result =&gt; processResult(result, i),</span><br><span class="line">            <span class="comment">// 4. 如果参数中有一个promise失败，那么Promise.all返回的promise对象失败</span></span><br><span class="line">            reason =&gt; reject(reason)</span><br><span class="line">          )</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="allSettled"><a href="#allSettled" class="headerlink" title="allSettled"></a>allSettled</h3><p>allSettled API 在 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/allSettled" target="_blank" rel="noopener">MDN</a> 的解释如下</p>
<blockquote>
<p>The <code>Promise.allSettled()</code> method returns a promise that resolves after all of the given promises have either fulfilled or rejected, with an array of objects that each describes the outcome of each promise.</p>
</blockquote>
<p>即</p>
<blockquote>
<p><code>Promise.allSettled</code> 方法会返回一个 promise，then 中传的函数的参数就是一个对象数组，这个对象数组描述了每个 promise 的输出情况，这个 promise 能够 resolve 所有给到的 promises，无论这些 promises 是被 fulfilled 了还是被 rejected</p>
</blockquote>
<p>比如如下的代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise1 = <span class="built_in">Promise</span>.resolve(<span class="number">3</span>);</span><br><span class="line"><span class="keyword">const</span> promise2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> setTimeout(reject, <span class="number">100</span>, <span class="string">'foo'</span>));</span><br><span class="line"><span class="keyword">const</span> promises = [promise1, promise2];</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.allSettled(promises).</span><br><span class="line">  then(<span class="function">(<span class="params">results</span>) =&gt;</span> results.forEach(<span class="function">(<span class="params">result</span>) =&gt;</span> <span class="built_in">console</span>.log(result)));</span><br></pre></td></tr></table></figure>
<p>输出就是如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; Object &#123; status: <span class="string">"fulfilled"</span>, value: 3 &#125;</span><br><span class="line">&gt; Object &#123; status: <span class="string">"rejected"</span>, reason: <span class="string">"foo"</span> &#125;</span><br></pre></td></tr></table></figure>
<h4 id="测试用例-7"><a href="#测试用例-7" class="headerlink" title="测试用例"></a>测试用例</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">it(<span class="string">'测试 allSettled'</span>, done =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> promise1 = <span class="built_in">Promise</span>.resolve2(<span class="number">3</span>)</span><br><span class="line">  <span class="keyword">const</span> promise2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> reject(<span class="string">'foo'</span>))</span><br><span class="line">  <span class="keyword">const</span> promises = [promise1, promise2]</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> ret</span><br><span class="line">  <span class="built_in">Promise</span>.allSettled(promises).then(<span class="function"><span class="params">results</span> =&gt;</span> &#123;</span><br><span class="line">    ret = results</span><br><span class="line">  &#125;)</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    assert(ret[<span class="number">0</span>].state === <span class="string">'fulfilled'</span> &amp;&amp; ret[<span class="number">0</span>].result === <span class="number">3</span>)</span><br><span class="line">    assert(ret[<span class="number">1</span>].state === <span class="string">'rejected'</span> &amp;&amp; ret[<span class="number">1</span>].reason === <span class="string">'foo'</span>)</span><br><span class="line">    done()</span><br><span class="line">  &#125;, <span class="number">10</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="源码-7"><a href="#源码-7" class="headerlink" title="源码"></a>源码</h4><p>源码的逻辑就是在 <code>all</code> API 的基础上做修改，注意这里返回的状态</p>
<ul>
<li>如果成功，那么每个 promise 产出的结果应该是 <code>{ state: &#39;fulfilled&#39;, result: 123 }</code></li>
<li>如果失败，那么每个 promise 产出的结果应该是 <code>{ state: &#39;rejected&#39;, reason: 456 }</code></li>
</ul>
<p>所以应该这么写</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PromiseComplex</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">static</span> allSettled(promises) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> PromiseComplex(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> index = <span class="number">0</span></span><br><span class="line">      <span class="keyword">let</span> resultArray = []</span><br><span class="line">      <span class="keyword">if</span> (promises &amp;&amp; promises.length === <span class="number">0</span>) <span class="keyword">return</span> resolve(resultArray)</span><br><span class="line">      <span class="comment">// 这里的逻辑需要对 state 做个判断</span></span><br><span class="line">      <span class="keyword">const</span> processResult = <span class="function">(<span class="params">result, i, state</span>) =&gt;</span> &#123;</span><br><span class="line">        resultArray[i] = status === <span class="string">'fulfilled'</span></span><br><span class="line">          ? &#123;status, result&#125;</span><br><span class="line">          : &#123;status, <span class="attr">reason</span>: result&#125;</span><br><span class="line">        <span class="keyword">if</span> (++index === promises.length) resolve(resultArray)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; promises.length; i++) &#123;</span><br><span class="line">        PromiseComplex.resolve2(promises[i])</span><br><span class="line">          .then(</span><br><span class="line">            result =&gt; processResult(result, i, <span class="string">'fulfilled'</span>),</span><br><span class="line">            <span class="comment">// 无论成功或者失败，都调用 resolve</span></span><br><span class="line">            reason =&gt; processResult(reason, i, <span class="string">'rejected'</span>)</span><br><span class="line">          )</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>但是这里其实还有一种更加优雅的写法，直接调用 <code>Promise.all</code> 的形式来实现</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> allSettled(promises) &#123;</span><br><span class="line">  <span class="keyword">const</span> x = <span class="function">(<span class="params">promises</span>) =&gt;</span> promises.map(</span><br><span class="line">    promise =&gt; promise.then(</span><br><span class="line">      value =&gt; (&#123;<span class="attr">status</span>: <span class="string">'fulfilled'</span>, value&#125;),</span><br><span class="line">      reason =&gt; (&#123;<span class="attr">status</span>: <span class="string">'rejected'</span>, reason&#125;)</span><br><span class="line">    )</span><br><span class="line">  )</span><br><span class="line">  <span class="keyword">return</span> PromiseComplex.all(x(promises))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里将 promises 做了一个 map，然后它返回的是一个数组 <code>x(promises)</code>，代码就变得更加精简和易读了。你可能会迷惑，这里为啥要用到一个 <code>promise.then</code> 对其做一个值的构建呢？因为我们这里，<code>then</code> 是会返回一个 promise 的，通过使用 <code>.then()</code> 这种方式来修改 promise 中的传值参数才是一种符合 promise 的方式。</p>
<h3 id="race"><a href="#race" class="headerlink" title="race"></a>race</h3><p>race 在 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/race" target="_blank" rel="noopener">MDN</a> 上的解释如下</p>
<blockquote>
<p>The <code>Promise.race()</code> method returns a promise that fulfills or rejects as soon as one of the promises in an iterable fulfills or rejects, with the value or reason from that promise.</p>
</blockquote>
<p>即</p>
<blockquote>
<p><code>Promise.race()</code> 方法返回一个 promise，一旦其中一个 promise 处于一个可迭代的 fulfills 或者 rejects 中时，那这个对应的 promise 就会 fulfill 一个 value 出来或者 reject 一个 reason 出来</p>
</blockquote>
<p>简单来说就是 <strong>竞争</strong>，哪个先执行 resolve 或者 reject，哪个就先导出对应的结果</p>
<h4 id="测试用例-8"><a href="#测试用例-8" class="headerlink" title="测试用例"></a>测试用例</h4><p>上面可能说的不是很清楚，先看下测试用例吧</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">it(<span class="string">'测试 race'</span>, done =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> promise1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(</span><br><span class="line">    (resolve, reject) =&gt; setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> resolve(<span class="number">200</span>), <span class="number">200</span>)</span><br><span class="line">  )</span><br><span class="line">  <span class="keyword">const</span> promise2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(</span><br><span class="line">    (resolve, reject) =&gt; setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> resolve(<span class="number">10</span>), <span class="number">10</span>)</span><br><span class="line">  )</span><br><span class="line">  <span class="keyword">const</span> promise3 = <span class="keyword">new</span> <span class="built_in">Promise</span>(</span><br><span class="line">    (resolve, reject) =&gt; setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> reject(<span class="number">100</span>), <span class="number">100</span>)</span><br><span class="line">  )</span><br><span class="line">  <span class="keyword">let</span> result, reason</span><br><span class="line">  <span class="built_in">Promise</span>.race([promise1, promise2, promise3])</span><br><span class="line">    .then(</span><br><span class="line">      data =&gt; result = data,</span><br><span class="line">      error =&gt; reason = error</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    assert(result === <span class="number">10</span>)</span><br><span class="line">    done()</span><br><span class="line">  &#125;, <span class="number">500</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>以上的测试用例，由于 promise2 持续的时间最短，那么按照道理来说，promise2 的结果就是最终的结果</p>
<h4 id="源码-8"><a href="#源码-8" class="headerlink" title="源码"></a>源码</h4><p>race API 源码实现思路也是通过遍历来实现，但是这里是通过调用 <code>Promise.resolve(xxx).then</code> 来实现的。只要其中有一个 <code>resolve</code> 或者 <code>reject</code> 了，那么就<strong>自动</strong>走 <code>then</code> 的逻辑，其他的就忽略掉。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> race(promises) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> PromiseComplex(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (promises &amp;&amp; promises.length === <span class="number">0</span>) <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; promises.length; i++) &#123;</span><br><span class="line">      PromiseComplex.resolve2(promises[i])</span><br><span class="line">      .then(</span><br><span class="line">        <span class="comment">// 谁(promises[i]) 先完成谁先 resolve</span></span><br><span class="line">        result =&gt; resolve(result),</span><br><span class="line">        reason =&gt; reject(reason)</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你可能会疑惑了，为啥这里可以自动走 <code>then</code> 的逻辑呢？这又牵扯到 <strong>微任务宏任务</strong> 的知识了。先说结论，<strong>在 eventLoop 中，一旦执行一个阶段里的一个宏任务(setTimeout, setInterval 和 setImmediate)就立刻执行微任务队列(Node 11 及以上或者浏览器环境中)</strong>，而我们代码中的 <code>resolve</code> 方法(不是 <code>resolve2</code> 方法) 是放在微任务队列中的(下文优化代码部分会说到)。所以它会先执行 <code>PromiseComplex.resolve2(promises[i])</code>(宏任务)，在下一个宏任务(<code>promise2</code> 中的 <code>resolve</code>)到来之前，执行微任务(<code>resolve</code> 中的代码逻辑)，发现状态没有变(<code>state === &#39;pending&#39;</code>)就往下执行，将状态改变，并且将 <code>nextTick</code> 中的代码入<strong>微任务队列</strong>。然后时间到，执行宏任务(<code>promise2</code> 中的 <code>resolve</code>)，然后执行<strong>微任务</strong>(<code>resolve</code> 中的代码逻辑)，发现状态变了(<code>state !== &#39;pending&#39;</code>)，后面的逻辑就不执行了。这个时候因为你已经将 <code>then</code> 中的 <code>callback</code> 当作参数传给了 <code>Promise</code> 内部的变量，所以就可以拿着这些 <code>callbacks</code> 去执行。这样看起来就是 <code>then</code> 中的逻辑被 <em>自动执行</em> 了</p>
<p>你可能又会疑惑了，为啥这里可以忽略掉其他的 <code>promise</code> 呢？还记得规范 2.3.3.3.3 中说的是啥么(手动滑稽)，以及结合规范 2.2.2 和 2.2.3 来看的话，关键的地方在于，<strong>这个 <code>promise</code> 内部的 <code>state</code> 改变了</strong>，一旦这个 <code>state</code> 被改变了，那么无论后面怎么 <code>resolve</code> 或者 <code>reject</code>，那么都会在判断 <code>state</code> 状态时被 return 掉</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">resolve (result) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.state !== <span class="string">'pending'</span>) <span class="keyword">return</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">reject (reason) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.state !== <span class="string">'pending'</span>) <span class="keyword">return</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="重构-resolve-reject-API"><a href="#重构-resolve-reject-API" class="headerlink" title="重构 resolve/reject API"></a>重构 resolve/reject API</h2><p>在之前的这两个 api 的逻辑中，关于异步的部分只是用了 <code>setTimeout</code> 来解决的，但是这里就会存在一个 bug，在测试用例中，要断言 assert 测试代码的结果，也需要用到 <code>setTimeout</code>，但是这里需要延时一小段时间，不然会和源码中的 <code>setTimeout</code> 有冲突(即如果测试用例中 <code>setTimeout</code> 传的时间是 0 ms，那么有可能这个会优先源码中的 <code>setTimeout</code> 执行)，这是一个 bug 隐患。那么解决方式是什么呢？很简单，将 <code>setTimeout</code> 修改成 <code>process.nextTick</code>(微任务，优先级更高) 即可</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">resolve(result) &#123;</span><br><span class="line">  process.nextTick(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">reject(reason) &#123;</span><br><span class="line">  process.nextTick(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是这样又会带来新的问题，如果是浏览器环境就不支持 <code>process.nextTick</code>，所以这里就需要想办法做一个兼容的处理。怎么兼容呢，这里可以参考 <a href="https://juejin.im/post/5d519abce51d453b753a1a9d" target="_blank" rel="noopener">Vue 源码中关于 <code>nextTick</code> 是怎么处理的</a>。这里方便起见就直接上代码了</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 兼容 process.nextTick 和 setImmediate 方案</span></span><br><span class="line"><span class="comment">// 其实就是 vue 里面的 nextTick 方案</span></span><br><span class="line"><span class="comment">// 主要是用 mutationObserver 实现的，这个只要改动下 dom 去更新一个函数</span></span><br><span class="line"><span class="comment">// 而在这个函数里面去做操作即可，这个是比 setTimeout 要快的</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">nextTick</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 兼容处理</span></span><br><span class="line">  <span class="keyword">if</span> (process !== <span class="literal">undefined</span> &amp;&amp; <span class="keyword">typeof</span> process.nextTick === <span class="string">'function'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> process.nextTick(fn)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> counter = <span class="number">1</span></span><br><span class="line">  <span class="keyword">var</span> observer = <span class="keyword">new</span> MutationObserver(fn)</span><br><span class="line">  <span class="keyword">var</span> textNode = <span class="built_in">document</span>.createTextNode(<span class="built_in">String</span>(counter))</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 监听节点变化</span></span><br><span class="line">  observer.observe(textNode, &#123; <span class="attr">characterData</span>: <span class="literal">true</span> &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 修改节点</span></span><br><span class="line">  counter = (counter + <span class="number">1</span>) % <span class="number">2</span></span><br><span class="line">  textNode.data = <span class="built_in">String</span>(counter)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里是通过 <a href="https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver" target="_blank" rel="noopener">MutationObserver</a> 这个 API，通过创建一个 textNode 的节点，然后使用 <code>observer.observe</code> 去 <strong>监听这个节点的变化</strong>，节点一旦变化就会去执行传入的 <code>fn</code> 回调，这样就可以做一个兼容的处理了。</p>
<p>最后只需要将 <code>resolve/reject</code> API 中的 <code>process.nextTick</code> 改写成 <code>nextTick</code> 函数即可</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上就是实现一个复杂的 <code>Promise</code> 的完整步骤了，<a href="https://github.com/strugglebak/promise-complex" target="_blank" rel="noopener">仓库链接可以点击这里</a>，另外我还在这个项目中对部分代码进行了优化，但总体上的逻辑和本文都是一样的，若有看到源码不一样的同学还请不要惊讶</p>
<p>本质上来说，这里主要就规范中的 2.2.7 以及 2.3 的部分进行了比较细的描述，如果有问题欢迎各位大佬在项目中提 issue</p>
]]></content>
      <categories>
        <category>手写源码</category>
      </categories>
      <tags>
        <tag>Promise</tag>
      </tags>
  </entry>
  <entry>
    <title>从Webpack本质开始(三):手写plugin</title>
    <url>/2020/03/09/%E4%BB%8EWebpack%E6%9C%AC%E8%B4%A8%E5%BC%80%E5%A7%8B-%E4%B8%89-%E6%89%8B%E5%86%99plugin/</url>
    <content><![CDATA[<blockquote>
<p>这个是探究 Webpack 本质的系列文章，会详细讲解如何手写一些源码如 Webpack, loader, plugin 等等，本文主要讲解的是如何手写 plugin</p>
</blockquote>
<a id="more"></a>
<h2 id="webpack-流程"><a href="#webpack-流程" class="headerlink" title="webpack 流程"></a>webpack 流程</h2><p>在手写 webpack <code>plugin</code> 之前，需要了解一下的是 webpack 整个流程是怎么样的，为了方便起见，这里用几张图来概括下</p>
<ul>
<li>整体的流程图<br>  <img src="./1.jpg" alt></li>
<li><code>compilation</code> 对象<br>  <img src="./2.jpg" alt></li>
</ul>
<p>为什么只是用这两张图呢，因为这是 webpack 运行流程中最重要的两个部分。我们对 webpack 的印象是什么，基本上 webpack 是以下这么个大致的流程</p>
<ol>
<li>整合配置 <code>options</code></li>
<li>实例化 <code>compiler</code> 对象</li>
<li>实例化所有的插件(这里包括内置的以及自己配置的)，调用其 <code>apply</code> 方法</li>
<li>返回 <code>compiler</code> 对象</li>
<li>执行 <code>complier</code> 对象的 <code>run</code> 方法</li>
</ol>
<p>而在 webpack 的内部(这里主要说它的 <code>compiler</code> 对象做了啥事)，它会经历大致如下的流程(以 <code>SingleEntryPlugin</code> 为例)</p>
<ol>
<li>调用 <code>beforeRun</code> 钩子</li>
<li>调用 <code>run</code> 钩子</li>
<li>调用 <code>compile</code> 方法(调用 <code>beforeCompiler</code> 钩子 -&gt; 调用 <code>compile</code> 钩子 -&gt; 实例化 <code>compilation</code> 对象 -&gt; 调用 <code>thisCompilation</code> 以及 <code>compliation</code> 钩子 -&gt; 执行 <code>make</code> 钩子 -&gt; <code>seal</code> 封装 -&gt; 调用 <code>afterCompile</code> 钩子)</li>
<li>编译结束后会 <code>run</code> 方法会执行 <code>onCompiled</code> 回调，在这个回调中会先调用 <code>shouldEmit</code> 钩子做判断，成功执行 <code>emitAssets</code> 然后调用 <code>emit</code> 钩子输出文件，失败则调用 <code>done</code> 钩子结束</li>
</ol>
<p>再细一点，我们深入到 <code>compilation</code> 里，看看在实例化 <code>compilation</code> 对象里面做了啥</p>
<ol>
<li>调用 <code>addEntry</code> 钩子，调用完毕后执行其回调通知 <code>make</code> 钩子插件编译完成</li>
<li>调用 <code>addEntry</code> 钩子时会执行 <code>_addModuleChain</code> 方法(根据 <code>dep</code> 拿到 <code>moduleFactory</code> -&gt; 调用 <code>moduleFactory.create</code> 拿到 <code>module</code> -&gt; 调用 <code>buildModule</code> 方法构建模块依赖 -&gt; 调用 <code>afterBuild</code> 方法<strong>递归</strong>用模块工厂创建依赖的模块)</li>
</ol>
<p>从以上的描述我们可以看到，webpack 的一个基本流程就是 <strong>读取配置， 实例化 compiler 时会调用各种钩子以及回调函数, 最后再去挂载相应的插件</strong></p>
<h2 id="所以插件是怎么回事"><a href="#所以插件是怎么回事" class="headerlink" title="所以插件是怎么回事"></a>所以插件是怎么回事</h2><p>webpack 中，如果要写自己的插件，其实就是利用 <strong>发布订阅模式</strong>来写的。因为在 webpack 里面有很多的事件，我们通过 “监听” 这些事件后去执行相应的回调就好，这样说是不是很像前端页面中的交互逻辑呢。是的，基本上原理是相似的。所以插件一般都是这么写</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestPlugin</span> </span>&#123;</span><br><span class="line">  apply(compiler) &#123;</span><br><span class="line">    compiler.hooks.compilation.tap(<span class="string">'TestPlugin'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">compilation</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'compilation'</span>, compilation);</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导出 Plugin</span></span><br><span class="line"><span class="built_in">module</span>.exports = TestPlugin;</span><br></pre></td></tr></table></figure>
<p>在 webpack 使用的钩子中，很大部分都是依赖 <code>tapable</code> 这个库，而这个库的作用就是为 <code>plugin</code> 创建钩子用的，它里面会有类似 <code>XXXHook</code> 类型的钩子，有同步的也有异步的。里面的 <code>tap</code> 方法就是用于 <strong>订阅事件</strong>。代码 <code>compiler.hooks.compilation.tap()</code> 就是当 <code>compilation</code> 这个钩子被触发时就会去执行 <code>tap</code> 里面的回调。</p>
<h2 id="手写文件列表插件"><a href="#手写文件列表插件" class="headerlink" title="手写文件列表插件"></a>手写文件列表插件</h2><p>这个插件主要就是将 webpack 最后 <code>emit</code> 时输出到终端的内容做一个 “拦截”，然后将其输出到一个设置的 <code>filename</code> 文件中。</p>
<blockquote>
<p>注意这里还要安装 <code>html-webpack-plugin</code> 插件</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FileListPlugin</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(&#123; filename &#125;) &#123;</span><br><span class="line">    <span class="keyword">this</span>.filename = filename</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  apply(compiler) &#123;</span><br><span class="line">    <span class="comment">// 在发射文件这个时候截取</span></span><br><span class="line">    compiler.hooks.emit.tap(<span class="string">'FileListPlugin'</span>, (compilation) =&gt; &#123;</span><br><span class="line">      <span class="comment">// 当前打包的资源会放在 assets 属性上</span></span><br><span class="line">      <span class="keyword">const</span> &#123; assets &#125; = compilation</span><br><span class="line">      <span class="keyword">let</span> content = <span class="string">`## 文件名    大小 \r\n`</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">const</span> [filename, stat] <span class="keyword">of</span> <span class="built_in">Object</span>.entries(assets)) &#123;</span><br><span class="line">        content += <span class="string">`- <span class="subst">$&#123;filename&#125;</span>    <span class="subst">$&#123;stat.size()&#125;</span>\r\n`</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 为 assets 添加一个 filename 的字段，在 webpack 接下来的处理中为输出相应的文件做准备</span></span><br><span class="line">      assets[<span class="keyword">this</span>.filename] = &#123;</span><br><span class="line">        source() &#123; <span class="keyword">return</span> content &#125;,</span><br><span class="line">        size() &#123; <span class="keyword">return</span> content.length &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = FileListPlugin</span><br></pre></td></tr></table></figure>
<p>这里我们就知道了为什么要知道 webpack 的流程才能写插件了，如果要做一个文件列表的插件，那么就应该是在 <strong>文件发射之前做</strong>，而不是在 webpack 调用其他的钩子的时候做</p>
<h2 id="手写内联-webpack-插件"><a href="#手写内联-webpack-插件" class="headerlink" title="手写内联 webpack 插件"></a>手写内联 webpack 插件</h2><p>这个所谓的内联插件实际上的功能就是将外链的标签变成内联的，主要体现在</p>
<ul>
<li>将 <code>link</code> 标签变成 <code>style</code> 标签，然后里面填充的是引入的 css 的内容</li>
<li>将 <code>script</code> 标签填充引入的 <code>script</code> 文件内容</li>
<li>删除掉已经生成的没必要引入的文件</li>
</ul>
<p>首先还需要安装三个插件 <code>css-loader</code> 、<code>mini-css-extract-plugin</code> 以及 <code>html-webpack-plugin/next</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yarn add css-loader mini-css-extract-plugin html-webpack-plugin/next</span><br></pre></td></tr></table></figure>
<p>webpack 配置如下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>)</span><br><span class="line"><span class="keyword">const</span> MiniCssExtractPlugin = <span class="built_in">require</span>(<span class="string">'mini-css-extract-plugin'</span>)</span><br><span class="line"><span class="keyword">const</span> InlineSourcePlugin = <span class="built_in">require</span>(<span class="string">'./plugins/inlineSource-plugin'</span>)</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  mode: <span class="string">'development'</span>,</span><br><span class="line">  entry: <span class="string">'./src/index.js'</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">'bundle.js'</span>,</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'dist'</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        use: [MiniCssExtractPlugin.loader, <span class="string">'css-loader'</span>]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> MiniCssExtractPlugin(&#123;</span><br><span class="line">      filename: <span class="string">'main.css'</span></span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="keyword">new</span> InlineSourcePlugin(&#123;</span><br><span class="line">      test: <span class="regexp">/\.(js|css)/</span></span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">      template: <span class="string">'./src/index.html'</span></span><br><span class="line">    &#125;),</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后是关键的 <code>InlineSourcePlugin</code> 插件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 因为最后是改变 html 的 tag 然后插入到 html 中的，所以这里会使用到</span></span><br><span class="line"><span class="comment">// html-webpack-plugin 提供的一些 hooks 来供我们使用</span></span><br><span class="line"><span class="comment">// 在 html-webpack-plugin 的基础上开发插件</span></span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InlineSourcePlugin</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(&#123; test &#125;) &#123;</span><br><span class="line">    <span class="comment">// 用于匹配文件的正则，这里主要寻找以 js 或 css 结尾的文件</span></span><br><span class="line">    <span class="keyword">this</span>.reg = test</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 处理一个 tag 的数据</span></span><br><span class="line">  processTag(tag, compilation) &#123;</span><br><span class="line">    <span class="keyword">let</span> newTag, url</span><br><span class="line">    <span class="keyword">const</span> &#123; tagName, attributes &#125; = tag</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (tagName === <span class="string">'link'</span> &amp;&amp; <span class="keyword">this</span>.reg.test(attributes.href)) &#123;</span><br><span class="line">      newTag = &#123;</span><br><span class="line">        tagName: <span class="string">'style'</span>,</span><br><span class="line">        attributes: &#123; <span class="attr">type</span>: <span class="string">'text/css'</span> &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      url = attributes.href</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (tagName === <span class="string">'script'</span> &amp;&amp; <span class="keyword">this</span>.reg.test(attributes.src)) &#123;</span><br><span class="line">      newTag = &#123;</span><br><span class="line">        tagName: <span class="string">'script'</span>,</span><br><span class="line">        attributes: &#123; <span class="attr">type</span>: <span class="string">'application/javascript'</span> &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      url = attributes.src</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (url) &#123;</span><br><span class="line">      <span class="comment">// 标签里面插入对应文件的源码</span></span><br><span class="line">      newTag.innerHTML = compilation.assets[url].source()</span><br><span class="line">      <span class="comment">// 既然都把源码怼 html 上了，就应该删除对应的文件</span></span><br><span class="line">      <span class="keyword">delete</span> compilation.assets[url]</span><br><span class="line">      <span class="keyword">return</span> newTag</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> tag</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 处理引入 tags 的数据</span></span><br><span class="line">  processTags(data, compilation) &#123;</span><br><span class="line">    <span class="keyword">const</span> headTags = []</span><br><span class="line">    data.headTags.forEach(<span class="function"><span class="params">headTag</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 处理引入 css 的 link 标签</span></span><br><span class="line">      headTags.push(<span class="keyword">this</span>.processTag(headTag, compilation))</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> bodyTags = []</span><br><span class="line">    data.bodyTags.forEach(<span class="function"><span class="params">bodyTag</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 处理引入 script 标签</span></span><br><span class="line">      bodyTags.push(<span class="keyword">this</span>.processTag(bodyTag, compilation))</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123; ...data, headTags, bodyTags &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  apply (compiler) &#123;</span><br><span class="line">    compiler.hooks.compilation.tap(<span class="string">'InlineSourcePlugin'</span>, (compilation) =&gt; &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'The compiler is starting a new compilation...'</span>)</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 静态插件接口 | compilation | HOOK NAME | register listener</span></span><br><span class="line">      <span class="comment">// 使用 alterAssetTagGroups 这个 hooks</span></span><br><span class="line">      HtmlWebpackPlugin.getHooks(compilation).alterAssetTagGroups.tapAsync(</span><br><span class="line">        <span class="string">'alterPlugin'</span>, <span class="comment">// 为堆栈取名</span></span><br><span class="line">        (data, cb) =&gt; &#123;</span><br><span class="line">          <span class="comment">// 处理 html 的某些 tags, 这里需要做处理的是 css 和 js</span></span><br><span class="line">          <span class="keyword">const</span> newData = <span class="keyword">this</span>.processTags(data, compilation)</span><br><span class="line">          <span class="comment">// 返回 data</span></span><br><span class="line">          cb(<span class="literal">null</span>, newData)</span><br><span class="line">        &#125;</span><br><span class="line">      )</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = InlineSourcePlugin</span><br></pre></td></tr></table></figure>
<p>其实这里整体的逻辑很简单，就是找出 <code>index.html</code> 中的 <code>link</code> 标签以及 <code>script</code> 标签，将其的 <code>innerHTML</code> 替换为对应文件的源码而已。从 <code>compliation</code> 这个对象里面找对应的字段然后做对应的修改即可。但是这里的重点是，应该在哪里或者说是哪个钩子里面去用？这里就用到了 <code>html-webpack-plugin</code> 这个插件了，众所周知这个插件的作用是 <strong>简化 html 文件的创建的</strong>，而且这个插件本身也提供了一些钩子给开发者在基于这个插件的基础上再开发插件。去看 <a href="https://github.com/jantimon/html-webpack-plugin" target="_blank" rel="noopener">html-webpack-plugin 的官方文档</a>，在 <code>plugin.js</code> 这个小标题下可以找到对应插件的写法，上面就是它说明的提供的一些钩子。不过这里不是用 <code>beforeEmit</code> 这个钩子，因为我们想要的是要修改标签，理所当然的就是跟 <code>tag</code> 相关的 hooks 了。这里有两个 <code>tag</code>，一个是 <code>alterAssetTags</code>，另一个是 <code>alterAssetTagGroups</code>，这里我们选择的是 <code>alterAssetTagGroups</code>，因为我们重点是在 <code>head</code> 以及 <code>body</code> 上找标签，而且为了之后能修改更多的标签，选这个比较靠谱。选择了之后将 <code>beforeEmit</code> 改为 <code>alterAssetTagGroups</code> 就可以整活了, 后面就是根据 <code>data</code> 的属性去做相应的修改， <code>processTags</code> 完成之后调用 <code>cb</code> 回调，代码修改执行完毕。</p>
<p>这里还有一张 <code>html-webpack-plugin</code> hooks 图，以供参考</p>
<p><img src="./3.jpg" alt></p>
<h2 id="手写打包自动发布插件"><a href="#手写打包自动发布插件" class="headerlink" title="手写打包自动发布插件"></a>手写打包自动发布插件</h2><p>这个插件的主要功能就是将打包后的文件(就是 <code>dist</code> 目录下的)放到 cdn 服务器上。然后页面中就直接引用 cdn 的文件就可以了。这里使用免费的 <strong>七牛云</strong> 来做</p>
<p>首先需要安装 <code>qiniu</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yarn add qiniu</span><br></pre></td></tr></table></figure>
<p>webpack 配置文件设置 <code>output</code> 的 <code>publicPath</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">output: &#123;</span><br><span class="line">    filename: <span class="string">'bundle.js'</span>,</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'dist'</span>),</span><br><span class="line">    publicPath: <span class="string">'http://test.strugglebak.com'</span> <span class="comment">// 在你的七牛云的 bucket 上设置的外链域名</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<p>然后写一个 <code>upload-plugin.js</code> 在 <code>plugin</code> 目录，webpack 配置文件引入和使用</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> UploadPlugin = <span class="built_in">require</span>(<span class="string">'./plugins/upload-plugin'</span>)</span><br><span class="line">...</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">...</span><br><span class="line">    plugins: [</span><br><span class="line">        <span class="keyword">new</span> UploadPlugin(&#123;</span><br><span class="line">            bucket: <span class="string">'ststatic'</span>, <span class="comment">// 你的七牛云对象存储中创建的 bucket 名字</span></span><br><span class="line">            domain: <span class="string">'test.strugglebak.com'</span> <span class="comment">// 在你的七牛云的 bucket 上设置的外链域名</span></span><br><span class="line">        &#125;)</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后是 <code>upload-plugin.js</code> 文件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"><span class="keyword">const</span> qiniu = <span class="built_in">require</span>(<span class="string">'qiniu'</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UploadPlugin</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(&#123;bucket, domain&#125;) &#123;</span><br><span class="line">    <span class="comment">// 初始化七牛云参数以及内部变量</span></span><br><span class="line">    <span class="keyword">this</span>.init(&#123;bucket, domain&#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  apply(compiler) &#123;</span><br><span class="line">    <span class="comment">// 上传文件是多个，且返回的是 promise，所以这里用 tapPromise</span></span><br><span class="line">    compiler.hooks.afterEmit.tapPromise(</span><br><span class="line">      <span class="string">'UploadPlugin'</span>,</span><br><span class="line">      (compliation) =&gt; &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; assets &#125; = compliation</span><br><span class="line">        <span class="keyword">const</span> promises = []</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> [filename, stat] <span class="keyword">of</span> <span class="built_in">Object</span>.entries(assets)) &#123;</span><br><span class="line">          promises.push(<span class="keyword">this</span>.upload(filename))</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Promise</span>.all(promises)</span><br><span class="line">      &#125;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 上传文件</span></span><br><span class="line">  upload(filename) &#123;</span><br><span class="line">    <span class="comment">// 代码参考在 https://developer.qiniu.com/kodo/sdk/1289/nodejs#form-upload-file</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resovle, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 要上传的本地文件目录为 dist 目录下的</span></span><br><span class="line">      <span class="keyword">const</span> localFile = path.resolve(__dirname, <span class="string">'../dist'</span>, filename)</span><br><span class="line">      <span class="comment">// 使用表单方式上传本地文件</span></span><br><span class="line">      <span class="keyword">this</span>.formUploader.putFile(</span><br><span class="line">        <span class="keyword">this</span>.uploadToken, filename, localFile, <span class="keyword">this</span>.putExtra,</span><br><span class="line">        (respErr, respBody, respInfo) =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (respErr) &#123;</span><br><span class="line">          reject(respErr)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (respInfo.statusCode == <span class="number">200</span>) &#123;</span><br><span class="line">          resovle(respBody)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  init(&#123;bucket, domain&#125;) &#123;</span><br><span class="line">    <span class="comment">// 读取本地的 qiniu 的密钥文件，这样比较安全</span></span><br><span class="line">    <span class="keyword">const</span> keyJSON = fs.readFileSync(</span><br><span class="line">      path.resolve(__dirname, <span class="string">'../'</span>, <span class="string">'qiniu-key.json'</span>),</span><br><span class="line">      <span class="string">'utf8'</span></span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">const</span> &#123; accessKey, secretKey &#125; = <span class="built_in">JSON</span>.parse(keyJSON)</span><br><span class="line">    <span class="keyword">const</span> mac = <span class="keyword">new</span> qiniu.auth.digest.Mac(accessKey, secretKey)</span><br><span class="line">    <span class="keyword">const</span> putPolicy = <span class="keyword">new</span> qiniu.rs.PutPolicy(&#123; <span class="attr">scope</span>: bucket &#125;)</span><br><span class="line">    <span class="keyword">const</span> config = <span class="keyword">new</span> qiniu.conf.Config()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.uploadToken = putPolicy.uploadToken(mac)</span><br><span class="line">    <span class="keyword">this</span>.formUploader = <span class="keyword">new</span> qiniu.form_up.FormUploader(config)</span><br><span class="line">    <span class="keyword">this</span>.putExtra = <span class="keyword">new</span> qiniu.form_up.PutExtra()</span><br><span class="line">    <span class="keyword">this</span>.domain = domain</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = UploadPlugin</span><br></pre></td></tr></table></figure>
<p>这里的整体逻辑很简单，就是先初始化 <code>qiniu</code> 的一些参数，然后利用其 <code>formUploader</code> 对象进行<strong>表单方式的文件上传</strong>。而因为是在 <strong>发射文件之后</strong> 才采取的操作，所以这里就使用 <code>afterEmit</code> 这个 hooks，传的参数里面 <code>compilation</code> 对象的 <code>assets</code> 属性有对应的文件名和其对应的内容。拿到这个文件路径之后就将其 <code>push</code> 到一个 <code>promise</code> 数组里面，最后再整体返回(因为这里使用的是 <code>tapPromise</code>)。在文件上传代码的核心部分，就是利用 <a href="https://developer.qiniu.com/kodo/sdk/1289/nodejs#form-upload-file" target="_blank" rel="noopener">qiniu 表单上传代码</a> 来做的，本质上就是返回了一个 <code>promise</code>。在 <code>formUploader.putFile</code> 这个函数中，有几个参数</p>
<ul>
<li>uploadToken: upload 的 token，主要根据 <code>accessKey</code> 和 <code>secretKey</code> 生成的，用于身份的验证</li>
<li>filename: 这个相当于文件的 <code>key</code></li>
<li>localFile: 这个要上传的本地文件的 <code>value</code>，就是文件路径，与上面的 <code>filename</code> 对应</li>
<li>putExtra: qiniu.form_up.PutExtra() 对象(意义不明)</li>
</ul>
<p>这里主要 <code>resolve</code> 的是 <code>respBody</code> 这个数据。这样整体的逻辑就算完成。</p>
<h2 id="补充-在七牛云添加-cdn"><a href="#补充-在七牛云添加-cdn" class="headerlink" title="补充(在七牛云添加 cdn)"></a>补充(在七牛云添加 cdn)</h2><p>这里可能有些小伙伴不知道如何在七牛云添加 cdn 域名。下面我来说下步骤</p>
<ul>
<li><p>首先你需要有一个七牛云账号，在注册完账号后，点击主页的 <code>管理控制台</code> 进入控制台<br><img src="./console.jpg" alt></p>
</li>
<li><p>进入 <code>管理控制台</code> 后，点击左边的 <code>cdn</code><br>  <img src="./4.jpg" alt></p>
</li>
<li><p>然后点击 <code>域名管理</code><br>  <img src="./5.jpg" alt></p>
</li>
<li><p>再点击 <code>添加域名</code><br>  <img src="./6.jpg" alt></p>
</li>
<li><p>然后在 <code>加速域名</code> 那块输入要加速的域名<br>  <img src="./7.jpg" alt></p>
<p>  这里需要注意的是，你目前的域名已经<strong>注册并且备过案了!!!</strong>，比如我的 <code>strugglebak.com</code> 这个域名是备过案的才能用。<br>  我这里输入的要加速的域名是 <code>test.strugglebak.com</code>，其中 <code>test</code> 表示 <strong>主机记录</strong>，你也可以随便取啥名</p>
</li>
<li><p>再点击 <code>创建</code><br>  <img src="./8.jpg" alt></p>
</li>
<li><p>跳回到 <code>域名管理</code> 上，鼠标悬浮到你刚创建的域名上(<code>test.strugglebak.com</code>)，复制 <code>CNAME</code><br>  <img src="./9.jpg" alt></p>
</li>
<li><p>然后在自己的服务器在对应的域名上添加 <code>解析记录</code>(因为我这里通常就是用腾讯云小程序搞的，所以截图是小程序的手机截图)<br>  <img src="./10.jpg" alt></p>
<p>  点击 <code>域名解析</code></p>
<p>  <img src="./11.jpg" alt></p>
<p>  点击 <code>添加解析记录</code></p>
<p>  <img src="./12.jpg" alt></p>
<p>  然后填写 <code>主机记录</code> 以及 <code>记录值</code></p>
<p>  <img src="./13.jpg" alt></p>
<p>  其中 <code>test</code> 对应你设置的七牛云 <code>bucket</code> 的外链，而 <code>记录值</code> 就是 <code>CNAME</code></p>
</li>
<li><p>最后在你的七牛云 <code>对象存储</code> 中，在对应的 <code>bucket</code> 中设置外链<br>  <img src="./14.jpg" alt></p>
</li>
</ul>
<p>如果最后看到 cdn 外链的下面的图，则说明设置成功</p>
<p><img src="./15.jpg" alt></p>
<p>所以当你在访问 <code>test.strugglebak.com/xxx文件</code>时，就相当于在访问 <code>test-strugglebak-com-idva9dm.qiniudns.com/xxx文件</code>，效果就是会先访问你的服务器，然后再转到七牛的服务器上访问文件。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>由以上的内容我们知道了，在写一个 webpack 的插件之前，最重要的是要了解一个流程是怎么走的，都是利用 webpack 的钩子或者其他插件本身的钩子来进行编写。注意 webpack 插件的本质是利用了 <strong>发布订阅</strong> 的模式。我们订阅了这个事件后，执行对应的回调，并将执行回调的结果再传回给 webpack，最终结果会体现在打包的文件上。这样 webpack 就完成了对插件的加载以及处理。</p>
<p>另，<a href="https://github.com/strugglebak/webpack-plugin-test.git" target="_blank" rel="noopener">👉项目测试仓库戳这里</a></p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://juejin.im/post/5d418879f265da03af19b03f" target="_blank" rel="noopener">Webpack 源码研究</a></p>
]]></content>
      <categories>
        <category>前端工程化</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>从Webpack本质开始(二):手写loader</title>
    <url>/2020/02/24/%E4%BB%8EWebpack%E6%9C%AC%E8%B4%A8%E5%BC%80%E5%A7%8B-%E4%BA%8C-%E6%89%8B%E5%86%99loader/</url>
    <content><![CDATA[<blockquote>
<p>这个是探究 Webpack 本质的系列文章，会详细讲解如何手写一些源码如 Webpack, loader, plugin 等等，本文主要讲解的是如何手写 loader</p>
</blockquote>
<a id="more"></a>
<h2 id="loader-是个啥"><a href="#loader-是个啥" class="headerlink" title="loader 是个啥"></a>loader 是个啥</h2><p>webpack 只能处理 js 中的模块，所以若是要处理<strong>其他类型</strong>的文件的时候，就需要 loader 去做<strong>转换(transform)</strong>。本质上来说，loader 是用来<strong>将一段代码转换成另一段代码的 webpack 加载器</strong>。为什么叫做 “loader”？因为当你使用 <code>import</code> 或者其他方式去 “加载” 模块时，这些 loader 就会对模块进行一些<strong>预处理</strong>的工作。这就是 loader 的作用。</p>
<p>我们经常写 <code>loader</code> 时会这么写</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loader</span>(<span class="params">source</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// TODO</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'loader'</span>)</span><br><span class="line">  <span class="keyword">return</span> source</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = loader</span><br></pre></td></tr></table></figure>
<p>可以看出 <code>loader</code> 本质上是一个<strong>函数</strong>，并且其<strong>参数就是源码</strong></p>
<h2 id="loader-的配置规则"><a href="#loader-的配置规则" class="headerlink" title="loader 的配置规则"></a>loader 的配置规则</h2><p>在 <code>webpack.config.js</code> 的配置中，<code>loader</code> 的配置一般有三种写法</p>
<ul>
<li><p>在 <code>use</code> 中写死路径</p>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">  rules: [</span><br><span class="line">    &#123;</span><br><span class="line">      test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">      <span class="comment">// loader 为项目目录的 /loaders/demo-loader.js</span></span><br><span class="line">      use: path.resolve(__dirname, <span class="string">'loaders'</span>, <span class="string">'demo-loader.js'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在 <code>resolveLoader</code> 中建立别名，然后 <code>use</code> 使用这个别名</p>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">resolveLoader: &#123;</span><br><span class="line">  alias: &#123;</span><br><span class="line">    demoLoader: path.resolve(__dirname, <span class="string">'loaders'</span>, <span class="string">'demo-loader.js'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">  rules: [</span><br><span class="line">    &#123;</span><br><span class="line">      test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">      <span class="comment">// 别名</span></span><br><span class="line">      use: <span class="string">'demoLoader'</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在 <code>resolveLoader</code> 中配置 <code>modules</code>，从自定义的目录开始寻找</p>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">resolveLoader: &#123;</span><br><span class="line">  <span class="comment">// node_modules 目录下找不到，就会从 loaders 目录下寻找 loader</span></span><br><span class="line">  modules: [<span class="string">'node_modules'</span>, path.resolve(__dirname, <span class="string">'loaders'</span>)]</span><br><span class="line">&#125;,</span><br><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">  rules: [</span><br><span class="line">    &#123;</span><br><span class="line">      test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">      use: <span class="string">'demo-loader'</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="loader-的执行顺序"><a href="#loader-的执行顺序" class="headerlink" title="loader 的执行顺序"></a>loader 的执行顺序</h2><p>从配置来看，默认的 <code>loader</code> 执行顺序是<strong>从下到上、从右往左的</strong>。对于 <code>loader</code> 来说，它有如下的分类</p>
<ul>
<li>pre (在前面执行)</li>
<li>normal (默认不配置)</li>
<li>inline (插入)</li>
<li>post (在后面执行)</li>
</ul>
<p>比如下面的配置</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">  rules: [</span><br><span class="line">    &#123;</span><br><span class="line">      test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">      use: &#123; <span class="attr">loader</span>: <span class="string">'demo-loader'</span> &#125;,</span><br><span class="line">      enforce: <span class="string">'pre'</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">      use: &#123; <span class="attr">loader</span>: <span class="string">'demo-loader2'</span> &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">      use: &#123; <span class="attr">loader</span>: <span class="string">'demo-loader3'</span> &#125;,</span><br><span class="line">      enforce: <span class="string">'post'</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其执行顺序就变成了 <code>demo-loader -&gt; demo-loader2 -&gt; demo-loader3</code></p>
<p>那 <code>inline loader</code> 是怎么回事呢？它实际上就是插入的 loader，如果希望在 <code>require</code> 其他模块时将其导到 <code>post loader</code> 前面去执行，就这样写</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ./src/index.js</span></span><br><span class="line"><span class="keyword">const</span> moduleA = <span class="built_in">require</span>(<span class="string">'inline-loader!./moduleA'</span>)</span><br></pre></td></tr></table></figure>
<p>这里的 <code>inline-loader</code> 是 inline-loader 的名字，前面加个 <code>!</code> 表示希望交给 <code>inline-loader</code> 去做处理</p>
<p>那么打印顺序就变成了</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">loader</span><br><span class="line">loader2</span><br><span class="line">loader3</span><br><span class="line">loader</span><br><span class="line">loader2</span><br><span class="line">inline-loader</span><br><span class="line">loader3</span><br></pre></td></tr></table></figure>
<p>但是由于 <code>require</code> 配置的不同，<code>inline-loader</code> 插入的方式也不一样，比如</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ./src/index.js</span></span><br><span class="line"><span class="keyword">const</span> moduleA = <span class="built_in">require</span>(<span class="string">'-!inline-loader!./moduleA'</span>)</span><br></pre></td></tr></table></figure>
<p>那么打印顺序变成</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">loader</span><br><span class="line">loader2</span><br><span class="line">loader3</span><br><span class="line">inline-loader</span><br><span class="line">loader3</span><br></pre></td></tr></table></figure>
<p>后面的 <code>pre</code> 以及 <code>normal</code> 的就没有打印出来了</p>
<p>如果只有一个 <code>!</code> 表示后面的 <code>normal</code> 不执行</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ./src/index.js</span></span><br><span class="line"><span class="keyword">const</span> moduleA = <span class="built_in">require</span>(<span class="string">'!inline-loader!./moduleA'</span>)</span><br></pre></td></tr></table></figure>
<p>那么打印顺序变成</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">loader</span><br><span class="line">loader2</span><br><span class="line">loader3</span><br><span class="line">loader</span><br><span class="line">inline-loader</span><br><span class="line">loader3</span><br></pre></td></tr></table></figure>
<p>如果是两个 <code>!</code> ，则表示后面的啥都不执行</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ./src/index.js</span></span><br><span class="line"><span class="keyword">const</span> moduleA = <span class="built_in">require</span>(<span class="string">'!!inline-loader!./moduleA'</span>)</span><br></pre></td></tr></table></figure>
<p>那么打印顺序变成</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">loader</span><br><span class="line">loader2</span><br><span class="line">loader3</span><br><span class="line">inline-loader</span><br></pre></td></tr></table></figure>
<p>总结下符号的含义</p>
<ul>
<li><code>-!</code> 禁用前置和正常 loader</li>
<li><code>!</code> 禁用普通 loader</li>
<li><code>!!</code> 禁用前置后置以及正常 loader</li>
</ul>
<p>这里说一个为何 <code>inline-loader</code> 前面有打印输出，这是因为 <code>loader</code> 本身还由两个阶段组成: <strong>pitching</strong> 和 <strong>normal execution</strong></p>
<p>假如一个 use 配置是这样的</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">use: [<span class="string">'loader3'</span>, <span class="string">'loader2'</span>, <span class="string">'loader1'</span>]</span><br></pre></td></tr></table></figure>
<p>如果 <code>loader</code> 的 <code>pitch</code> 方法<strong>都没有返回值</strong>，那么它执行的顺序为</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">|- loader3 `pitch`</span><br><span class="line">  |- loader2 `pitch`</span><br><span class="line">    |- loader1 `pitch`</span><br><span class="line">      |- requested module is picked up as a dependency</span><br><span class="line">    |- loader1 normal execution</span><br><span class="line">  |- loader2 normal execution</span><br><span class="line">|- loader3 normal execution</span><br></pre></td></tr></table></figure>
<p>如果某一个 <code>loader</code> 的 <code>pitch</code> 方法<strong>有返回值</strong>(比如 <code>loader2</code>)，那么它执行的顺序为</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">|- loader3 `pitch`</span><br><span class="line">  |- loader2 `pitch`</span><br><span class="line">|- loader3 normal execution</span><br></pre></td></tr></table></figure>
<p>最后需要说下的是 <code>loader</code> 的特点</p>
<ul>
<li>第一个 <code>loader</code> 必须返回的是 js 脚本</li>
<li>每个 <code>loader</code> 只做其对应的事情，这是为了使 <code>loader</code> 能在更多的场景下进行<strong>链式调用</strong></li>
<li>每一个 <code>loader</code> 都是一个模块</li>
<li>每一个 <code>loader</code> 都应该是 <strong>无状态</strong> 的，确保 <code>loader</code> 在不同模块的转换之间不保存状态</li>
</ul>
<h2 id="手写-babel-loader"><a href="#手写-babel-loader" class="headerlink" title="手写 babel-loader"></a>手写 babel-loader</h2><p>首先需要装三个包</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yarn add @babel/core @babel/preset-env loader-utils</span><br></pre></td></tr></table></figure>
<ul>
<li>@babel/core: js 编译器的核心组件</li>
<li>@babel/preset-env babel 的插件预设，用来提供支持新语法的环境</li>
<li>loader-utils 一个专门用于写 webpack loader 的工具库</li>
</ul>
<p>然后 <code>webpack.config.js</code> 的内容如下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    mode: <span class="string">'development'</span>,</span><br><span class="line">	entry: <span class="string">'./src/index.js'</span>,</span><br><span class="line">	output: &#123;</span><br><span class="line">		filename: <span class="string">'bundle.js'</span>,</span><br><span class="line">		path: path.resolve(__dirname, <span class="string">'dist'</span>)</span><br><span class="line">	&#125;,</span><br><span class="line">	resolveLoader: &#123;</span><br><span class="line">		modules: [<span class="string">'node_modules'</span>, path.resolve(__dirname, <span class="string">'loaders'</span>)]</span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="comment">// 整个 source map 作为一个单独的文件生成。它为 bundle 添加了一个引用注释，以便开发工具知道在哪里可以找到它</span></span><br><span class="line">	devtool: <span class="string">'source-map'</span>,</span><br><span class="line">	<span class="built_in">module</span>: &#123;</span><br><span class="line">		rules: [</span><br><span class="line">			&#123;</span><br><span class="line">				test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">				use: &#123;</span><br><span class="line">					loader: <span class="string">'babel-loader'</span>,</span><br><span class="line">					options: &#123;</span><br><span class="line">          	            presets: [<span class="string">'@babel/preset-env'</span>] <span class="comment">// 使用 @babel/preset-env 来转化</span></span><br><span class="line">        	        &#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		]</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里说一下 <code>source-map</code>，<code>source-map</code> 是一种提供 debug 的源码映射文件，它建立的是一种将压缩文件中的代码对应到源代码文件的方式，有这个source map 文件，出问题了就可以找到对应的代码是哪一段</p>
<p>然后就可以写 <code>babel-loader</code> 了</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> babel = <span class="built_in">require</span>(<span class="string">'@babel/core'</span>)</span><br><span class="line"><span class="keyword">const</span> loaderUtils = <span class="built_in">require</span>(<span class="string">'loader-utils'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loader</span>(<span class="params">source</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// this 就是 loaderContext</span></span><br><span class="line">  <span class="keyword">const</span> options = loaderUtils.getOptions(<span class="keyword">this</span>)</span><br><span class="line">  <span class="comment">// 异步返回需要用到 async 这个函数</span></span><br><span class="line">  <span class="keyword">const</span> cb = <span class="keyword">this</span>.async()</span><br><span class="line">  <span class="comment">// babel 转化代码</span></span><br><span class="line">  babel.transform(source, &#123;</span><br><span class="line">    ...options,</span><br><span class="line">    sourceMaps: <span class="literal">true</span>, <span class="comment">// 使用源码映射 生成 .js.map</span></span><br><span class="line">    filename: <span class="keyword">this</span>.resourcePath.split(<span class="string">'/'</span>).pop() <span class="comment">// 取出资源文件名</span></span><br><span class="line">  &#125;, (err, result) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; code, map &#125; = result</span><br><span class="line">    cb(err, code, map) <span class="comment">// 返回 code 以及 map 文件</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = loader</span><br></pre></td></tr></table></figure>
<p>这里的逻辑就是，拿到 <code>loader</code> 的 Context，将其转化成 <code>options</code>，然后使用 <code>babel</code> 的 <code>transform</code> API 来进行代码的转换(es6 -&gt; es5)，里面除了传入 <code>options</code> 之外，还要传入 <code>sourceMaps</code> 确定生成 soureMap 文件，然后 <code>filename</code> 设置 sourcemap 的文件名。最后是一个异步回调函数，由于是异步的，所以这里就需要 <code>async</code> 这个 API，只要调用它就会自动返回传的参数。</p>
<h2 id="手写-banner-loader"><a href="#手写-banner-loader" class="headerlink" title="手写 banner-loader"></a>手写 banner-loader</h2><p>实现这个 <code>loader</code> 的功能主要是这样</p>
<ul>
<li>读取 js 文件，获取其里面的内容，将其作为注释加入到最终生成的源码文件中</li>
<li>若这个 js 文件不存在，则读取其配置中的 <code>text</code> 选项的内容作为注释加入到最终生成的源码文件中</li>
</ul>
<p>先安装 <code>schema-utils</code>，这是一个 webpack 专门用于验证 <code>loaders</code> 以及 <code>plugins</code> 的 <code>options</code> 的库</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yarn add schema-utils</span><br></pre></td></tr></table></figure>
<p>然后是 <code>webpack.config.js</code> 配置，修改 <code>module.rules[0]</code> 选项</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">	use: &#123;</span><br><span class="line">		loader: <span class="string">'banner-loader'</span>,</span><br><span class="line">		options: &#123;</span><br><span class="line">			text: <span class="string">'这里是注释'</span>,</span><br><span class="line">			filename: path.resolve(__dirname, <span class="string">'banner.js'</span>)</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>同时设置 <code>watch</code> 选项为 <code>true</code></strong></p>
<p>在项目当前目录增加 <code>banner.js</code> 文件，文件里面写上 <code>helloworld</code></p>
<p>然后在 <code>loaders</code> 目录下增加 <code>banner-loader.js</code> 文件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"><span class="keyword">const</span> loaderUtils = <span class="built_in">require</span>(<span class="string">'loader-utils'</span>)</span><br><span class="line"><span class="keyword">const</span> validateOptions = <span class="built_in">require</span>(<span class="string">'schema-utils'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loader</span>(<span class="params">source</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 若有缓存则优先用缓存</span></span><br><span class="line">  <span class="keyword">this</span>.cacheable &amp;&amp; <span class="keyword">this</span>.cacheable()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> cb = <span class="keyword">this</span>.async()</span><br><span class="line">  <span class="keyword">const</span> options = loaderUtils.getOptions(<span class="keyword">this</span>)</span><br><span class="line">  <span class="keyword">const</span> schema = &#123;</span><br><span class="line">    type: <span class="string">'object'</span>,</span><br><span class="line">    properties: &#123;</span><br><span class="line">      text: &#123; <span class="attr">type</span>: <span class="string">'string'</span> &#125;,</span><br><span class="line">      filename: &#123; <span class="attr">type</span>: <span class="string">'string'</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 验证配置有没有写正确</span></span><br><span class="line">  validateOptions(schema, options, <span class="string">'banner-loader'</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> &#123; filename, text &#125; = options</span><br><span class="line">  <span class="keyword">if</span> (filename) &#123;</span><br><span class="line">    <span class="comment">// 添加依赖 在 webpack 使用 watch 配置时使用，只要对应文件有改动，会自动打包更新</span></span><br><span class="line">    <span class="keyword">this</span>.addDependency(filename)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取文件并写入注释</span></span><br><span class="line">    fs.readFile(filename, <span class="string">'utf8'</span>, (err, data) =&gt; &#123;</span><br><span class="line">      cb(err, <span class="string">`/**<span class="subst">$&#123;data&#125;</span>*/<span class="subst">$&#123;source&#125;</span>`</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    cb(<span class="literal">null</span>, <span class="string">`/**<span class="subst">$&#123;text&#125;</span>*/<span class="subst">$&#123;source&#125;</span>`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = loader</span><br></pre></td></tr></table></figure>
<p>主要的逻辑很简单，就是看有没有配置有没有写对，配置写对了的话就看 <code>filename</code> 存在不存在，<code>filename</code> 不存在就走 <code>text</code>，<code>filename</code> 存在就读取相应文件然后写进去。这里有两个 <code>loader</code> 的 API 需要注意的，一个是 <code>cacheable</code>，另一个是 <code>addDependency</code>，前者是用来缓存文件的，后者是用来配合 <code>webpack</code> 的 <code>watch</code> 配置来用的</p>
<h2 id="手写-file-loader-以及-url-loader"><a href="#手写-file-loader-以及-url-loader" class="headerlink" title="手写 file-loader 以及 url-loader"></a>手写 file-loader 以及 url-loader</h2><p>首先新建一个图片 <code>demo.jpg</code> 放入 <code>assets</code> 目录下</p>
<p>然后在 <code>src/index.js</code> 中写入</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 测试 file-loader 以及 url-loader</span></span><br><span class="line"><span class="keyword">import</span> picture <span class="keyword">from</span> <span class="string">'./assets/demo.jpg'</span></span><br><span class="line"><span class="keyword">const</span> img = <span class="built_in">document</span>.createElement(<span class="string">'img'</span>)</span><br><span class="line">img.src = picture</span><br><span class="line"><span class="built_in">document</span>.body.appendChild(img)</span><br></pre></td></tr></table></figure>
<p><code>file-loader</code> 的作用就是</p>
<ul>
<li>根据图片生成 md5 发射到 <code>dist</code> 目录下</li>
<li>返回当前的图片路径</li>
</ul>
<p>首先是 <code>webpack.config.js</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    test: <span class="regexp">/\.(png|jpg)$/</span>,</span><br><span class="line">    use: &#123;</span><br><span class="line">        loader: <span class="string">'file-loader'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在项目 <code>loaders</code> 下新建 <code>file-loader.js</code> 文件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> loaderUtils = <span class="built_in">require</span>(<span class="string">'loader-utils'</span>)</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loader</span>(<span class="params">source</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 根据 loaderContext 生成文件, 这个文件是一串 hash + .jpg 作为后缀名的</span></span><br><span class="line">  <span class="keyword">const</span> filename = loaderUtils.interpolateName(<span class="keyword">this</span>, <span class="string">'[hash].[ext]'</span>, &#123;</span><br><span class="line">    content: source</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// 发射文件</span></span><br><span class="line">  <span class="keyword">this</span>.emitFile(filename, source)</span><br><span class="line">  <span class="comment">// 最后 file-loader 需要返回一个路径，这样 index.js 在 import 图片的时候</span></span><br><span class="line">  <span class="comment">// img 的 src 才是正确的路径</span></span><br><span class="line">  <span class="keyword">return</span> <span class="string">`module.exports = "<span class="subst">$&#123;filename&#125;</span>"`</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 让 source 变成二进制的 buffer</span></span><br><span class="line">loader.raw = <span class="literal">true</span></span><br><span class="line"><span class="built_in">module</span>.exports = loader</span><br></pre></td></tr></table></figure>
<p>这里需要注意的一点是 <strong>需要将 source 变成二进制的 buffer</strong>，这样便于传参以及后续的处理。最后返回的是一个 <code>module.exports</code>，因为最终需要的是一个路径，这样相当于改变了模块的源码，别人在引入图片的时候就直接引入了路径了</p>
<p>当然更高级一点的写法是 <code>url-loader</code>，这个 loader 的作用就是</p>
<ul>
<li>将传入的文件做一个 <code>limit</code> 的判断，如果这个文件大于 <code>limit</code>，则返回的是文件路径</li>
<li>若小于 <code>limit</code>，则返回的是一串 <code>base64</code></li>
</ul>
<p>写这个之前需要安装 <code>mime</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yarn add mime</span><br></pre></td></tr></table></figure>
<p><code>mime</code> 是一个判断文件类型的工具包，生成 <code>base64</code> 的时候还需要注明图片类型</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> loaderUtils = <span class="built_in">require</span>(<span class="string">'loader-utils'</span>)</span><br><span class="line"><span class="keyword">const</span> mime = <span class="built_in">require</span>(<span class="string">'mime'</span>)</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loader</span>(<span class="params">source</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; limit &#125; = loaderUtils.getOptions(<span class="keyword">this</span>)</span><br><span class="line">  <span class="keyword">if</span> (limit &amp;&amp; source.length &lt; limit) &#123;</span><br><span class="line">    <span class="comment">// 图片没有超过设定的限制大小就返回 base64</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">`module.exports = "data:<span class="subst">$&#123;mime.getType(<span class="keyword">this</span>.resourcePath)&#125;</span>;base64,<span class="subst">$&#123;source.toString(<span class="string">'base64'</span>)&#125;</span>"`</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 图片超过了就调用 file-loader 返回图片本身路径</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">require</span>(<span class="string">'./file-loader'</span>).call(<span class="keyword">this</span>, source)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 让 source 变成二进制的 buffer</span></span><br><span class="line">loader.raw = <span class="literal">true</span></span><br><span class="line"><span class="built_in">module</span>.exports = loader</span><br></pre></td></tr></table></figure>
<p>这里我们看到使用二进制的好处是便于判断图片的大小</p>
<h2 id="手写-less-loader、css-loader-以及-style-loader"><a href="#手写-less-loader、css-loader-以及-style-loader" class="headerlink" title="手写 less-loader、css-loader 以及 style-loader"></a>手写 less-loader、css-loader 以及 style-loader</h2><p>由于上篇文章已经讲过 <code>less-loader</code> 以及 <code>style-loader</code> 的写法(那个时候将 <code>style-loader</code> 当成 <code>css-loader</code> 使用了，不过不影响讲解)，这里就列出 <code>less-loader</code> 以及 <code>style-loader</code> 的源码</p>
<p>首先还是要安装 <code>less</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yarn add less</span><br></pre></td></tr></table></figure>
<p>然后是 <code>webpack.config.js</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	test: <span class="regexp">/\.less$/</span>,</span><br><span class="line">	use: [<span class="string">'style-loader'</span>, <span class="string">'css-loader'</span>, <span class="string">'less-loader'</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意这里 <code>use</code> 数组的顺序不能变</strong></p>
<p><code>src/index.less</code></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">@color: red;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: @color;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>这里的分号必须是要的!!!</strong></p>
<p><code>src/index.js</code> 里面引入</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'./index.less'</span></span><br></pre></td></tr></table></figure>
<p>然后是 <code>less-loader.js</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> less = <span class="built_in">require</span>(<span class="string">'less'</span>)</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loader</span>(<span class="params">source</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> css = <span class="string">''</span></span><br><span class="line">  less.render(source, (err, c) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(c)</span><br><span class="line">    css = c.css</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> css</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = loader</span><br></pre></td></tr></table></figure>
<p>然后是 <code>style-loader</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loader</span>(<span class="params">source</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> str = <span class="string">`</span></span><br><span class="line"><span class="string">    let style = document.createElement('style')</span></span><br><span class="line"><span class="string">    style.innerHTML = <span class="subst">$&#123;<span class="built_in">JSON</span>.stringify(source)&#125;</span></span></span><br><span class="line"><span class="string">    document.head.appendChild(style)</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">  <span class="keyword">return</span> str</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = loader</span><br></pre></td></tr></table></figure>
<p>前面讲过，使用 <code>JSON.stringfy</code> 的原因是可以将源码转换成字符串，而且把里面的回车都转成 <code>\r\n</code></p>
<p>现在将 <code>index.less</code> 改成如下</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">@color: red;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: @color;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">url</span>(./assets/demo.jpg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>很显然，打包进 <code>dist/bundle.js</code> 中的文件路径直接在这里使用是引用不到的，因为 <code>dist</code> 目录下并没有 <code>assets/demo.jpg</code>。这时候就必须要写 <code>css-loader</code> 来解析这个 <code>less</code> 文件，首先就是要考虑到 <code>url(./assets/demo.jpg)</code>，将他变成 <code>url(require(./assets/demo.jpg))</code> 就可以了，因为有 <code>require</code> 的情况下 <code>webpack</code> 就会自动将其打包到 <code>bundle.js</code> 中了</p>
<p>那么怎么做呢？可以将这个 <code>index.less</code> 分为三个部分</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">【@color: red;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: @color;</span><br><span class="line">  background:】【 url(./assets/demo.jpg);】</span><br><span class="line">【&#125;】</span><br></pre></td></tr></table></figure>
<p>如上，用 “【】”包起来的就是一部分了，接下来看看 <code>css-loader.js</code> 的代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loader</span>(<span class="params">source</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 匹配 url(xxx) 这个东西, 用 g 表示全局查找，因为 less 文件里不只是只有一个 url</span></span><br><span class="line">  <span class="keyword">const</span> reg = <span class="regexp">/url\((.+?)\)/g</span></span><br><span class="line">  <span class="comment">// 匹配的指针位置</span></span><br><span class="line">  <span class="keyword">let</span> pos = <span class="number">0</span></span><br><span class="line">  <span class="comment">// 当前匹配的结果</span></span><br><span class="line">  <span class="keyword">let</span> current</span><br><span class="line">  <span class="comment">// 这个数组本质上就是保存一个代码段的</span></span><br><span class="line">  <span class="keyword">const</span> arr = [<span class="string">'let list = []'</span>]</span><br><span class="line">  <span class="comment">// 在 source 中循环匹配 reg</span></span><br><span class="line">  <span class="keyword">while</span>(current = reg.exec(source)) &#123;</span><br><span class="line">    <span class="comment">// 匹配到了 ['url(./assets/demo.jpg)', './assets/demo.jpg']</span></span><br><span class="line">    <span class="keyword">const</span> [matchUrl, g] = current</span><br><span class="line">    <span class="comment">// ↓ lastPos 位置</span></span><br><span class="line">    <span class="comment">// url(./assets/demo.jpg)</span></span><br><span class="line">    <span class="keyword">const</span> lastPos = reg.lastIndex - matchUrl.length</span><br><span class="line">    <span class="comment">// 截取第一部分</span></span><br><span class="line">    arr.push(<span class="string">`list.push(<span class="subst">$&#123;<span class="built_in">JSON</span>.stringify(source.slice(pos, lastPos))&#125;</span>)`</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指针移动</span></span><br><span class="line">    <span class="comment">// pos 位置             ↓</span></span><br><span class="line">    <span class="comment">// url(./assets/demo.jpg)</span></span><br><span class="line">    pos = reg.lastIndex</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 截取第二部分</span></span><br><span class="line">    <span class="comment">// 把 g 替换成 require 的写法</span></span><br><span class="line">    <span class="comment">// 即 './assets/demo.jpg' =&gt; require('./assets/demo.jpg')</span></span><br><span class="line">    arr.push(<span class="string">`list.push('url(' + require('<span class="subst">$&#123;g&#125;</span>') + ')')`</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 截取第三部分</span></span><br><span class="line">  arr.push(<span class="string">`list.push(<span class="subst">$&#123;<span class="built_in">JSON</span>.stringify(source.slice(pos))&#125;</span>)`</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将整个 less 文件作为一个模块返回，而这个模块是一整个字符串</span></span><br><span class="line">  <span class="comment">// 当 style-loader require 引入时，里面的代码就可以直接执行了</span></span><br><span class="line">  arr.push(<span class="string">`module.exports = list.join('')`</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 为了好看，每行代码之间增加一个回车</span></span><br><span class="line">  <span class="keyword">return</span> arr.join(<span class="string">'\r\n'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = loader</span><br></pre></td></tr></table></figure>
<p>这里主要的思路就是将如上的 <code>less</code> 中的代码看成三个部分，然后以匹配 <code>url</code> 为界点将代码分成三个部分，前两个部分都在循环匹配 <code>url</code>，然后将 <code>url</code> 里的路径改为 <code>require</code> 引入。匹配修改完成之后再截取剩下的第三部分。这里用了数组 <code>arr</code> 的方式将 <code>less</code> 代码转变成了另一段代码，而这段代码也是用数组的形式将 <code>less</code> 代码 <strong>拼凑起来</strong>，最后形成了一个 <strong>模块</strong>。到最后，<code>style-loader</code> 在使用 <code>require</code> 引入时就以字符串的形式引入了这些代码。</p>
<p>接下来改造 <code>style-loader.js</code>，增加 <code>pitch</code> 函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> loaderUtils = <span class="built_in">require</span>(<span class="string">'loader-utils'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通 loader</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loader</span>(<span class="params">source</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> str = <span class="string">`</span></span><br><span class="line"><span class="string">    let style = document.createElement('style')</span></span><br><span class="line"><span class="string">    style.innerHTML = <span class="subst">$&#123;<span class="built_in">JSON</span>.stringify(source)&#125;</span></span></span><br><span class="line"><span class="string">    document.head.appendChild(style)</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">  <span class="keyword">return</span> str</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// pitch 执行的顺序是 style-loader css-loader less-loader</span></span><br><span class="line"><span class="comment">// 这里 remainingRequest 剩余请求表示的就是 css-loader!less-loader!./index.less</span></span><br><span class="line"><span class="comment">// 也就是剩下的还没操作的 css-loader less-loader</span></span><br><span class="line">loader.pitch = <span class="function">(<span class="params">remainingRequest</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 使用 stringifyRequest 的作用是</span></span><br><span class="line">  <span class="comment">// 将请求转换为可以在 require() 或 import 中使用的字符串，同时避免使用绝对路径</span></span><br><span class="line">  <span class="keyword">const</span> req = loaderUtils.stringifyRequest(<span class="keyword">this</span>, <span class="string">'!!'</span> + remainingRequest</span><br><span class="line">  <span class="keyword">const</span> str = <span class="string">`</span></span><br><span class="line"><span class="string">    let style = document.createElement('style')</span></span><br><span class="line"><span class="string">    style.innerHTML = require(<span class="subst">$&#123;req&#125;</span>)</span></span><br><span class="line"><span class="string">    document.head.appendChild(style)</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">  <span class="keyword">return</span> str</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = loader</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意，这里使用 <code>stringifyRequest</code> 的意义在于，由于 webpack 在将模块路径转换为模块 id 之前<strong>会计算哈希值</strong>，因此在这里<strong>必须避免使用绝对路径</strong>，以确保不同编译之间的哈希值保持一致。</p>
</blockquote>
<p>这样写的好处就是，<code>style-loader</code> 的 <code>pitch loader</code> 会首先执行，但是上面的普通 <code>loader</code> 就不会执行了。这里参数 <code>remainingRequest</code> 相当于<strong>剩下的请求</strong>，打印出来其实就相当于<strong>局部路径</strong> <code>css-loader!less-loader!./index.less</code>。还记得前面说的这些感叹号的意思么？ <code>require(&#39;css-loader!less-loader!./index.less&#39;)</code> 表示<strong>内联 loader</strong>，优先级是 <strong>从右往左</strong>。但是这里就有个问题，<code>index.less</code> 会先从 <code>style-loader</code> 的 <code>pitch</code> 开始，因为有 <code>require</code> 的存在，会经过 <code>less-loader</code> 和 <code>css-loader</code>，然后又会经过 <code>style-loader</code> 的 <code>pitch</code>，这样一来就会死循环了。所以需要在 <code>require</code> 时添加 <strong>!!</strong>，也就是 <code>require(&#39;!!css-loader!less-loader!./index.less&#39;)</code>，这里 <strong>!!</strong> 号就表示执行完 <code>less-loader</code> 和 <code>css-loader</code> 就不会调用 <code>style-loader</code> 去执行了，也就解决了之前的死循环的问题。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文写了比较多的 <code>loader</code>，现在对 <code>loader</code> 一个最基本的认识就是 <code>loader</code> 就是一个 <strong>函数</strong>，一旦有模块被 <code>import</code> 或者 <code>require</code> 时它就会去拦截这些模块的源码，对其进行改造，然后输出到另一个模块中，循环往复，最终迭代到入口文件中，形成最终的代码<br>所以它的本质在于对代码的 <strong>拼凑</strong> 和 <strong>转换</strong>，其中用的比较多的库是 <code>loaderUtils</code>，这个工具库在写 <code>loader</code> 时必用，需要注意。</p>
<p>另，<a href="https://github.com/strugglebak/webpack-loader-test.git" target="_blank" rel="noopener">👉项目测试仓库戳这里</a></p>
]]></content>
      <categories>
        <category>前端工程化</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>从Webpack本质开始(四):手写tapable</title>
    <url>/2020/03/09/%E4%BB%8EWebpack%E6%9C%AC%E8%B4%A8%E5%BC%80%E5%A7%8B-%E5%9B%9B-%E6%89%8B%E5%86%99tapable/</url>
    <content><![CDATA[<blockquote>
<p>这个是探究 Webpack 本质的系列文章，会详细讲解如何手写一些源码如 Webpack, loader, plugin 等等，本文主要讲解的是如何手写 tapbable 库</p>
</blockquote>
<a id="more"></a>
<h2 id="tapable-是个啥"><a href="#tapable-是个啥" class="headerlink" title="tapable 是个啥"></a>tapable 是个啥</h2><p>由之前写的文章可以了解到，webpack 本质上是基于 <strong>事件流</strong> 的机制，它的工作流程就是将各个插件串联起来，而实现这一切的核心就是 <code>tapable</code>。<code>tapable</code> 就有点类似于 Node.js 的 <code>events</code> 库，核心原理也依赖于 <strong>发布订阅</strong> 模式</p>
<p>以下是 <code>tapable</code> 几个常用钩子</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;</span><br><span class="line">	SyncHook,</span><br><span class="line">	SyncBailHook,</span><br><span class="line">	SyncWaterfallHook,</span><br><span class="line">	SyncLoopHook,</span><br><span class="line"></span><br><span class="line">	AsyncParallelHook,</span><br><span class="line">	AsyncParallelBailHook,</span><br><span class="line">	AsyncSeriesHook,</span><br><span class="line">	AsyncSeriesBailHook,</span><br><span class="line">	AsyncSeriesWaterfallHook</span><br><span class="line"> &#125; = <span class="built_in">require</span>(<span class="string">"tapable"</span>)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>以 <code>Sync</code> 开头的都是同步钩子，以 <code>Async</code> 开头的都是异步钩子</p>
</blockquote>
<p>这些钩子基本上都是通过 <code>tap</code> 来绑定事件，然后使用 <code>call</code> 来触发事件，比如如下的代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; SyncHook &#125; = <span class="built_in">require</span>(<span class="string">'tapable'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.hooks = &#123;</span><br><span class="line">      <span class="comment">// new 一个钩子</span></span><br><span class="line">      arch: <span class="keyword">new</span> SyncHook([<span class="string">'name'</span>])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 注册监听函数</span></span><br><span class="line">  tap() &#123;</span><br><span class="line">    <span class="keyword">this</span>.hooks.arch.tap(<span class="string">'test1'</span>, (name) =&gt; &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'test1'</span>, name)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">this</span>.hooks.arch.tap(<span class="string">'test2'</span>, (name) =&gt; &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'test2'</span>, name)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 调用方法</span></span><br><span class="line">  call() &#123;</span><br><span class="line">    <span class="comment">// 'strugglebak' 就是 tap 函数中回调的 name</span></span><br><span class="line">    <span class="keyword">this</span>.hooks.arch.call(<span class="string">'strugglebak'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> t = <span class="keyword">new</span> Test()</span><br><span class="line">t.tap()</span><br><span class="line">t.call()</span><br></pre></td></tr></table></figure>
<p>执行下打印结果是</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">test1 strugglebak</span><br><span class="line">test2 strugglebak</span><br></pre></td></tr></table></figure>
<p>由以上可以看出，<code>tapable</code> 是将一堆 <code>tap</code> 中订阅的函数放到一个数组中去，调用 <code>call</code> 时分别按顺序去执行</p>
<h2 id="实现-SyncHook"><a href="#实现-SyncHook" class="headerlink" title="实现 SyncHook"></a>实现 SyncHook</h2><p>由以上的论证，代码不难实现</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SyncHook</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(args) &#123;</span><br><span class="line">    <span class="keyword">this</span>.tasks = []</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  tap(name, task) &#123;</span><br><span class="line">    <span class="keyword">this</span>.tasks.push(task)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// call 传入的不只有一个参数</span></span><br><span class="line">  call(...args) &#123;</span><br><span class="line">    <span class="keyword">this</span>.tasks.forEach(<span class="function"><span class="params">task</span> =&gt;</span> task(...args))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> hook = <span class="keyword">new</span> SyncHook([<span class="string">'name'</span>])</span><br><span class="line">hook.tap(<span class="string">'test1'</span>, (name) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'test1'</span>, name)</span><br><span class="line">&#125;)</span><br><span class="line">hook.tap(<span class="string">'test2'</span>, (name) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'test2'</span>, name)</span><br><span class="line">&#125;)</span><br><span class="line">hook.call(<span class="string">'strugglebak'</span>)</span><br></pre></td></tr></table></figure>
<p>打印结果为</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">test1 strugglebak</span><br><span class="line">test2 strugglebak</span><br></pre></td></tr></table></figure>
<h2 id="实现-SyncBailHook"><a href="#实现-SyncBailHook" class="headerlink" title="实现 SyncBailHook"></a>实现 SyncBailHook</h2><p>这个钩子的作用是，<strong>只要有任何的监听函数返回了一个非 undefined 的结果，那么该监听函数里面的逻辑在执行完成后会就不会继续向下执行了</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SyncBailHook</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(args) &#123;</span><br><span class="line">    <span class="keyword">this</span>.tasks = []</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  tap(name, task) &#123;</span><br><span class="line">    <span class="keyword">this</span>.tasks.push(task)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  call(...args) &#123;</span><br><span class="line">    <span class="keyword">let</span> index = <span class="number">0</span>, ret</span><br><span class="line">    <span class="keyword">const</span> &#123; length &#125; = <span class="keyword">this</span>.tasks</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      <span class="comment">// 每个任务里面调用函数并传参</span></span><br><span class="line">      ret = <span class="keyword">this</span>.tasks[index++](...args)</span><br><span class="line">      <span class="comment">// while 里面对其返回的结果做判断</span></span><br><span class="line">    &#125; <span class="keyword">while</span>(ret === <span class="literal">undefined</span> &amp;&amp; index &lt; length)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> hook = <span class="keyword">new</span> SyncBailHook([<span class="string">'name'</span>])</span><br><span class="line">hook.tap(<span class="string">'test1'</span>, (name) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'test1'</span>, name)</span><br><span class="line">&#125;)</span><br><span class="line">hook.tap(<span class="string">'test2'</span>, (name) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'test2'</span>, name)</span><br><span class="line">&#125;)</span><br><span class="line">hook.tap(<span class="string">'test3'</span>, (name) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'test3'</span>, name)</span><br><span class="line">  <span class="keyword">return</span> name</span><br><span class="line">&#125;)</span><br><span class="line">hook.tap(<span class="string">'test4'</span>, (name) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'test4'</span>, name)</span><br><span class="line">&#125;)</span><br><span class="line">hook.call(<span class="string">'strugglebak'</span>)</span><br></pre></td></tr></table></figure>
<p>打印结果</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">test1 strugglebak</span><br><span class="line">test2 strugglebak</span><br><span class="line">test3 strugglebak</span><br></pre></td></tr></table></figure>
<h2 id="实现-SyncWaterfallHook"><a href="#实现-SyncWaterfallHook" class="headerlink" title="实现 SyncWaterfallHook"></a>实现 SyncWaterfallHook</h2><p>这个钩子本质上就是，<strong>在调用函数的时候，将上一个函数的返回值作为下一个函数的参数</strong>，这样一个传递的流程</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SyncWaterfallHook</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(args) &#123;</span><br><span class="line">    <span class="keyword">this</span>.tasks = []</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  tap(name, task) &#123;</span><br><span class="line">    <span class="keyword">this</span>.tasks.push(task)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  call(...args) &#123;</span><br><span class="line">    <span class="keyword">const</span> [first, ...rest] = <span class="keyword">this</span>.tasks</span><br><span class="line">    <span class="keyword">const</span> ret = first(...args)</span><br><span class="line">    <span class="comment">// 由于是流水线式的传参数，所以这里可以用 reduce</span></span><br><span class="line">    rest.reduce(<span class="function">(<span class="params">acc, cur</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> cur(acc)</span><br><span class="line">    &#125;, ret) <span class="comment">// 初始传入是第一个函数的返回值</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> hook = <span class="keyword">new</span> SyncWaterfallHook([<span class="string">'name'</span>])</span><br><span class="line">hook.tap(<span class="string">'test1'</span>, (name) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'test1'</span>, name)</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'test1'</span></span><br><span class="line">&#125;)</span><br><span class="line">hook.tap(<span class="string">'test2'</span>, (data) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'test2'</span>, data)</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'test2'</span></span><br><span class="line">&#125;)</span><br><span class="line">hook.tap(<span class="string">'test3'</span>, (data) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'test3'</span>, data)</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'test3'</span></span><br><span class="line">&#125;)</span><br><span class="line">hook.tap(<span class="string">'test4'</span>, (data) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'test4'</span>, data)</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'test4'</span></span><br><span class="line">&#125;)</span><br><span class="line">hook.call(<span class="string">'strugglebak'</span>)</span><br></pre></td></tr></table></figure>
<p>打印结果</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">test1 strugglebak</span><br><span class="line">test2 test1</span><br><span class="line">test3 test2</span><br><span class="line">test4 test3</span><br></pre></td></tr></table></figure>
<h2 id="实现-SyncLoopHook"><a href="#实现-SyncLoopHook" class="headerlink" title="实现 SyncLoopHook"></a>实现 SyncLoopHook</h2><p>这个钩子的作用就是 <strong>当在同步执行时，遇到某个不返回 undefined 的函数会多次执行</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SyncLoopHook</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(args) &#123;</span><br><span class="line">    <span class="keyword">this</span>.tasks = []</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  tap(name, task) &#123;</span><br><span class="line">    <span class="keyword">this</span>.tasks.push(task)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  call(...args) &#123;</span><br><span class="line">    <span class="keyword">this</span>.tasks.forEach(<span class="function">(<span class="params">task</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> ret</span><br><span class="line">      <span class="comment">// 某个不返回 undefined 的函数会多次执行</span></span><br><span class="line">      <span class="keyword">do</span> &#123;</span><br><span class="line">        ret = task(...args)</span><br><span class="line">      &#125; <span class="keyword">while</span> (ret !== <span class="literal">undefined</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> hook = <span class="keyword">new</span> SyncLoopHook([<span class="string">'name'</span>])</span><br><span class="line"><span class="keyword">let</span> count = <span class="number">0</span></span><br><span class="line">hook.tap(<span class="string">'test1'</span>, (data) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'test1'</span>, data)</span><br><span class="line">  <span class="keyword">return</span> ++count === <span class="number">3</span> ? <span class="literal">undefined</span> : <span class="string">'keep going'</span></span><br><span class="line">&#125;)</span><br><span class="line">hook.tap(<span class="string">'test2'</span>, (data) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'test2'</span>, data)</span><br><span class="line">&#125;)</span><br><span class="line">hook.tap(<span class="string">'test3'</span>, (data) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'test3'</span>, data)</span><br><span class="line">&#125;)</span><br><span class="line">hook.tap(<span class="string">'test4'</span>, (data) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'test4'</span>, data)</span><br><span class="line">&#125;)</span><br><span class="line">hook.call(<span class="string">'strugglebak'</span>)</span><br></pre></td></tr></table></figure>
<p>打印结果</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">test1 strugglebak</span><br><span class="line">test1 strugglebak</span><br><span class="line">test1 strugglebak</span><br><span class="line">test2 strugglebak</span><br><span class="line">test3 strugglebak</span><br><span class="line">test4 strugglebak</span><br></pre></td></tr></table></figure>
<h2 id="实现-AsyncParallelHook"><a href="#实现-AsyncParallelHook" class="headerlink" title="实现 AsyncParallelHook"></a>实现 AsyncParallelHook</h2><p>首先需要说明的是，这是一个 <strong>异步并行</strong> 的钩子，所谓 “异步并行”，在这里的表现就是 <strong>需要等待所有并发的异步事件执行完成后再执行回调方法</strong></p>
<p>比如如下的代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; AsyncParallelHook &#125; = <span class="built_in">require</span>(<span class="string">'tapable'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.hooks = &#123;</span><br><span class="line">      arch: <span class="keyword">new</span> AsyncParallelHook([<span class="string">'name'</span>])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 注册监听函数</span></span><br><span class="line">  tapAsync() &#123;</span><br><span class="line">    <span class="keyword">this</span>.hooks.arch.tapAsync(<span class="string">'test1'</span>, (name, cb) =&gt; &#123;</span><br><span class="line">      <span class="comment">// 异步代码</span></span><br><span class="line">      setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'test1'</span>, name)</span><br><span class="line">        cb()</span><br><span class="line">      &#125;, <span class="number">1000</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">this</span>.hooks.arch.tapAsync(<span class="string">'test2'</span>, (name, cb) =&gt; &#123;</span><br><span class="line">      <span class="comment">// 异步代码</span></span><br><span class="line">      setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'test2'</span>, name)</span><br><span class="line">        cb()</span><br><span class="line">      &#125;, <span class="number">1000</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 调用方法</span></span><br><span class="line">  callAsync() &#123;</span><br><span class="line">    <span class="keyword">this</span>.hooks.arch.callAsync(<span class="string">'strugglebak'</span>, () =&gt; &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'end'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> t = <span class="keyword">new</span> Test()</span><br><span class="line">t.tapAsync()</span><br><span class="line">t.callAsync()</span><br></pre></td></tr></table></figure>
<p>打印输出为</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">test1 strugglebak</span><br><span class="line">test2 strugglebak</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>以上代码的意思是，只有当 <code>tapAsync</code> 里面的回调函数中，<code>cb</code> <strong>都执行完了</strong>，最后才会调用 <code>callAsync</code> 里的回调函数，即输出 <code>end</code></p>
<p>原理大致就是，每次执行完一个异步操作，就会调用 <code>cb</code>，而这个 <code>cb</code> 里面会有个计数器，如果计数器的总数等于当前回调函数注册的总数，就说明所有的异步操作执行完成，接着就可以执行最后的 <code>callAsync</code> 里面的回调了，所以代码可以这么写</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AsyncParallelHook</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(args) &#123;</span><br><span class="line">    <span class="keyword">this</span>.tasks = []</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  tapAsync(name, task) &#123;</span><br><span class="line">    <span class="keyword">this</span>.tasks.push(task)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  callAsync(...args) &#123;</span><br><span class="line">    <span class="comment">// 取出最后的函数</span></span><br><span class="line">    <span class="keyword">const</span> finalCallback = args.pop()</span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">0</span></span><br><span class="line">    <span class="comment">// 当注册的函数(cb)执行完成之后会执行 done 回调里的 finalCallback</span></span><br><span class="line">    <span class="keyword">const</span> done = <span class="function"><span class="params">()</span> =&gt;</span> &#123;(++count === <span class="keyword">this</span>.tasks.length) &amp;&amp; finalCallback()&#125;</span><br><span class="line">    <span class="keyword">this</span>.tasks.forEach(<span class="function">(<span class="params">task</span>) =&gt;</span> &#123;</span><br><span class="line">      task(...args, done)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试代码为</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> hook = <span class="keyword">new</span> AsyncParallelHook([<span class="string">'name'</span>])</span><br><span class="line">hook.tapAsync(<span class="string">'test1'</span>, (data, cb) =&gt; &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'test1'</span>, data)</span><br><span class="line">    cb()</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br><span class="line">hook.tapAsync(<span class="string">'test2'</span>, (data, cb) =&gt; &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'test2'</span>, data)</span><br><span class="line">    cb()</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br><span class="line">hook.callAsync(<span class="string">'strugglebak'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'end'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>打印输出为</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">test1 strugglebak</span><br><span class="line">test2 strugglebak</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>当然，以上的思想跟 <code>Promise.all</code> 很像，那么这种异步也可以用 <code>Promise</code> 来改写</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AsyncParallelHook</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(args) &#123;</span><br><span class="line">    <span class="keyword">this</span>.tasks = []</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  tapPromise(name, task) &#123;</span><br><span class="line">    <span class="keyword">this</span>.tasks.push(task)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  promise(...args) &#123;</span><br><span class="line">    <span class="comment">// 这里每个 task 都是 promise</span></span><br><span class="line">    <span class="keyword">const</span> tasks = <span class="keyword">this</span>.tasks.map(<span class="function"><span class="params">task</span> =&gt;</span> task(...args))</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.all(tasks)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试代码为</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> hook = <span class="keyword">new</span> AsyncParallelHook([<span class="string">'name'</span>])</span><br><span class="line">hook.tapPromise(<span class="string">'test1'</span>, (data) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'test1'</span>, data)</span><br><span class="line">      resolve(data)</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line">hook.tapPromise(<span class="string">'test2'</span>, (data) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'test2'</span>, data)</span><br><span class="line">      resolve(data)</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line">hook.promise(<span class="string">'strugglebak'</span>).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'end'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>测试结果为</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">test1 strugglebak</span><br><span class="line">test2 strugglebak</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<h2 id="实现-AsyncSeriesHook"><a href="#实现-AsyncSeriesHook" class="headerlink" title="实现 AsyncSeriesHook"></a>实现 AsyncSeriesHook</h2><p>注意这个是 <strong>异步串行</strong> 的钩子，而 <strong>异步串行</strong> 表示只有执行完 <strong>异步 1</strong> 之后才可以执行 <strong>异步 2</strong>，能够这么实现的就是使用回调函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AsyncSerieslHook</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(args) &#123;</span><br><span class="line">    <span class="keyword">this</span>.tasks = []</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  tapAsync(name, task) &#123;</span><br><span class="line">    <span class="keyword">this</span>.tasks.push(task)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  callAsync(...args) &#123;</span><br><span class="line">    <span class="comment">// 取出最后的函数</span></span><br><span class="line">    <span class="keyword">const</span> finalCallback = args.pop()</span><br><span class="line">    <span class="keyword">let</span> index = <span class="number">0</span></span><br><span class="line">    <span class="keyword">const</span> next = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (index === <span class="keyword">this</span>.tasks.length) <span class="keyword">return</span> finalCallback()</span><br><span class="line">      <span class="keyword">const</span> task = <span class="keyword">this</span>.tasks[index++]</span><br><span class="line">      <span class="comment">// 可以看出这里 next 是递归去在执行的</span></span><br><span class="line">      <span class="comment">// 这里的思想有点像 express 中间件</span></span><br><span class="line">      task(...args, next)</span><br><span class="line">    &#125;</span><br><span class="line">    next()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试代码为</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> hook = <span class="keyword">new</span> AsyncSerieslHook([<span class="string">'name'</span>])</span><br><span class="line">hook.tapAsync(<span class="string">'test1'</span>, (data, cb) =&gt; &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'test1'</span>, data)</span><br><span class="line">    cb()</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br><span class="line">hook.tapAsync(<span class="string">'test2'</span>, (data, cb) =&gt; &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'test2'</span>, data)</span><br><span class="line">    cb()</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br><span class="line">hook.callAsync(<span class="string">'strugglebak'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'end'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>打印输出为</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">test1 strugglebak</span><br><span class="line">test1 strugglebak</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>当然，有异步的地方也可以改写成 <code>Promise</code> 的形式，如下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AsyncSerieslHook</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(args) &#123;</span><br><span class="line">    <span class="keyword">this</span>.tasks = []</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  tapPromise(name, task) &#123;</span><br><span class="line">    <span class="keyword">this</span>.tasks.push(task)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  promise(...args) &#123;</span><br><span class="line">    <span class="comment">// 注意这里 tasks 是一个 promise 的数组</span></span><br><span class="line">    <span class="keyword">const</span> [first, ...rest] = <span class="keyword">this</span>.tasks</span><br><span class="line">    <span class="keyword">const</span> ret = first(...args)</span><br><span class="line">    <span class="keyword">return</span> rest.reduce(<span class="function">(<span class="params">acc, cur</span>) =&gt;</span> &#123; <span class="comment">// 有些像 redux 的思想</span></span><br><span class="line">      <span class="keyword">return</span> acc.then(<span class="function"><span class="params">()</span> =&gt;</span> cur(...args)) <span class="comment">// promise 串行执行用 reduce</span></span><br><span class="line">    &#125;, ret)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试代码为</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> hook = <span class="keyword">new</span> AsyncSerieslHook([<span class="string">'name'</span>])</span><br><span class="line">hook.tapPromise(<span class="string">'test1'</span>, (data) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resovle, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'test1'</span>, data)</span><br><span class="line">      resovle(data)</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line">hook.tapPromise(<span class="string">'test2'</span>, (data) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resovle, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'test2'</span>, data)</span><br><span class="line">      resovle(data)</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line">hook.promise(<span class="string">'strugglebak'</span>).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'end'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>打印输出为</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">test1 strugglebak</span><br><span class="line">test2 strugglebak</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<h2 id="实现-AsyncSeriesWaterfallHook"><a href="#实现-AsyncSeriesWaterfallHook" class="headerlink" title="实现 AsyncSeriesWaterfallHook"></a>实现 AsyncSeriesWaterfallHook</h2><p>这里顾名思义，就是 <strong>异步 + 串行 + waterfall 钩子</strong>，那么代码应该这么写</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AsyncSeriesWaterfalllHook</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(args) &#123;</span><br><span class="line">    <span class="keyword">this</span>.tasks = []</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  tapAsync(name, task) &#123;</span><br><span class="line">    <span class="keyword">this</span>.tasks.push(task)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  callAsync(...args) &#123;</span><br><span class="line">    <span class="keyword">const</span> finalCallback = args.pop()</span><br><span class="line">    <span class="keyword">let</span> index = <span class="number">0</span></span><br><span class="line">    <span class="comment">// 这里需要异步迭代</span></span><br><span class="line">    <span class="keyword">const</span> next = <span class="function">(<span class="params">error, data</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> task = <span class="keyword">this</span>.tasks[index]</span><br><span class="line">      <span class="comment">// 如果没有注册函数，直接调用 callAsync 的回调</span></span><br><span class="line">      <span class="keyword">if</span> (!task) <span class="keyword">return</span> finalCallback()</span><br><span class="line">      <span class="keyword">if</span> (index === <span class="number">0</span>) &#123; <span class="comment">// 如果执行的是第一个注册的函数</span></span><br><span class="line">        <span class="comment">// 这里的 next 就是 cb</span></span><br><span class="line">        task(...args, next)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123; <span class="comment">// 如果执行的不是第一个注册的函数，这里就应该传 data</span></span><br><span class="line">        <span class="comment">// 因为这里是迭代传了，不应该传 args 而应该传 data</span></span><br><span class="line">        task(data, next)</span><br><span class="line">      &#125;</span><br><span class="line">      ++index</span><br><span class="line">    &#125;</span><br><span class="line">    next()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试代码为</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> hook = <span class="keyword">new</span> AsyncSeriesWaterfalllHook([<span class="string">'name'</span>])</span><br><span class="line">hook.tapAsync(<span class="string">'test1'</span>, (data, cb) =&gt; &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'test1'</span>, data)</span><br><span class="line">    cb(<span class="literal">null</span>, <span class="string">'hello world'</span>)</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br><span class="line">hook.tapAsync(<span class="string">'test2'</span>, (data, cb) =&gt; &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'test2'</span>, data)</span><br><span class="line">    cb(<span class="literal">null</span>)</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br><span class="line">hook.callAsync(<span class="string">'strugglebak'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'end'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>打印结果为</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">test1 strugglebak</span><br><span class="line">test2 hello world</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>当然，这里也可以用 <code>Promise</code> 改写</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AsyncSeriesWaterfalllHook</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(args) &#123;</span><br><span class="line">    <span class="keyword">this</span>.tasks = []</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  tapPromise(name, task) &#123;</span><br><span class="line">    <span class="keyword">this</span>.tasks.push(task)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  promise(...args) &#123;</span><br><span class="line">    <span class="keyword">const</span> [first, ...rest] = <span class="keyword">this</span>.tasks</span><br><span class="line">    <span class="keyword">const</span> ret = first(...args)</span><br><span class="line">    <span class="keyword">return</span> rest.reduce(<span class="function">(<span class="params">acc, cur</span>) =&gt;</span> &#123; <span class="comment">// 这里的代码可以参考之前写 SyncWaterfallHook 的</span></span><br><span class="line">      <span class="keyword">return</span> acc.then(<span class="function">(<span class="params">data</span>) =&gt;</span> cur(data))</span><br><span class="line">    &#125;, ret)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试代码为</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> hook = <span class="keyword">new</span> AsyncSeriesWaterfalllHook([<span class="string">'name'</span>])</span><br><span class="line">hook.tapPromise(<span class="string">'test1'</span>, (data) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resovle, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'test1'</span>, data)</span><br><span class="line">      resovle(<span class="string">'hello world'</span>)</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line">hook.tapPromise(<span class="string">'test2'</span>, (data, cb) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resole, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'test2'</span>, data)</span><br><span class="line">      resole(<span class="literal">null</span>)</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line">hook.promise(<span class="string">'strugglebak'</span>).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'end'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>打印结果为</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">test1 strugglebak</span><br><span class="line">test2 hello world</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>由以上的描述我们可以看出一个规律，那就是</p>
<ul>
<li>tapable 库中有 3 种注册方法: tap(同步注册)、tapAsync(cb) (异步注册)、tapPromise(注册时是 promise)</li>
<li>tapable 库中有 3 种调用方法: call(同步调用)、callAsync(cb)(异步调用)、promise(调用时是 promise 用 .then)</li>
</ul>
<p>以上三者两两对应</p>
<p>同时，我们也知道了，对于 <code>tapable</code> 这个库的钩子来说，分同步钩子和异步钩子，同时钩子还分并行和串行钩子</p>
<p>对于异步并行钩子来说，异步的操作可以是同时发生的，即哪个执行快就先执行<br>对于异步串行钩子来说，异步的操作是依赖于上个异步的结果的，只有等上个异步执行了，才能执行下个异步</p>
]]></content>
      <categories>
        <category>前端工程化</category>
      </categories>
      <tags>
        <tag>tapable</tag>
      </tags>
  </entry>
  <entry>
    <title>块级元素与行内元素的区别</title>
    <url>/2019/01/12/%E5%9D%97%E7%BA%A7%E5%85%83%E7%B4%A0%E4%B8%8E%E8%A1%8C%E5%86%85%E5%85%83%E7%B4%A0%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h2 id="主要的块级元素"><a href="#主要的块级元素" class="headerlink" title="主要的块级元素"></a>主要的块级元素</h2><ul>
<li>文档分区: <code>&lt;div&gt;</code></li>
<li>标题: <code>&lt;h1&gt; &lt;h2&gt; &lt;h3&gt; &lt;h4&gt; &lt;h5&gt; &lt;h6&gt;</code></li>
<li>段落行: <code>&lt;p&gt;</code></li>
<li>列表: <code>&lt;ul&gt; &lt;ol&gt;</code></li>
<li>表单: <code>&lt;form&gt;</code></li>
<li>预格式化文本: <code>&lt;pre&gt;</code></li>
<li>其他标签: <code>&lt;header&gt; &lt;nav&gt; &lt;section&gt; &lt;article&gt;</code></li>
</ul>
<h2 id="主要的行内元素"><a href="#主要的行内元素" class="headerlink" title="主要的行内元素"></a>主要的行内元素</h2><ul>
<li>表单: <code>&lt;input&gt; &lt;button&gt; &lt;textarea&gt; &lt;select&gt; &lt;label&gt;</code></li>
<li>强调: <code>&lt;strong&gt; &lt;em&gt;</code></li>
<li>小块内容: <code>&lt;span&gt;</code></li>
<li>超链接: <code>&lt;a&gt;</code></li>
<li>图片: <code>&lt;img&gt;</code></li>
<li>换行: <code>&lt;br&gt;</code></li>
<li>代码块: <code>&lt;code&gt;</code></li>
<li>脚本: <code>&lt;script&gt;</code></li>
</ul>
<h2 id="主要区别"><a href="#主要区别" class="headerlink" title="主要区别"></a>主要区别</h2><table>
<thead>
<tr>
<th>区别</th>
<th>块级元素</th>
<th>行内元素</th>
</tr>
</thead>
<tbody>
<tr>
<td>width</td>
<td>与爸爸元素的宽度一致</td>
<td>宽度就是内容宽度,设置 width 没用</td>
</tr>
<tr>
<td>height</td>
<td>可以设置,如果没有设置，高度与儿子元素高度一致</td>
<td>设置高度同样没用</td>
</tr>
<tr>
<td>margin 和 padding</td>
<td>设置上下左右都有用</td>
<td>设置上下没用，设置左右可以</td>
</tr>
<tr>
<td>vertical-align</td>
<td>设置对包含的<strong>行内元素</strong>有用</td>
<td>没用</td>
</tr>
<tr>
<td>放置情况</td>
<td>另起一行放在前一个元素的下面</td>
<td>一串文字流</td>
</tr>
<tr>
<td>浮动情况</td>
<td>浮动并挤入上一行(条件是上一行宽度够)</td>
<td>几乎变成了个块级元素</td>
</tr>
</tbody>
</table>
<p>注意几点</p>
<ul>
<li><code>&lt;img&gt;</code> 这个标签是个很特殊的元素，它同时具有块级元素与行内元素两者的特点(replace element)</li>
<li>块级元素里面既可以有块级元素，也可以有行内元素(感觉像是废话…)</li>
<li>若不做任何 css 设置,则行内元素里面只能有行内元素</li>
</ul>
]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>html5</tag>
      </tags>
  </entry>
  <entry>
    <title>实现AJAX以及Promise</title>
    <url>/2019/02/20/%E5%AE%9E%E7%8E%B0AJAX%E4%BB%A5%E5%8F%8APromise/</url>
    <content><![CDATA[<h2 id="JS-操作请求与响应"><a href="#JS-操作请求与响应" class="headerlink" title="JS 操作请求与响应"></a>JS 操作请求与响应</h2><ul>
<li><p>客户端的JS发起请求（浏览器上的）<br>  使用 <code>XMLHttpRequest</code> 的 <code>setRequestHeader</code> 修改请求头的第二部分<br>  使用 <code>send</code> 修改请求头第四部分<br>  使用 <code>getAllResponseHeaders</code> 获取全部的响应头<br>  使用 <code>getResponseHeader</code> 获取响应头第二部分<br>  使用 <code>statusText</code> 获取到响应状态是否 OK<br>  使用 <code>responseText</code> 获取响应头第四部分</p>
<p>  AJAX 设置请求<br>  第一部分 request.open(‘get’, ‘/xxx’);<br>  第二部分 request.setHeader(‘ContentType’, ‘x-www-form-urlencodeed’);<br>  第四部分 request.send(‘a=1&amp;b=2’);</p>
<p>  AJAX 设置响应<br>  第一部分 request.status / request.statusText<br>  第二部分 request.getResponseHeader() / request.getAllResponseHeaders()<br>  第四部分 request.responseText</p>
</li>
<li><p>服务端的JS发送响应（Node.js上的）<br>  待续</p>
</li>
</ul>
<h2 id="自己实现-jQuery-ajax"><a href="#自己实现-jQuery-ajax" class="headerlink" title="自己实现 jQuery.ajax"></a>自己实现 jQuery.ajax</h2><p>就是对 ajax 的封装,代码如下<br><figure class="highlight qml"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.jQuery.ajax = <span class="function"><span class="keyword">function</span>(<span class="params">url, method, body, success, fail</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> request = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">    request.open(method, <span class="built_in">url</span>);</span><br><span class="line">    request.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (request.readyState === <span class="number">4</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (request.status &gt;= <span class="number">200</span> &amp;&amp; request.status &lt; <span class="number">300</span>) &#123;</span><br><span class="line">                <span class="comment">// 成功就打印出响应</span></span><br><span class="line">                success.call(<span class="literal">undefined</span>, request.responseText);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (request.status &gt;= <span class="number">400</span>) &#123;</span><br><span class="line">                <span class="comment">// 失败就打印出 request</span></span><br><span class="line">                fail.call(<span class="literal">undefined</span>, request);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// body 为消息实体,即为 HTTP 请求的第 4 部分</span></span><br><span class="line">    request.send(body);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重命名</span></span><br><span class="line"><span class="built_in">window</span>.$ = <span class="built_in">window</span>.jQuery;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义成功回调函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">success</span>(<span class="params">responseText</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(responseText);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fail</span>(<span class="params">request</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(request);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="ES-6-语法之解构赋值"><a href="#ES-6-语法之解构赋值" class="headerlink" title="ES 6 语法之解构赋值"></a>ES 6 语法之解构赋值</h2><p>比如有这样的赋值<br><figure class="highlight nix"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">method</span> = options.method</span><br><span class="line"><span class="keyword">let</span> <span class="attr">body</span> = options.body</span><br><span class="line"><span class="keyword">let</span> <span class="attr">successFn</span> = options.successFn</span><br><span class="line"><span class="keyword">let</span> <span class="attr">failFn</span> = options.failFn</span><br><span class="line"><span class="keyword">let</span> <span class="attr">headers</span> = options.headers</span><br></pre></td></tr></table></figure></p>
<p>在 ES 6 中是这样赋值的<br><figure class="highlight ceylon"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 析构赋值</span></span><br><span class="line"><span class="keyword">let</span> &#123;method, body, successFn, failFn, headers&#125; = options</span><br></pre></td></tr></table></figure></p>
<p>跟 <code>python</code> 一些语法有点像<br>又例如<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ES5</span></span><br><span class="line">f = <span class="function"><span class="keyword">function</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ES6</span></span><br><span class="line">f2 = <span class="function">(<span class="params">a</span>)=&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES5</span></span><br><span class="line"><span class="keyword">var</span> x = <span class="string">'???'</span>;</span><br><span class="line"><span class="keyword">var</span> o = &#123;&#125;;</span><br><span class="line">o[x] = <span class="literal">true</span>; <span class="comment">// '???' as key</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6</span></span><br><span class="line"><span class="keyword">var</span> x = <span class="string">'???'</span>;</span><br><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">    [x]: <span class="literal">true</span> <span class="comment">// [x] is '???'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="promise"><a href="#promise" class="headerlink" title="promise"></a>promise</h2><p>一个确定函数形式的 <strong>规范</strong><br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">success</span>(<span class="params">responseText</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(responseText);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fail</span>(<span class="params">request</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(request);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">myButton.addEventListener(<span class="string">'click'</span>, (e)=&gt; &#123;</span><br><span class="line">    $.ajax(&#123;</span><br><span class="line">        url: <span class="string">'/frank'</span>,</span><br><span class="line">        method: <span class="string">'get'</span></span><br><span class="line">    &#125;).then(success, fail); <span class="comment">// 成功调用 success , 失败调用 fail</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>这样一来就不用管成功或者是失败用的函数名是什么了</p>
<figure class="highlight coffeescript"><table><tr><td class="code"><pre><span class="line">myButton.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="params">(e)</span>=&gt;</span> &#123;</span><br><span class="line">    $.ajax(&#123;</span><br><span class="line">        url: <span class="string">'/frank'</span>,</span><br><span class="line">        method: <span class="string">'get'</span></span><br><span class="line">    &#125;).<span class="keyword">then</span>(</span><br><span class="line">            (responseText)=&gt; &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(responseText);</span><br><span class="line">                <span class="keyword">return</span> responseText;</span><br><span class="line">            &#125;,</span><br><span class="line">            (request)=&gt; &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(request);</span><br><span class="line">                <span class="keyword">return</span> request;</span><br><span class="line">            &#125;</span><br><span class="line">    ).<span class="keyword">then</span>(</span><br><span class="line">        (上一次的处理结果)=&gt; &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(上一次的处理结果);</span><br><span class="line">        &#125;,</span><br><span class="line">        (request)=&gt; &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(request);</span><br><span class="line">        &#125;</span><br><span class="line">    );</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>以上就是对同一个状态进行多次处理</p>
<p>在自己写的 ajax 里面添加<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.jQuery.ajax = <span class="function"><span class="keyword">function</span>(<span class="params">&#123;url, method, body, headers&#125;</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">        <span class="comment">//... ajax 逻辑代码</span></span><br><span class="line">        <span class="keyword">let</span> request = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">        request.open(method, url);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> headers) &#123;</span><br><span class="line">            <span class="keyword">let</span> value = headers[key];</span><br><span class="line">            request.setRequestHeader(value);</span><br><span class="line">        &#125;</span><br><span class="line">        request.onreadystatechange = <span class="function"><span class="params">()</span>=&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (request.readyState === <span class="number">4</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (request.status &gt;= <span class="number">200</span> &amp;&amp; request.status &lt; <span class="number">300</span>) &#123;</span><br><span class="line">                    <span class="comment">// 注意这里用的是 resovle</span></span><br><span class="line">                    resolve.call(<span class="literal">undefined</span>, request.responseText);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (request.status &gt;= <span class="number">400</span>) &#123;</span><br><span class="line">                    <span class="comment">// 注意这里用的是 reject</span></span><br><span class="line">                    reject.call(<span class="literal">undefined</span>, request);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        request.send(body);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这是 <code>window</code> 下的一个全局属性叫 <code>Promise</code><br>那么如何调用呢<br><figure class="highlight coffeescript"><table><tr><td class="code"><pre><span class="line">myButton.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="params">(e)</span>=&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">window</span>.jQuery.ajax(&#123;</span><br><span class="line">        url: <span class="string">'/frank'</span>,</span><br><span class="line">        method: <span class="string">'get'</span>,</span><br><span class="line">        headers: &#123;</span><br><span class="line">            <span class="string">'Content-Type:'</span>, <span class="string">'application/x-www-form-urlencoded'</span>,</span><br><span class="line">            <span class="string">'frank'</span>: <span class="string">'18'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).<span class="keyword">then</span>(</span><br><span class="line">        (text)=&gt; &#123;<span class="built_in">console</span>.log(text);&#125;, <span class="regexp">//</span> 成功调用</span><br><span class="line">        (request)=&gt; &#123;<span class="built_in">console</span>.log(request);&#125; <span class="regexp">//</span> 失败调用</span><br><span class="line">    );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>而 <code>Promise</code> 的源码大致是这样的<br><figure class="highlight qml"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.Promise = <span class="function"><span class="keyword">function</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attribute">then</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意，假设有这样的一个 <code>Promise</code> 对象 <code>xxx</code>,在调用 <code>then</code> 的时候出现以下情况<br><figure class="highlight erlang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">xxx</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    .<span class="title">then</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        fn1, fn2</span></span></span><br><span class="line"><span class="function"><span class="params">    )</span></span></span><br><span class="line"><span class="function">    .<span class="title">then</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        fn3, fn4</span></span></span><br><span class="line"><span class="function"><span class="params">    )</span></span></span><br></pre></td></tr></table></figure></p>
<p><strong>fn3 是在 fn1 以及 fn2 都没有问题的情况下调用</strong><br><strong>fn4 是在 fn1 或者 fn2 有问题的情况下调用</strong></p>
]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>ajax</tag>
        <tag>promise</tag>
      </tags>
  </entry>
  <entry>
    <title>尝试理解一下MVC</title>
    <url>/2019/02/20/%E5%B0%9D%E8%AF%95%E7%90%86%E8%A7%A3%E4%B8%80%E4%B8%8BMVC/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>MVC (Model View Controller)， 即 模型 视图 控制器，我觉得这里可以用 <strong>内容行为样式分离</strong> 来简单理解一下</p>
<ul>
<li>用 html 来写样式?<br> 那么整个 html 中就会充斥着很多无用的标签, html 的逻辑结构会变得很复杂</li>
<li><p>用 css 来写内容?</p>
<ul>
<li><p>代码如下</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">'hello world'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样在浏览器呈现的页面上会选不中这个 div,并且 JS 也取不到</p>
</li>
</ul>
</li>
<li>用 css 表示行为??<br>  IE 时代有过,不过这个 css 不仅要表示样式,还要控制一些复杂逻辑,会使得整个页面加载变慢</li>
<li><p>JS 控制样式??像如下代码</p>
  <figure class="highlight gams"><table><tr><td class="code"><pre><span class="line">var <span class="symbol">$</span><span class="built-in">div</span> = <span class="symbol">$</span>(<span class="string">'#x'</span>);</span><br><span class="line"><span class="meta"><span class="meta-keyword">$div</span>.hide();</span></span><br><span class="line"><span class="meta"><span class="meta-keyword">$div</span>.show();</span></span><br></pre></td></tr></table></figure>
<p>  那么上面代码 <code>hide</code> 之后 <code>div.style.display</code> 就不确定了</p>
</li>
</ul>
<h2 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h2><p>通过前面的描述，我们就知道，需要代码进行模块化了，而想让代码模块之间没有影响，必须要做到如下几点</p>
<ul>
<li><p>使用立即执行函数将模块包起来</p>
<ol>
<li>我们不想要全局变量</li>
<li>我们要使用局部变量</li>
<li>ES 5 里面，只有函数有局部变量</li>
<li>于是我们声明一个 function xxx，然后 xxx.call()</li>
<li>这个时候 xxx 是全局变量（全局函数）</li>
<li>所以我们不能给这个函数名字</li>
<li>function(){}.call()</li>
<li>但是 Chrome 报错，语法错误</li>
<li><p>试出来一种方法可以不报错:<br> i. !function(){}.call() (我们不在乎这个匿名函数的返回值，所以加个 ! 取反没关系)<br> ii. (function(){}).call() 不推荐</p>
<p>  xxx<br>  (function(){}).call() 报错,这种方法会被浏览器当作<br>  xxx(function(){}).call() 执行</p>
<p> iii. frank192837192463981273912873098127912378.call() 不推荐, 就是函数名后加一串随机数</p>
</li>
</ol>
</li>
<li><p>使用闭包<br>  如以下代码</p>
  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 模块一定义</span></span><br><span class="line">!<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> person = &#123;</span><br><span class="line">        name: <span class="string">'frank'</span>,</span><br><span class="line">        age: <span class="number">18</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">window</span>.frankGrowUp = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        person.age += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> person.age;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;.call();</span><br><span class="line"><span class="comment">// 模块二调用</span></span><br><span class="line">!<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> newAge = <span class="built_in">window</span>.frankGrowUp();</span><br><span class="line">    <span class="built_in">console</span>.log(newAge); <span class="comment">// 19</span></span><br><span class="line">&#125;.call();</span><br></pre></td></tr></table></figure>
<p>  从以上代码可以看出</p>
<ol>
<li>立即执行函数使得 person 无法被外部访问</li>
<li>闭包使得匿名函数可以操作 person</li>
<li>window.frankGrowUp 保存了匿名函数的地址</li>
<li>任何地方都可以使用 window.frankGrowUp<br>=&gt; 任何地方都可以使用 window.frankGrowUp 操作 person，但是不能直接访问 person</li>
</ol>
</li>
<li><p>然后用 js 文件将这些代码包起来<br>  就是将代码写入到这些 js 文件中，然后在页面上用 script 标签引入即可，注意 js 文件名要与实现代码功能相关</p>
</li>
</ul>
<h2 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h2><p>view 就相当于 html，就是能看得见的那一块东西<br>controller 属于操作 view 的一些事件逻辑用的,一般 controller 的写法如下<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> view = <span class="built_in">document</span>.querySelector();</span><br><span class="line"><span class="keyword">let</span> controller = <span class="function"><span class="keyword">function</span>(<span class="params">view</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 操作 view 的代码逻辑</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用 controller</span></span><br><span class="line">controller.call(view);</span><br></pre></td></tr></table></figure></p>
<p>更高级一点的写法<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> view = <span class="built_in">document</span>.querySelector();</span><br><span class="line"><span class="keyword">let</span> controller = &#123;</span><br><span class="line">    view: <span class="literal">null</span>,</span><br><span class="line">    init: <span class="function"><span class="keyword">function</span>(<span class="params">view</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.view = view;</span><br><span class="line">        <span class="keyword">this</span>.bindEvents(); <span class="comment">// 调用定义的事件绑定,这里相当于代码 this.bindEvents.call(this);</span></span><br><span class="line">    &#125;,</span><br><span class="line">    bindEvents: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> view = <span class="keyword">this</span>.view;</span><br><span class="line">        <span class="built_in">window</span>.addEventListener(<span class="string">'事件'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="comment">// 绑定事件操作逻辑代码</span></span><br><span class="line">            ...</span><br><span class="line">            <span class="comment">// active or deactive code according to your condition</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    active: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 激活添加类</span></span><br><span class="line">    &#125;,</span><br><span class="line">    deactive: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 去激活添加类</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用 controller, 这里代码相当于 controller.init.call(controller, view);</span></span><br><span class="line">controller.init(view);</span><br></pre></td></tr></table></figure></p>
<p>继续优化，使用箭头函数，那么箭头函数外的 <code>this</code> 就可以拿到箭头函数里面使用，而不用担心 <code>this</code> 的指向问题,即<strong>箭头函数内外 <code>this</code> 不变</strong>,如<br><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">bindEvents: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> view = <span class="keyword">this</span>.view;</span><br><span class="line">    <span class="built_in">window</span>.addEventListener(<span class="string">'事件'</span>, <span class="function"><span class="params">()</span>=&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>); <span class="comment">// this 在这里就指向 controller</span></span><br><span class="line">        <span class="comment">// 绑定事件操作逻辑代码</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p>Model 就是模型，跟数据相关，一般来说它的写法是这样<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> model = &#123; <span class="comment">// 获取数据</span></span><br><span class="line">    fetch: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> 一个 <span class="built_in">Promise</span> 对象</span><br><span class="line">    &#125;,</span><br><span class="line">    save: <span class="function"><span class="keyword">function</span>(<span class="params">name, content</span>) </span>&#123; <span class="comment">// 保存数据</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// 存入数据</span></span><br><span class="line">        <span class="keyword">return</span> 一个 <span class="built_in">Promise</span> 对象</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>整个 MVC 的逻辑图如下所示<br><img src="./img1.png" alt></p>
<h2 id="总结代码"><a href="#总结代码" class="headerlink" title="总结代码"></a>总结代码</h2><h3 id="Model"><a href="#Model" class="headerlink" title="Model"></a>Model</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.Model = <span class="function"><span class="keyword">function</span>(<span class="params">object</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> resourceName = object.resourceName;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        init: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        &#125;,</span><br><span class="line">        fetch: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        &#125;,</span><br><span class="line">        save: <span class="function"><span class="keyword">function</span> (<span class="params">object</span>) </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="View"><a href="#View" class="headerlink" title="View"></a>View</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.View = <span class="function"><span class="keyword">function</span>(<span class="params">xxx</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">document</span>.querySelector(xxx);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a>Controller</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">window.Controller = function(options) &#123;</span><br><span class="line">    <span class="keyword">var</span> <span class="keyword">init</span> = options.<span class="keyword">init</span>;</span><br><span class="line">    let <span class="keyword">object</span> = &#123;</span><br><span class="line">        view: <span class="literal">null</span>,</span><br><span class="line">        model: <span class="literal">null</span>,</span><br><span class="line">        <span class="keyword">init</span>: function(view, model)&#123;</span><br><span class="line">            <span class="keyword">this</span>.view = view;</span><br><span class="line">            <span class="keyword">this</span>.model = model;</span><br><span class="line">            <span class="keyword">this</span>.model.<span class="keyword">init</span>();</span><br><span class="line">            <span class="keyword">init</span>.call(<span class="keyword">this</span>, view, model);</span><br><span class="line">            <span class="keyword">this</span>.bindEvents();</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">for</span> (let key <span class="keyword">in</span> options) &#123;</span><br><span class="line">        <span class="keyword">if</span> (key !== <span class="string">'init'</span>) &#123;</span><br><span class="line">            <span class="keyword">object</span>[key] = options[key];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">object</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="或者也可以这么写"><a href="#或者也可以这么写" class="headerlink" title="或者也可以这么写"></a>或者也可以这么写</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> model = &#123;</span><br><span class="line">    <span class="keyword">data</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="keyword">init</span>()&#123;&#125;, <span class="comment">// model 初始化</span></span><br><span class="line">    fetch()&#123;&#125;, <span class="comment">// model 的数据获取</span></span><br><span class="line">    save()&#123;&#125; <span class="comment">// model 的数据保存</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> view = &#123;</span><br><span class="line">    <span class="keyword">init</span>() &#123;&#125;, <span class="comment">// view 初始化</span></span><br><span class="line">    template: <span class="string">'html 内容'</span> <span class="comment">// view 网页上的内容</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> controller = &#123;</span><br><span class="line">    view: <span class="literal">null</span>,</span><br><span class="line">    model: <span class="literal">null</span>,</span><br><span class="line">    <span class="keyword">init</span>(view, model)&#123;</span><br><span class="line">        <span class="comment">// 获取到 view 以及 model 的实例</span></span><br><span class="line">        <span class="keyword">this</span>.view = view;</span><br><span class="line">        <span class="keyword">this</span>.model = model;</span><br><span class="line">        <span class="comment">// 分别调用 view 以及 model 的初始化函数对其进行初始化操作</span></span><br><span class="line">        <span class="keyword">this</span>.view.<span class="keyword">init</span>.call(<span class="keyword">this</span>.view);</span><br><span class="line">        <span class="keyword">this</span>.model.<span class="keyword">init</span>.call(<span class="keyword">this</span>.model);</span><br><span class="line">        <span class="comment">// 最后绑定事件</span></span><br><span class="line">        <span class="keyword">this</span>.bindEvents();</span><br><span class="line">    &#125;</span><br><span class="line">    render()&#123;</span><br><span class="line">        <span class="comment">// 用来渲染 view</span></span><br><span class="line">    &#125;,</span><br><span class="line">    bindEvents()&#123;</span><br><span class="line">        <span class="comment">// 用来绑定事件</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="最后的总结"><a href="#最后的总结" class="headerlink" title="最后的总结"></a>最后的总结</h2><p>MVC 是一种设计模式，即 Model View Controller,具体来说他按照功能将代码分成三大块</p>
<ol>
<li>Model 层<br> 这一层负责跟 Server 打交道，与 Server 进行请求和响应，保证数据的存储和更新</li>
<li>View 层<br> View 层主要是用来展示给用户操作的，即一个操作的界面</li>
<li>Controller 层<br> 这一层则用来综合控制 view 层以及 Model 层，它监听 view 层的变化，当 view 层有变化时则及时通知 Controller ,然后 Controller 调用 Model 来返回数据并同时更新 view, Molde 则再次请求 Server 进行数据的更新</li>
</ol>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>mvc</tag>
      </tags>
  </entry>
  <entry>
    <title>有关Session、LocalStorage、Cache-Control等等等等</title>
    <url>/2019/02/20/%E6%9C%89%E5%85%B3Session%E3%80%81LocalStorage%E3%80%81Cache-Control%E7%AD%89%E7%AD%89%E7%AD%89%E7%AD%89/</url>
    <content><![CDATA[<h2 id="解释一下-Session"><a href="#解释一下-Session" class="headerlink" title="解释一下 Session"></a>解释一下 Session</h2><p>Session 代表服务器与浏览器之间的一次会话过程，这是一种服务端的机制，它用这样的机制来识别具体的用户，用于跟踪用户的状态</p>
<h2 id="与-Cookie-的关系"><a href="#与-Cookie-的关系" class="headerlink" title="与 Cookie 的关系"></a>与 Cookie 的关系</h2><p>一般来说，Session 是基于 Cookie 来实现的，那么它们的区别在哪儿呢</p>
<ul>
<li>Cookie<ol>
<li>服务器通过 <code>Set-Cookie</code> 头给客户端一串字符串</li>
<li>客户端每次访问 <strong>相同域名</strong> 的网页时，必须带上这串字符串</li>
<li><strong>客户端</strong> 要在一段时间内保存这个 Cookie</li>
<li>默认情况下 Cookie 在用户关闭页面后就失效，但是后端可以任意修改 Cookie 的过期时间(通过修改 Set-Cookie 头的 Expires 或者 Max-age 属性实现)</li>
<li><a href="https://stackoverflow.com/questions/640938/what-is-the-maximum-size-of-a-web-browsers-cookies-key" target="_blank" rel="noopener">Cookie 的大小一般在 4kb 以内</a></li>
</ol>
</li>
<li>Session<ol>
<li>将一串随机数组成的 session-id 通过 Cookie 发送给客户端</li>
<li>客户端在访问服务器时，服务器就会通过客户端发送回来的 Cookie 中读取到这个 session-id</li>
<li><strong>服务器</strong>有块内存也就是哈希表保存了所有的 session</li>
<li>然后通过这个 session-id 服务器就知道了用户的一些隐私信息</li>
<li>这块内存就是服务器上所有的 session</li>
</ol>
</li>
</ul>
<p>需要注意的是，Cookie 能被用户篡改，所以 session 也是用来解决这个问题的</p>
<h2 id="与-localStorage-的关系"><a href="#与-localStorage-的关系" class="headerlink" title="与 localStorage 的关系"></a>与 localStorage 的关系</h2><p>localStorage 自 firefox 3.5 引进，是一个与 sessionStorage 相似的浏览器接口，主要用于 js 脚本在浏览器保存数据用，它的特点如下</p>
<ul>
<li>localStorage<ol>
<li>localStorage 与 HTTP 无关，所以 HTTP 不会带上 localStorage 的值</li>
<li>只有相同域名的页面才能互相读取 localStorage,但它没有同源那么严格(也就是说协议和端口不一致也能互相读取)</li>
<li>每个域名 localStorage 最大存储量为 5Mb 左右，但每个浏览器对应的存储上限不一样(Chrome 是 2.5MB，Firefox 和 Opera 是 5MB，IE 是 10MB)</li>
<li>它的常用场景是记录有无提示用户</li>
<li>localStorage 永久有效，除非用户清理缓存</li>
</ol>
</li>
</ul>
<h2 id="与-sessionStorage-的关系"><a href="#与-sessionStorage-的关系" class="headerlink" title="与 sessionStorage 的关系"></a>与 sessionStorage 的关系</h2><p>除了上面 localStorage 的第 5 点,对应的它是 <strong>会在用户关闭页面即会话结束时数据就被清空</strong>,所以它并不是永久有效的，其他方面与 localStorage 一致</p>
<h2 id="Cache-Control"><a href="#Cache-Control" class="headerlink" title="Cache-Control"></a>Cache-Control</h2><p>即 HTTP 缓存控制，一般用于 web 相关性能优化，这个 cache-control 首部可以给资源或文档附加一个”过期日期”,在后端代码中指定 cache-control 的 <code>max-age</code> 属性来指定文档更新的 <strong>相对时间</strong>,这样的话可以一定程度上优化 web 网站加载资源的速度，从而提高用户体验<br><a href="https://github.com/strugglebak/sign-in-and-sign-up-demo/commit/506df5b504f1ad445183f49a824229a0e94941b7" target="_blank" rel="noopener">代码链接</a><br>而如何进行缓存的更新呢? 其实主要的方式还是在源文件的引用路径上加上版本号，有点类似于查询参数的写法<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"/css/default.css?v=2"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>你的密码是：__password__<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"/js/main.js?v=3"</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>需要对 css 或者 js 进行升级的时候就修改问号后面的版本号即可，或者版本号也可以用一串随机数来代替,这样既能做到缓存又能随时升级的作用</p>
<h2 id="Expire"><a href="#Expire" class="headerlink" title="Expire"></a>Expire</h2><p>Expire 则用来指定 <strong>实际的日期</strong> 而不是秒数，因为服务器的时间都不是同步的，那么用这个绝对的时间来表示过期的话就很麻烦,于是出现了 Expire 的升级版，即 Cache-Control，即用多长时间过期来替代, Expire 的格式如下<br><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">Expires:</span> <span class="string">Wed,</span> <span class="number">21</span> <span class="string">Oct</span> <span class="number">2015</span> <span class="number">07</span><span class="string">:28:00</span> <span class="string">GMT</span></span><br></pre></td></tr></table></figure></p>
<p>格林威治时间格式</p>
<h2 id="ETag"><a href="#ETag" class="headerlink" title="ETag"></a>ETag</h2><p>ETag 这个 HTTP 响应头是资源的特定版本的标识符，每次若在 url 对应的资源更新时，则生成一个新的 ETag 值，若资源没有改变，则 ETag 值不变，这样对于没有改变的资源服务器就没有必要发送完整响应(注意这里是<strong>完整响应</strong>)，所以这样就可以让缓存更高效，带宽更节省,而使用 MD5 生成的一串字符来生成对应资源的 ETag 值可以避免值的碰撞</p>
<p>与 Cache-Control 的区别是，若 MD5 一样，则用 Cache-Control 是<strong>直接不请求</strong>,而 ETag 是<strong>有请求，但是响应体是空的</strong>,这里可以具体看这个<a href="https://github.com/strugglebak/sign-in-and-sign-up-demo/commit/637190aac8733490e1616ebdb950ab0a07cc1c16" target="_blank" rel="noopener">代码链接</a><br>其关键代码如下<br><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">diff <span class="comment">--git a/server.js b/server.js</span></span><br><span class="line">index <span class="number">0</span>c39ea9.<span class="number">.81</span>a1e37 <span class="number">100644</span></span><br><span class="line"><span class="comment">--- a/server.js</span></span><br><span class="line">+++ b/server.js</span><br><span class="line">@@ <span class="number">-6</span>,<span class="number">6</span> +<span class="number">6</span>,<span class="number">8</span> @@ var port = process.argv[<span class="number">2</span>]</span><br><span class="line"> // 定义一个空 session</span><br><span class="line"> var sessions = &#123;&#125;</span><br><span class="line"></span><br><span class="line">+var md5 = <span class="built_in">require</span>(<span class="string">'md5'</span>)</span><br><span class="line">+</span><br><span class="line"> <span class="keyword">if</span>(!port)&#123;</span><br><span class="line">   console.<span class="built_in">log</span>(<span class="string">'请指定端口号好不啦？\nnode server.js 8888 这样不会吗？'</span>)</span><br><span class="line">   process.<span class="built_in">exit</span>(<span class="number">1</span>)</span><br><span class="line">@@ <span class="number">-23</span>,<span class="number">10</span> +<span class="number">25</span>,<span class="number">16</span> @@ var server = http.createServer(<span class="function"><span class="keyword">function</span><span class="params">(request, response)</span></span>&#123;</span><br><span class="line">   console.<span class="built_in">log</span>(<span class="string">'含查询字符串的路径\n'</span> + pathWithQuery)</span><br><span class="line">   <span class="keyword">if</span>(<span class="built_in">path</span> === <span class="string">'/js/main.js'</span>)&#123;</span><br><span class="line">     let <span class="built_in">string</span> = fs.readFileSync(<span class="string">'./js/main.js'</span>, <span class="string">'utf8'</span>)</span><br><span class="line">-    response.statusCode = <span class="number">200</span></span><br><span class="line">+    let fileMd5 = md5(<span class="built_in">string</span>)</span><br><span class="line">     response.setHeader(<span class="string">'Content-Type'</span>, <span class="string">'application/javascript;charset=utf-8'</span>)</span><br><span class="line">-    response.setHeader(<span class="string">'Cache-Control'</span>, <span class="string">'max-age=3000000'</span>)</span><br><span class="line">-    response.<span class="built_in">write</span>(<span class="built_in">string</span>)</span><br><span class="line">+    response.setHeader(<span class="string">'ETag'</span>, fileMd5)</span><br><span class="line">+    <span class="keyword">if</span>(request.headers[<span class="string">'if-none-match'</span>] === fileMd5)&#123;</span><br><span class="line">+      // 资源未改变,就返回 <span class="number">304</span> ，没有响应体</span><br><span class="line">+      response.statusCode = <span class="number">304</span></span><br><span class="line">+    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">+      // 资源改变了,有响应体</span><br><span class="line">+      response.<span class="built_in">write</span>(<span class="built_in">string</span>)</span><br><span class="line">+    &#125;</span><br><span class="line">     response.<span class="keyword">end</span>()</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">path</span> === <span class="string">'/css/default.css'</span>)&#123;</span><br></pre></td></tr></table></figure></p>
<p>当第一次访问首页时，正常加载 js 文件，第一次响应头中出现 <code>ETag</code>,然后第二次发送请求时，这个时候第二次的请求头中会出现 <code>If-None-Match</code> 这个头，这个头的值就是 <code>ETag</code> 的值，服务器接收到这个头的值以后，就会与其当前版本的资源文件的 <code>Etag</code> 值进行比较，若资源没改变就返回 304,资源改变了就返回新资源</p>
<h2 id="Last-Modified"><a href="#Last-Modified" class="headerlink" title="Last-Modified"></a>Last-Modified</h2><p>这个响应头是服务器用来认定资源被修改的时间以及日期用的，由于每个服务器上的时间均不同步，所以用这个来验证资源是否修改还是不精确的, Last-Modified 的格式如下<br><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">Last-Modified:</span> <span class="string">Wed,</span> <span class="number">21</span> <span class="string">Oct</span> <span class="number">2015</span> <span class="number">07</span><span class="string">:28:00</span> <span class="string">GMT</span></span><br></pre></td></tr></table></figure></p>
<h2 id="缓存与-304-的区别"><a href="#缓存与-304-的区别" class="headerlink" title="缓存与 304 的区别"></a>缓存与 304 的区别</h2><ul>
<li>缓存是没有请求的</li>
<li>304 是有请求，也有响应的，但是响应没有第四部分，即响应体没有</li>
</ul>
<h2 id="用-LocalStorage-查询参数实现-Session"><a href="#用-LocalStorage-查询参数实现-Session" class="headerlink" title="用 LocalStorage + 查询参数实现 Session"></a>用 LocalStorage + 查询参数实现 Session</h2><p>可以通过查询参数以及 localStorage 的方式实现，<a href="https://github.com/strugglebak/sign-in-and-sign-up-demo/tree/session" target="_blank" rel="noopener">代码链接</a><br>关键代码如下<br><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">diff --git a/server.js b/server.js</span><br><span class="line">index ed88b7e.<span class="number">.349e35</span>d <span class="number">100644</span></span><br><span class="line">--- a/server.js</span><br><span class="line">+++ b/server.js</span><br><span class="line">@@ <span class="number">-25</span>,<span class="number">19</span> +<span class="number">25</span>,<span class="number">12</span> @@ <span class="keyword">var</span> server = http.createServer(<span class="function"><span class="keyword">function</span>(<span class="params">request, response</span>)</span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(path === <span class="string">'/'</span>)&#123;</span><br><span class="line">     <span class="comment">// 若请求是根路径</span></span><br><span class="line">     <span class="keyword">let</span> <span class="built_in">string</span> = fs.readFileSync(<span class="string">'./index.html'</span>, <span class="string">'utf8'</span>)</span><br><span class="line">-    <span class="comment">// 解析请求中的 Cookie, 并存放到一个 hash 中</span></span><br><span class="line">-    <span class="keyword">let</span> cookies = request.headers.cookie.split(<span class="string">'; '</span>) <span class="comment">// ['email=1@', 'a=1', 'b=2']</span></span><br><span class="line">-    <span class="keyword">let</span> hash = &#123;&#125;</span><br><span class="line">-    <span class="keyword">for</span>(<span class="keyword">let</span> i =<span class="number">0</span>;i&lt;cookies.length; i++)&#123;</span><br><span class="line">-      <span class="keyword">let</span> parts = cookies[i].split(<span class="string">'='</span>)</span><br><span class="line">-      <span class="keyword">let</span> key = parts[<span class="number">0</span>]</span><br><span class="line">-      <span class="keyword">let</span> value = parts[<span class="number">1</span>]</span><br><span class="line">-      hash[key] = value</span><br><span class="line">-    &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//从文件模拟的数据库中查找用户是否存在</span></span><br><span class="line">     <span class="keyword">let</span> email = <span class="string">''</span></span><br><span class="line">-    <span class="keyword">let</span> sessionId = hash[<span class="string">'session-id'</span>]</span><br><span class="line">+    <span class="comment">// 通过查询参数拿到 sessionId</span></span><br><span class="line">+    <span class="keyword">let</span> sessionId = query.sessionId</span><br><span class="line">+    <span class="built_in">console</span>.log(sessionId)</span><br><span class="line">     <span class="keyword">if</span>(sessions[sessionId])&#123;</span><br><span class="line">       email = sessions[sessionId].sign_in_email</span><br><span class="line">     &#125;</span><br><span class="line">@@ <span class="number">-159</span>,<span class="number">7</span> +<span class="number">152</span>,<span class="number">10</span> @@ <span class="keyword">var</span> server = http.createServer(<span class="function"><span class="keyword">function</span>(<span class="params">request, response</span>)</span>&#123;</span><br><span class="line">         <span class="comment">// 先生成一个 session-id</span></span><br><span class="line">         <span class="keyword">let</span> sessionId = <span class="built_in">Math</span>.random() * <span class="number">100000</span></span><br><span class="line">         sessions[sessionId] = &#123;sign_in_email: email&#125;</span><br><span class="line">-        response.setHeader(<span class="string">'Set-Cookie'</span>, <span class="string">`session-id=<span class="subst">$&#123;sessionId&#125;</span>`</span>)</span><br><span class="line">+        <span class="comment">// sessionId 直接通过 JSON 传</span></span><br><span class="line">+        response.write(<span class="string">`&#123;</span></span><br><span class="line"><span class="string">+          "sessionId": <span class="subst">$&#123;sessionId&#125;</span></span></span><br><span class="line"><span class="string">+        &#125;`</span>)</span><br><span class="line">         response.statusCode = <span class="number">200</span></span><br><span class="line">       &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">         response.statusCode = <span class="number">401</span></span><br><span class="line">diff --git a/sign_in.html b/sign_in.html</span><br><span class="line">index <span class="number">61217</span>c4..e75d616 <span class="number">100644</span></span><br><span class="line">--- a/sign_in.html</span><br><span class="line">+++ b/sign_in.html</span><br><span class="line">@@ <span class="number">-72</span>,<span class="number">9</span> +<span class="number">72</span>,<span class="number">11</span> @@</span><br><span class="line">           .text(<span class="string">'填密码呀同学'</span>)</span><br><span class="line">         <span class="keyword">return</span></span><br><span class="line">       &#125;</span><br><span class="line">-      $.post(<span class="string">'/sign_in'</span>, hash)</span><br><span class="line">+      $.post(<span class="string">'/sign_in'</span>, hash)</span><br><span class="line">         .then(<span class="function">(<span class="params">response</span>)=&gt;</span>&#123;</span><br><span class="line">-          <span class="built_in">window</span>.location.href = <span class="string">'/'</span></span><br><span class="line">+          <span class="keyword">let</span> sessionId = <span class="built_in">JSON</span>.parse(response).sessionId</span><br><span class="line">+          localStorage.setItem(<span class="string">'sessionId'</span>, sessionId)</span><br><span class="line">+          <span class="built_in">window</span>.location.href = <span class="string">`/?sessionId=<span class="subst">$&#123;sessionId&#125;</span>`</span></span><br><span class="line">         &#125;, <span class="function">(<span class="params">request</span>)=&gt;</span>&#123;</span><br><span class="line">           alert(<span class="string">'邮箱与密码不匹配'</span>)</span><br><span class="line">         &#125;)</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title>手摸手踩坑react-template</title>
    <url>/2021/11/23/%E6%89%8B%E6%91%B8%E6%89%8B%E8%B8%A9%E5%9D%91react-template/</url>
    <content><![CDATA[<blockquote>
<p>注意：为了方便统一，本文中出现的安装包依赖的方式均使用 <code>yarn</code> 来安装</p>
</blockquote>
<a id="more"></a>
<h2 id="采取最简便的方式"><a href="#采取最简便的方式" class="headerlink" title="采取最简便的方式"></a>采取最简便的方式</h2><p>如果说搭建一个 react template 最简便的方式，那便是使用官方的 cli，即 <code>create-react-app</code>，因为这边还需要使用 typescript 技术栈，所以在搭建的过程中可以加一个参数 <code>--template typescript</code>，表示使用的模板是 typescript 的模板</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yarn create react-app my-app --template typescript</span><br></pre></td></tr></table></figure>
<p>然后在项目的目录中执行如下的命令安装依赖</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yarn add typescript @types/node @types/react @types/react-dom @types/jest</span><br></pre></td></tr></table></figure>
<p>然后生成的目录结构基本上如下所示</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># my-app</span></span><br><span class="line">├── README.md</span><br><span class="line">├── package.json</span><br><span class="line">├── public</span><br><span class="line">│   ├── favicon.ico</span><br><span class="line">│   ├── index.html</span><br><span class="line">│   ├── logo192.png</span><br><span class="line">│   ├── logo512.png</span><br><span class="line">│   ├── manifest.json</span><br><span class="line">│   └── robots.txt</span><br><span class="line">├── src</span><br><span class="line">│   ├── App.css</span><br><span class="line">│   ├── App.test.tsx</span><br><span class="line">│   ├── App.tsx</span><br><span class="line">│   ├── index.css</span><br><span class="line">│   ├── index.tsx</span><br><span class="line">│   ├── logo.svg</span><br><span class="line">│   ├── react-app-env.d.ts</span><br><span class="line">│   ├── serviceWorker.ts</span><br><span class="line">│   └── setupTests.ts</span><br><span class="line">├── tsconfig.json</span><br><span class="line">└── yarn.lock</span><br></pre></td></tr></table></figure>
<p>其中比较重要的就是 <code>src</code> 以及 <code>tsconfig.json</code> 文件，一个用来存放源码，一个用来定义 <code>tsconfig.json</code> 文件。但这两个文件并不是在最开始搭建的时候一个大障碍，一个比较大的障碍是，使用 cra 创建的项目，如果以后项目的需求变更，就必须使用 <code>config-overide.js</code> 去做一个覆盖原本默认 <code>webpack</code> 配置的配置文件。同时你还需要下载 <a href="https://github.com/timarney/react-app-rewired/blob/master/README_zh.md" target="_blank" rel="noopener"><code>react-app-rewired</code></a> 这个库来重新构建整个项目。考虑到 <code>react-app-rewired</code> 社区中维护的插件/包/库都不是特别的多，并且使用这种过度包装的 package 也比较黑盒，难于调试，所以最后决定使用 <code>yarn eject</code> 抛出该项目的 webpack 配置，手动实现真正自定义的配置和其他的操作(做注释以及方便后面的维护)</p>
<h3 id="yarn-eject"><a href="#yarn-eject" class="headerlink" title="yarn eject"></a>yarn eject</h3><p>执行 <code>yarn eject</code> 之后，基本上就多了两个文件夹 <code>scripts</code> 以及 <code>config</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># scripts</span></span><br><span class="line">├── build.js</span><br><span class="line">├── start.js</span><br><span class="line">└── test.js</span><br></pre></td></tr></table></figure>
<p>其中的 <code>build.js</code>、<code>start.js</code>、<code>test.js</code> 分别对应 <code>package.json</code> 文件中的 <code>scripts</code> 脚本</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">// package.json</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="attr">"scripts"</span>: &#123;</span><br><span class="line">    <span class="attr">"start"</span>: <span class="string">"node scripts/start.js"</span>,</span><br><span class="line">    <span class="attr">"build"</span>: <span class="string">"node scripts/build.js"</span>,</span><br><span class="line">    <span class="attr">"test"</span>: <span class="string">"node scripts/test.js"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>道理我都明白，<code>start</code> 对应启动一个本地的 devServer 进行调试，而 <code>build</code> 对应打包最终的文件，<code>test</code> 对应代码的测试脚本，但是你特么的为啥要引入这么多个包啊？全部都是函数套函数的形式，你这谁看的懂啊？</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># config</span></span><br><span class="line">├── env.js</span><br><span class="line">├── getHttpsConfig.js</span><br><span class="line">├── jest</span><br><span class="line">│   ├── cssTransform.js</span><br><span class="line">│   └── fileTransform.js</span><br><span class="line">├── modules.js</span><br><span class="line">├── paths.js</span><br><span class="line">├── pnpTs.js</span><br><span class="line">├── webpack.config.js</span><br><span class="line">└── webpackDevServer.config.js</span><br></pre></td></tr></table></figure>
<p>还有这个所谓的 eject 出来的 <code>webpack</code> 的配置，粗略看了下核心文件 <code>webpack.config.js</code> 中光是配置文件的行数就有 <code>670</code> 行，尽管中间参杂了各种英文的注释，但是对于一个需要配置的新人来说，还是过于繁杂了，光是看到它引入的各种插件也是头疼无比，其实到这个时候，就已经有不详的预感了(对于如此复杂的一个配置，任何修改和添加或者删除都将是灾难性的)</p>
<h3 id="sass-loader-的-bug"><a href="#sass-loader-的-bug" class="headerlink" title="sass-loader 的 bug"></a>sass-loader 的 bug</h3><p>因为在之前的 xp 项目中(比如 <code>xp-homework</code>)，可以通过 <code>.env</code> 中的环境变量给一个 scss 变量赋值并追加到某个定义好的 scss 文件中，在 <code>xp-homework</code> 项目中的 <code>vue.config.js</code> 有这样的代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  ...</span><br><span class="line">  css: &#123;</span><br><span class="line">    loaderOptions: &#123;</span><br><span class="line">      sass: &#123;</span><br><span class="line">        data: <span class="string">`@import "@/styles/variables.scss"; $userSelect: <span class="subst">$&#123;process.env</span></span></span><br><span class="line"><span class="string"><span class="subst">          .VUE_APP_USER_SELECT || <span class="string">'none'</span>&#125;</span>;`</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>参考 <a href="https://webpack.js.org/loaders/sass-loader/#prependdata" target="_blank" rel="noopener">webpack 中有关 sassloader prependData 属性的文档</a>，里面的解释如下</p>
<blockquote>
<p>Prepends Sass/SCSS code before the actual entry file. In this case, the sass-loader will not override the data option but just append the entry’s content.</p>
</blockquote>
<p>This is especially useful when some of your Sass variables depend on the environment</p>
<p>以及里面的函数配置的写法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    loader: <span class="string">'sass-loader'</span>,</span><br><span class="line">    options: &#123;</span><br><span class="line">      prependData: <span class="function">(<span class="params">loaderContext</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// More information about available properties https://webpack.js.org/api/loaders/</span></span><br><span class="line">        <span class="keyword">const</span> &#123; resourcePath, rootContext &#125; = loaderContext;</span><br><span class="line">        <span class="keyword">const</span> relativePath = path.relative(rootContext, resourcePath);</span><br><span class="line">        <span class="keyword">if</span> (relativePath === <span class="string">'styles/foo.scss'</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="string">'$value: 100px;'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'$value: 200px;'</span>;</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将项目中的 <code>webpack.config.js</code> 中如下的代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">if</span> (preProcessor) &#123;</span><br><span class="line">  loaders.push(</span><br><span class="line">    &#123;</span><br><span class="line">      loader: <span class="built_in">require</span>.resolve(<span class="string">'resolve-url-loader'</span>),</span><br><span class="line">      options: &#123;</span><br><span class="line">        sourceMap: isEnvProduction &amp;&amp; shouldUseSourceMap,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      loader: <span class="built_in">require</span>.resolve(preProcessor),</span><br><span class="line">      options: &#123;</span><br><span class="line">        sourceMap: <span class="literal">true</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> loaders;</span><br></pre></td></tr></table></figure>
<p>改写成</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (preProcessor) &#123;</span><br><span class="line">  <span class="keyword">const</span> loader = &#123;</span><br><span class="line">    loader: <span class="built_in">require</span>.resolve(preProcessor),</span><br><span class="line">    options: &#123;</span><br><span class="line">      sourceMap: <span class="literal">true</span>,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (preProcessor === <span class="string">'sass-loader'</span>) &#123;</span><br><span class="line">    loader.options.prependData = <span class="function">(<span class="params">loaderContext</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123; resourcePath, rootContext &#125; = loaderContext</span><br><span class="line">      <span class="keyword">const</span> relativePath = path.relative(rootContext, resourcePath)</span><br><span class="line">      <span class="keyword">if</span> (relativePath === <span class="string">'src/styles/base.scss'</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">`$userSelect: <span class="subst">$&#123;process.env.REACT_APP_USER_SELECT || <span class="string">'none'</span>&#125;</span>`</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  loaders.push(</span><br><span class="line">    &#123;</span><br><span class="line">      loader: <span class="built_in">require</span>.resolve(<span class="string">'resolve-url-loader'</span>),</span><br><span class="line">      options: &#123;</span><br><span class="line">        sourceMap: isEnvProduction &amp;&amp; shouldUseSourceMap</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    loader</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> loaders</span><br></pre></td></tr></table></figure>
<p>使用 <code>yarn start</code> 后报如下的错误</p>
<p><img src="./1.png" alt></p>
<p>就非常的奇怪，一个比较 trick 的解决方式是，将所有需要引入到 .scss 文件的地方，都改为 .sass，并将其语法也改写成 sass 语法。编译通过。不过这并不是一个好的解决方式，因为定位的问题应该是 sass-loader，可能还有其他的配置，于是去 github 上找了 <a href="https://github.com/webpack-contrib/sass-loader" target="_blank" rel="noopener">sass-loader 的相关配置</a>，找到了这么一段话</p>
<p><img src="./2.png" alt></p>
<p>但是看了下，项目中其实是安装了 sass 的，按照道理来说应该会自动使用 sass 来 implementation 才对，但是这里又报错，于是尝试去掉 sass，直接安装 node-sass，问题居然解决了!!!所以如果以后需要用到 sass-loader 的地方，最好还是先安装 node-sass 比较稳妥</p>
<h3 id="路径-alias-引入失败"><a href="#路径-alias-引入失败" class="headerlink" title="路径 alias 引入失败"></a>路径 alias 引入失败</h3><p>之前在搭建模板的过程中，只是在 <code>tsconfig.json</code> 文件中设置了 <code>baseUrl</code> 以及 <code>paths</code></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"baseUrl"</span>: <span class="string">"./src"</span>, <span class="comment">// 解析非相对模块名的基准目录</span></span><br><span class="line">  <span class="attr">"paths"</span>: &#123; <span class="comment">// 这个属性就是用来填写编译时对应的 alias 用的</span></span><br><span class="line">    <span class="attr">"@"</span>: [<span class="string">"./src"</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果是在 webpack 中不做设置，那么在编译时 webpack 会报错，所以在该项目中的 <code>webpack.config.js</code> 中也需要做 alias 的配置</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">alias: &#123;</span><br><span class="line">  <span class="string">'@'</span>: path.resolve(__dirname, <span class="string">'../src'</span>),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是设置完后编译，typescript 表示依然找不到模块，这个时候就是 <code>tsconfig.json</code> 配置的问题了。如果你的 <code>baseUrl</code> 中已经写了 <code>./src</code>，那么 <code>paths</code> 应该这么写</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"baseUrl"</span>: <span class="string">"./src"</span>, <span class="comment">// 解析非相对模块名的基准目录</span></span><br><span class="line">  <span class="attr">"paths"</span>: &#123; <span class="comment">// 这个属性就是用来填写编译时对应的 alias 用的</span></span><br><span class="line">    <span class="attr">"@/*"</span>: [<span class="string">"."</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>@/*</code> 表示匹配代码中的以 <code>@/xxx/yyy</code> 这种形式引入模块，由于已经设置了 <code>baseUrl</code>，所以这里 <code>paths</code> 中的配置就自动加上了 <code>baseUrl</code>了。比如引入一个包 <code>import XXX from &#39;@/xxx/yyy&#39;</code>，而你的配置为 <code>&quot;@/*&quot;: [&quot;.&quot;]</code> 的话，它会自动在 <code>./src/xxx/yyy</code> 下去寻找这个模块。另外为了保持格式，我将对应的 webpack 的 alias 以及 tsconfig 的 alias 都做了一一对应，如下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line">alias: &#123;</span><br><span class="line">  <span class="comment">// 设置 webpack 编译时的 alias</span></span><br><span class="line">  <span class="comment">// ../ 目录的原因是因为当前 src 目录相当于当前 webpack.config.js 的就是上级目录</span></span><br><span class="line">  <span class="string">'@'</span>: path.resolve(__dirname, <span class="string">'../src'</span>),</span><br><span class="line">  <span class="string">'@api'</span>: path.resolve(__dirname, <span class="string">'../src/api'</span>),</span><br><span class="line">  <span class="string">'@assets'</span>: path.resolve(__dirname, <span class="string">'../src/assets'</span>),</span><br><span class="line">  <span class="string">'@components'</span>: path.resolve(__dirname, <span class="string">'../src/components'</span>),</span><br><span class="line">  <span class="string">'@router'</span>: path.resolve(__dirname, <span class="string">'../src/router'</span>),</span><br><span class="line">  <span class="string">'@styles'</span>: path.resolve(__dirname, <span class="string">'../src/styles'</span>),</span><br><span class="line">  <span class="string">'@utils'</span>: path.resolve(__dirname, <span class="string">'../src/utils'</span>),</span><br><span class="line">  <span class="string">'@views'</span>: path.resolve(__dirname, <span class="string">'../src/views'</span>),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">// tsconfig.json</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"baseUrl"</span>: <span class="string">"."</span>, <span class="comment">// 解析非相对模块名的基准目录</span></span><br><span class="line">  <span class="attr">"paths"</span>: &#123; <span class="comment">// 这个属性就是用来填写编译时对应的 alias 用的</span></span><br><span class="line">     <span class="attr">"@/*"</span>: [<span class="string">"./src/*"</span>],</span><br><span class="line">     <span class="attr">"@api/*"</span>: [<span class="string">"./src/api/*"</span>],</span><br><span class="line">     <span class="attr">"@assets/*"</span>: [<span class="string">"./src/assets/*"</span>],</span><br><span class="line">     <span class="attr">"@components/*"</span>: [<span class="string">"./src/components/*"</span>],</span><br><span class="line">     <span class="attr">"@router/*"</span>: [<span class="string">"./src/router/*"</span>],</span><br><span class="line">     <span class="attr">"@styles/*"</span>: [<span class="string">"./src/styles/*"</span>],</span><br><span class="line">     <span class="attr">"@utils/*"</span>: [<span class="string">"./src/utils/*"</span>],</span><br><span class="line">     <span class="attr">"@views/*"</span>: [<span class="string">"./src/views/*"</span>],</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="引入-svg-报错"><a href="#引入-svg-报错" class="headerlink" title="引入 svg 报错"></a>引入 svg 报错</h3><p>虽然现在能够以 img 标签 src 方式引入 svg，如下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react</span></span><br><span class="line"><span class="string">import logoPng from '</span>@assets/logo.png<span class="string">'</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">class Demo extends React.Component &#123;</span></span><br><span class="line"><span class="string">    return (</span></span><br><span class="line"><span class="string">      &lt;div&gt;</span></span><br><span class="line"><span class="string">        &lt;img src=&#123;logoPng&#125; alt="logo" /&gt;</span></span><br><span class="line"><span class="string">      &lt;/div&gt;</span></span><br><span class="line"><span class="string">    )</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>
<p>但是我们更希望能将 svg 当成一个组件的方式引入，如下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react</span></span><br><span class="line"><span class="string">import Logo from '</span>../../assets/logo.svg<span class="string">'</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">class Demo extends React.Component &#123;</span></span><br><span class="line"><span class="string">    return (</span></span><br><span class="line"><span class="string">      &lt;div&gt;</span></span><br><span class="line"><span class="string">        &lt;Logo /&gt;</span></span><br><span class="line"><span class="string">      &lt;/div&gt;</span></span><br><span class="line"><span class="string">    )</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>
<p>最开始是参考 <a href="https://create-react-app.dev/docs/adding-images-fonts-and-files/" target="_blank" rel="noopener">Adding SVGs</a> 这篇文章，它的解决方案如下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; ReactComponent <span class="keyword">as</span> Logo &#125; <span class="keyword">from</span> <span class="string">'./logo.svg'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &#123;<span class="comment">/* Logo is an actual React component */</span>&#125;</span><br><span class="line">      &lt;Logo /&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<p>试了下发现是不行的，然后继续搜集线索，发现有个 babel 的插件可以解决这个问题，即 <code>babel-plugin-inline-react-svg</code>，而这是需要在 <code>babel-loader</code> 的 <code>options.plugins</code> 进行配置，如下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">oneOf: [</span><br><span class="line">  &#123;</span><br><span class="line">    test: <span class="regexp">/\.(js|mjs|jsx|ts|tsx)$/</span>,</span><br><span class="line">    ...</span><br><span class="line">    loader: <span class="built_in">require</span>.resolve(<span class="string">'babel-loader'</span>),</span><br><span class="line">    options: &#123;</span><br><span class="line">      ...</span><br><span class="line">      plugins: [</span><br><span class="line">        <span class="built_in">require</span>.resolve(<span class="string">'babel-plugin-inline-react-svg'</span>), <span class="comment">// 这里只是需要添加这个插件即可</span></span><br><span class="line">        [</span><br><span class="line">          <span class="built_in">require</span>.resolve(<span class="string">'babel-plugin-named-asset-import'</span>),</span><br><span class="line">          &#123;</span><br><span class="line">            loaderMap: &#123;</span><br><span class="line">              svg: &#123;</span><br><span class="line">                ReactComponent:</span><br><span class="line">                  <span class="string">'@svgr/webpack?-svgo,+titleProp,+ref![path]'</span></span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">     ],</span><br><span class="line">  &#125;,</span><br><span class="line">  ...</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>在说 <code>babel-plugin-inline-react-svg</code> 这个插件的原理之前，先说下 <code>babel-plugin-named-asset-import</code> 的原理，这个插件本质上会将如下的语句</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; url <span class="keyword">as</span> logoUrl &#125; <span class="keyword">from</span> <span class="string">'./logo.png'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; ReactComponent <span class="keyword">as</span> Icon &#125; <span class="keyword">from</span> <span class="string">'./icon.svg'</span>;</span><br></pre></td></tr></table></figure>
<p>转换成</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> logoUrl <span class="keyword">from</span> <span class="string">'url-loader!./logo.png'</span>;</span><br><span class="line"><span class="keyword">import</span> Icon <span class="keyword">from</span> <span class="string">'svgr/webpack?-svgo,+titleProp,+ref!./icon.svg'</span>;<span class="string">"</span></span><br></pre></td></tr></table></figure>
<p>但是由于这个插件对 svg 的处理，只能是通过 img 的 src 标签引入，所以才需要 <code>babel-plugin-inline-react-svg</code> 这个插件，能把 svg 自动封装成一个组件来使用，原理应该是 babel-loader 在对文件进行处理时，对源码做了一些修改导致的</p>
<h3 id="新的问题"><a href="#新的问题" class="headerlink" title="新的问题"></a>新的问题</h3><p>但是紧接着又带来了新的问题，<strong>在使用 alias 的方式引入 svg 时，会报错，即 svg 文件对应的路径找不到</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Logo <span class="keyword">from</span> <span class="string">'@assets/logo.svg'</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p><img src="./3.png" alt></p>
<p>出现这个问题的原因，可能在于 babel-loader 的 plugin 那里，之前我有提到过 <code>babel-plugin-named-asset-import</code> 这个插件的工作原理，有可能是 webpack 在处理 alias 之前，<strong>优先</strong>被这个插件做了处理了，即以上的代码会被转换成</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Logo <span class="keyword">from</span> <span class="string">'svgr/webpack?-svgo,+titleProp,+ref!@assets/logo.svg'</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>这个时候 svgr/webpack 这个 loader 自然就找不到路径为 <code>@assets/logo.svg</code> 的这个模块，于是编译就会报错了。</p>
<h2 id="所以更好的方式？"><a href="#所以更好的方式？" class="headerlink" title="所以更好的方式？"></a>所以更好的方式？</h2><p>由以上的方式，我们就懂得了一个道理，最 easy 的方式，有的时候往往也是最 hard 的。且不说上面的 svg 引入的问题没有得到完美的解决，要是以后项目逐渐的变得复杂了，需要对项目的基建做修改和升级呢？出了问题之后要怎么维护呢？连现在这个简单的问题的解决方案都如此麻烦的情况下，那万一以后出了更加匪夷所思的问题需要将项目基建整体重构呢? …etc</p>
<p>基于以上的风险考虑，从项目的可读性和可维护性着想的话，也许最好的方式，就是自己手撸一个 template 出来</p>
<h3 id="重构-config"><a href="#重构-config" class="headerlink" title="重构 config"></a>重构 config</h3><p>进行重构的操作之前，可以先将依赖包进行删除(包括 package.json 中的)，然后执行如下安装基础包</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安装 typesript</span></span><br><span class="line">yarn add -D typescript</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装 react 相关包</span></span><br><span class="line">yarn add react react-dom react-router-dom</span><br><span class="line">yarn add -D @types/react-router-dom @types/react-dom @types/react</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装 babel 相关包</span></span><br><span class="line">yarn add -D</span><br><span class="line">@babel/core <span class="comment"># babel 核心</span></span><br><span class="line">@babel/plugin-proposal-class-properties <span class="comment"># 支持 class xxx &#123; a = 'xxx' &#125; 这样在类中定义属性</span></span><br><span class="line">@babel/plugin-proposal-decorators <span class="comment"># 支持使用装饰器</span></span><br><span class="line">@babel/plugin-syntax-dynamic-import <span class="comment"># 支持异步加载(improt (xxx))</span></span><br><span class="line">@babel/preset-react  @babel/preset-typescript <span class="comment"># 支持将 react 以及 ts 编译成 js</span></span><br><span class="line">babel-loader</span><br><span class="line">babel-plugin-import <span class="comment"># 若是需要 antd 的包，可以安装这个进行按需加载</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装 html-webpack-plugin</span></span><br><span class="line">yarn add -D html-webpack-plugin</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装 sass 以及 style 配置相关包</span></span><br><span class="line">yarn add -D sass-loader node-sass style-loader css-loader css-modules-typescript-loader</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装 url-loader</span></span><br><span class="line">yarn add -D url-loader</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装 @svgr/webpack</span></span><br><span class="line">yarn add -D @svgr/webpack</span><br></pre></td></tr></table></figure>
<p>然后需要做的就是删除 config 文件夹下的各种 js 文件，然后新建几个文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># config</span></span><br><span class="line">├── devServerConfig.js <span class="comment"># webpack devServer 相关配置</span></span><br><span class="line">├── devServerProxyConfig.js <span class="comment"># webpack devServer proxy 相关配置</span></span><br><span class="line">├── pluginsConfig.js <span class="comment"># webpack plugins 相关配置</span></span><br><span class="line">├── resolveConfig.js <span class="comment"># webpack resolve 相关配置</span></span><br><span class="line">├── rules <span class="comment"># webpack rules 相关配置</span></span><br><span class="line">│   ├── assetsRules.js <span class="comment"># assets 资源文件相关 rules</span></span><br><span class="line">│   ├── fileRules.js <span class="comment"># file 文件相关 rules</span></span><br><span class="line">│   ├── jsRules.js <span class="comment"># js 相关 rules</span></span><br><span class="line">│   └── styleRules.js <span class="comment"># style 相关 rules</span></span><br><span class="line">├── utils.js <span class="comment"># 工具库 js，将一些可能用到公共的函数放到这个里面</span></span><br><span class="line">└── webpack.config.js <span class="comment"># webpack 配置</span></span><br></pre></td></tr></table></figure>
<p>从整体上看，<code>webpack.config.js</code> 的配置文件只有寥寥几行</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; resolve &#125; = <span class="built_in">require</span>(<span class="string">'./utils'</span>)</span><br><span class="line"><span class="keyword">const</span> jsRules = <span class="built_in">require</span>(<span class="string">'./rules/jsRules'</span>)</span><br><span class="line"><span class="keyword">const</span> styleRules = <span class="built_in">require</span>(<span class="string">'./rules/styleRules'</span>)</span><br><span class="line"><span class="keyword">const</span> fileRules = <span class="built_in">require</span>(<span class="string">'./rules/fileRules'</span>)</span><br><span class="line"><span class="keyword">const</span> assetsRules = <span class="built_in">require</span>(<span class="string">'./rules/assetsRules'</span>)</span><br><span class="line"><span class="keyword">const</span> pluginsConfig = <span class="built_in">require</span>(<span class="string">'./pluginsConfig'</span>)</span><br><span class="line"><span class="keyword">const</span> resolveConfig = <span class="built_in">require</span>(<span class="string">'./resolveConfig'</span>)</span><br><span class="line"><span class="keyword">const</span> devServerConfig = <span class="built_in">require</span>(<span class="string">'./devServerConfig'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@type <span class="type">&#123;import('webpack').Configuration&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    app: resolve(<span class="string">'src/index.tsx'</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: resolve(<span class="string">'dist'</span>),</span><br><span class="line">    filename: <span class="string">'[name].js'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  devServer: devServerConfig,</span><br><span class="line">  resolve: resolveConfig,</span><br><span class="line">  plugins: [...pluginsConfig],</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      ...jsRules,</span><br><span class="line">      ...styleRules,</span><br><span class="line">      ...fileRules,</span><br><span class="line">      ...assetsRules</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结构非常清晰了，相信大家应该都对这个配置挺熟悉了，所以下面就重点来详细说说这几个文件</p>
<h4 id="utils-js"><a href="#utils-js" class="headerlink" title="utils.js"></a>utils.js</h4><p>源码如下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@title </span>utils.js</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description </span>这个文件是为了方便路径处理用的</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"></span><br><span class="line">exports.resolve = <span class="function"><span class="params">dir</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> path.join(__dirname, <span class="string">'./../'</span>, dir)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为这里是用 node 启动的，所以我们可以将其当成一个 commonjs 模块，<code>exports.resolve</code> 表示暴露出一个叫 <code>resolve</code> 的模块给外部，里面的逻辑就是将一个 dir 的名字拼凑成上级目录并返回。因为很多地方会用到，所以这里封装成一个模块比较好</p>
<h4 id="jsRules-js"><a href="#jsRules-js" class="headerlink" title="jsRules.js"></a>jsRules.js</h4><p>源码如下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@title </span>jsRules.js</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description </span>定义 js 规则</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; resolve &#125; = <span class="built_in">require</span>(<span class="string">'../utils'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// 这里编写 babel 对 .tsx 文件编译的配置</span></span><br><span class="line">    test: <span class="regexp">/\.(j|t)sx?$/</span>, <span class="comment">// 正则匹配以 .jsx 或者 .tsx 结尾的文件</span></span><br><span class="line">    include: resolve(<span class="string">'src'</span>), <span class="comment">// 表示限定范围在 src 目录下</span></span><br><span class="line">    use: [</span><br><span class="line">      &#123;</span><br><span class="line">        loader: <span class="string">'babel-loader'</span>,</span><br><span class="line">        options: &#123;</span><br><span class="line">          babelrc: <span class="literal">false</span>, <span class="comment">// 这里不用 babelrc 文件</span></span><br><span class="line">          presets: [<span class="string">'@babel/preset-typescript'</span>, <span class="string">'@babel/preset-react'</span>],</span><br><span class="line">          plugins: [</span><br><span class="line">            [<span class="string">'@babel/plugin-proposal-decorators'</span>, &#123; <span class="attr">legacy</span>: <span class="literal">true</span> &#125;], <span class="comment">// 支持使用装饰器语法</span></span><br><span class="line">            [<span class="string">'@babel/plugin-proposal-class-properties'</span>, &#123; <span class="attr">loose</span>: <span class="literal">false</span> &#125;], <span class="comment">// 非宽松模式，类属性编译成赋值表达式，而不是 Object.defineProperty 这种形式</span></span><br><span class="line">            <span class="string">'@babel/plugin-syntax-dynamic-import'</span> <span class="comment">// 支持动态引入 import</span></span><br><span class="line">          ]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p><a href="https://juejin.im/post/5c822e426fb9a04a0a5ffb49" target="_blank" rel="noopener">为什么不使用 ts-loader 以及 awesome-typescript-loader? 是因为 babel 的编译速度更快</a></p>
<h4 id="styleRules-js"><a href="#styleRules-js" class="headerlink" title="styleRules.js"></a>styleRules.js</h4><p>源码如下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@title </span>styleRules.js</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description </span>定义 style 规则</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; resolve &#125; = <span class="built_in">require</span>(<span class="string">'../utils'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// 支持 scss/sass</span></span><br><span class="line">    test: <span class="regexp">/\.(scss|sass)$/</span>,</span><br><span class="line">    use: [</span><br><span class="line">      <span class="string">'style-loader'</span>,</span><br><span class="line">      <span class="string">'css-modules-typescript-loader'</span>, <span class="comment">// 在编写或改动了scss文件后，这个插件会自动生成 xxx.scss.d.ts 文件</span></span><br><span class="line">      &#123;</span><br><span class="line">        loader: <span class="string">'css-loader'</span>,</span><br><span class="line">        options: &#123;</span><br><span class="line">          modules: &#123; <span class="comment">// 支持 css-module</span></span><br><span class="line">            localIdentName: <span class="string">'[local]_[hash:base64:10]'</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        loader: <span class="string">'sass-loader'</span>,</span><br><span class="line">        options: &#123;</span><br><span class="line">          includePaths: [ <span class="comment">// 添加公共样式文件路径，这里 sass-loader 的版本为 7.3.1，请勿瞎升级！！！</span></span><br><span class="line">            resolve(<span class="string">'src/styles'</span>)</span><br><span class="line">          ]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123; <span class="comment">// 支持 less</span></span><br><span class="line">    test: <span class="regexp">/\.less$/</span>,</span><br><span class="line">    use: [</span><br><span class="line">      <span class="string">'style-loader'</span>,</span><br><span class="line">      <span class="string">'css-loader'</span>,</span><br><span class="line">      &#123;</span><br><span class="line">        loader: <span class="string">'less-loader'</span>,</span><br><span class="line">        options: &#123; <span class="comment">// 这里 javascriptEnabled 一定要为 true</span></span><br><span class="line">          javascriptEnabled: <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>这里需要注意的是，如果不做特殊的设置，webpack 的调用 loader 的顺序是从右往左的，即对于上面的支持 sass 的 loader 来说，它的执行顺序如下</p>
<ol>
<li>sass-loader: 将 sass|scss 文件编译成 css</li>
<li>css-loader: 将 css 转化为 commonjs 模块，比如 css 中有 <code>url(./xxx)</code> 的将其转化成 <code>require(./xxx)</code></li>
<li>css-modules-typescript-loader: 在编写或改动了scss文件后，这个插件会自动生成 xxx.scss.d.ts 文件</li>
<li>style-loader: 将经过 css-loader 转化成的 js 字符串转化成 style 的内容然后挂在 dom 上</li>
</ol>
<p>为什么需要 <code>css-modules-typescript-loader</code> 这个 loader 呢，因为对于 react 来说，我们一般通过这种方式使用一个 css 文件的类</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// index.tsx</span></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> style <span class="keyword">from</span> <span class="string">'./index.scss'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> App = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#123;style.xxx&#125;</span>&gt;</span>你好<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App</span><br></pre></td></tr></table></figure>
<p>这个时候不做设置，<code>index.tsx</code> 文件会报错说找不到这个 <code>index.scss</code> 模块。这是因为 ts 不认识这个 <code>index.scss</code> 文件，这个时候就需要加 <code>.d.ts</code> 写对应的类型文件才行(毕竟是 ts 的项目。。。)</p>
<p>可以自己在 <code>src/types</code> 目录下新建这个文件，然后写上</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">declare <span class="built_in">module</span> <span class="string">'*.scss'</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> content: any</span><br><span class="line">  <span class="keyword">export</span> = content</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个时候就可以了，当然我们可以想，不可能每个 scss 文件都这样做，能不能做的自动化一点，可以的，就使用 <code>css-modules-typescript-loader</code> 这个 loader 来帮我们做事情</p>
<p>那么这里做的 <code>css-module</code> 有什么好处呢？就是 react 中的 <strong>css 的模块化</strong>，<code>local</code> 表示 <strong>类名</strong>，<code>[hash:base64:10]</code> 表示这是一串由 base64 码生成的 hash，并且这个码的长度有 10 位。那么在浏览器上对应的 dom 上就会生成对应的类，这个对应的类下就有对应的 css 了，就形成来 css 的模块化，也就是自行隔离</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">xxx_1oiiefdai &#123;</span><br><span class="line">  background: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="fileRules-js"><a href="#fileRules-js" class="headerlink" title="fileRules.js"></a>fileRules.js</h4><p>源码如下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@title </span>fileRules.js</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description </span>定义 file 输出文件的规则</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"><span class="keyword">const</span> imageInlineSizeLimit = <span class="built_in">parseInt</span>(</span><br><span class="line">  process.env.IMAGE_INLINE_SIZE_LIMIT || <span class="string">'10000'</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = [</span><br><span class="line">  &#123;</span><br><span class="line">    test: <span class="regexp">/\.(png|jpe?g|gif|bmp)(\?.*)?$/</span>,</span><br><span class="line">    use: [</span><br><span class="line">      &#123;</span><br><span class="line">        loader: <span class="string">'url-loader'</span>,</span><br><span class="line">        options: &#123;</span><br><span class="line">          limit: imageInlineSizeLimit,</span><br><span class="line">          <span class="comment">// 在任意操作系统上使用 POSIX 文件路径时获得一致的结果</span></span><br><span class="line">          name: path.posix.join(<span class="string">'static/media'</span>, <span class="string">'[name].[hash:8].[ext]'</span>)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>这里主要是对 png 等图片格式的处理，这里注意 <code>limit</code> 属性配置，这个属性配置是用来指定文件的最大的 byte 也就是字节数的，若文件的大小超过定义的字节数，那么 webpack 就会使用 file-loader 去处理文件，并且所有的查询参数都会传递给 file-loader。这里在使用 url-loader 时不需要安装 file-loader，因为它本身就依赖 file-loader。<code>name</code> 属性配置表示最终生成的目标资源文件的路径以及名字</p>
<h4 id="assetsRules-js"><a href="#assetsRules-js" class="headerlink" title="assetsRules.js"></a>assetsRules.js</h4><p>源码如下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@title </span>assetsRules.js</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description </span>定义资源的规则</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// 支持本地 svg 导入</span></span><br><span class="line">    test: <span class="regexp">/\.svg$/</span>,</span><br><span class="line">    use: [<span class="string">'@svgr/webpack'</span>],</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>终于来了！只要单纯使用这个 loader，便可以解决上文中提到的本地以组件方式引入 svg 的问题！没有其他任何的幺蛾子！非常简单的配置!!!(这里当然也顺便解决了 alias 引入的问题)</p>
<h4 id="pluginsConfig-js"><a href="#pluginsConfig-js" class="headerlink" title="pluginsConfig.js"></a>pluginsConfig.js</h4><p>源码如下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@title </span>plugins.js</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description </span>这个文件是为了存放 webpack 插件用的</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>)</span><br><span class="line"><span class="keyword">const</span> &#123; resolve &#125; = <span class="built_in">require</span>(<span class="string">'./utils'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = [</span><br><span class="line">  <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">    template: resolve(<span class="string">'public/index.html'</span>),</span><br><span class="line">    inject: <span class="literal">true</span> <span class="comment">// script 注入到 template 的 body 下</span></span><br><span class="line">  &#125;)</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p><code>html-webpack-plugin</code> 一个耳熟能详的插件了，本质上的作用就是将生成的 js 生成 script 标签并且注入到模板页面的 body 中</p>
<p>当然在这个文件中统一做插件的处理，这样就能够方便的管理配置</p>
<h4 id="resolveConfig-js"><a href="#resolveConfig-js" class="headerlink" title="resolveConfig.js"></a>resolveConfig.js</h4><p>源码如下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@title </span>aliases.js</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description </span>webpack 中需要配置的 alias</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> &#123; resolve &#125; = <span class="built_in">require</span>(<span class="string">'./utils'</span>)</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  extensions: [<span class="string">'.js'</span>, <span class="string">'.jsx'</span>, <span class="string">'.ts'</span>, <span class="string">'.tsx'</span>], <span class="comment">// 定义了文件的下标之后，以后 import js 模块的时候可以不用加后缀</span></span><br><span class="line">  alias: &#123; <span class="comment">// 定义 alias</span></span><br><span class="line">    <span class="string">'@'</span>: resolve(<span class="string">'src'</span>),</span><br><span class="line">    <span class="string">'@api'</span>: resolve(<span class="string">'src/api'</span>),</span><br><span class="line">    <span class="string">'@assets'</span>: resolve(<span class="string">'src/assets'</span>),</span><br><span class="line">    <span class="string">'@components'</span>: resolve(<span class="string">'src/components'</span>),</span><br><span class="line">    <span class="string">'@router'</span>: resolve(<span class="string">'src/router'</span>),</span><br><span class="line">    <span class="string">'@styles'</span>: resolve(<span class="string">'src/styles'</span>),</span><br><span class="line">    <span class="string">'@utils'</span>: resolve(<span class="string">'src/utils'</span>),</span><br><span class="line">    <span class="string">'@views'</span>: resolve(<span class="string">'src/views'</span>),</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个文件的配置也很简单，基本就是配置了下 <code>extensions</code> 以及 <code>alias</code> 属性，都是为了方便写代码做的配置。不过这里需要注意的是，对于 <code>extensions</code> 配置，如果引入的是同名的文件，比如在某个文件夹下有两个文件 <code>xxx.js</code>、<code>xxx.jsx</code>，你这边做引入了 <code>import xxx from &#39;xxx&#39;</code>，那么这个时候 webpack 就会采用你 <code>extensions</code> 中配置的第一个后缀名，剩下的不要，也就是说你最终引入的就是 <code>xxx.js</code></p>
<h4 id="devServerConfig-js"><a href="#devServerConfig-js" class="headerlink" title="devServerConfig.js"></a>devServerConfig.js</h4><p>源码如下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@title </span>devServerConfig.js</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description </span>devServer 配置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="built_in">require</span>(<span class="string">'./devServerProxyConfig'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> host = process.env.HOST || <span class="string">'0.0.0.0'</span></span><br><span class="line"><span class="keyword">const</span> port = process.env.PORT || <span class="number">3000</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  compress: <span class="literal">true</span>, <span class="comment">// 为所有 served 的文件启用 gzip 压缩</span></span><br><span class="line">  clientLogLevel: <span class="string">'debug'</span>, <span class="comment">// 设置 log 等级，可设置为 'silent' | 'trace' | 'debug' | 'info' | 'warn' | 'error' | 'none' | 'warning'</span></span><br><span class="line">  hot: <span class="literal">true</span>, <span class="comment">// 开启热重载</span></span><br><span class="line">  host,</span><br><span class="line">  overlay: <span class="literal">false</span>, <span class="comment">// 出现编译器错误或警告时，在浏览器中显示全屏覆盖。 如果只想显示编译器错误就置为 true</span></span><br><span class="line">  port,</span><br><span class="line">  proxy,</span><br><span class="line">  quiet: <span class="literal">false</span>, <span class="comment">// 允许 errors 或者 warnings log</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注释都写的很清楚了，其实都是些基本的配置</p>
<h4 id="devServerProxyConfig-js"><a href="#devServerProxyConfig-js" class="headerlink" title="devServerProxyConfig.js"></a>devServerProxyConfig.js</h4><p>源码如下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@title </span>devServerProxyConfig.js</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description </span>devServer proxy 代理配置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="string">'/xhb_api'</span>: &#123;</span><br><span class="line">    target: <span class="string">'https://demo.xxx.cn'</span>,</span><br><span class="line">    changeOrigin: <span class="literal">true</span>, <span class="comment">// 默认情况下，代理时会保留主机头的来源，您可以将 changeOrigin 设置为 true 来覆盖此行为。</span></span><br><span class="line">    pathRewrite: &#123;</span><br><span class="line">      <span class="string">'^/xhb_api'</span>: <span class="string">'/api'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">'/api'</span>: &#123;</span><br><span class="line">    target: process.env.REACT_APP_API_DOMAIN,</span><br><span class="line">    changeOrigin: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代理配置，跟之前 <code>vue.config.js</code> 中的代理配置很像的，上面第一个代理配置表示 <strong>请求 /xhb_api/users/xxx 类似的接口时，请求本来会被代理到 <a href="https://demo.xxx.cn/xhb_api/user/xxx" target="_blank" rel="noopener">https://demo.xxx.cn/xhb_api/user/xxx</a> 这个上面来，但是因为你写了 pathRewrite，中间的 /xhb_api 会被替换成 /api，也就是说最终的代理地址为 <a href="https://demo.xxx.cn/api/user/xxx" target="_blank" rel="noopener">https://demo.xxx.cn/api/user/xxx</a></strong></p>
<h3 id="微小的总结"><a href="#微小的总结" class="headerlink" title="微小的总结"></a>微小的总结</h3><p>至此为止，一个基本的基于 react 以及 typescript 的项目就搭建完成了，后续的部分就是对模板进行些许优化的步骤了。不过总体来看，比之前使用 cra eject 的配置清爽了不少，并且由于配置的模块化(而不是函数嵌套似的模块化)，也使得项目本身易于阅读和拓展</p>
<h3 id="优化配置"><a href="#优化配置" class="headerlink" title="优化配置"></a>优化配置</h3><h4 id="构建加速与构建缓存"><a href="#构建加速与构建缓存" class="headerlink" title="构建加速与构建缓存"></a>构建加速与构建缓存</h4><p>首先需要安装两个 loader</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yarn add -D cache-loader thread-loader</span><br></pre></td></tr></table></figure>
<p>一般使用 <code>cache-loader</code> 构建缓存，用 <code>thread-loader</code> 构建加速。首先创建 <code>config/loaders.js</code> 文件。然后源码如下所示</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"> * @description 这个文件是为了设置构建缓存和构建加速用的</span><br><span class="line"> *<span class="regexp">/</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">const &#123; resolve &#125; = require('./u</span>tils<span class="string">')</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">// 构建缓存</span></span><br><span class="line"><span class="string">const cacheLoader = &#123;</span></span><br><span class="line"><span class="string">  loader: '</span>cache-loader<span class="string">',</span></span><br><span class="line"><span class="string">  options: &#123;</span></span><br><span class="line"><span class="string">    // 缓存文件路径</span></span><br><span class="line"><span class="string">    cacheDirectory: resolve('</span>.cache-loader<span class="string">')</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">// 构建加速，多线程编译</span></span><br><span class="line"><span class="string">const threadLoader = workerParallelJobs =&gt; &#123;</span></span><br><span class="line"><span class="string">  const options = &#123; workerParallelJobs &#125;</span></span><br><span class="line"><span class="string">  Object.assign(options, &#123;</span></span><br><span class="line"><span class="string">    poolTimeout: 2000</span></span><br><span class="line"><span class="string">  &#125;)</span></span><br><span class="line"><span class="string">  return &#123;</span></span><br><span class="line"><span class="string">    loader: '</span>thread-loader<span class="string">',</span></span><br><span class="line"><span class="string">    options</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">module.exports = &#123;</span></span><br><span class="line"><span class="string">  cacheLoader,</span></span><br><span class="line"><span class="string">  threadLoader</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>
<p>构建缓存的原理就是在本地有一个 .cache-loader 的文件夹，所有的需要缓存的玩意儿都放在这个里面，这样每次构建的时候若变化不大就直接取缓存里面的东西输出，可以加快构建的速度。而构建加速就是开启多线程编译。</p>
<p>因为平常在编译时，需要编译的主要是 js 以及 css 文件，所以应当在 <code>jsRules</code> 以及 <code>styleRules</code> 里引入</p>
<p><img src="./4.png" alt><br><img src="./5.png" alt></p>
<p>这里 <code>less-loader</code> 就没有用到 <code>thread-loader</code> 了，因为会报错</p>
<h4 id="优化打包和抽离-css"><a href="#优化打包和抽离-css" class="headerlink" title="优化打包和抽离 css"></a>优化打包和抽离 css</h4><p>优化打包方面主要用到了两个插件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yarn add -D terser-webpack-plugin optimize-css-assets-webpack-plugin</span><br></pre></td></tr></table></figure>
<ul>
<li>terser-webpack-plugin 是用来优化 js 的压缩过程的，这里没有用到 <code>webpack.optimize.UglifyJsPlugin</code> 的原因是该插件不支持 es6 语法，为了方便就直接使用它了</li>
<li>optimize-css-assets-webpack-plugin 是用来优化 css 的压缩过程的</li>
</ul>
<p>再加上 webpack 本身有对代码分割的 <code>optimization</code> 配置，那么一个优化配置文件 <code>config/optimizationConfig.js</code> 的源码就是如下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@title </span>optimizationConfig.js</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description </span>定义 webpack 优化配置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> TerserPlugin = <span class="built_in">require</span>(<span class="string">'terser-webpack-plugin'</span>)</span><br><span class="line"><span class="keyword">const</span> OptimizeCSSAssetsPlugin = <span class="built_in">require</span>(<span class="string">'optimize-css-assets-webpack-plugin'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// 将部分清单代码单独打包出来并命名为 manifest</span></span><br><span class="line">  runtimeChunk: &#123;</span><br><span class="line">    name: <span class="string">'manifest'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  splitChunks: &#123; <span class="comment">// 这是 webpack optimization 的优化配置，具体可以参考官网，本质上就是配置需要分离的包</span></span><br><span class="line">    cacheGroups: &#123;</span><br><span class="line">      <span class="keyword">default</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="comment">// 抽离 node_modules 下的公共代码</span></span><br><span class="line">      <span class="comment">// TODO 这里还可以继续抽离代码，待优化</span></span><br><span class="line">      commons: &#123;</span><br><span class="line">        test: <span class="regexp">/[\\/]node_modules[\\/]/</span>,</span><br><span class="line">        name: <span class="string">'commons'</span>,</span><br><span class="line">        chunks: <span class="string">'initial'</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">// 这里还可以为一些其他的包做单独打包的配置，比如</span></span><br><span class="line">      <span class="comment">// antd: &#123;</span></span><br><span class="line">      <span class="comment">//   name: 'antd',</span></span><br><span class="line">      <span class="comment">//   test: /[\\/]node_modules[\\/](antd)[\\/]/,</span></span><br><span class="line">      <span class="comment">//   chunks: 'all',</span></span><br><span class="line">      <span class="comment">//   priority: 9</span></span><br><span class="line">      <span class="comment">// &#125;,</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  minimizer: [</span><br><span class="line">    <span class="comment">// 优化 js 压缩过程</span></span><br><span class="line">    <span class="keyword">new</span> TerserPlugin(&#123;</span><br><span class="line">      <span class="comment">// 开启缓存</span></span><br><span class="line">      cache: <span class="literal">true</span>,</span><br><span class="line">      <span class="comment">// 开启多线程</span></span><br><span class="line">      parallel: <span class="literal">true</span>,</span><br><span class="line">      extractComments: <span class="literal">false</span></span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="comment">// 优化 css 压缩过程</span></span><br><span class="line">    <span class="keyword">new</span> OptimizeCSSAssetsPlugin(&#123;</span><br><span class="line">      <span class="comment">// 使用 cssnano 压缩，插件自带</span></span><br><span class="line">      cssProcessor: <span class="built_in">require</span>(<span class="string">'cssnano'</span>),</span><br><span class="line">      cssProcessorOptions: &#123;</span><br><span class="line">        safe: <span class="literal">true</span>,</span><br><span class="line">        autoprefixer: <span class="literal">false</span>,</span><br><span class="line">        discardComments: &#123;</span><br><span class="line">          removeAll: <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">// 将压缩过程输出到控制台</span></span><br><span class="line">      canPrint: <span class="literal">true</span></span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>css 文件若是都堆积在一坨也会变的很大，所以需要 <code>mini-css-extract-plugin</code> 来对 css 进行抽离</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">yarn add -D mini-css-extract-plugin</span><br></pre></td></tr></table></figure>
<p>在 <code>config/pluginsConfig.js</code> 中加上这个插件配置</p>
<p><img src="./6.png" alt></p>
<p>然后在 <code>styleRules.js</code> 中加上这个 MiniCssExtractPluginLoader（是的，本身这个插件是包含一个 loader 和一个 plugin 的）</p>
<p><img src="./7.png" alt></p>
<p>这里为啥要对 <code>style-loader</code> 做一个替换呢，因为我们知道在 <code>style-loader</code> 是在页面上添加一个 style 节点的，而分离 css 的步骤应该发生在 <code>css-loader</code> 之后，所以需要做一个替换(也就是说 minicss extract 这个插件内部帮我们做了 style-loader 的事情)</p>
<p>这里需要注意几个 hash 值所表达的意思</p>
<ol>
<li>hash: hash 和整个项目的配置有关，只要项目中有代码改变，那么所有打包出来的 hash 值都会变，并且所有文件共用一个 hash 值</li>
<li>chunkhash: chunkhash 和 hash 不同点在于，它根据入口文件进行依赖文件解析，然后构建对应的 hash 值，也就是每个打包出来的文件 hash 值都是不一样的，每次修改代码时候，他会根据依赖关系自动修改相关模块的 hash 值，但是打包出来对应的 js 和 css 文件的 hash 会相同。</li>
<li>contenthash: 在打包代码的时候，一般会将 css 文件分离出来，然后我们通常会在组件中引入 css 文件，这时候如果使用的是 chunkhash，在只修改组件 js 代码的情况下因为对应的 css 文件的 hash 值相同，打包出来的 css 文件的 hash 值也会跟着变，这时候就可以使用 contenthash了，他会针对每个文件的内容来计算 hash 值</li>
</ol>
<h4 id="将-config-json-拷贝到-dist-目录"><a href="#将-config-json-拷贝到-dist-目录" class="headerlink" title="将 config.json 拷贝到 dist 目录"></a>将 config.json 拷贝到 dist 目录</h4><p>这个很简单，只需要装一个插件 <code>copy-webpack-plugin</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yarn add -D copy-webpack-plugin</span><br></pre></td></tr></table></figure>
<p>然后在 <code>config/pluginsConfig.js</code> 中配置这个插件</p>
<p><img src="./8.png" alt></p>
<h4 id="支持在代码中使用环境变量"><a href="#支持在代码中使用环境变量" class="headerlink" title="支持在代码中使用环境变量"></a>支持在代码中使用环境变量</h4><p>可以使用 <code>dotenv-webpack</code> 这个插件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yarn add -D dotenv-webpack</span><br></pre></td></tr></table></figure>
<p>然后在 <code>config/pluginsConfig.js</code> 中引入这个插件</p>
<p><img src="./9.png" alt></p>
<p><code>path</code> 属性表示引入的是哪个文件</p>
<h4 id="支持-px-向-vw-的单位转换"><a href="#支持-px-向-vw-的单位转换" class="headerlink" title="支持 px 向 vw 的单位转换"></a>支持 px 向 vw 的单位转换</h4><p>这个配置是直接从 xp 的项目拷贝过来的，即 <code>postcss.config.js</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  plugins: &#123;</span><br><span class="line">    autoprefixer: &#123;&#125;,</span><br><span class="line">    <span class="string">'postcss-px-to-viewport'</span>: &#123;</span><br><span class="line">      viewportWidth: <span class="string">'375'</span>, <span class="comment">// 视窗的宽度，对应的是我们设计稿的宽度，一般是750</span></span><br><span class="line">      unitPrecision: <span class="number">3</span>, <span class="comment">// 指定`px`转换为视窗单位值的小数位数（很多时候无法整除）</span></span><br><span class="line">      viewportUnit: <span class="string">'vw'</span>, <span class="comment">// 指定需要转换成的视窗单位，建议使用vw</span></span><br><span class="line">      <span class="comment">// propList: ['*', '!background-image'],</span></span><br><span class="line">      selectorBlackList: [</span><br><span class="line">        <span class="comment">// 指定不转换为视窗单位的类，可以自定义，可以无限添加,建议定义一至两个通用的类名</span></span><br><span class="line">        <span class="string">'ignore'</span>,</span><br><span class="line">      ],</span><br><span class="line">      minPixelValue: <span class="number">1</span>, <span class="comment">// 小于或等于`1px`不转换为视窗单位</span></span><br><span class="line">      mediaQuery: <span class="literal">false</span>, <span class="comment">// 允许在媒体查询中转换`px`</span></span><br><span class="line">      <span class="comment">// exclude: /(\/|\\)(node_modules)(\/|\\)/</span></span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是这里需要安装两个东西</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yarn add -D postcss-loader postcss-px-to-viewport</span><br></pre></td></tr></table></figure>
<p>因为是对 css 做一个预处理，所以应该是在 sass-loader 转换为 css 之后应该执行这个 loader，所以直接在 sass-loader 后添加这个 loader 即可</p>
<p><img src="./10.png" alt></p>
<h4 id="提交自动检查-commit"><a href="#提交自动检查-commit" class="headerlink" title="提交自动检查 commit"></a>提交自动检查 commit</h4><p>在 <code>pre-commit</code> 之前要能够自动检查代码以及 commit，首先需要安装 husky</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yarn add -D husky</span><br></pre></td></tr></table></figure>
<p>然后在 <code>package.json</code> 中做配置</p>
<p><img src="./11.png" alt></p>
<p>要规范 commit 提交，就必须安装如下的库</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yarn add -D @commitlint/cli @commitlint/config-conventional</span><br></pre></td></tr></table></figure>
<p>然后新建一个 <code>commitlint.config.js</code>，自定义 commit 提交规则</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// commitlint.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  extends: [<span class="string">'@commitlint/config-conventional'</span>],</span><br><span class="line">  rules: &#123;</span><br><span class="line">    <span class="string">'type-enum'</span>: [</span><br><span class="line">      <span class="number">2</span>,</span><br><span class="line">      <span class="string">'always'</span>,</span><br><span class="line">      [</span><br><span class="line">        <span class="string">'chore'</span>,</span><br><span class="line">        <span class="string">'feat'</span>,</span><br><span class="line">        <span class="string">'fix'</span>,</span><br><span class="line">        <span class="string">'test'</span>,</span><br><span class="line">        <span class="string">'perf'</span>,</span><br><span class="line">        <span class="string">'style'</span>,</span><br><span class="line">        <span class="string">'merge'</span>,</span><br><span class="line">        <span class="string">'config'</span>,</span><br><span class="line">        <span class="string">'improvement'</span>,</span><br><span class="line">      ],</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样每次提交时都会先检查代码，然后再检查提交，提交的规则可以<a href="https://github.com/conventional-changelog/commitlint" target="_blank" rel="noopener">参考</a></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上基本就是搭建模板中踩过的坑以及一系列的搭建步骤了，总的来说，还是手撸一遍项目比较香，不仅比当初的 cra eject 项目简单，而且也更利于后续人员的优化和配置</p>
]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>webpack</tag>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title>理解AJAX</title>
    <url>/2019/02/20/%E7%90%86%E8%A7%A3AJAX/</url>
    <content><![CDATA[<blockquote>
<p>AJAX, 是 Asynchronous JavaScript and XML, 即 javascript 的异步请求</p>
</blockquote>
<h2 id="发送请求的方法"><a href="#发送请求的方法" class="headerlink" title="发送请求的方法"></a>发送请求的方法</h2><ul>
<li>用 form 表单可以发送 GET 或者 POST 请求, 但是会刷新页面或新开页面</li>
<li>用 a 可以发送 GET 请求，但是也会刷新页面或新开页面</li>
<li>用 img 可以发送 GET 请求，但是只能以图片的形式展示</li>
<li>用 link 可以发送 GET 请求，但是只能以 CSS、favicon 的形式展示</li>
<li>用 script 可以发送 GET 请求，但是只能以脚本的形式进行</li>
</ul>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>微软在 IE5 中引入了 ActiveX 对象,使得 JS 可以发送 HTTP 请求,随后后面其他浏览器跟进，有了后来的 XMLHttpRequest,并纳入 W3C 规范</p>
<h2 id="AJAX"><a href="#AJAX" class="headerlink" title="AJAX"></a>AJAX</h2><ol>
<li>使用 XMLHttpRequest 发送请求</li>
<li>服务器返回 XML 格式的字符串</li>
<li>JS 解析 XML，并更新局部页面</li>
</ol>
<p>下面是使用原生 JS 发送 AJAX 请求的前端 Demo<br><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">myButton.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="params">()</span>=&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> request = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">    <span class="comment">// 配置 request</span></span><br><span class="line">    request.open(<span class="string">'GET'</span>, <span class="string">'/xxx'</span>);</span><br><span class="line">    request.send();</span><br><span class="line">    request.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (request.readyState === <span class="number">4</span>) &#123; <span class="comment">// 请求响应都完成</span></span><br><span class="line">            <span class="keyword">if</span> (request.status &gt;= <span class="number">200</span> &amp;&amp; request.status &lt; <span class="number">300</span>) &#123;</span><br><span class="line">                <span class="comment">// 请求成功,读取响应</span></span><br><span class="line">                <span class="built_in">console</span>.log(request.responseText);</span><br><span class="line">                <span class="keyword">let</span> parser = <span class="keyword">new</span> DOMParser();</span><br><span class="line">                <span class="keyword">let</span> xmlDoc = parser.parseFromString(request.responseText, <span class="string">'text/xml'</span>);</span><br><span class="line">                <span class="keyword">let</span> c = xmlDoc.getElementByTagName(<span class="string">'content'</span>)[<span class="number">0</span>].textContent;</span><br><span class="line">                <span class="comment">// 使用 JSON 方式</span></span><br><span class="line">                <span class="comment">// 把符合 JSON 语法的字符串，转换成 JS 对应的值</span></span><br><span class="line">                <span class="keyword">let</span> <span class="built_in">string</span> = request.responseText;</span><br><span class="line">                <span class="keyword">let</span> object = <span class="built_in">window</span>.JSON.parse(<span class="built_in">string</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (request.status &gt;= <span class="number">400</span>) &#123;</span><br><span class="line">                <span class="comment">// 请求失败</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>后端 node.js demo<br><figure class="highlight xquery"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in">(path</span> === <span class="string">'/xxx'</span>) &#123;</span><br><span class="line">    response.statusCode = <span class="number">200</span>;</span><br><span class="line">    response.setHeader(<span class="string">'Content-Type'</span>, <span class="string">'text/xml; charset=utf-8'</span>);</span><br><span class="line">    response.write(`</span><br><span class="line">        <span class="xml"><span class="tag">&lt;<span class="name">note</span>&gt;</span></span></span><br><span class="line"><span class="xml">            </span><span class="xml"><span class="tag">&lt;<span class="name">to</span>&gt;</span>Tove<span class="tag">&lt;/<span class="name">to</span>&gt;</span></span></span><br><span class="line"><span class="xml">            </span><span class="xml"><span class="tag">&lt;<span class="name">from</span>&gt;</span>Jani<span class="tag">&lt;/<span class="name">from</span>&gt;</span></span></span><br><span class="line"><span class="xml">            </span><span class="xml"><span class="tag">&lt;<span class="name">heading</span>&gt;</span>Reminder<span class="tag">&lt;/<span class="name">heading</span>&gt;</span></span></span><br><span class="line"><span class="xml">            </span><span class="xml"><span class="tag">&lt;<span class="name">content</span>&gt;</span>Don't forget me this weekend!<span class="tag">&lt;/<span class="name">content</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">note</span>&gt;</span></span></span><br><span class="line">    `);</span><br><span class="line">    response.<span class="keyword">end</span>();</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<h2 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h2><p>全称: JavaScript Object Notation, 轻量级的<strong>数据交换语言</strong>,抄袭 JS 的语言，官网为 <a href="json.org">json.org</a>, 由于其衍生自 JavaScript, 所以在某些地方跟 JavaScript 很像，比如传输的数据对象是由一些 “属性-值”对 以及 “数组数据类型” 组成</p>
<p>以下为 JavaScript 与 JSON 的区别</p>
<table>
<thead>
<tr>
<th style="text-align:center">JavaScript</th>
<th style="text-align:center">JSON</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">undefined</td>
<td style="text-align:center">没有</td>
</tr>
<tr>
<td style="text-align:center">null</td>
<td style="text-align:center">null</td>
</tr>
<tr>
<td style="text-align:center">[‘a’, ‘b’]</td>
<td style="text-align:center">[“a”, “b”]</td>
</tr>
<tr>
<td style="text-align:center">function fn(){}</td>
<td style="text-align:center">没有</td>
</tr>
<tr>
<td style="text-align:center">{name: ‘frank’}</td>
<td style="text-align:center">{“name”, “frank”}</td>
</tr>
<tr>
<td style="text-align:center">‘frank’</td>
<td style="text-align:center">“frank”</td>
</tr>
<tr>
<td style="text-align:center">var a = {};a.self = a</td>
<td style="text-align:center">没有变量</td>
</tr>
<tr>
<td style="text-align:center">{<code>__proto__</code>}</td>
<td style="text-align:center">没有原型链</td>
</tr>
</tbody>
</table>
<p>由此可以看出，<strong>JSON 只能用来表示 hash</strong></p>
<ol>
<li>JSON 没有抄袭 function 和 undefined</li>
<li>JSON 的字符串首尾必须是 <code>&quot;</code></li>
<li>需要补充的是，JSON 没有内置的 Date Math RegExp 等</li>
</ol>
<p>则以上的 xml 可以表示为<br><figure class="highlight gherkin"><table><tr><td class="code"><pre><span class="line">// 原 xml</span><br><span class="line"><span class="variable">&lt;note&gt;</span></span><br><span class="line">    <span class="variable">&lt;to&gt;</span>Tove<span class="variable">&lt;/to&gt;</span></span><br><span class="line">    <span class="variable">&lt;from&gt;</span>Jani<span class="variable">&lt;/from&gt;</span></span><br><span class="line">    <span class="variable">&lt;heading&gt;</span>Reminder<span class="variable">&lt;/heading&gt;</span></span><br><span class="line">    <span class="variable">&lt;content&gt;</span>Don't forget me this weekend!<span class="variable">&lt;/content&gt;</span></span><br><span class="line"><span class="variable">&lt;/note&gt;</span></span><br><span class="line"></span><br><span class="line">// 转换成 JSON</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"note"</span>: &#123;</span><br><span class="line">        <span class="string">"to"</span>: <span class="string">"Tove"</span>,</span><br><span class="line">        <span class="string">"from"</span>: <span class="string">"Jani"</span>,</span><br><span class="line">        <span class="string">"heading"</span>: <span class="string">"Reminder"</span>,</span><br><span class="line">        <span class="string">"content"</span>: <span class="string">"Don't forget me this weekend!"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h2><p>CORS, 全称 Cross-Orign Resource Sharing (跨源资源共享)</p>
<p>只有/协议/域名/端口一模一样的才允许发 AJAX 请求</p>
<ol>
<li><a href="http://baidu.com" target="_blank" rel="noopener">http://baidu.com</a> 可以向 <a href="http://www.baidu.com" target="_blank" rel="noopener">http://www.baidu.com</a> 发送 AJAX 请求嘛(不行)</li>
<li><a href="http://baidu.com:80" target="_blank" rel="noopener">http://baidu.com:80</a> 可以向 <a href="http://baidu.com:81" target="_blank" rel="noopener">http://baidu.com:81</a> 发送 AJAX 请求嘛(不行)</li>
</ol>
<p>那么怎么才能从一个网站访问到另一个网站的响应数据呢,有一个方式是设置响应头 <code>Access-Control-Allow-Orign</code></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>手写一个基本的 AJAX 请求 (原生 JS)<br><figure class="highlight vbscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="built_in">request</span> = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line"><span class="built_in">request</span>.open(<span class="comment">'GET', 'http://demo.com');</span></span><br><span class="line"><span class="built_in">request</span>.send();</span><br><span class="line"><span class="built_in">request</span>.onreadystatechange = () =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">request</span>.readyState === <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">request</span>.status &gt;=<span class="number">200</span> &amp;&amp; <span class="built_in">request</span>.status &lt; <span class="number">300</span>) &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="built_in">string</span> = <span class="built_in">request</span>.responseText;</span><br><span class="line">            <span class="keyword">let</span> object = window.JSON.parse(<span class="built_in">string</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>ajax</tag>
      </tags>
  </entry>
  <entry>
    <title>有关react hooks这一堆东西的详细解释(万字长文)</title>
    <url>/2020/03/09/%E6%9C%89%E5%85%B3react-hooks%E8%BF%99%E4%B8%80%E5%A0%86%E4%B8%9C%E8%A5%BF%E7%9A%84%E8%AF%A6%E7%BB%86%E8%A7%A3%E9%87%8A-%E4%B8%87%E5%AD%97%E9%95%BF%E6%96%87/</url>
    <content><![CDATA[<blockquote>
<p>本文主要会就 React hooks 中用的比较多的 <code>useState</code> 做一个详细讲解，其他的 hooks 会涉及到原理和使用但不会涉及到源码仿写，望周知</p>
</blockquote>
<a id="more"></a>
<h2 id="实现-useState"><a href="#实现-useState" class="headerlink" title="实现 useState"></a>实现 useState</h2><h3 id="useState-是怎么用的"><a href="#useState-是怎么用的" class="headerlink" title="useState 是怎么用的"></a>useState 是怎么用的</h3><p>在实现一个 <code>useState</code> 之前，先来看看 <code>useState</code> 大致是怎么用的</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123;useState&#125; <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [n, setN] = useState(<span class="number">0</span>)</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">"App"</span>&gt;</span><br><span class="line">      &lt;p&gt;&#123;n&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">      &lt;p&gt;</span></span><br><span class="line"><span class="regexp">        &lt;button onClick=&#123;() =&gt; setN(n+1)&#125;&gt;+1&lt;/</span>button&gt;</span><br><span class="line">      &lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里是一个简单的 <a href="https://codesandbox.io/s/inspiring-tree-3yrpr" target="_blank" rel="noopener">加法器的应用</a>，所以这里的效果就是点击一下 button, n 就会加 1。那么这里面的过程是怎么样的呢，这里分 2 部走</p>
<ul>
<li>首次渲染<br>  首次渲染时，会调用 <code>App()</code> 函数，得到一个 <strong>虚拟 DOM</strong>，然后再创建<strong>真实 DOM</strong></li>
<li>用户点击 button 时<br>  会先调用 <code>setN(n+1)</code> 函数，然后<strong>再次 render 渲染</strong>，渲染就调用 <code>App()</code> 函数，然后再次得到一个<strong>新的虚拟 DOM</strong>，这个虚拟 DOM 会和之前的虚拟 DOM 做一个 <strong>Diff</strong> 的操作，然后再更新对应的真实 DOM</li>
</ul>
<blockquote>
<p>这里注意，每次调用 <code>App()</code> 函数时，都会调用 <code>useState(0)</code></p>
</blockquote>
<p>所以这里我们可以看到两个问题</p>
<ul>
<li><strong>在执行 <code>setN</code></strong>时，<strong>n 不会变</strong>，但是 <code>App()</code> 函数会重新执行</li>
<li><code>App()</code> 函数在执行后，在 <code>useState(0)</code> 时，<strong>每次的 n 的值都是不同的</strong></li>
</ul>
<h3 id="分析-useState"><a href="#分析-useState" class="headerlink" title="分析 useState"></a>分析 useState</h3><p>对于数据 <code>X</code> 来说，使用 <code>useState</code> 会有如下的规律</p>
<ul>
<li><p><code>setN</code></p>
<ol>
<li><code>setN</code> 一定会修改数据 <code>X</code>, 将 <code>n+1</code> 存入 <code>X</code></li>
<li><code>setN</code> 一定会触发 <code>&lt;App/&gt;</code> 并重新渲染(执行 <code>App()</code> 函数)</li>
</ol>
</li>
<li><p><code>useState</code><br>  <code>useState</code> 肯定会从 <code>X</code> <strong>读取</strong> <code>n</code> 的最新值</p>
</li>
<li><p><code>X</code><br>  每个组件都有自己的数据 <code>X</code>，其实就是所谓的 <code>state</code></p>
</li>
</ul>
<h3 id="实现-useState-初级版本"><a href="#实现-useState-初级版本" class="headerlink" title="实现 useState 初级版本"></a>实现 useState 初级版本</h3><p>有了以上的分析，可以写一个简单的 <code>useState</code> 了</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> _state; <span class="comment">// 全局变量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> useState = <span class="function"><span class="params">initValue</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// _state 用来保存一个全局的状态</span></span><br><span class="line">  _state = _state === <span class="literal">undefined</span> ? initValue : _state;</span><br><span class="line">  <span class="comment">// setState 是一个 callback, 只要 setState 被调用，就会重新 render 一遍</span></span><br><span class="line">  <span class="comment">// 同时 _state 也会得到更新</span></span><br><span class="line">  <span class="keyword">const</span> setState = <span class="function"><span class="params">newValue</span> =&gt;</span> &#123;</span><br><span class="line">    _state = newValue;</span><br><span class="line">    render();</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> [_state, setState];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// render 函数</span></span><br><span class="line"><span class="keyword">const</span> render = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> rootElement = <span class="built_in">document</span>.getElementById(<span class="string">"root"</span>);</span><br><span class="line">  ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span></span>, rootElement);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这里为了方便起见，其 <code>render</code> 函数就直接调用了 <code>ReactDom.render</code>。比较关键的是这个全局的 <code>_state</code>，这个 <code>_state</code> 是一个全局的变量，为了下次渲染时不被初始化而设立的，<code>setState</code> 实际上就是一个回调，作用就是 <strong>保存 state 并开启渲染</strong>，所以这里可以知道为何在调用 <code>setN</code> 时，<code>n</code> 不会变了。因为此的 <code>n</code> 只是被存放在 <code>_state</code> 中，最后返回的 <code>_state</code> 中才是变化的 <code>n</code>，而只有再次渲染才能得到这个变化的 <code>n</code></p>
<h3 id="实现-useState-升级版本"><a href="#实现-useState-升级版本" class="headerlink" title="实现 useState 升级版本"></a>实现 useState 升级版本</h3><p>但是目前还有一个问题，就是万一同一个组件，调用用了 <strong>2 次以上的 useState</strong> 怎么办。以上的初始版本的代码会带来什么问题呢？就是因为 <code>_state</code> 是全局的，导致组件的数据之间会相互冲突</p>
<h4 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h4><p>解决的思路有两个</p>
<ul>
<li>将 <code>_state</code> 变成对象的形式，比如变成 <code>_state: {n: 0, m: 0}</code><br>  实际上这样做是不可取的，因为 <code>useState</code> 中参数就是传一个初始值(initValue)，这种情况下我们怎么知道是 <code>n</code> 是 0, 还是 <code>m</code> 是 0 呢</li>
<li>将 <code>_state</code> 变成<strong>数组</strong>的形式，比如 <code>_state: [0, 0]</code><br>  这种是可以的，因为可以通过<strong>下标</strong>区分每个 <code>useState</code> 的数据</li>
</ul>
<h4 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> _state = []; <span class="comment">// 全局变量</span></span><br><span class="line"><span class="keyword">let</span> index = <span class="number">0</span>; <span class="comment">// 解决 state 冲突的问题,因为有可能使用多个 useState</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> useState = <span class="function"><span class="params">initValue</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 保存当前的 index</span></span><br><span class="line">  <span class="keyword">let</span> currentIndex = index;</span><br><span class="line">  <span class="comment">// _state 用来保存一个全局的状态</span></span><br><span class="line">  _state[currentIndex] =</span><br><span class="line">    _state[currentIndex] === <span class="literal">undefined</span> ? initValue : _state[currentIndex];</span><br><span class="line">  <span class="comment">// setState 是一个 callback, 只要 setState 被调用，就会重新 render 一遍</span></span><br><span class="line">  <span class="comment">// 同时 _state 也会得到更新</span></span><br><span class="line">  <span class="keyword">const</span> setState = <span class="function"><span class="params">newValue</span> =&gt;</span> &#123;</span><br><span class="line">    _state[currentIndex] = newValue;</span><br><span class="line">    render();</span><br><span class="line">  &#125;;</span><br><span class="line">  index += <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> [_state[currentIndex], setState];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> render = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  index = <span class="number">0</span>; <span class="comment">// 注意这里要 index 置零</span></span><br><span class="line">  <span class="keyword">const</span> rootElement = <span class="built_in">document</span>.getElementById(<span class="string">"root"</span>);</span><br><span class="line">  ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span></span>, rootElement);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>既然要采取上面的数组的方案做，那么 <code>_state</code> 自然初始值就是一个数组。其他的逻辑并没有变化，主要是增加了一个全局的变量 <code>index</code> 以及一个 <code>useState</code> 中的临时变量 <code>currentIndex</code>。每次当 <code>useState</code> 执行时，<code>index</code> 就自增 1 与其他的 <code>state</code> 做区分。<code>currentIndex</code> 的作用是能让 <code>_state[0]</code> 有个初始值而不至于是 <code>undefined</code>。同时在每次 <code>render</code> 时需要将 <code>index</code> 置为零。这样一来每次执行 <code>useState</code> 得到的就是不同的 <code>n</code> 以及 <code>setN</code> 了</p>
<p><a href="https://codesandbox.io/s/winter-surf-9nqr2" target="_blank" rel="noopener">测试代码链接点击这里</a></p>
<h4 id="数组方案的主要缺点"><a href="#数组方案的主要缺点" class="headerlink" title="数组方案的主要缺点"></a>数组方案的主要缺点</h4><p>数组的一个很明显的缺点就是它的 <strong>调用顺序</strong>。因为数组非常强调顺序，所以在 React 中不允许出现类似如下的代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;useState&#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">...</span><br><span class="line">  <span class="keyword">const</span> [n, setN] = useState(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">let</span> m, setM;</span><br><span class="line">  <span class="keyword">if</span> (n % <span class="number">2</span> === <span class="number">0</span>) &#123;</span><br><span class="line">    [m, setM] = useState(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>React 就会报如下的错误</p>
<blockquote>
<p>❌ :React Hook “React.useState” is called conditionally. React Hooks must be called in the exact same order in every component render</p>
</blockquote>
<p>意思是说，React 不能依照条件调用 <code>useState</code>，在每个组件渲染时应该依照一样的顺序调用 hooks</p>
<p>所以在使用 React 相关的 hook 时，上面的代码是不被 React 允许的</p>
<h4 id="数组方案的其他缺点以及解决方案"><a href="#数组方案的其他缺点以及解决方案" class="headerlink" title="数组方案的其他缺点以及解决方案"></a>数组方案的其他缺点以及解决方案</h4><ul>
<li><code>App</code> 组件使用了全局的 <code>_state</code> 和 <code>index</code>，那么其他组件怎么用？不还是冲突了么？<br>  只需要在每个组件内部维护一个 <code>_state</code> 和 <code>index</code> 即可</li>
<li>对于类组件来说，不存在全局作用域重名的问题，对于函数组件来说就有，这个时候怎么办？<br>  只需要将 <code>_state</code> 和 <code>index</code> 放在组件对应的虚拟 DOM 对象上即可</li>
</ul>
<p>原理是这样的</p>
<p><img src="./1.png" alt></p>
<p>在函数组件调用了 <code>useState</code> 时，就会更新绑定在虚拟 DOM 对象上的 <code>_state</code> 和 <code>index</code>，当下次数据有变化触发 render 时，会再次调用 <code>useState</code> 并生成一个新的虚拟 DOM 对象，这个对象会跟之前的旧对象进行一个 Diff 的操作，对比出要更改的节点后会出一个 Patch，然后再根据这个 Patch 更新虚拟 DOM 上的数据，这里面包括了 <code>_state</code> 和 <code>index</code>，最后再修改生成一个真实 DOM 节点。</p>
<h3 id="useState-注意点"><a href="#useState-注意点" class="headerlink" title="useState 注意点"></a>useState 注意点</h3><ul>
<li><p>对于其使用状态</p>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> [n, setN] = React.useState(<span class="number">0</span>) <span class="comment">// 这里 n 的初始值就是 0</span></span><br><span class="line"><span class="keyword">const</span> [m, setM] = React.useState(&#123;<span class="attr">name</span>: <span class="string">'xxx'</span>&#125;) <span class="comment">// 这里 m 的初始值就是 &#123;name: 'xxx'&#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>不可以局部更新<br>  <a href="https://codesandbox.io/s/laughing-dawn-v2d5t" target="_blank" rel="noopener">代码链接</a></p>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> [user, setUser] = useState(&#123; <span class="attr">name</span>: <span class="string">"xxx"</span>, <span class="attr">age</span>: <span class="number">18</span> &#125;);</span><br><span class="line"><span class="keyword">const</span> onClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  setUser(&#123;</span><br><span class="line">    name: <span class="string">"Jack"</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line">  &lt;div className=<span class="string">"App"</span>&gt;</span><br><span class="line">    &lt;h1&gt;&#123;user.name&#125;&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">    &lt;h2&gt;&#123;user.age&#125;&lt;/</span>h2&gt;</span><br><span class="line">    &lt;button onClick=&#123;onClick&#125;&gt;Click&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>div&gt;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>  从贴出的代码链接可以看出，点击 button 后，<code>user.age</code> 并没有显示出来。这是因为 <strong>setState 并不会帮你合并属性，要合并的话需要自己额外操作，比如利用拓展运算符 <code>...</code></strong></p>
</li>
<li><p><code>setState(obj)</code> 中的地址要变<br>  <a href="https://codesandbox.io/s/runtime-feather-2wi3n" target="_blank" rel="noopener">代码链接</a></p>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> [user, setUser] = useState(&#123; <span class="attr">name</span>: <span class="string">"xxx"</span>, <span class="attr">age</span>: <span class="number">18</span> &#125;);</span><br><span class="line"><span class="keyword">const</span> obj = user <span class="comment">// 注意这里 !!!</span></span><br><span class="line"><span class="keyword">const</span> onClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  obj.name = <span class="string">'Jack'</span> <span class="comment">// 注意这里 !!!</span></span><br><span class="line">  setUser(obj); <span class="comment">// 在这种情况下页面数据是不会更新的 !!!</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line">  &lt;div className=<span class="string">"App"</span>&gt;</span><br><span class="line">    &lt;h1&gt;&#123;user.name&#125;&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">    &lt;h2&gt;&#123;user.age&#125;&lt;/</span>h2&gt;</span><br><span class="line">    &lt;button onClick=&#123;onClick&#125;&gt;Click&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>div&gt;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>  只要 <code>obj</code> 的地址没变，React 就认为其数据没有变化，因此就不会触发更新</p>
</li>
<li><p><code>useState</code> 可以接受一个函数</p>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> [state, setState] = useState(<span class="function"><span class="params">()</span> =&gt;</span> initialState) <span class="comment">// 该函数返回初始值 state，且只执行一次</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>setState</code> 可以接受一个函数</p>
<p>  <a href="https://codesandbox.io/s/runtime-feather-2wi3n" target="_blank" rel="noopener">代码链接</a></p>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> [n, setN] = useState(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">const</span> onClick = <span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">  setN(n+<span class="number">1</span>)</span><br><span class="line">  setN(n+<span class="number">1</span>) <span class="comment">// 你会发现 n 不能加 2</span></span><br><span class="line">  <span class="comment">// setN(i=&gt;i+1)</span></span><br><span class="line">  <span class="comment">// setN(i=&gt;i+1) // 但是使用了函数之后就可以加 2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line">  &lt;div className=<span class="string">"App"</span>&gt;</span><br><span class="line">    &lt;h1&gt;n: &#123;n&#125;&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">    &lt;button onClick=&#123;onClick&#125;&gt;+2&lt;/</span>button&gt;</span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">);</span></span><br></pre></td></tr></table></figure>
<p>  所以为了避免 bug，应该优先使用这种在 <code>setState</code> 中传函数更新 <code>state</code> 的方式</p>
</li>
</ul>
<h3 id="useState-总结"><a href="#useState-总结" class="headerlink" title="useState 总结"></a>useState 总结</h3><ul>
<li>每个函数组件对应着一个 React 节点(FiberNode)</li>
<li>每个节点保存着 <code>_state</code> 和 <code>index</code></li>
<li>useState 会读取 <code>_state[index]</code></li>
<li><code>index</code> 由 useState 出现的顺序决定</li>
<li><code>setState</code> 会修改 <code>_state</code>，并且之后会触发更新</li>
</ul>
<blockquote>
<p>⚠ 注意：这里只是一个对 <code>useState</code> 的思路型源码，并非是 React hook 中的源码。另这里的 <code>_state</code> 对应源码中的 <code>memorizedState</code>，而 <code>index</code> 在源码中是利用链表来实现的。这里只是抛砖引玉一下。</p>
</blockquote>
<h2 id="useReducer"><a href="#useReducer" class="headerlink" title="useReducer"></a>useReducer</h2><p><code>useReducer</code> 本质就是用来践行 <code>Flux/Redux</code> 的思想的这么一个 hook，例子的<a href="https://codesandbox.io/s/practical-lederberg-f1hp6" target="_blank" rel="noopener">代码链接</a>在这里</p>
<h3 id="使用-useReducer"><a href="#使用-useReducer" class="headerlink" title="使用 useReducer"></a>使用 useReducer</h3><p>首先是声明一个 <code>initial</code> 初始变量</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> initial = &#123;</span><br><span class="line">  n: <span class="number">0</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>然后声明 <code>reducer</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> reducer = <span class="function">(<span class="params">state, action</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (action.type === <span class="string">"add"</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">n</span>: state.n + action.number &#125;;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (action.type === <span class="string">"multi"</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">n</span>: state.n * <span class="number">2</span> &#125;;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"unknown type"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>然后在 <code>App()</code> 函数组件中使用将这个 <code>reducer</code> 以及 <code>initial</code> 值当作参数传入 <code>useReducer</code> 中，返回的就是一个 <code>state</code> 和 <code>dispatch</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注意这里参数的传入顺序</span></span><br><span class="line"><span class="keyword">const</span> [state, dispatch] = useReducer(reducer, initial);</span><br><span class="line"><span class="keyword">const</span> &#123; n &#125; = state;</span><br><span class="line"><span class="keyword">const</span> onClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  dispatch(&#123; <span class="attr">type</span>: <span class="string">"add"</span>, <span class="attr">number</span>: <span class="number">1</span> &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> onClick2 = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  dispatch(&#123; <span class="attr">type</span>: <span class="string">"add"</span>, <span class="attr">number</span>: <span class="number">2</span> &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line">  &lt;div className=<span class="string">"App"</span>&gt;</span><br><span class="line">    &lt;h1&gt;n: &#123;n&#125;&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">    &lt;button onClick=&#123;onClick&#125;&gt;+1&lt;/</span>button&gt;</span><br><span class="line">    &lt;button onClick=&#123;onClick2&#125;&gt;+<span class="number">2</span>&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>div&gt;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>可以看出，以上的代码是分几步走的</p>
<ol>
<li>创建初始值 <code>initial</code></li>
<li>创建 <code>reducer</code> 这个操作的集合，它接受一个 <code>state</code> 和一个 <code>action</code></li>
<li>将 <code>reducer</code> 和 <code>initial</code> 传给 <code>useReducer</code>，并得到一个读(<code>state</code>)和写(<code>dispatch</code>)的 API</li>
<li>调用写(<code>dispatch</code>) API 传入 <code>{type: &#39;操作类型&#39;}</code> 去对 <code>state</code> 做相应的更新</li>
</ol>
<p>从以上描述我们不难看出，这个 <code>useReducer</code> 可以用来代替 <code>redux</code></p>
<h3 id="使用-useReducer-代替-redux"><a href="#使用-useReducer-代替-redux" class="headerlink" title="使用 useReducer 代替 redux"></a>使用 useReducer 代替 redux</h3><p><a href="https://codesandbox.io/s/interesting-volhard-lfxpm" target="_blank" rel="noopener">代码链接</a></p>
<blockquote>
<p>由于代码太长了所以这里就不放代码了，详情可以点击链接中的代码去查看</p>
</blockquote>
<p>由以上的代码我们可以知道一个基本的使用 <code>useReducer</code> 代替 redux 的步骤为</p>
<ol>
<li>声明一个 <code>store</code> 对象，对象中存放着该组件使用的数据</li>
<li>声明一个 <code>reducer</code> ，所有的相关的 crud 之类的操作都往这个里面放</li>
<li>使用 <code>createContext</code> 创建一个 <code>Context</code>，为组件间传递数据做准备</li>
<li>在 <code>App</code> 组件中使用 <code>useReducer</code> 创建读写 API，在其子组件中使用 <code>useContext</code> 创建读写 API(读: state 访问数据, 写: dispatch 对数据进行操作)</li>
<li>将第 4 步的返回内容放入到第 3 步的 <code>Context.Provider</code> 组件的 <code>value</code> 中</li>
<li>使用 <code>Context.Provider</code> 将 <code>Context</code> 提供给所有组件</li>
<li>然后各个子组件使用 <code>useContext(Context)</code> 获取到读写 API</li>
</ol>
<p>当然了，如果涉及到模块化的问题，将代码分开就可以了。比如</p>
<p><code>Context.js</code> 中可以放入</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Context.js</span></span><br><span class="line">mport React <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Context = React.createContext(<span class="literal">null</span>);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Context;</span><br></pre></td></tr></table></figure>
<p><code>reducers</code> 可以单独建立一个文件夹，里面放入的都是对应数据的一些操作，比如对 book 的操作可以这么写</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// reducers/books_reducer.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  setBooks: <span class="function">(<span class="params">state, action</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; ...state, <span class="attr">books</span>: action.books &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  deleteBook: <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>然后 <code>App</code> 子组件就放入 <code>components</code> 文件夹中，里面就是组件的一些东西了，这里不再赘述</p>
<p>最后的最后，在从 <code>src/index.js</code> 中引入这些文件即可，然后再做相应的代码优化。实际上模块化的本质就是分类整理代码，这样做了之后基本就能起到替代 <code>redux</code> 的作用了</p>
<h3 id="useReducer-注意点"><a href="#useReducer-注意点" class="headerlink" title="useReducer 注意点"></a>useReducer 注意点</h3><p>需要注意的是，<code>useReducer</code> 本身也不会帮你合并属性，所以同 <code>useState</code> 一样，要合并属性时需要自己动手操作</p>
<h3 id="useReducer-总结"><a href="#useReducer-总结" class="headerlink" title="useReducer 总结"></a>useReducer 总结</h3><p>总的来说，<code>useReducer</code> 这个 hook 其实本质上借鉴了 Flux/Redux 的一些思想，我们可以通过一些 hooks 来创建一个类似 <code>redux</code> 的写法，只要将其模块化后就可以替代 redux</p>
<h2 id="useRef"><a href="#useRef" class="headerlink" title="useRef"></a>useRef</h2><p>在理解 <code>uesRef</code> 之前，先看一个<a href="https://codesandbox.io/s/boring-booth-n6igq" target="_blank" rel="noopener">例子</a></p>
<h3 id="useState-的-bug"><a href="#useState-的-bug" class="headerlink" title="useState 的 bug"></a>useState 的 bug</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState &#125; <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [n, setN] = useState(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> log = <span class="function"><span class="params">()</span> =&gt;</span> setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">"n ="</span>, n), <span class="number">3000</span>);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">"App"</span>&gt;</span><br><span class="line">      &lt;p&gt;&#123;n&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">      &lt;p&gt;</span></span><br><span class="line"><span class="regexp">        &lt;button</span></span><br><span class="line"><span class="regexp">          onClick=&#123;() =&gt; &#123;</span></span><br><span class="line"><span class="regexp">            setN(n + 1);</span></span><br><span class="line"><span class="regexp">          &#125;&#125;</span></span><br><span class="line"><span class="regexp">        &gt;</span></span><br><span class="line"><span class="regexp">          +1</span></span><br><span class="line"><span class="regexp">        &lt;/</span>button&gt;</span><br><span class="line">      &lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">      &lt;p&gt;</span></span><br><span class="line"><span class="regexp">        &lt;button onClick=&#123;log&#125;&gt;log&lt;/</span>button&gt;</span><br><span class="line">      &lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在有个问题，在点击完 +1 button 然后点击 log，打印出来的 n 是正常的。但是如果是先 log 然后立即执行 +1，那么我们可以发现一个 bug，就是 <strong>n 居然没有变化!!!居然还是之前的旧数据!!!</strong></p>
<p>wtf, 这是什么情况???</p>
<p>先来看一张图</p>
<p><img src="./2.png" alt></p>
<ul>
<li>如果先点 +1 再点 log<br>  <code>setN</code> 会先执行，然后触发 <code>render</code>，3 秒过后，<code>log</code> 里面读到的 <code>n</code> 就是 <strong>已经从 <code>useState</code></strong> 里面读出来的 <code>n</code>，所以 <code>n = 1</code></li>
<li>如果先点 log 再点 +1<br>  <code>log</code> 会先执行，但是注意，此时 <code>log</code> 里的 <code>n</code> 还是初始状态下读到的 <strong>旧的 <code>n</code></strong>，随后 <code>setN</code> 执行后会产生一个<strong>新的 <code>n</code></strong>。然而此时其触发的 <code>render</code> 早就更新页面上的 <code>n</code> 了。所以会出现这种 “滞后” 的 bug</li>
</ul>
<h3 id="useState-bug-的解决方案"><a href="#useState-bug-的解决方案" class="headerlink" title="useState bug 的解决方案"></a>useState bug 的解决方案</h3><ul>
<li><p>将 <code>n</code> 和 <code>setN</code> 挂在全局变量 <code>window</code> 上<br>  这种解决方案太傻了，不考虑变量之间相互污染的问题么?</p>
</li>
<li><p>使用 <code>useRef</code></p>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useRef &#125; <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> n = useRef(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> log = <span class="function"><span class="params">()</span> =&gt;</span> setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">"n ="</span>, n.current), <span class="number">3000</span>);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">"App"</span>&gt;</span><br><span class="line">      &lt;p&gt;&#123;n.current&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">      &lt;p&gt;</span></span><br><span class="line"><span class="regexp">        &lt;button</span></span><br><span class="line"><span class="regexp">          onClick=&#123;() =&gt; &#123;</span></span><br><span class="line"><span class="regexp">            n.current += 1;</span></span><br><span class="line"><span class="regexp">          &#125;&#125;</span></span><br><span class="line"><span class="regexp">        &gt;</span></span><br><span class="line"><span class="regexp">          +1</span></span><br><span class="line"><span class="regexp">        &lt;/</span>button&gt;</span><br><span class="line">      &lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">      &lt;p&gt;</span></span><br><span class="line"><span class="regexp">        &lt;button onClick=&#123;log&#125;&gt;log&lt;/</span>button&gt;</span><br><span class="line">      &lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  但你会发现这种<a href="https://codesandbox.io/s/boring-booth-n6igq" target="_blank" rel="noopener">方案</a>，页面上的元素不更新了，于是你可以这么改<a href="https://codesandbox.io/s/exciting-mirzakhani-4i06k" target="_blank" rel="noopener">代码</a></p>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useRef, useState &#125; <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> n = useRef(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> update = useState(<span class="number">0</span>)[<span class="number">1</span>]; <span class="comment">// 注意这里!!!</span></span><br><span class="line">  <span class="keyword">const</span> log = <span class="function"><span class="params">()</span> =&gt;</span> setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">"n ="</span>, n.current), <span class="number">3000</span>);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">"App"</span>&gt;</span><br><span class="line">      &lt;p&gt;&#123;n.current&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">      &lt;p&gt;</span></span><br><span class="line"><span class="regexp">        &lt;button</span></span><br><span class="line"><span class="regexp">          onClick=&#123;() =&gt; &#123;</span></span><br><span class="line"><span class="regexp">            n.current += 1;</span></span><br><span class="line"><span class="regexp">            update(n.current); /</span><span class="regexp">/ 注意这里!!!</span></span><br><span class="line"><span class="regexp">          &#125;&#125;</span></span><br><span class="line"><span class="regexp">        &gt;</span></span><br><span class="line"><span class="regexp">          +1</span></span><br><span class="line"><span class="regexp">        &lt;/</span>button&gt;</span><br><span class="line">      &lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">      &lt;p&gt;</span></span><br><span class="line"><span class="regexp">        &lt;button onClick=&#123;log&#125;&gt;log&lt;/</span>button&gt;</span><br><span class="line">      &lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  这里做了一个小 trick，就是使用 <code>useState</code> 返回的第二个函数强制更新。。。当然这种方式太过 hack 肯定是不推荐的。不过由此我们可以知道 <code>useRef</code> 可以作为一种 <strong>贯穿始终的状态</strong> 来解决 <code>useState</code> 使用上的 bug</p>
</li>
</ul>
<h3 id="与-forwardRef-的关系"><a href="#与-forwardRef-的关系" class="headerlink" title="与 forwardRef 的关系"></a>与 forwardRef 的关系</h3><p>使用 <code>useRef</code> 时，<code>props</code> 是不能直接传递 <code>ref</code> 属性的，比如下面的代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> buttonRef = useRef(<span class="literal">null</span>);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">"App"</span>&gt;</span><br><span class="line">      &lt;Button2 ref=&#123;buttonRef&#125;&gt;按钮&lt;<span class="regexp">/Button2&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Button2 = <span class="function"><span class="params">props</span> =&gt;</span> &#123; <span class="comment">// 这里的 props 中的 ref 传不进来</span></span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">className</span>=<span class="string">"red"</span> &#123;<span class="attr">...props</span>&#125; /&gt;</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>浏览器会报错</p>
<blockquote>
<p>Warning: Function components cannot be given refs. Attempts to access this ref will fail. Did you mean to use React.forwardRef()?</p>
</blockquote>
<p>React 这个时候提醒你使用 <code>React.forwardRef()</code> 来传 <code>props</code> 中的 <code>ref</code> 属性，于是你可以这么改</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> buttonRef = useRef(<span class="literal">null</span>);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">"App"</span>&gt;</span><br><span class="line">      &lt;Button3 ref=&#123;buttonRef&#125;&gt;按钮&lt;<span class="regexp">/Button3&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意这里使用 React.forwardRef 多包裹了一层</span></span><br><span class="line"><span class="keyword">const</span> Button3 = React.forwardRef(<span class="function">(<span class="params">props, ref</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">className</span>=<span class="string">"red"</span> <span class="attr">ref</span>=<span class="string">&#123;ref&#125;</span> &#123;<span class="attr">...props</span>&#125; /&gt;</span></span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>当然你也可以通过两次传递 <code>ref</code> 来得到 button 的引用，这里就不细讲，有兴趣的童鞋可以参考<a href="https://codesandbox.io/s/amazing-snow-9f5g3" target="_blank" rel="noopener">这个链接</a><br>这个例子本质上也是参考上面代码的例子，只是这里我们需要理解的是 <code>ref</code> 属性是可以传一个引用的</p>
<p>所以由上面的例子我们知道了，其实 <code>useRef</code> <strong>既能引用 DOM 对象也能引用普通对象</strong>，但是在传 <code>ref</code> 时需要用到 <code>forwardRef</code></p>
<p>而对于 <code>forwardRef</code> 来说，由于 <code>props</code> 不包含 <code>ref</code>(主要是大部分时候也不需要 <code>props</code> 去传一个 <code>ref</code>)，这个时候才需要 <code>forwardRef</code>。</p>
<p>而 <code>forwardRef</code> 本身就是通过 <code>ref</code> 的透传来实现对于指定的 DOM 的定位的，这一点和 Vue 的 refs 是一样的</p>
<h3 id="useRef-总结"><a href="#useRef-总结" class="headerlink" title="useRef 总结"></a>useRef 总结</h3><p>由于每次的渲染，组件函数中对应的 <code>state</code> 都会不一样，比如上述代码中的 <code>n</code>。如果希望拿到同一个 <code>n</code>，那么可以考虑使用 <code>useRef</code> 这个 hook，那么这个时候你就需要访问的是 <code>n.current</code> 而不是 <code>n</code> 了。</p>
<p><code>useRef</code> <strong>不能做到变化时自动更新 render</strong>，前面说过解决方案，就是通过监听 <code>n</code>，当 <code>n.current</code> 变化时调用 <code>update</code> 解决，这里需要配合 <code>useState</code> 这个 hook 来使用。也就是说这个功能需要你自己加</p>
<h2 id="useContext"><a href="#useContext" class="headerlink" title="useContext"></a>useContext</h2><p>其实想想，<code>Context</code> 的译文就是 “上下文”。那么什么是上下文呢？</p>
<ul>
<li><strong>全局变量</strong> 是全局的 <strong>上下文</strong></li>
<li><strong>上下文</strong> 是局部的 <strong>全局变量</strong></li>
</ul>
<p>实际上 <code>useContext</code> 的用法跟 <code>useRef</code> 差不多，不过 <code>useContext</code> 不仅能<strong>贯穿始终</strong>，还能<strong>贯穿不同组件</strong></p>
<h3 id="使用-useContext"><a href="#使用-useContext" class="headerlink" title="使用 useContext"></a>使用 useContext</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useContext, useState &#125; <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> themeContext = React.createContext(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [theme, setTheme] = useState(<span class="string">"red"</span>);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="comment">// 这里 value 传入读写 API</span></span><br><span class="line">    &lt;themeContext.Provider value=&#123;&#123; theme, setTheme &#125;&#125;&gt;</span><br><span class="line">      &lt;div className=&#123;<span class="string">`App <span class="subst">$&#123;theme&#125;</span>`</span>&#125;&gt;</span><br><span class="line">        &lt;p&gt;&#123;theme&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">        &lt;div&gt;</span></span><br><span class="line"><span class="regexp">          &lt;ChildA /</span>&gt;</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;div&gt;</span></span><br><span class="line"><span class="regexp">          &lt;ChildB /</span>&gt;</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    &lt;<span class="regexp">/themeContext.Provider&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">function ChildA() &#123;</span></span><br><span class="line"><span class="regexp">  const &#123; theme, setTheme &#125; = useContext(themeContext); /</span><span class="regexp">/ 子组件中可以用 setTheme 函数</span></span><br><span class="line"><span class="regexp">  console.log(theme); /</span><span class="regexp">/ 子组件中可以拿到 theme 状态</span></span><br><span class="line"><span class="regexp">  return (</span></span><br><span class="line"><span class="regexp">    &lt;div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;button onClick=&#123;() =&gt; setTheme("red")&#125;&gt;red&lt;/</span>button&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">function ChildB() &#123;</span></span><br><span class="line"><span class="regexp">  const &#123; setTheme &#125; = useContext(themeContext); /</span><span class="regexp">/ 子组件中可以用 setTheme 函数</span></span><br><span class="line"><span class="regexp">  return (</span></span><br><span class="line"><span class="regexp">    &lt;div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;button onClick=&#123;() =&gt; setTheme("blue")&#125;&gt;blue&lt;/</span>button&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<p><a href="https://codesandbox.io/s/exciting-mirzakhani-4i06k" target="_blank" rel="noopener">代码链接在这里</a></p>
<p>所以我们从中可以看到使用 <code>useContext</code> 的步骤了</p>
<ol>
<li>使用 <code>C = CreateContext(initial)</code> 创建上下文</li>
<li>使用 <code>C.Provider</code> 来限定要传的值的作用域在这个范围内</li>
<li>然后在 <code>C.Provider</code> 的作用域内使用 <strong><code>useContext(C)</code></strong> 来使用上下文(也就是 <code>C.Provider</code> 组件里面的 <code>value</code>)</li>
</ol>
<h3 id="useContext-注意点"><a href="#useContext-注意点" class="headerlink" title="useContext 注意点"></a>useContext 注意点</h3><p><code>useContext</code> 这个 hook 并不是响应式的，在一个组件中将 <code>C</code> 里面的值改变了(比如上述代码中的 <code>theme</code> 改变了)，另一个组件并不会知道这个变化。<strong>所以如果需要能够响应式，最好是配合 <code>useState</code> 来使用</strong></p>
<h3 id="useContext-总结"><a href="#useContext-总结" class="headerlink" title="useContext 总结"></a>useContext 总结</h3><p>如果希望拿到同一个 <code>n</code>，那么可以考虑使用 <code>useContext</code> 这个 hook，只需要将 <code>useRef</code> 的地方改成 <code>useContext</code> 就行</p>
<h2 id="useEffect"><a href="#useEffect" class="headerlink" title="useEffect"></a>useEffect</h2><p>这个就是 “副作用” 了，什么意思呢？</p>
<ul>
<li>在 js 中，我们把对环境的改变就叫 <strong>副作用</strong>，一个很典型的例子就是 <strong>修改 <code>document.title</code></strong></li>
<li>一定非得要把一些副作用的操作放到 <code>useEffect</code> 中执行么？<strong>不一定</strong></li>
<li>你可以把它理解为 <code>afterRender</code> ，因为这个<strong>总在 <code>render</code> 后执行</strong></li>
</ul>
<p>React 渲染的大致流程如下</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">App()          <span class="comment">--&gt;  执行          --&gt; 生成虚拟 DOM --</span></span><br><span class="line">                                                    |</span><br><span class="line">             render 完毕                            |</span><br><span class="line">                ↓                                   |</span><br><span class="line">执行 useEffect &lt;<span class="comment">--  改变外观     &lt;-- 生成真实 DOM &lt;--</span></span><br><span class="line">      ↑                ↑</span><br><span class="line">&lt;<span class="keyword">div</span>&gt;<span class="number">1000</span>&lt;/<span class="keyword">div</span>&gt;     &lt;<span class="keyword">div</span>&gt;<span class="number">0</span>&lt;/<span class="keyword">div</span>&gt;</span><br></pre></td></tr></table></figure>
<p>如上面所示，在改变外观这里，render 完毕之后，就会执行 <code>useEffect</code>。</p>
<h3 id="使用-useEffect"><a href="#使用-useEffect" class="headerlink" title="使用 useEffect"></a>使用 useEffect</h3><ul>
<li><code>useEffect(() =&gt; {}, [])</code><br>  由于第二个参数传的是一个空数组，所以第一个参数函数只有在<strong>第一次渲染时执行</strong></li>
<li><code>useEffect(() =&gt; {}, [n])</code><br>  由于第二个参数传的是一个 <code>[n]</code>，这里表示<strong>只要 <code>n</code> 有变化</strong>，那么第一个参数函数就会执行</li>
<li><code>useEffect(() =&gt; {})</code><br>  由于没有传第二个参数，这里就表示 <strong>任何一个 state 变化时都不会执行</strong></li>
</ul>
<p><code>useEffect</code> 还有个用法，就是当组件处于 <code>componentWillUnmount</code> 时，即组件快要挂掉时使用，比如</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> id = setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;, <span class="number">1000</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="comment">// 这里 return 一个函数，当组件挂掉时调用这个，清理掉定时器，避免内存泄露</span></span><br><span class="line">    clearInterval(id)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, [])</span><br></pre></td></tr></table></figure>
<p><code>useEffect</code> 还有一个特点跟 <code>useState</code> 一样的，就是<strong>如果同时存在多个 <code>useEffect</code>， 会按照其出现的次序执行</strong></p>
<h3 id="useEffect-总结"><a href="#useEffect-总结" class="headerlink" title="useEffect 总结"></a>useEffect 总结</h3><ul>
<li>在对环境有些副作用操作的时候用 <code>useEffect</code></li>
<li>前面说的 <code>useEffect</code> 的几种用法中，可以都同时存在</li>
<li>可以将 <code>useEffect</code> 理解成 “afterRender”，因为它就是在 render 之后执行的</li>
</ul>
<h2 id="useLayoutEffect"><a href="#useLayoutEffect" class="headerlink" title="useLayoutEffect"></a>useLayoutEffect</h2><p>如果说 <code>useEffect</code> 在浏览器渲染完成后执行，那么 <code>useLayoutEffect</code> 就是在<strong>浏览器渲染完成前执行</strong>，它的位置在如下所示的位置</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">App()          <span class="comment">--&gt;  执行          --&gt; 生成虚拟 DOM --</span></span><br><span class="line">                                                     |</span><br><span class="line">             render 完毕       useLayoutEffect       |</span><br><span class="line">                ↓                 ↓                  |</span><br><span class="line">执行 useEffect &lt;<span class="comment">--  改变外观     &lt;-- 生成真实 DOM &lt;--</span></span><br><span class="line">      ↑                ↑</span><br><span class="line">&lt;<span class="keyword">div</span>&gt;<span class="number">1000</span>&lt;/<span class="keyword">div</span>&gt;     &lt;<span class="keyword">div</span>&gt;<span class="number">0</span>&lt;/<span class="keyword">div</span>&gt;</span><br></pre></td></tr></table></figure>
<h3 id="useLayoutEffect-特点"><a href="#useLayoutEffect-特点" class="headerlink" title="useLayoutEffect 特点"></a>useLayoutEffect 特点</h3><ul>
<li>由图可知，<code>useLayoutEffect</code> 总是比 <code>useEffect</code> 先执行</li>
<li><code>useLayoutEffect</code> 里的操作最好是影响了 layout，虽然它性能更高，但是如果在这个里面的操作很多，它会影响用户看到画面变化的时间。从用户的角度来说，这是很影响用户体验的</li>
</ul>
<h3 id="useLayoutEffect-总结"><a href="#useLayoutEffect-总结" class="headerlink" title="useLayoutEffect 总结"></a>useLayoutEffect 总结</h3><ul>
<li>是跟 <code>useEffect</code> 差不多的玩意儿，不同之处在于其执行的优先级，它的优先级比 <code>useEffect</code> 高</li>
<li>为了用户体验，在能使用 <code>useEffect</code> 解决问题的前提下，尽量不要使用这个 <code>useLayoutEffect</code></li>
</ul>
<h2 id="useMemo"><a href="#useMemo" class="headerlink" title="useMemo"></a>useMemo</h2><p>这里 <code>Memo</code> 的全称应该是 <code>Memorize</code> 也就是 “记忆”，这个钩子的作用就是记忆代码，如果有多余的代码就不执行，怎么理解呢，在理解这个之前，需要先看看 <code>React.memo</code></p>
<h3 id="理解-React-memo"><a href="#理解-React-memo" class="headerlink" title="理解 React.memo"></a>理解 React.memo</h3><p>假设有如下的代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [n, setN] = React.useState(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> [m, setM] = React.useState(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> onClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    setN(n + <span class="number">1</span>);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">"App"</span>&gt;</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;button onClick=&#123;onClick&#125;&gt;update n &#123;n&#125;&lt;<span class="regexp">/button&gt; /</span>*点击 button 只让 n + <span class="number">1</span>*<span class="regexp">/</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">      &lt;Child data=&#123;m&#125; /&gt; <span class="comment">/* 这里的 m 没有变化，按照理由来说 child 不应该重新渲染才对*/</span></span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">function Child(props) &#123;</span></span><br><span class="line"><span class="regexp">  console.log("child 执行了");</span></span><br><span class="line"><span class="regexp">  console.log("假设这里有大量代码"); /</span><span class="regexp">/ 但是这里却执行了!!!</span></span><br><span class="line"><span class="regexp">  return &lt;div&gt;child: &#123;props.data&#125;&lt;/</span>div&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>传入的 <code>props.data</code> 根本没有变化，即 <code>m</code> 没有变，变的只是 <code>n</code>，但是这里 <code>Child()</code> 每次都执行了，要是 <code>Child()</code> 函数里面有很多的代码，势必会造成页面的卡顿现象，于是这个时候，<code>React.memo</code> 就排上用场了</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [n, setN] = React.useState(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> [m, setM] = React.useState(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> onClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    setN(n + <span class="number">1</span>);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">"App"</span>&gt;</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;button onClick=&#123;onClick&#125;&gt;update n &#123;n&#125;&lt;<span class="regexp">/button&gt; /</span>*点击 button 只让 n + <span class="number">1</span>*<span class="regexp">/</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">      &lt;Child2 data=&#123;m&#125; /&gt; <span class="comment">/* 这里的 m 没有变化，按照理由来说 child 不应该重新渲染才对*/</span></span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">function Child(props) &#123;</span></span><br><span class="line"><span class="regexp">  console.log("child 执行了");</span></span><br><span class="line"><span class="regexp">  console.log("假设这里有大量代码"); /</span><span class="regexp">/ 使用了 React.memo 后，这里就没有执行了!!!</span></span><br><span class="line"><span class="regexp">  return &lt;div&gt;child: &#123;props.data&#125;&lt;/</span>div&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Child2 = React.memo(Child)</span><br></pre></td></tr></table></figure>
<p>如果 <code>props</code> 没变，就没有必要再次执行一个函数组件，这个 <code>React.memo</code> 是属于 React 优化的一部分。原理就是跟缓存的道理一样的。在 React 中，其默认有多余的 render。为了解决这个问题后面才出来 memo</p>
<h3 id="React-memo-的-bug"><a href="#React-memo-的-bug" class="headerlink" title="React.memo 的 bug"></a>React.memo 的 bug</h3><p>请看如下的代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [n, setN] = React.useState(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> [m, setM] = React.useState(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> onClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    setN(n + <span class="number">1</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">const</span> onClickChild = <span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="comment">// 这里只是添加了一个 click 的回调而已。。。</span></span><br><span class="line">    <span class="built_in">console</span>.log(m);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">"App"</span>&gt;</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;button onClick=&#123;onClick&#125;&gt;update n &#123;n&#125;&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">      &lt;Child2 data=&#123;m&#125; onClick=&#123;onClickChild&#125; /&gt;</span><br><span class="line">      &#123;<span class="comment">/* Child2 居然又执行了 */</span>&#125;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">function Child(props) &#123;</span></span><br><span class="line"><span class="regexp">  console.log("child 执行了");</span></span><br><span class="line"><span class="regexp">  console.log("假设这里有大量代码"); /</span><span class="regexp">/ 这里的代码因为仅仅只是添加了回调的原因，居然又执行了!!!</span></span><br><span class="line"><span class="regexp">  return &lt;div onClick=&#123;props.onClick&#125;&gt;child: &#123;props.data&#125;&lt;/</span>div&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Child2 = React.memo(Child); <span class="comment">// memo 在这里就没用了!!!</span></span><br></pre></td></tr></table></figure>
<p>为什么在这种情况下 <code>React.memo</code> 的优化作用失效了呢？因为在点击 button 更新 <code>n</code> 的数据时会再次渲染页面，就会再次执行 <code>App()</code>，就会再次声明 <code>onClickChild</code> 这个函数，<strong>而这个函数的地址已经变了!!!!</strong>。因为这个函数地址变的原因，<strong>React 就判断其 <code>props</code> 产生了变化</strong>，于是就认为 <code>Child</code> 组件已经变化了，需要重新渲染它!!，于是乎 <code>Child()</code> 就会再次执行!!!</p>
<p>那么还有什么解决办法呢？有的，就是使用 <code>useMemo</code>，使用这个 hook 就不会有这个问题</p>
<h3 id="使用-useMemo"><a href="#使用-useMemo" class="headerlink" title="使用 useMemo"></a>使用 useMemo</h3><p>使用 <code>useMemo</code> 去解决上面的 bug 的话，只需要将 <code>onClickChild</code> 函数修改成如下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> onClickChild = useMemo(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> fn = <span class="function"><span class="params">div</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"on click child, m: "</span> + m);</span><br><span class="line">    <span class="built_in">console</span>.log(div);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> fn;</span><br><span class="line">&#125;, [m]); <span class="comment">// 这里只要 m 变化才能说明 `onClickChild` 变化了，当然这里的 m 要是改为 n 会打印出旧的 n 的数据</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>useMemo</code> 第一个参数是一个工厂函数 <code>() =&gt; value</code>, 第二个参数是依赖<code>[n, m]</code>，只有当依赖变化时，才会计算出新的 <code>value</code></li>
<li>如果依赖没有变化，则服用之前的 <code>value</code></li>
</ul>
<h3 id="useMemo-注意点"><a href="#useMemo-注意点" class="headerlink" title="useMemo 注意点"></a>useMemo 注意点</h3><ul>
<li><p>如果本身 <code>value</code> 是一个函数，你就必须要这么写</p>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">useMemo(<span class="function"><span class="params">()</span> =&gt;</span> <span class="function"><span class="params">x</span> =&gt;</span> <span class="built_in">console</span>.log(x), [m]) <span class="comment">// 注意这里是一个返回函数的函数</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>如果觉得这很不优雅，推荐使用 <code>useCallback</code></p>
</li>
</ul>
<h3 id="useMemo-总结"><a href="#useMemo-总结" class="headerlink" title="useMemo 总结"></a>useMemo 总结</h3><p>从本质上看 <code>useMemo</code> 有点像 Vue 中的 Computed，其计算属性本来就依赖一个会变化的数据，数据变化时 vue 会帮你做相应的更新操作</p>
<p><code>useMemo</code> 一般是结合 <code>React.memo</code> 做一些代码层面的优化工作</p>
<h2 id="useCallback"><a href="#useCallback" class="headerlink" title="useCallback"></a>useCallback</h2><p><code>useCallback</code> 就是为了解决上述 <code>useMemo</code> 中 <code>value</code> 是一个函数时的传参写法问题的，它的用法如下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">useCallback(<span class="function"><span class="params">x</span> =&gt;</span> <span class="built_in">console</span>.log(x), [m])</span><br></pre></td></tr></table></figure>
<p>其等价于<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">useMemo(<span class="function"><span class="params">()</span> =&gt;</span> <span class="function"><span class="params">x</span> =&gt;</span> <span class="built_in">console</span>.log(x), [m])</span><br></pre></td></tr></table></figure></p>
<h3 id="useCallback-总结"><a href="#useCallback-总结" class="headerlink" title="useCallback 总结"></a>useCallback 总结</h3><p>这个是跟 <code>useMemo</code> 功能相近的 hook，主要为了补充 <code>useMemo</code> 传参的写法用的</p>
<h2 id="useImperativeHandle"><a href="#useImperativeHandle" class="headerlink" title="useImperativeHandle"></a>useImperativeHandle</h2><p>你可以将其理解为 <code>setRef</code>，其作用就是 <strong>自定义 ref 的属性</strong>，<a href="https://codesandbox.io/s/elegant-poitras-mxoym" target="_blank" rel="noopener">代码链接在这里</a></p>
<p>关键的代码在这一句</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">setRef(ref, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    x: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      realButton.current.remove();</span><br><span class="line">    &#125;,</span><br><span class="line">    realButton: realButton</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>其实就是给 <code>ref</code> 增添了属性，让其对应的 <code>ref</code> 能够访问到 <code>realButton</code> 这个属性以及能够调用 <code>x</code> 这个方法</p>
<h2 id="hooks-其他内容-dlc"><a href="#hooks-其他内容-dlc" class="headerlink" title="hooks 其他内容(dlc)"></a>hooks 其他内容(dlc)</h2><h3 id="如何自定义-hook"><a href="#如何自定义-hook" class="headerlink" title="如何自定义 hook"></a>如何自定义 hook</h3><p>拿 <code>useState</code> 举例，可以将自己定义的 hook 作为一个模块封装起来然后 <code>export</code> 出去，具体来说就像如下代码所做的</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useState, useEffect &#125; <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> useList = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [list, setList] = useState(<span class="literal">null</span>);</span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    ajax(<span class="string">"/list"</span>).then(<span class="function"><span class="params">list</span> =&gt;</span> &#123;</span><br><span class="line">      setList(list); <span class="comment">// 异步请求</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;, []); <span class="comment">// [] 确保只在第一次运行</span></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    list: list,</span><br><span class="line">    setList: setList,</span><br><span class="line">    addItem: <span class="function"><span class="params">name</span> =&gt;</span> &#123;</span><br><span class="line">      setList([...list, &#123; <span class="attr">id</span>: <span class="built_in">Math</span>.random(), <span class="attr">name</span>: name &#125;]);</span><br><span class="line">    &#125;,</span><br><span class="line">    deleteIndex: <span class="function"><span class="params">index</span> =&gt;</span> &#123;</span><br><span class="line">      setList(list.slice(<span class="number">0</span>, index).concat(list.slice(index + <span class="number">1</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> useList;</span><br></pre></td></tr></table></figure>
<p>所以我们可以看到，这里本质上就是对 <code>useState</code> 这个 hook 做了一层封装，然后返回的依然是 <code>state</code> 以及 <code>setState</code> 这个方法，即返回的是一个<strong>读(查)写(增删改) API</strong></p>
<h3 id="自定义-hook-注意点"><a href="#自定义-hook-注意点" class="headerlink" title="自定义 hook 注意点"></a>自定义 hook 注意点</h3><ul>
<li>也可以在自定义 hook 里面使用 <code>Context</code> API</li>
<li><code>useState</code> 可以在函数里使用，关键是这个函数是在组件里面运行的就可以</li>
</ul>
<h3 id="Stale-Closure"><a href="#Stale-Closure" class="headerlink" title="Stale Closure"></a>Stale Closure</h3><p>这个主要是被尤大吐槽过的，说他在读一些使用 hooks 写的库时就十分的脑壳疼，评价其为过时的闭包(stale closure)</p>
<p>那么过时闭包是怎么一回事呢，来看如下的代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createIncrement</span>(<span class="params">i</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> value = <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">increment</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    value += i;</span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">    <span class="keyword">const</span> message = <span class="string">`Current value is <span class="subst">$&#123;value&#125;</span>`</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">logValue</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(message);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> increment;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> inc = createIncrement(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">const</span> log = inc(); <span class="comment">// logs 1</span></span><br><span class="line">inc();             <span class="comment">// logs 2</span></span><br><span class="line">inc();             <span class="comment">// logs 3</span></span><br><span class="line"><span class="comment">// Does not work!</span></span><br><span class="line">log();             <span class="comment">// logs "Current value is 1"</span></span><br></pre></td></tr></table></figure>
<p>最后 <code>log</code> 居然还是之前第一次的 <code>value</code>, 这不科学！！！但是这是正常的，毕竟你保存的是第一个函数执行的地址，而其他函数执行地址跟这个不一样，所以才有这个问题</p>
<p>于是解决办法也有，其实只要每次得到最新的 <code>value</code> 就可以了</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createIncrementFixed</span>(<span class="params">i</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> value = <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">increment</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    value += i;</span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">logValue</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">const</span> message = <span class="string">`Current value is <span class="subst">$&#123;value&#125;</span>`</span>; <span class="comment">// 注意这里将这句移动到 logValue 里面来了 !!!</span></span><br><span class="line">      <span class="built_in">console</span>.log(message);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> increment;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> inc = createIncrementFixed(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">const</span> log = inc(); <span class="comment">// logs 1</span></span><br><span class="line">inc();             <span class="comment">// logs 2</span></span><br><span class="line">inc();             <span class="comment">// logs 3</span></span><br><span class="line"><span class="comment">// Works!</span></span><br><span class="line">log();             <span class="comment">// logs "Current value is 3"</span></span><br></pre></td></tr></table></figure>
<p>所以说 hooks 中也有解决这些过时闭包的 bug 出现的措施，就是依赖更新。<br>比如 <code>useEffect</code> 中要传的第二个参数，比如 <code>useState</code> 中 <code>setState</code> 传一个函数更新的形式，都是为了解决这个 bug 而出现的举措。<br>这里就不详细说明了，有兴趣的童鞋可以去参考我列出的链接</p>
<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul>
<li><a href="https://dmitripavlutin.com/react-hooks-stale-closures/" target="_blank" rel="noopener">Be Aware of Stale Closures when Using React Hooks</a></li>
<li><a href="https://zh-hans.reactjs.org/docs/hooks-intro.html" target="_blank" rel="noopener">hooks 简介</a></li>
</ul>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>react-hooks</tag>
      </tags>
  </entry>
  <entry>
    <title>用hexo搭建静态博客</title>
    <url>/2019/01/08/%E7%94%A8hexo%E6%90%AD%E5%BB%BA%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h2 id="环境介绍"><a href="#环境介绍" class="headerlink" title="环境介绍"></a>环境介绍</h2><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">4.13.0-30-generic #33~16.04.1-Ubuntu SMP Mon Jan 15 21:31:06 UTC 2018 x86_64 x86_64 x86_64 GNU/Linux</span><br><span class="line"></span><br><span class="line"><span class="attribute">NAME</span>=<span class="string">"Ubuntu"</span></span><br><span class="line"><span class="attribute">VERSION</span>=<span class="string">"16.04.3 LTS (Xenial Xerus)"</span></span><br><span class="line"><span class="attribute">ID</span>=ubuntu</span><br><span class="line"><span class="attribute">ID_LIKE</span>=debian</span><br><span class="line"><span class="attribute">PRETTY_NAME</span>=<span class="string">"Ubuntu 16.04.3 LTS"</span></span><br><span class="line"><span class="attribute">VERSION_ID</span>=<span class="string">"16.04"</span></span><br><span class="line"><span class="attribute">HOME_URL</span>=<span class="string">"http://www.ubuntu.com/"</span></span><br><span class="line"><span class="attribute">SUPPORT_URL</span>=<span class="string">"http://help.ubuntu.com/"</span></span><br><span class="line"><span class="attribute">BUG_REPORT_URL</span>=<span class="string">"http://bugs.launchpad.net/ubuntu/"</span></span><br><span class="line"><span class="attribute">VERSION_CODENAME</span>=xenial</span><br><span class="line"><span class="attribute">UBUNTU_CODENAME</span>=xenial</span><br></pre></td></tr></table></figure>
<h2 id="安装-Node-js"><a href="#安装-Node-js" class="headerlink" title="安装 Node.js"></a>安装 Node.js</h2><p>首先需要到 <a href="https://nodejs.org/en/" target="_blank" rel="noopener">Node.js 官网</a>上下载 node.js 的二进制包,目前我下载的版本是 <strong>8.9.4 LTS</strong>稳定版,然后解压到任意目录，目前我是解压到 <code>/usr/local/</code> 这个目录下</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">xz -d <span class="keyword">node</span><span class="title">-v8</span>.<span class="number">9.4</span>-linux-x64.tar.xz</span><br><span class="line">sudo tar xvf <span class="keyword">node</span><span class="title">-v8</span>.<span class="number">9.4</span>-linux-x64.tar -C /usr/local/</span><br></pre></td></tr></table></figure>
<p>然后配置环境变量，将以下加入 <code>~/.bashrc</code> 中</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在底部添加 PATH 变量</span></span><br><span class="line"><span class="builtin-name">export</span> <span class="attribute">NODE_DIR</span>=/usr/local/node-v8.9.4-linux-x64</span><br><span class="line"><span class="builtin-name">export</span> <span class="attribute">PATH</span>=<span class="variable">$PATH</span>:$NODE_DIR/bin</span><br></pre></td></tr></table></figure>
<p>保存退出并使 .bashrc 生效</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure>
<h2 id="安装-Hexo"><a href="#安装-Hexo" class="headerlink" title="安装 Hexo"></a>安装 Hexo</h2><p>首先在 HOME 目录创建博客所在目录</p>
<figure class="highlight dos"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~</span><br><span class="line"><span class="built_in">mkdir</span> myBlog</span><br></pre></td></tr></table></figure>
<p>然后是安装 Hexo</p>
<figure class="highlight vala"><table><tr><td class="code"><pre><span class="line">cd myBlog</span><br><span class="line"><span class="meta"># 安装 git</span></span><br><span class="line">sudo apt install git -y</span><br><span class="line"><span class="meta"># 安装 hexo</span></span><br><span class="line">sudo npm install -g hexo-cli</span><br><span class="line"><span class="meta"># 初始化 hexo</span></span><br><span class="line">hexo init</span><br><span class="line">npm i</span><br></pre></td></tr></table></figure>
<p>这个时候可以启动 hexo 来测试一下 hexo 是否安装成功</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">hexo s</span></span><br></pre></td></tr></table></figure>
<p>会出现</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">INFO  <span class="keyword">Start</span> processing</span><br><span class="line">INFO  Hexo <span class="keyword">is</span> running <span class="keyword">at</span> <span class="keyword">http</span>://localhost:<span class="number">4000</span>/. Press Ctrl+C <span class="keyword">to</span> stop.</span><br></pre></td></tr></table></figure>
<p>字样，这个时候点击链接 <a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a> 会出现类似下图页面</p>
<p><img src="./img1.png" alt></p>
<p>(主要是其中我修改了 _config.yml 配置文件的关系，所以标题什么的可能显得不一样，不过能出现类似的页面说明 hexo 已经配置成功)</p>
<h2 id="安装-hexo-程序拓展插件"><a href="#安装-hexo-程序拓展插件" class="headerlink" title="安装 hexo 程序拓展插件"></a>安装 hexo 程序拓展插件</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">sudo npm <span class="keyword">install</span> hexo-generator-<span class="keyword">index</span>  hexo-generator-<span class="keyword">archive</span>  hexo-generator-<span class="keyword">category</span>  hexo-generator-tag hexo-<span class="keyword">server</span> hexo-deployer-git hexo-deployer-heroku hexo-deployer-rsync hexo-deployer-openshift hexo-renderer-marked  hexo-renderer-stylus  hexo-generator-feed hexo-generator-sitemap <span class="comment">--save</span></span><br></pre></td></tr></table></figure>
<p>这些最好还是全部装上吧</p>
<h2 id="配置-Hexo-相关主题"><a href="#配置-Hexo-相关主题" class="headerlink" title="配置 Hexo 相关主题"></a>配置 Hexo 相关主题</h2><p>有关主题的配置文件有两个,一个是博客根目录下的 <code>_config.yml</code> 即 <code>myBlog/_config.yml</code>;还有一个是主题目录下的 <code>_config.yml</code> 即 <code>myBlog/your_theme_dirname/_config.yml</code>，这里我选择的是 <code>nexT</code> 这个主题，并且我命名的目录名为 <code>next</code>，所以我的主题配置文件路径为 <code>myBlog/next/_config.yml</code></p>
<p>以下是我的博客根目录 <code>_config.yml</code> 的配置</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Hexo Configuration</span></span><br><span class="line"><span class="comment">## Docs: https://hexo.io/docs/configuration.html</span></span><br><span class="line"><span class="comment">## Source: https://github.com/hexojs/hexo/</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Site</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">Stay</span> <span class="string">Hungry</span></span><br><span class="line"><span class="attr">subtitle:</span> <span class="string">对，跑快一些，再快一些</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">个人技术博客，记录工作中遇到的问题以及学习过程中的坑</span></span><br><span class="line"><span class="attr">author:</span> <span class="string">strugglebak</span></span><br><span class="line"><span class="attr">language:</span> <span class="string">zh-Hans</span></span><br><span class="line"><span class="attr">timezone:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># URL</span></span><br><span class="line"><span class="comment">## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'</span></span><br><span class="line"><span class="attr">url:</span> <span class="string">https://strugglebak.github.io/</span></span><br><span class="line"><span class="attr">root:</span> <span class="string">/</span></span><br><span class="line"><span class="attr">permalink:</span> <span class="string">:year/:month/:day/:title/</span></span><br><span class="line"><span class="attr">permalink_defaults:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Directory</span></span><br><span class="line"><span class="attr">source_dir:</span> <span class="string">source</span></span><br><span class="line"><span class="attr">public_dir:</span> <span class="string">public</span></span><br><span class="line"><span class="attr">tag_dir:</span> <span class="string">tags</span></span><br><span class="line"><span class="attr">archive_dir:</span> <span class="string">archives</span></span><br><span class="line"><span class="attr">category_dir:</span> <span class="string">categories</span></span><br><span class="line"><span class="attr">code_dir:</span> <span class="string">downloads/code</span></span><br><span class="line"><span class="attr">i18n_dir:</span> <span class="string">:lang</span></span><br><span class="line"><span class="attr">skip_render:</span> <span class="string">README.md</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Writing</span></span><br><span class="line"><span class="attr">new_post_name:</span> <span class="string">:title-:year-:month-:day.md</span> <span class="comment"># File name of new posts</span></span><br><span class="line"><span class="attr">default_layout:</span> <span class="string">post</span></span><br><span class="line"><span class="attr">titlecase:</span> <span class="literal">false</span> <span class="comment"># Transform title into titlecase</span></span><br><span class="line"><span class="attr">external_link:</span> <span class="literal">true</span> <span class="comment"># Open external links in new tab</span></span><br><span class="line"><span class="attr">filename_case:</span> <span class="number">0</span></span><br><span class="line"><span class="attr">render_drafts:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">post_asset_folder:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">relative_link:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">future:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">highlight:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">line_number:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">auto_detect:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">tab_replace:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Home page setting</span></span><br><span class="line"><span class="comment"># path: Root path for your blogs index page. (default = '')</span></span><br><span class="line"><span class="comment"># per_page: Posts displayed per page. (0 = disable pagination)</span></span><br><span class="line"><span class="comment"># order_by: Posts order. (Order by date descending by default)</span></span><br><span class="line"><span class="attr">index_generator:</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">''</span></span><br><span class="line">  <span class="attr">per_page:</span> <span class="number">10</span></span><br><span class="line">  <span class="attr">order_by:</span> <span class="string">-date</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Category &amp; Tag</span></span><br><span class="line"><span class="attr">default_category:</span> <span class="string">uncategorized</span></span><br><span class="line"><span class="attr">category_map:</span></span><br><span class="line"><span class="attr">tag_map:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Date / Time format</span></span><br><span class="line"><span class="comment">## Hexo uses Moment.js to parse and display date</span></span><br><span class="line"><span class="comment">## You can customize the date format as defined in</span></span><br><span class="line"><span class="comment">## http://momentjs.com/docs/#/displaying/format/</span></span><br><span class="line"><span class="attr">date_format:</span> <span class="string">YYYY-MM-DD</span></span><br><span class="line"><span class="attr">time_format:</span> <span class="string">HH:mm:ss</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Pagination</span></span><br><span class="line"><span class="comment">## Set per_page to 0 to disable pagination</span></span><br><span class="line"><span class="attr">per_page:</span> <span class="number">10</span></span><br><span class="line"><span class="attr">pagination_dir:</span> <span class="string">page</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Extensions</span></span><br><span class="line"><span class="attr">plugins:</span> <span class="string">hexo-generate-feed</span></span><br><span class="line"><span class="comment">## Plugins: https://hexo.io/plugins/</span></span><br><span class="line"><span class="comment">## Themes: https://hexo.io/themes/</span></span><br><span class="line"><span class="comment"># theme: landscape</span></span><br><span class="line"><span class="attr">theme:</span> <span class="string">next</span></span><br><span class="line"><span class="attr">stylus:</span></span><br><span class="line">  <span class="attr">compress:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Deployment</span></span><br><span class="line"><span class="comment">## Docs: https://hexo.io/docs/deployment.html</span></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">git@github.com:strugglebak/strugglebak.github.io</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br><span class="line">  <span class="attr">message:</span> <span class="string">'站点更新: <span class="template-variable">&#123;&#123; now("YYYY-MM-DD HH:mm:ss") &#125;&#125;</span>'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Search</span></span><br><span class="line"><span class="attr">search:</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">search.xml</span></span><br><span class="line">  <span class="attr">field:</span> <span class="string">post</span></span><br><span class="line">  <span class="attr">format:</span> <span class="string">html</span></span><br><span class="line">  <span class="attr">limit:</span> <span class="number">10000</span></span><br></pre></td></tr></table></figure>
<h2 id="Hexo-相关主题的美化"><a href="#Hexo-相关主题的美化" class="headerlink" title="Hexo 相关主题的美化"></a>Hexo 相关主题的美化</h2><p>首先就是主题的安装，就是 git clone 到 theme 目录</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cd</span> ~/myBlog</span><br><span class="line">git clone http<span class="variable">s:</span>//github.<span class="keyword">com</span>/iissnan/hexo-theme-<span class="keyword">next</span>.git theme/<span class="keyword">next</span></span><br></pre></td></tr></table></figure>
<p>然后就是修改 theme/next 下的配置文件来美化自己的主题了，我主要做了如下几步</p>
<h3 id="显示-RSS"><a href="#显示-RSS" class="headerlink" title="显示 RSS"></a>显示 RSS</h3><p>记住要安装 Hexo 插件,如果上面我说的安装插件没有做的话，就执行下面</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">npm <span class="keyword">install</span> <span class="comment">--save hexo-generator-feed</span></span><br></pre></td></tr></table></figure>
<p>然后在<strong>博客根目录</strong>下的 <code>_config.yml</code> 中添加</p>
<figure class="highlight clean"><table><tr><td class="code"><pre><span class="line"># Extensions</span><br><span class="line">## Plugins: http:<span class="comment">//hexo.io/plugins/</span></span><br><span class="line">## 注意冒号后的空格</span><br><span class="line">plugins: hexo-generate-feed</span><br></pre></td></tr></table></figure>
<p>然后在 <strong>next 主题目录</strong>下的 <code>_config.yml</code> 中配置 rss</p>
<figure class="highlight vbscript"><table><tr><td class="code"><pre><span class="line"># <span class="keyword">Set</span> rss <span class="keyword">to</span> <span class="literal">false</span> <span class="keyword">to</span> disable feed link.</span><br><span class="line"># Leave rss as <span class="literal">empty</span> <span class="keyword">to</span> use site<span class="comment">'s feed link.</span></span><br><span class="line"># <span class="keyword">Set</span> rss <span class="keyword">to</span> specific value <span class="keyword">if</span> you have burned your feed already.</span><br><span class="line">rss: /atom.xml</span><br></pre></td></tr></table></figure>
<h3 id="设置侧边栏社交图标"><a href="#设置侧边栏社交图标" class="headerlink" title="设置侧边栏社交图标"></a>设置侧边栏社交图标</h3><p>依然在 <code>theme/next/_config.yml</code> 中配置</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># Sidebar Settings</span></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"><span class="attr">social:</span></span><br><span class="line">  <span class="attr">GitHub:</span> <span class="string">https://github.com/strugglebak</span> <span class="string">||</span> <span class="string">github</span></span><br><span class="line">  <span class="attr">E-Mail:</span> <span class="string">mailto:strugglebak@gmail.com</span> <span class="string">||</span> <span class="string">envelope</span></span><br><span class="line"><span class="attr">social_icons:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">icons_only:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">transition:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">Github:</span> <span class="string">github</span> <span class="comment"># 这个是对应的图标名</span></span><br><span class="line">  <span class="attr">E-Mail:</span> <span class="string">fa-envelope</span> <span class="comment"># 这个是对应的图标名</span></span><br></pre></td></tr></table></figure>
<p>有关图标可以到这个网站找 <a href="http://fontawesome.io/icons/" target="_blank" rel="noopener">Font Awesome</a></p>
<h3 id="配置评论系统"><a href="#配置评论系统" class="headerlink" title="配置评论系统"></a>配置评论系统</h3><p>目前使用的是 <a href="https://livere.com/" target="_blank" rel="noopener">来比力</a>，这个可能需要科学上网，不能科学上网的同学请自己搭个梯子吧。然后登录注册，在<strong>代码管理</strong>的页面中获取 LiveRe UID,然后将这个 UID 粘贴到你的 <code>theme/next/_config.yml</code> 中的</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">livere_uid:</span> <span class="comment">#your livere_uid</span></span><br></pre></td></tr></table></figure>
<h3 id="配置搜索服务"><a href="#配置搜索服务" class="headerlink" title="配置搜索服务"></a>配置搜索服务</h3><p>在 <code>myBlog</code> 目录下执行</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">npm <span class="keyword">install</span> hexo-generator-searchdb <span class="comment">--save</span></span><br></pre></td></tr></table></figure>
<p>编辑 <code>myBlog/_config.yml</code>，添加</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">search:</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">search.xml</span></span><br><span class="line">  <span class="attr">field:</span> <span class="string">post</span></span><br><span class="line">  <span class="attr">format:</span> <span class="string">html</span></span><br><span class="line">  <span class="attr">limit:</span> <span class="number">10000</span></span><br></pre></td></tr></table></figure>
<p>编辑 <code>myBlog/theme/next/_config.yml</code>，启动本地搜索</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">local_search:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<h3 id="设置阅读全文"><a href="#设置阅读全文" class="headerlink" title="设置阅读全文"></a>设置阅读全文</h3><p>编辑 <code>myBlog/theme/next/_config.yml</code></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">auto_excerpt:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">length:</span> <span class="number">150</span></span><br></pre></td></tr></table></figure>
<h3 id="修改文章内链接样式"><a href="#修改文章内链接样式" class="headerlink" title="修改文章内链接样式"></a>修改文章内链接样式</h3><p>将链接文本设置为蓝色，鼠标划过时文字颜色加深，并显示下划线<br>编辑 <code>/themes/next/source/css/_custom/custom.styl</code>，添加</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.post-body</span> <span class="selector-tag">p</span> <span class="selector-tag">a</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#0593d3</span>;</span><br><span class="line">  <span class="attribute">border-bottom</span>: none;</span><br><span class="line">  &amp;<span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#0477ab</span>;</span><br><span class="line">    <span class="attribute">text-decoration</span>: underline;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="隐藏网页底部-powered-By-Hexo-强力驱动-字样"><a href="#隐藏网页底部-powered-By-Hexo-强力驱动-字样" class="headerlink" title="隐藏网页底部 powered By Hexo / 强力驱动 字样"></a>隐藏网页底部 powered By Hexo / 强力驱动 字样</h3><p>很简单，编辑 <code>themes/next/layout/_partials/footer.swig</code>，然后就去掉 <code>power-by</code> 以及 <code>theme-info</code> 相关的标签</p>
<figure class="highlight django"><table><tr><td class="code"><pre><span class="line"><span class="template-tag">&#123;% <span class="name"><span class="name">if</span></span> theme.footer.powered %&#125;</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"powered-by"</span>&gt;</span></span></span><br><span class="line"><span class="xml">    </span><span class="comment">&#123;##&#125;</span></span><br><span class="line"><span class="xml">    </span><span class="template-variable">&#123;&#123; __('footer.powered', '&lt;a class="theme-link" target="_blank" href="https://hexo.io"&gt;Hexo&lt;/a&gt;') &#125;&#125;</span></span><br><span class="line"><span class="xml">    </span><span class="comment">&#123;##&#125;</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">    </span><span class="template-tag">&#123;% <span class="name"><span class="name">endif</span></span> %&#125;</span></span><br><span class="line"><span class="xml">    </span><span class="template-tag">&#123;% <span class="name"><span class="name">if</span></span> theme.footer.powered and theme.footer.theme.enable %&#125;</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"post-meta-divider"</span>&gt;</span>|<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="xml">    </span><span class="template-tag">&#123;% <span class="name"><span class="name">endif</span></span> %&#125;</span></span><br><span class="line"><span class="xml">    </span><span class="template-tag">&#123;% <span class="name"><span class="name">if</span></span> theme.footer.theme.enable %&#125;</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"theme-info"</span>&gt;</span></span></span><br><span class="line"><span class="xml">    </span><span class="comment">&#123;##&#125;</span><span class="template-variable">&#123;&#123; __('footer.theme') &#125;&#125;</span><span class="xml"> <span class="symbol">&amp;mdash;</span></span></span><br><span class="line"><span class="xml">    </span><span class="comment">&#123;##&#125;</span><span class="xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">"theme-link"</span> <span class="attr">target</span>=<span class="string">"_blank"</span> <span class="attr">href</span>=<span class="string">"https://github.com/iissnan/hexo-theme-next"</span>&gt;</span></span></span><br><span class="line"><span class="xml">    </span><span class="comment">&#123;##&#125;</span><span class="xml">NexT.</span><span class="template-variable">&#123;&#123; theme.scheme &#125;&#125;</span></span><br><span class="line"><span class="xml">    </span><span class="comment">&#123;##&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><span class="template-tag">&#123;% <span class="name"><span class="name">if</span></span> theme.footer.theme.version %&#125;</span><span class="xml"> v</span><span class="template-variable">&#123;&#123; theme.version &#125;&#125;</span><span class="template-tag">&#123;% <span class="name"><span class="name">endif</span></span> %&#125;</span></span><br><span class="line"><span class="xml">    </span><span class="comment">&#123;##&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="template-tag">&#123;% <span class="name"><span class="name">endif</span></span> %&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="右上角实现-fork-me-on-github"><a href="#右上角实现-fork-me-on-github" class="headerlink" title="右上角实现 fork me on github"></a>右上角实现 fork me on github</h3><p>我的选择是 <a href="http://tholman.com/github-corners/" target="_blank" rel="noopener">这个黑色的 github 猫</a>，然后编辑 <code>themes/next/layout/_layout.swig</code>，将代码复制到</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">&lt;<span class="keyword">div</span> <span class="built_in">class</span>=<span class="string">"headband"</span>&gt;&lt;/<span class="keyword">div</span>&gt;</span><br></pre></td></tr></table></figure>
<p>这个下面</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"https://github.com/strugglebak"</span> <span class="attr">class</span>=<span class="string">"github-corner"</span> <span class="attr">aria-label</span>=<span class="string">"View source on Github"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">svg</span> <span class="attr">width</span>=<span class="string">"80"</span> <span class="attr">height</span>=<span class="string">"80"</span> <span class="attr">viewBox</span>=<span class="string">"0 0 250 250"</span> <span class="attr">style</span>=<span class="string">"fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;"</span> <span class="attr">aria-hidden</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">path</span> <span class="attr">d</span>=<span class="string">"M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"</span>&gt;</span><span class="tag">&lt;/<span class="name">path</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">path</span> <span class="attr">d</span>=<span class="string">"M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"</span> <span class="attr">fill</span>=<span class="string">"currentColor"</span> <span class="attr">style</span>=<span class="string">"transform-origin: 130px 106px;"</span> <span class="attr">class</span>=<span class="string">"octo-arm"</span>&gt;</span><span class="tag">&lt;/<span class="name">path</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">path</span> <span class="attr">d</span>=<span class="string">"M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"</span> <span class="attr">fill</span>=<span class="string">"currentColor"</span> <span class="attr">class</span>=<span class="string">"octo-body"</span>&gt;</span><span class="tag">&lt;/<span class="name">path</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"><span class="selector-class">.github-corner</span><span class="selector-pseudo">:hover</span> <span class="selector-class">.octo-arm</span>&#123;<span class="attribute">animation</span>:octocat-wave <span class="number">560ms</span> ease-in-out&#125;<span class="keyword">@keyframes</span> octocat-wave&#123;0%,100%&#123;<span class="attribute">transform</span>:<span class="built_in">rotate</span>(<span class="number">0</span>)&#125;20%,60%&#123;<span class="attribute">transform</span>:<span class="built_in">rotate</span>(-<span class="number">25deg</span>)&#125;40%,80%&#123;<span class="attribute">transform</span>:<span class="built_in">rotate</span>(<span class="number">10deg</span>)&#125;&#125;<span class="keyword">@media</span> (<span class="attribute">max-width:</span><span class="number">500px</span>)&#123;<span class="selector-class">.github-corner</span><span class="selector-pseudo">:hover</span> <span class="selector-class">.octo-arm</span>&#123;<span class="attribute">animation</span>:none&#125;<span class="selector-class">.github-corner</span> <span class="selector-class">.octo-arm</span>&#123;<span class="attribute">animation</span>:octocat-wave <span class="number">560ms</span> ease-in-out&#125;&#125;</span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="添加-README-md-文件"><a href="#添加-README-md-文件" class="headerlink" title="添加 README.md 文件"></a>添加 README.md 文件</h3><p>在 <code>myBlog/source/</code> 目录添加 <code>README.md</code>，并修改 <code>myBlog/_config.yml</code></p>
<figure class="highlight avrasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">skip_render:</span> README.md</span><br></pre></td></tr></table></figure>
<p>这里的目的是为了部署提交时这个 <code>README.md</code> 文件不会被渲染成 html</p>
<h2 id="开始更新部署博客"><a href="#开始更新部署博客" class="headerlink" title="开始更新部署博客"></a>开始更新部署博客</h2><p>执行以下命令</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">hexo clean</span></span><br><span class="line"><span class="attribute">hexo g</span></span><br><span class="line"><span class="attribute">hexo d</span></span><br></pre></td></tr></table></figure>
<p>以下是我的博客链接!<br><a href="https://strugglebak.github.io/">我的博客链接</a><br>以下是截图!</p>
<p><img src="./img2.png" alt></p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://mritd.me/2015/12/31/Github-搭建-Hexo-静态博客" target="_blank" rel="noopener">Github-搭建-Hexo-静态博客</a><br><a href="https://zhuanlan.zhihu.com/p/28360099" target="_blank" rel="noopener">Hexo博客之主题美化</a><br><a href="https://www.jianshu.com/p/f054333ac9e6" target="_blank" rel="noopener">hexo的next主题个性化教程:打造炫酷网站</a><br><a href="https://github.com/iissnan/hexo-theme-next/wiki/%E8%AE%BE%E7%BD%AE%E8%AF%AD%E8%A8%80" target="_blank" rel="noopener">设置语言</a></p>
]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>搭建博客</tag>
      </tags>
  </entry>
  <entry>
    <title>简单总结一些布局和居中套路</title>
    <url>/2019/02/19/%E7%AE%80%E5%8D%95%E6%80%BB%E7%BB%93%E4%B8%80%E4%BA%9B%E5%B8%83%E5%B1%80%E5%92%8C%E5%B1%85%E4%B8%AD%E5%A5%97%E8%B7%AF/</url>
    <content><![CDATA[<h2 id="左右布局"><a href="#左右布局" class="headerlink" title="左右布局"></a>左右布局</h2><p>左右布局实现的效果图如下<br><img src="./img1.png" alt></p>
<p>主要 html 代码如下<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">section</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"left-half"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">article</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Left Half<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"right-half"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">article</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Right Half<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<h3 id="使用绝对定位"><a href="#使用绝对定位" class="headerlink" title="使用绝对定位"></a>使用绝对定位</h3><p>使用 position 绝对定位，用两个 div 宽度分别占 50%,就可以得到两个左右布局的 div 了</p>
<p>主要 css 代码<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.left-half</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#ff9e2c</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">0px</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">50%</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.right-half</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#b6701e</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">right</span>: <span class="number">0px</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">50%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><a href="https://jsbin.com/hiyaqevupe/4/edit?html,css,output" target="_blank" rel="noopener">点击这里 demo 预览</a></p>
<h3 id="使用-float-clearfix-清除浮动"><a href="#使用-float-clearfix-清除浮动" class="headerlink" title="使用 float + clearfix 清除浮动"></a>使用 float + clearfix 清除浮动</h3><p>用 float 做左浮动也可以做到左右布局.当然这里也需要在父元素身上加上<strong>清除浮动</strong>，日常的做法是在父元素上添加 clearfix</p>
<p>主要 css 代码<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">* &#123; <span class="attribute">box-sizing</span>: border-box; &#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.left-half</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#ff9e2c</span>;</span><br><span class="line">    <span class="attribute">float</span>: left;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">50%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.right-half</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#b6701e</span>;</span><br><span class="line">    <span class="attribute">float</span>: left;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">50%</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">""</span>;</span><br><span class="line">    <span class="attribute">display</span>: block;</span><br><span class="line">    <span class="attribute">clear</span>: both;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><a href="https://jsbin.com/hiyaqevupe/3/edit?html,css,output" target="_blank" rel="noopener">点击这里 demo 预览</a></p>
<h3 id="使用-inline-block"><a href="#使用-inline-block" class="headerlink" title="使用 inline-block"></a>使用 inline-block</h3><p>将要排列的 div 元素变成 inline-block</p>
<p>主要 css 代码<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: inline-block;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">50%</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.left-half</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#ff9e2c</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.right-half</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#b6701e</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>但这种方法有个不可取的地方，就是它把 div 变成了内联元素后，在 html 中只有<strong>去掉了他们(div)之间的空格</strong>才能进行左右布局</p>
<p><a href="https://jsbin.com/figefaruwu/1/edit?html,css,output" target="_blank" rel="noopener">点击这里 demo 预览</a></p>
<h3 id="使用-flexbox"><a href="#使用-flexbox" class="headerlink" title="使用 flexbox"></a>使用 flexbox</h3><p>常言道: flex 大法吼啊</p>
<p>主要 css 代码<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">section</span><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">    <span class="attribute">flex-direction</span>: row;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">flex</span>: <span class="number">1</span> <span class="number">1</span> auto;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.left-half</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#ff9e2c</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.right-half</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#b6701e</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>flexbox 布局方式，可以将父容器变成一个 flexible box，这个 box 可以让子容器取得和其相等的大小空间,这个时候就可以不用考虑其宽和高的问题了</p>
<p><a href="https://jsbin.com/hiyaqevupe/6/edit?html,css,output" target="_blank" rel="noopener">点击这里 demo 预览</a></p>
<h2 id="左中右布局"><a href="#左中右布局" class="headerlink" title="左中右布局"></a>左中右布局</h2><p>左中右布局实现的效果图如下<br><img src="./img2.png" alt></p>
<p>主要 html 代码如下<br><figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">&lt;<span class="keyword">div</span> <span class="built_in">class</span>=<span class="string">"wrap clearfix"</span>&gt;</span><br><span class="line">    &lt;<span class="keyword">div</span> <span class="built_in">class</span>=<span class="string">"left"</span>&gt;left&lt;/<span class="keyword">div</span>&gt;</span><br><span class="line">    &lt;<span class="keyword">div</span> <span class="built_in">class</span>=<span class="string">"mid"</span>&gt;<span class="keyword">middle</span>&lt;/<span class="keyword">div</span>&gt;</span><br><span class="line">    &lt;<span class="keyword">div</span> <span class="built_in">class</span>=<span class="string">"right"</span>&gt;right&lt;/<span class="keyword">div</span>&gt;</span><br><span class="line">&lt;/<span class="keyword">div</span>&gt;</span><br></pre></td></tr></table></figure></p>
<p>主要 css 代码如下<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.wrap</span> &#123;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span> auto;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#00a8b5</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.left</span>, <span class="selector-class">.mid</span>, <span class="selector-class">.right</span> &#123;</span><br><span class="line">    <span class="attribute">float</span>: left;</span><br><span class="line">    <span class="attribute">margin-left</span>: <span class="number">5%</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">26%</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#774898</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.mid</span> &#123;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#de4383</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#f3ae4b</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">''</span>;</span><br><span class="line">    <span class="attribute">display</span>: block;</span><br><span class="line">    <span class="attribute">clear</span>: both;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看出来，这里使用的还是 float 左浮动 + clearfix 清除浮动实现</p>
<p><a href="https://jsbin.com/hamucivowe/edit?html,css,output" target="_blank" rel="noopener">点击这里 demo 预览</a></p>
<h2 id="水平居中"><a href="#水平居中" class="headerlink" title="水平居中"></a>水平居中</h2><h3 id="居中元素为-inline-inline"><a href="#居中元素为-inline-inline" class="headerlink" title="居中元素为 inline/inline-*"></a>居中元素为 inline/inline-*</h3><p>可以使用 <code>text-algin: center</code></p>
<p>需要实现效果如下<br><img src="./img3.png" alt></p>
<p>主要 html 代码<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>One<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>Two<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>Three<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>Four<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>主要 css 代码<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid red;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">20px</span> <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">div</span> &gt; <span class="selector-tag">a</span> &#123;</span><br><span class="line">    <span class="attribute">text-decoration</span>: none;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid black;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">3px</span> <span class="number">8px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><a href="https://jsbin.com/hiyaqevupe/8/edit?html,css,output" target="_blank" rel="noopener">点击这里 demo 预览</a></p>
<h3 id="居中元素为-block"><a href="#居中元素为-block" class="headerlink" title="居中元素为 block"></a>居中元素为 block</h3><p>可以使用 <code>margin: 0 auto</code></p>
<p>需要实现效果如下<br><img src="./img4.png" alt></p>
<p>主要 html 代码<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">main</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"center"</span>&gt;</span></span><br><span class="line">        block element center</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>主要 css 代码<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">main</span> &#123;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid red;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">20px</span> <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.center</span> &#123;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid green;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span> auto;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>无论这个块级元素的宽度如何，这个方法都能起到居中的效果</p>
<p><a href="https://jsbin.com/hiyaqevupe/9/edit?html,css,output" target="_blank" rel="noopener">点击这里 demo 预览</a></p>
<h3 id="居中元素为多个-block"><a href="#居中元素为多个-block" class="headerlink" title="居中元素为多个 block"></a>居中元素为多个 block</h3><p>需要实现效果如下<br><img src="./img5.png" alt></p>
<p>主要 html 代码<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span>inline-block 方法<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">main</span> <span class="attr">class</span>=<span class="string">"inline-block-center"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>div1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>div2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>div3<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span>flex-box 方法<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">main</span> <span class="attr">class</span>=<span class="string">"flex-center"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>div1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>div2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>div3<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>主要 css 代码<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">main</span> &#123;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid red;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">20px</span> <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">main</span> <span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid green;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">15px</span>;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">5px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.inline-block-center</span> &#123;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.inline-block-center</span> <span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: inline-block;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.flex-center</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">    <span class="attribute">justify-content</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里用了两种方法</p>
<ol>
<li>将 block 元素转变成 <code>display: inline-block</code> 然后其父元素用 <code>text-align: center</code> 来居中</li>
<li>直接使用 flex 布局，用 <code>display: flex; justify-content: center;</code> 来做</li>
</ol>
<p><a href="https://jsbin.com/hiyaqevupe/10/edit?html,css,output" target="_blank" rel="noopener">点击这里 demo 预览</a></p>
<h2 id="垂直居中"><a href="#垂直居中" class="headerlink" title="垂直居中"></a>垂直居中</h2><h3 id="居中元素为-inline-inline-1"><a href="#居中元素为-inline-inline-1" class="headerlink" title="居中元素为 inline/inline-*"></a>居中元素为 inline/inline-*</h3><p>i.如果是一行文字排列并进行垂直居中,可以尝试使用 padding</p>
<p>需要实现效果如下<br><img src="./img6.png" alt></p>
<p>主要 html 代码<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">main</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>world<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>world<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>主要 css 代码<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">main</span> &#123;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid red;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">20px</span> <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">50px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">main</span> &gt; <span class="selector-tag">a</span> &#123;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid green;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">40px</span> <span class="number">30px</span>;</span><br><span class="line">    <span class="attribute">text-decoration</span>: none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里由于父元素上下的 padding 相等,而子元素上下也相等，故在垂直方向上子元素已经居中了</p>
<p><a href="https://jsbin.com/meramiqiku/edit?html,css,output" target="_blank" rel="noopener">点击这里 demo 预览</a></p>
<p>ii.如果是多行文字排列并进行垂直居中则使用 <code>vertical-align: middle</code></p>
<p>需要实现效果如下<br><img src="./img7.png" alt></p>
<p>主要 html 代码<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"center-table"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>vertical center demo<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>主要 css 代码<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.center-table</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: table;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid red;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">250px</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">240px</span>;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.center-table</span> <span class="selector-tag">p</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: table-cell;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">10px</span> solid green;</span><br><span class="line">    <span class="attribute">vertical-align</span>: middle;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><a href="https://jsbin.com/hiyaqevupe/12/edit?html,css,output" target="_blank" rel="noopener">点击这里 demo 预览</a></p>
<p>或者也可以尝试用下 flexbox</p>
<p>需要实现效果如下<br><img src="./img8.png" alt></p>
<p>主要 html 代码<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"flex-center"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>vertical center demo<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>主要 css 代码<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.flex-center</span> &#123;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid red;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">    <span class="attribute">flex-direction</span>: column;</span><br><span class="line">    <span class="attribute">justify-content</span>: center;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.flex-center</span> <span class="selector-tag">p</span> &#123;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>只是这里需要注意的是，只有容器有固定的高这种方式才有意义</p>
<p><a href="https://jsbin.com/legaxovaku/edit?html,css,output" target="_blank" rel="noopener">点击这里 demo 预览</a></p>
<h3 id="居中元素为-block-1"><a href="#居中元素为-block-1" class="headerlink" title="居中元素为 block"></a>居中元素为 block</h3><p>需要实现效果如下<br><img src="./img9.png" alt></p>
<p>i.知道该块级元素的高<br>用 position 做相对定位,然后用个负 margin</p>
<p>主要 html 代码<br><figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="section">&lt;main&gt;</span></span><br><span class="line">    <span class="section">&lt;div&gt;</span></span><br><span class="line">        <span class="attribute">vertical</span> center demo</span><br><span class="line">    <span class="section">&lt;/div&gt;</span></span><br><span class="line"><span class="section">&lt;/main&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>主要 css 代码<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">main</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid red;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">main</span> &gt; <span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid green;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">margin-top</span>: -<span class="number">50px</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><a href="https://jsbin.com/pijobifila/edit?html,css,output" target="_blank" rel="noopener">点击这里 demo 预览</a></p>
<p>ii.不知道该块级元素的高<br>用 position 做相对定位,然后用个负 translate<br>主要 html 代码<br><figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="section">&lt;main&gt;</span></span><br><span class="line">    <span class="section">&lt;div&gt;</span></span><br><span class="line">        <span class="attribute">vertical</span> center demo</span><br><span class="line">    <span class="section">&lt;/div&gt;</span></span><br><span class="line"><span class="section">&lt;/main&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>CSS<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">main</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid red;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">main</span> &gt; <span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid green;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translateY</span>(-<span class="number">50%</span>);</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><a href="https://jsbin.com/gazolobese/edit?html,css,output" target="_blank" rel="noopener">点击这里 demo 预览</a></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li><p>用 flexbox 时 css 基本套路<br>父元素居中用下面的写法</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">    <span class="attribute">flex-direction</span>: column;</span><br><span class="line">    <span class="attribute">justify-content</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>子元素加 float,与之相近的父元素加 clearfix 可以进行水平的布局</p>
</li>
<li>父元素用相对定位，子元素用绝对定位，那么子元素就相对父元素定位了</li>
<li>负边距一般用于水平垂直居中，需要知道 width/height</li>
<li><p>如果有多个块级元素，我们想让其排列在一行并且总宽度依然相对父元素居中 </p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.inline-block-center</span> &#123; <span class="comment">/* wrapper */</span></span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.inline-block-center</span> <span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: inline-block;</span><br><span class="line">    <span class="attribute">text-align</span>: left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>行内元素水平居中对其父元素使用 <code>text-align: center</code></p>
</li>
</ul>
<h2 id="其他小技巧"><a href="#其他小技巧" class="headerlink" title="其他小技巧"></a>其他小技巧</h2><ul>
<li><p>三角形 trick</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">    <span class="attribute">border-style</span>: solid;</span><br><span class="line">    <span class="attribute">border-width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">border-color</span>: blue yellow green red;</span><br><span class="line">    <span class="comment">/* 尖朝下的蓝色三角形 */</span></span><br><span class="line">    <span class="comment">/* border-color:blue transparent transparent transparent; */</span></span><br><span class="line">    <span class="comment">/* 尖朝左的黄色三角形 */</span></span><br><span class="line">    <span class="comment">/* border-color:transparent yellow transparent transparent; */</span></span><br><span class="line">    <span class="comment">/* 尖朝上的绿色三角形 */</span></span><br><span class="line">    <span class="comment">/* border-color:transparent transparent green transparent; */</span></span><br><span class="line">    <span class="comment">/* 尖朝右的红色三角形 */</span></span><br><span class="line">    <span class="comment">/* border-color:transparent transparent red transparent; */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>文本 trick<br>解决文字溢出的问题，在文字溢出的后面加上省略号</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.text</span>&#123;</span><br><span class="line">    <span class="comment">/*有专门处理省略号的一个样式*/</span></span><br><span class="line">    <span class="attribute">text-overflow</span>: ellipsis;</span><br><span class="line">    <span class="comment">/*强制不换行*/</span></span><br><span class="line">    <span class="attribute">white-space</span>: nowrap;</span><br><span class="line">    <span class="comment">/*溢出隐藏*/</span></span><br><span class="line">    <span class="attribute">overflow</span>: hidden;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>简单说一下异步和回调</title>
    <url>/2019/02/20/%E7%AE%80%E5%8D%95%E8%AF%B4%E4%B8%80%E4%B8%8B%E5%BC%82%E6%AD%A5%E5%92%8C%E5%9B%9E%E8%B0%83/</url>
    <content><![CDATA[<h2 id="代码的异步"><a href="#代码的异步" class="headerlink" title="代码的异步"></a>代码的异步</h2><p>假如有这样的代码<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> result = <span class="string">''</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">writeCode</span>(<span class="params">code</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 里面有 setInterval</span></span><br><span class="line">    <span class="keyword">let</span> id = setInterval(<span class="function"><span class="params">()</span>=&gt;</span> &#123;</span><br><span class="line">        <span class="comment">//... 代码逻辑</span></span><br><span class="line">        <span class="keyword">if</span> (条件成立) &#123;</span><br><span class="line">            <span class="built_in">window</span>.clearInterval(id);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里调用 writeCode</span></span><br><span class="line">writeCode(result);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里再调用 fn</span></span><br><span class="line">fn();</span><br></pre></td></tr></table></figure></p>
<p>这里就有可能会出问题，问题是，因为 <code>setInterval</code> 里有设置时间，那么 <code>writeCode</code> 一执行，就会等待这个时间去执行它里面的代码逻辑，而这个时候 <code>fn</code> 早就执行了,有可能会造成页面的 bug</p>
<h2 id="代码的回调"><a href="#代码的回调" class="headerlink" title="代码的回调"></a>代码的回调</h2><p>异步的关键在于 [不等结果],直接进行下一步。那要怎么样才能拿到结果，就是使用 <strong>回调</strong>, <strong>回调是拿到异步结果的一种方式</strong>, 同时，<strong>回调也可以拿到同步结果</strong></p>
<p>如何解决呢，在 <code>writeCode</code> 里传个函数，然后当时间到的时候直接 <code>函数.call()</code>，如下代码所示<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> result = <span class="string">''</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">writeCode</span>(<span class="params">code, fn</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 里面有 setInterval</span></span><br><span class="line">    <span class="keyword">let</span> id = setInterval(<span class="function"><span class="params">()</span>=&gt;</span> &#123;</span><br><span class="line">        <span class="comment">//... 代码逻辑</span></span><br><span class="line">        <span class="keyword">if</span> (条件成立) &#123;</span><br><span class="line">            <span class="built_in">window</span>.clearInterval(id);</span><br><span class="line">            <span class="comment">// 这里调用 fn</span></span><br><span class="line">            fn.call();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里调用 writeCode</span></span><br><span class="line">writeCode(result, ()=&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'结束'</span>);</span><br><span class="line">    <span class="comment">// 这里才调用 fn</span></span><br><span class="line">    fn.call();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>以上代码可以保证在 <code>writeCode</code> 代码结束时才执行 <code>fn</code><br>补充: 那么怎么理解 <strong>回调也可以拿到同步结果</strong>呢<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> result = <span class="string">'result'</span>;</span><br><span class="line"><span class="keyword">var</span> result2 = <span class="string">'result2'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">writeCode</span>(<span class="params">code, fn</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 里面有 setInterval</span></span><br><span class="line">    <span class="keyword">let</span> id = setInterval(<span class="function"><span class="params">()</span>=&gt;</span> &#123;</span><br><span class="line">        <span class="comment">//... 代码逻辑</span></span><br><span class="line">        <span class="keyword">if</span> (条件成立) &#123;</span><br><span class="line">            <span class="built_in">window</span>.clearInterval(id);</span><br><span class="line">            <span class="comment">// 这里调用 fn</span></span><br><span class="line">            fn.call();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数里面添加一个回调函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">fn2</span>) </span>&#123;</span><br><span class="line">    fn2.call();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里调用 writeCode</span></span><br><span class="line">writeCode(result, ()=&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'结束'</span>);</span><br><span class="line">    <span class="comment">// 这里才调用 fn</span></span><br><span class="line">    fn( <span class="function"><span class="params">()</span>=&gt;</span> &#123;</span><br><span class="line">        writeCode(result, result2);</span><br><span class="line">    &#125; );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>这里的 <code>fn</code> 里的回调就是<strong>同步回调</strong></p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><ul>
<li>异步是指不用等待异步任务的结果，代码直接往下运行的操作。异步任务是被 JS 引擎放到一边，不进入主线程而进入任务队列的任务。</li>
<li>回调是拿到异步任务结果的一种方式，只有 JS 引擎认为某个异步任务可以执行了，该任务就会通过回调的方式进入主线程执行</li>
</ul>
]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>虚拟DOM</title>
    <url>/2019/02/20/%E8%99%9A%E6%8B%9FDOM/</url>
    <content><![CDATA[<h2 id="什么是虚拟-DOM"><a href="#什么是虚拟-DOM" class="headerlink" title="什么是虚拟 DOM"></a>什么是虚拟 DOM</h2><p>虚拟 DOM，就是说，把真实的 DOM 结构映射成计算机内存中的一段数据结构，然后通过操作这个虚拟的数据结构，最后变成一个新的虚拟 DOM，这个虚拟 DOM 再映射到真实 DOM 上，就完成了真实 DOM 结构的改变</p>
<h2 id="有什么作用"><a href="#有什么作用" class="headerlink" title="有什么作用"></a>有什么作用</h2><p>真实 DOM 的结构在发生变化时，假如用 js 去操作所有的 document 元素，那么将会对所有的 DOM 结构进行排列并渲染，这在技术上比较难实现不说，而且也使得页面的性能变得很差，虚拟 DOM 提供了一个方法，即在这个虚拟的数据结构中，若真实 DOM 的结构已经变化，那么先对这个已经变化对应的虚拟数据结构进行对比，提供一个类似 git 的一个 diff 的算法，看看是哪里产生的变化，最后就这个变化渲染出真实 DOM，其他的都不变，这样就实现了一定程度的页面性能的提升</p>
<h2 id="虚拟-DOM-Demo"><a href="#虚拟-DOM-Demo" class="headerlink" title="虚拟 DOM Demo"></a>虚拟 DOM Demo</h2><p>现在尝试实现一个虚拟 DOM 的算法,首先我们先定义一个 VNode,这个就是描述 DOM 的一个数据结构<br>从整体结构上看，它的构造函数应该接受三个参数,标签 tag/子元素 children/文本 text,<br>因为 VNode 是一颗树，所以渲染这颗树的时候，为简单起见，用递归方式渲染<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VNode</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(tag, children, text) &#123;</span><br><span class="line">    <span class="keyword">this</span>.tag = tag;</span><br><span class="line">    <span class="keyword">this</span>.text = text;</span><br><span class="line">    <span class="keyword">this</span>.children = children;</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123; <span class="comment">// 递归渲染</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.tag === <span class="string">'#text'</span>) &#123; <span class="comment">// 表示最底层的 node 节点是个 text 文本</span></span><br><span class="line">      <span class="keyword">return</span> document.createTextNode(<span class="keyword">this</span>.text);</span><br><span class="line">    &#125;</span><br><span class="line">    let el = document.createElement(<span class="keyword">this</span>.tag);</span><br><span class="line">    <span class="keyword">this</span>.children.forEach(vChild =&gt; &#123;</span><br><span class="line">      el.appendChild(vChild.render());</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> el;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后实现一个创建 VNode 的函数<br><figure class="highlight openscad"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">v</span><span class="params">(tag, children, text)</span> &#123;</span></span><br><span class="line">  <span class="keyword">if</span>(typeof <span class="built_in">children</span> === 'string') &#123;</span><br><span class="line">    <span class="built_in">text</span> = <span class="built_in">children</span>;</span><br><span class="line">    <span class="built_in">children</span> = [];</span><br><span class="line">  &#125;</span><br><span class="line">  return new VNode(tag, <span class="built_in">children</span>, <span class="built_in">text</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>假设我要实现的模板是这样的<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span>&gt;</span>demo1<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>demo2<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>那么我可以这么创建一个 vNode<br><figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">let vNode = v('div', [</span><br><span class="line">      v('p', [</span><br><span class="line">          v('span', [ v('#text', 'demo1') ])</span><br><span class="line">        ]</span><br><span class="line">      ),</span><br><span class="line">      v('span', [ v('#text',  'demo2') ])</span><br><span class="line">    ]</span><br><span class="line">  )<span class="comment">;</span></span><br></pre></td></tr></table></figure></p>
<p>好了，接下来要实现的就是那个关键函数，这个函数就是通过比较 vNode 中变化的部分，将那个变化的部分给渲染出来<br><figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line"><span class="comment">// parent 为父节点,这个参数是必须要传的</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">patchElement</span></span>(parent, <span class="keyword">new</span><span class="type">VNode</span>, oldVNode, index = <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span>(!oldVNode) &#123;</span><br><span class="line">    <span class="comment">// 若相比之前新增了节点</span></span><br><span class="line">    parent.appendChild(<span class="keyword">new</span><span class="type">VNode</span>.render()); <span class="comment">// 直接添加对应节点</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>(!<span class="keyword">new</span><span class="type">VNode</span>) &#123;</span><br><span class="line">    <span class="comment">// 若相比之前删除了节点</span></span><br><span class="line">    parent.removeChild(parent.childNodes[index]); <span class="comment">// 直接删除对应节点</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">new</span><span class="type">VNode</span>.tag !== oldVNode.tag || <span class="keyword">new</span><span class="type">VNode</span>.text !== oldVNode.text) &#123;</span><br><span class="line">    <span class="comment">// 若相比之前修改了节点</span></span><br><span class="line">    parent.replaceChild(<span class="keyword">new</span><span class="type">VNode</span>.render(), parent.childNodes[index]); <span class="comment">// 直接替换对应节点</span></span><br><span class="line">  &#125;  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">for</span>(let i = <span class="number">0</span>; i &lt; <span class="keyword">new</span><span class="type">VNode</span>.children.length || i &lt; oldVNode.children.length; i++) &#123;</span><br><span class="line">      <span class="comment">// 若这对比的这一层节点啥都没变，则继续递归比较节点</span></span><br><span class="line">      patchElement(parent.childNodes[index], <span class="keyword">new</span><span class="type">VNode</span>.children[i], oldVNode.children[i], i);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后就可以用了<br>首先是 html 代码<br><figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">&lt;<span class="keyword">div</span> <span class="built_in">id</span>=<span class="string">"root"</span>&gt;&lt;/<span class="keyword">div</span>&gt;</span><br></pre></td></tr></table></figure></p>
<p>然后是提示用的 css 代码<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: blue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">span</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最后是 javascript<br><figure class="highlight prolog"><table><tr><td class="code"><pre><span class="line">let vNode = v(<span class="string">'div'</span>, [</span><br><span class="line">      v(<span class="string">'p'</span>, [</span><br><span class="line">          v(<span class="string">'span'</span>, [ v(<span class="string">'#text'</span>, <span class="string">'demo1'</span>) ])</span><br><span class="line">        ]</span><br><span class="line">      ),</span><br><span class="line">      v(<span class="string">'span'</span>, [ v(<span class="string">'#text'</span>,  <span class="string">'demo2'</span>) ])</span><br><span class="line">    ]</span><br><span class="line">  );</span><br><span class="line">let parent = document.body.querySelector(<span class="string">'#root'</span>);</span><br><span class="line">parent.appendChild(vNode.render());</span><br><span class="line"></span><br><span class="line">let vNode2 = v(<span class="string">'div'</span>, [</span><br><span class="line">      v(<span class="string">'p'</span>, [</span><br><span class="line">          v(<span class="string">'span'</span>, [ v(<span class="string">'#text'</span>, <span class="string">'demo1'</span>) ])</span><br><span class="line">        ]</span><br><span class="line">      )</span><br><span class="line">    ]</span><br><span class="line">  );</span><br><span class="line">patchElement(parent, vNode2, vNode)</span><br></pre></td></tr></table></figure></p>
<h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><p>使用 <code>patchElement</code> 之前<br><img src="./img1.png" alt></p>
<p>使用 <code>patchElement</code> 之后<br><img src="./img2.png" alt></p>
<p><a href="https://jsbin.com/qokasafefu/edit?js,output" target="_blank" rel="noopener">点击这里预览</a></p>
]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>虚拟dom</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机是如何存储数据的</title>
    <url>/2019/01/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%98%AF%E5%A6%82%E4%BD%95%E5%AD%98%E5%82%A8%E6%95%B0%E6%8D%AE%E7%9A%84/</url>
    <content><![CDATA[<h2 id="基本书"><a href="#基本书" class="headerlink" title="基本书"></a>基本书</h2><ol>
<li>编码 操作系统 数据结构与算法分析 代码大全</li>
</ol>
<h2 id="字符编码以及字符集"><a href="#字符编码以及字符集" class="headerlink" title="字符编码以及字符集"></a>字符编码以及字符集</h2><ol>
<li>GBK 国标扩展字符集 &lt; unicode 字符集</li>
<li><p>将 unicode 字符集存到计算机里需要一种性价比高的方式进行，然后就出现了 utf-8(为了节省空间),注意，这个 <strong>utf-8 是存储到计算机中的一种算法</strong><br>下面是图<br><img src="./img1.png" alt></p>
</li>
<li><p>为什么有些中文软件更喜欢 GBK ??? 9几年没得选择啊，因为就那几个字符集</p>
</li>
<li>有关 JS 的一些编码问题<br>见下图<br><img src="./img2.png" alt></li>
</ol>
]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>字符编码</tag>
      </tags>
  </entry>
  <entry>
    <title>谈谈跨域的其他方式</title>
    <url>/2019/03/14/%E8%B0%88%E8%B0%88%E8%B7%A8%E5%9F%9F%E7%9A%84%E5%85%B6%E4%BB%96%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<blockquote>
<p>此篇文章是对跨域知识的补充，由于前面一篇已经介绍了 JSONP 这种跨域方式，这里就不再多赘述</p>
</blockquote>
<a id="more"></a>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>先总体来说说跨域的几种方式吧</p>
<ul>
<li><p>JSONP</p>
<p>  通过动态生成 <code>script</code> 标签的方式来进行不同源网页之间的数据传递,具体看 <a href="https://strugglebak.github.io/2019/02/20/JSONP%E5%88%9D%E6%8E%A2/">这篇博客</a></p>
</li>
<li><p>CORS</p>
<p>  全称 <strong>跨源资源共享</strong>(Cross-Origin Resource Sharing),是目前 <strong>主流的</strong> 跨域方案</p>
</li>
<li><p>postMessage</p>
<p>  HTML5 的一个 api，使用它也可以进行跨域操作</p>
</li>
</ul>
<h2 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h2><p>这个 CORS 要怎么进行跨域呢？很简单，它的原理就是 <strong>设置 HTTP 请求头</strong>,一般来讲在前后端进行 Ajax 通信时使用,比如 xxx.com 想向 yyy.com 发送 Ajax 请求<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// xxx.com 前端 Ajax 代码</span></span><br><span class="line"><span class="keyword">let</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">xhr.open(<span class="string">'GET'</span>, <span class="string">'yyy.com'</span>, <span class="literal">true</span>);</span><br><span class="line">xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (xhr.readyState === <span class="number">4</span> &amp;&amp; xhr.status === <span class="number">200</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(xhr.responseText);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;;</span><br><span class="line">xhr.send();</span><br></pre></td></tr></table></figure></p>
<p>这个时候你去打开控制台，会看到一个 <code>Access-Control-Allow-Origin</code> 的错误，就是说你进行跨域请求了，但是 yyy.com 上的服务器没有给你跨域的控制权限,所以你需要 <strong>在 yyy.com 这个服务器上设置 Access-Control-Allow-Origin 这个 HTTP 头，使它允许来自 xxx.com 的请求</strong><br><figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 假设你的后端是基于 node.js 写的</span></span><br><span class="line"><span class="keyword">var</span> server = http.createServer(<span class="function"><span class="keyword">function</span><span class="params">(request, response)</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    response.setHeader(<span class="string">'Access-Control-Allow-Origin'</span>, <span class="string">'yyy.com'</span>);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p>当然了，你也可以图方便，将 <code>Access-Control-Allow-Origin</code> 设置成 <code>*</code>, 表示允许任意源的请求，若你不想这样，想要允许多个源的请求，你可以这样设置<br><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">var<span class="built_in"> server </span>= http.createServer(function(request, response)&#123;</span><br><span class="line">    <span class="built_in">..</span>.</span><br><span class="line">    <span class="keyword">if</span> (request.headers.origin === <span class="string">'yyy.com'</span> </span><br><span class="line">        || request.headers.origin === <span class="string">'zzz.com'</span>) &#123;</span><br><span class="line">        response.setHeader(<span class="string">'Access-Control-Allow-Origin'</span>, request.headers.origin);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">..</span>.</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">..</span>.</span><br></pre></td></tr></table></figure></p>
<p>可是对于简单请求(<code>GET</code>, <code>POST</code>, <code>HEAD</code>)来说，只是需要设置这一个头就行了，假如需要非简单的请求呢(<code>PUT</code>, <code>DELETE</code>),这个时候浏览器一般会发送一个 <strong>预请求</strong>, 这个预请求的格式如下<br><figure class="highlight oxygene"><table><tr><td class="code"><pre><span class="line">Request <span class="function"><span class="keyword">Method</span>:</span> OPTIONS</span><br></pre></td></tr></table></figure></p>
<p>所以相应的服务端需要设置 <code>Access-Control-Allow-Methods</code> 这个头，浏览器才能用 <strong>非简单请求进行通信</strong><br><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">var<span class="built_in"> server </span>= http.createServer(function(request, response)&#123;</span><br><span class="line">    <span class="built_in">..</span>.</span><br><span class="line">    <span class="keyword">if</span> (request.headers.origin === <span class="string">'yyy.com'</span> </span><br><span class="line">        || request.headers.origin === <span class="string">'zzz.com'</span>) &#123;</span><br><span class="line">        response.setHeader(<span class="string">'Access-Control-Allow-Origin'</span>, request.headers.origin);</span><br><span class="line">        response.setHeader(<span class="string">'Access-Control-Allow-Methods'</span>, <span class="string">'put,delete'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">..</span>.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果你还想要传送 Cookie ，你需要在浏览器端设置 <code>withCredentials</code>, 然后在服务器端设置 <code>Access-Control-Allow-Credentials</code> 头<br><figure class="highlight lasso"><table><tr><td class="code"><pre><span class="line"><span class="comment">// xxx.com 前端 Ajax 代码</span></span><br><span class="line"><span class="params">...</span></span><br><span class="line">xhr.withCredentials = <span class="literal">true</span>;</span><br><span class="line"><span class="params">...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// yyy.com 后端代码</span></span><br><span class="line"><span class="built_in">var</span> server = http.createServer(function(request, response)&#123;</span><br><span class="line">    <span class="params">...</span></span><br><span class="line">    response.setHeader(<span class="string">'Access-Control-Allow-Credentials'</span>, <span class="literal">true</span>);</span><br><span class="line">    <span class="params">...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="postMessage"><a href="#postMessage" class="headerlink" title="postMessage"></a>postMessage</h2><p>使用方法: <code>postMessage(&#39;需要发送的消息&#39;, &#39;对方域名&#39;)</code><br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- xxx.com 前端代码 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">id</span>=<span class="string">"iframe"</span> <span class="attr">src</span>=<span class="string">"yyy.com"</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> iframe = <span class="built_in">document</span>.querySelector(<span class="string">'#iframe'</span>);</span></span><br><span class="line"><span class="actionscript">    iframe.setAttribute(<span class="string">'style'</span>, <span class="string">'display: none'</span>);</span></span><br><span class="line"><span class="actionscript">    iframe.onload = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">        iframe.contentWindow.postMessage(<span class="string">'我是 xxx.com'</span>, <span class="string">'yyy.com'</span>);</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- yyy.com 前端代码 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="built_in">window</span>.addEventListener(<span class="string">'message'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(e.data, e.origin);</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<h2 id="还有其他的方式"><a href="#还有其他的方式" class="headerlink" title="还有其他的方式?"></a>还有其他的方式?</h2><h3 id="hash-iframe"><a href="#hash-iframe" class="headerlink" title="hash + iframe"></a>hash + iframe</h3><p>当然还有其他的方式了，比如有一种 <code>hash + iframe</code><br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- xxx.com 前端代码 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">id</span>=<span class="string">"iframe"</span> <span class="attr">src</span>=<span class="string">"yyy.com"</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> iframe = <span class="built_in">document</span>.querySelector(<span class="string">'#iframe'</span>);</span></span><br><span class="line"><span class="actionscript">    iframe.setAttribute(<span class="string">'style'</span>, <span class="string">'display: none'</span>);</span></span><br><span class="line"><span class="javascript">    iframe.src = iframe.src + <span class="string">'#'</span> + <span class="built_in">JSON</span>.stringify(&#123;<span class="attr">data</span>: <span class="string">'hash'</span>&#125;);</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- yyy.com 前端代码 --&gt;</span></span><br><span class="line">window.onhashchange = function() &#123;</span><br><span class="line">    console.log(window.location.hash);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>原理: 动态改变 <code>iframe</code> src 属性的 hash 值，然后接受方通过监听 <code>onhashchange</code> 这个事件来接受到其传过来的数据</p>
<h3 id="WebSockets"><a href="#WebSockets" class="headerlink" title="WebSockets"></a>WebSockets</h3><p><code>WebSockets</code> 的基础用法如下<br><figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> ws = <span class="keyword">new</span> WebSocket(<span class="string">'ws://xxx.com'</span>);</span><br><span class="line">ws.onopen = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 连接成功建立</span></span><br><span class="line">&#125;</span><br><span class="line">ws.onmessage = <span class="function"><span class="keyword">function</span><span class="params">(event)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 处理数据</span></span><br><span class="line">&#125;</span><br><span class="line">ws.onerror = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 发生错误时触发，连接中断</span></span><br><span class="line">&#125;</span><br><span class="line">ws.onclose = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 连接关闭时触发</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其实就是在 xxx.com 上建立一个 <code>长连接</code>,一般使用 <code>socket.io</code> 第三方库来代替使用</p>
<h2 id="几种方式的特点"><a href="#几种方式的特点" class="headerlink" title="几种方式的特点"></a>几种方式的特点</h2><ol>
<li><p>JSONP<br>仅支持 GET 方式，而且也不方便确认 JSONP 是否请求失败</p>
</li>
<li><p>CORS<br>支持所有类型的 HTTP 方法,但是不兼容老版本浏览器</p>
</li>
<li><p>postMessage<br>仅支持 GET 方式</p>
</li>
<li><p>hash + iframe<br>仅支持 GET 方式以及 <strong>单向通信</strong></p>
</li>
<li><p>WebSockets<br>支持双向通信</p>
</li>
</ol>
]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>跨域</tag>
      </tags>
  </entry>
  <entry>
    <title>配置代码覆盖率徽标的问题</title>
    <url>/2020/03/11/%E9%85%8D%E7%BD%AE%E4%BB%A3%E7%A0%81%E8%A6%86%E7%9B%96%E7%8E%87%E5%BE%BD%E6%A0%87%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<blockquote>
<p>配置代码覆盖率的这个徽标也是一个很麻烦的问题，由于采用的是 travis 这个 ci 工具，所以坑还是有点多的，这里也记录了如何生成一个 github 的 token，也算做个记录</p>
</blockquote>
<a id="more"></a>
<h2 id="找库"><a href="#找库" class="headerlink" title="找库"></a>找库</h2><p>首先是看到 <a href="http://https://github.com/axios/axios" target="_blank" rel="noopener">axios 这个库</a> 里面有个 <code>coverage</code><br><img src="./1.png" alt></p>
<p>然后查人家的 <code>package.json</code> 发现是用 <code>coveralls</code> 这个工具的，并且命令为<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="string">"coveralls"</span>: <span class="string">"cat coverage/lcov.info | ./node_modules/coveralls/bin/coveralls.js"</span></span><br></pre></td></tr></table></figure></p>
<p>原理就是用 <code>coveralls</code> 这个工具计算好代码覆盖率之后，会在项目根目录下生成 <code>coveralls</code> 文件夹，里面就有相关的文件以及最关键的 – <code>lcov.info</code>， 这个文件就是我想要的那个徽标</p>
<h2 id="网站配置"><a href="#网站配置" class="headerlink" title="网站配置"></a>网站配置</h2><p>首先我项目都是基于 TravisCI 进行持续集成的，最开始的 <code>.travis.yml</code> 如下<br><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">language:</span> <span class="string">node_js</span></span><br><span class="line"><span class="attr">cache:</span></span><br><span class="line">  <span class="attr">directories:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">"~/.npm"</span></span><br><span class="line"><span class="attr">notifications:</span></span><br><span class="line">  <span class="attr">email:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">node_js:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">'10'</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">'11'</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">'8'</span></span><br><span class="line"><span class="attr">script:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">npm</span> <span class="string">run</span> <span class="string">test:prod</span> <span class="string">&amp;&amp;</span> <span class="string">npm</span> <span class="string">run</span> <span class="string">build</span></span><br><span class="line"><span class="attr">after_success:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">npm</span> <span class="string">run</span> <span class="string">travis-deploy-once</span> <span class="string">"npm run report-coverage"</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">if</span> <span class="string">[</span> <span class="string">"$TRAVIS_BRANCH"</span> <span class="string">=</span> <span class="string">"master"</span> <span class="string">-a</span> <span class="string">"$TRAVIS_PULL_REQUEST"</span> <span class="string">=</span> <span class="string">"false"</span> <span class="string">];</span> <span class="string">then</span> <span class="string">npm</span></span><br><span class="line">  <span class="string">run</span> <span class="string">travis-deploy-once</span> <span class="string">"npm run deploy-docs"</span><span class="string">;</span> <span class="string">fi</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">if</span> <span class="string">[</span> <span class="string">"$TRAVIS_BRANCH"</span> <span class="string">=</span> <span class="string">"master"</span> <span class="string">-a</span> <span class="string">"$TRAVIS_PULL_REQUEST"</span> <span class="string">=</span> <span class="string">"false"</span> <span class="string">];</span> <span class="string">then</span> <span class="string">npm</span></span><br><span class="line">  <span class="string">run</span> <span class="string">travis-deploy-once</span> <span class="string">"npm run sr"</span><span class="string">;</span> <span class="string">fi</span></span><br><span class="line"><span class="attr">branches:</span></span><br><span class="line">  <span class="attr">except:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">"/^v\\d+\\.\\d+\\.\\d+$/"</span></span><br></pre></td></tr></table></figure></p>
<p>按照道理来说，配置好后提交，然后 travis 那边只需要关联上你对应的项目就好，但是会出一个 bug 报错<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Error: GitHub authentication missing</span><br><span class="line">    at validate (/home/travis/build/strugglebak/txios/node_modules/travis-deploy-once/lib/validate.js:12:27)</span><br><span class="line">    at module.exports (/home/travis/build/strugglebak/txios/node_modules/travis-deploy-once/lib/travis-deploy-once.js:25:3)</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p>看了下是执行<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm run travis-deploy-once <span class="string">"npm run report-coverage"</span></span><br></pre></td></tr></table></figure></p>
<p>这句话报错的，刚好是要执行代码覆盖率相关操作的语句。 先放在这里不管，继续找徽标</p>
<h2 id="shields-io"><a href="#shields-io" class="headerlink" title="shields.io"></a>shields.io</h2><p>google 搜 <code>github 徽标</code>，出来第一个结果就是 <code>shields.io</code> 相关的，然后找 <code>Code Coverage</code>，匹配到 <code>coveralls</code> 相关的<br><img src="./2.png" alt><br>再一搜原来需要登陆 <code>Coveralls</code> 的官方网站搞，于是用 github 账号登陆<a href="https://coveralls.io/" target="_blank" rel="noopener">coveralls 官网</a>，看了下应该也是需要关联仓库的，点击左边的 <code>Add Repos</code><br><img src="./3.png" alt></p>
<p>添加完之后点击 <code>REPOS</code> 然后再点击刚刚添加项目会发现如下说明<br><img src="./4.png" alt></p>
<p>wtf。。。我才知道原来 travis 还有 pro 版本，赶紧一搜，原来是 travis-ci.org 和 travis-ci.com 的区别，估计是重构了服务什么的吧，这个就先没管了，于是搜 [coveralls 使用]，条件是过去一年内, 看到了<a href="https://zhuanlan.zhihu.com/p/54958391" target="_blank" rel="noopener">知乎的一篇文章</a>,浏览量下也就很普通的解决方案，但是用的是 travis-ci.com 也就是所谓的 pro 版本，于是登陆 pro 版，也是 github 账号登陆，选择管理项目的时候选择了[自己的 github 的所有 repo] 而不是 [指定的项目]，但是在搜索框搜项目的时候居然不存在。。。</p>
<p><img src="./5.png" alt></p>
<p>于是乱点了下，点击那个 <code>Migrate</code> tab 后终于出现了</p>
<p><img src="./6.png" alt></p>
<p>现在我懂了，如果你是从 travis-ci.org 那边过来的，那边如果有项目在的话，要在这个 travis-ci.com 用，必须要[迁移]过来。</p>
<p>现在照着知乎那篇帖子配置了下， git push 后看结果，傻眼了，还是报那个错，而且刷新 Coveralls 的相关项目页的时候还是没有出现所谓的[代码覆盖率的报告]，但是如果<strong>不生成这个报告的话，你就拿不到代码覆盖率的徽标了</strong>，继续搜索尝试解决问题</p>
<h2 id="bug-报错的提示"><a href="#bug-报错的提示" class="headerlink" title="bug 报错的提示"></a>bug 报错的提示</h2><p>前面说了那个 bug 的提示就是<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Error: GitHub authentication missing</span><br></pre></td></tr></table></figure></p>
<p>貌似就是跟 github 项目相关的 token 验证有关系，于是搜<br>[travis github token set]，<a href="https://docs.travis-ci.com/user/deployment/pages/" target="_blank" rel="noopener">第一个</a>无脑点进去看</p>
<p>还是官方文档</p>
<p><img src="./7.png" alt></p>
<p>看懂了，是这样的一个过程。<br><strong>一般是你要在 travis 帮你在 github page 上部署你的静态文件时会用到 personal access token 这个玩意儿，然后这个 token 是很敏感的私密字符串(因为你可以用这个 token 代替密码来进行仓库的一些操作)， 所以你需要对其进行加密处理</strong></p>
<p><img src="./8.png" alt></p>
<p>点击人家推荐的链接<a href="https://help.github.com/en/github/authenticating-to-github/creating-a-personal-access-token-for-the-command-line" target="_blank" rel="noopener">repository settings 里面看</a><br>最终得到类似这么个玩意儿</p>
<p><img src="./9.png" alt></p>
<p>然后点击人家推荐的链接<a href="https://docs.travis-ci.com/user/environment-variables#defining-encrypted-variables-in-travisyml" target="_blank" rel="noopener">encrypted variables</a></p>
<p><img src="./10.png" alt></p>
<p>然后再点击 <a href="https://docs.travis-ci.com/user/encryption-keys#usage" target="_blank" rel="noopener">Encryption keys – Usage</a></p>
<p><img src="./11.png" alt></p>
<p>返回去看了下</p>
<p><img src="./12.png" alt></p>
<p>看了下，大致意思就是，你可以使用下面这条命令<br><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">travis encrypt --pro SOMEVAR=<span class="string">"secretvalue"</span> --<span class="keyword">add</span></span><br></pre></td></tr></table></figure></p>
<p>去加密一个变量，然后这个就会以加密后的一串字符串追加到 <code>.travis.yml</code> 文件后<br><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">env:</span></span><br><span class="line">  <span class="attr">global:</span></span><br><span class="line">    <span class="attr">secure:</span> <span class="string">WPuJZvLNAyAfwu2gM89Y3t520/rnO5GK25Bf1WViJff5q...</span></span><br></pre></td></tr></table></figure></p>
<p>这就表示把你定义的变量加入到 travis 这个环境变量里面去了，然后你在 travis 上编译测试成功后，会在你项目你自己已经定义好的变量中去找，因为这是一个 key 和 value，找到你对应的 key 再解密然后比对 value，就达到了权限验证的目的了。</p>
<blockquote>
<p>这里我执行的命令是 <code>travis encrypt --pro GITHUB_TOKEN=&quot;yourgithubtokenvalue&quot; --add</code></p>
</blockquote>
<p>比如我的就是设置的变量名就是 <code>GITHUB_TOKEN</code>，就在 travis 项目中的 <code>setting</code> 页面中的那个 <code>Environment Variables</code> 里填，<code>Value</code> 项就是你在 github 上设置成功的 token 值，然后点击 <code>Add</code> 添加</p>
<p><img src="./xxx.png" alt></p>
<p><img src="./13.png" alt></p>
<p>最后就是项目的修改和提交了，主要就是更改了 <code>.travis.yml</code> 配置文件，提交了之后等待 travis 测试通过，再刷新 <code>Coveralls</code> 官网对应的项目，看到下图表示代码覆盖率报告已经生成，也就是说可以在 <code>shields.io</code> 上拿到 <code>coverage</code> 的徽标了!</p>
<p><img src="./14.png" alt></p>
<h2 id="travis-相关文件配置"><a href="#travis-相关文件配置" class="headerlink" title="travis 相关文件配置"></a>travis 相关文件配置</h2><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">provider:</span> <span class="string">pages</span></span><br><span class="line">  <span class="attr">skip_cleanup:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">github_token:</span> <span class="string">$GITHUB_TOKEN</span></span><br><span class="line">  <span class="attr">keep_history:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">on:</span></span><br><span class="line">    <span class="attr">branch:</span> <span class="string">master</span></span><br><span class="line"><span class="attr">language:</span> <span class="string">node_js</span></span><br><span class="line"><span class="attr">cache:</span></span><br><span class="line">  <span class="attr">directories:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">"~/.npm"</span></span><br><span class="line"><span class="attr">notifications:</span></span><br><span class="line">  <span class="attr">email:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">node_js:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">'10'</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">'11'</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">'8'</span></span><br><span class="line"><span class="attr">script:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">npm</span> <span class="string">run</span> <span class="string">test:prod</span> <span class="string">&amp;&amp;</span> <span class="string">npm</span> <span class="string">run</span> <span class="string">build</span></span><br><span class="line"><span class="attr">after_success:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">npm</span> <span class="string">run</span> <span class="string">travis-deploy-once</span> <span class="string">"npm run report-coverage"</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">if</span> <span class="string">[</span> <span class="string">"$TRAVIS_BRANCH"</span> <span class="string">=</span> <span class="string">"master"</span> <span class="string">-a</span> <span class="string">"$TRAVIS_PULL_REQUEST"</span> <span class="string">=</span> <span class="string">"false"</span> <span class="string">];</span> <span class="string">then</span> <span class="string">npm</span></span><br><span class="line">  <span class="string">run</span> <span class="string">travis-deploy-once</span> <span class="string">"npm run deploy-docs"</span><span class="string">;</span> <span class="string">fi</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">if</span> <span class="string">[</span> <span class="string">"$TRAVIS_BRANCH"</span> <span class="string">=</span> <span class="string">"master"</span> <span class="string">-a</span> <span class="string">"$TRAVIS_PULL_REQUEST"</span> <span class="string">=</span> <span class="string">"false"</span> <span class="string">];</span> <span class="string">then</span> <span class="string">npm</span></span><br><span class="line">  <span class="string">run</span> <span class="string">travis-deploy-once</span> <span class="string">"npm run sr"</span><span class="string">;</span> <span class="string">fi</span></span><br><span class="line"><span class="attr">branches:</span></span><br><span class="line">  <span class="attr">except:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">"/^v\\d+\\.\\d+\\.\\d+$/"</span></span><br><span class="line"><span class="attr">env:</span></span><br><span class="line">  <span class="attr">global:</span></span><br><span class="line">    <span class="attr">secure:</span> <span class="string">WPuJZvLNAyAfwu2gM89Y3t520/rnO5GK25Bf1WViJff5q893Z...</span></span><br></pre></td></tr></table></figure>
<p>注意我写的 <code>$GITHUB_NAME</code> 这里就是获取到你在 travis 上配置的环境变量名。</p>
<p>最后的最后需要注意的，可能是一个坑，但是我还是加上了，就是有看到  github 上有 issue 讨论这个问题<a href="https://github.com/semantic-release/travis-deploy-once/issues/52" target="_blank" rel="noopener">GH_TOKEN has not authenticated Travis CI yet</a><br>然后他是通过在 <code>package.json</code> 中的 <code>travis-deploy-once</code> 后加 <code>--pro</code> 解决的</p>
<p><img src="./15.png" alt></p>
<p>为了以防万一，我也在项目中加了, 我的项目地址为<a href="https://github.com/strugglebak/txios.git" target="_blank" rel="noopener">txios - 基于 TypeScript 的轻量级 http 库</a></p>
<p>虽然没试过，但是加了没有问题，就这样问题解决了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这个坑之前搞 travis ci 的时候没碰到过，算是给自己一个记录，以后谁踩坑了可以参考我这篇博客哈哈。</p>
]]></content>
      <categories>
        <category>bug</category>
      </categories>
      <tags>
        <tag>bug</tag>
      </tags>
  </entry>
  <entry>
    <title>需要注意的一些命令行</title>
    <url>/2019/01/08/%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E4%B8%80%E4%BA%9B%E5%91%BD%E4%BB%A4%E8%A1%8C/</url>
    <content><![CDATA[<h2 id="一些命令行"><a href="#一些命令行" class="headerlink" title="一些命令行"></a>一些命令行</h2><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">下载文件 curl -L http<span class="variable">s:</span>//www.baidu.<span class="keyword">com</span> &gt; baidu.html</span><br><span class="line">拷贝网页 wget -<span class="keyword">p</span> -H -<span class="keyword">e</span> robots=off http<span class="variable">s:</span>//www.baidu.<span class="keyword">com</span></span><br><span class="line">磁盘占用 df -kh</span><br><span class="line">当前目录大小 du -<span class="keyword">sh</span> .</span><br></pre></td></tr></table></figure>
<p>一个好工具，如果命令行的 help 太长，可以采用 tldr 这个工具</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">sudo npm <span class="keyword">install</span> -g tldr </span><br><span class="line"><span class="comment">#使用</span></span><br><span class="line">tldr 命令</span><br></pre></td></tr></table></figure>
<p>其他常用命令完全 google 搜索 Linux 常用 60 个命令</p>
<h2 id="git-一些有用的命令"><a href="#git-一些有用的命令" class="headerlink" title="git 一些有用的命令"></a>git 一些有用的命令</h2><p>这里就完全照抄了</p>
<ul>
<li>git remote add origin <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>:xxx.git 将本地仓库和远程仓库关联</li>
<li>git remote set-url origin <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>:xxx.git 上一步手抖了，可以用这个命令返回</li>
<li>git branch 新建分支</li>
<li>git merge 合并分支</li>
<li>git stash 通灵术???</li>
<li>git stash pop 反转通灵术 ?????</li>
<li>git revert 撤销一次历史提交，并生成一个新提交</li>
<li>git reset 版本回退</li>
<li>git diff 查看文件修改的地方</li>
</ul>
<h2 id="命令行的一些技巧"><a href="#命令行的一些技巧" class="headerlink" title="命令行的一些技巧"></a>命令行的一些技巧</h2><p>关于修改 .bashrc 中打开终端就进入默认目录，除了文档中说的直接加 cd ~/Desktop,还有一种更标准<br>的写法，如下:</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="attribute">HOME</span>=<span class="string">"/home/xm/GitPrj"</span></span><br><span class="line"><span class="attribute">HOME</span>=<span class="string">"<span class="variable">$(cd "$HOME" ; pwd)</span>"</span></span><br><span class="line">cd</span><br><span class="line"><span class="builtin-name">export</span> <span class="attribute">PATH</span>=<span class="string">"<span class="variable">$HOME</span>/bin:<span class="variable">$PATH</span>"</span></span><br></pre></td></tr></table></figure>
<ul>
<li>命令1 &amp;&amp; 命令2  —&gt; 表示命令1 <strong>执行成功</strong> 后就执行命令2</li>
<li>命令1 || 命令2 —&gt; 表示命令1 <strong>执行失败</strong> 后就执行命令2</li>
<li><p>命令1 ; 命令2 —&gt; 表示命令1 <strong>执行完成</strong> 后就执行命令2</p>
</li>
<li><p>shebang 就是 js 脚本中加的下面这一句</p>
</li>
</ul>
<figure class="highlight d"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env node</span></span><br></pre></td></tr></table></figure>
<p>其他关于 git 的一些高级用法以后更</p>
]]></content>
      <categories>
        <category>命令行</category>
      </categories>
      <tags>
        <tag>命令行</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>CMU-15-445-645-笔记-03-数据库存储-part1</title>
    <url>/2022/06/05/CMU-15-445-645-%E7%AC%94%E8%AE%B0-03-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%98%E5%82%A8-part1/</url>
    <content><![CDATA[<blockquote>
<p>注: 本文首发我的 b 站专栏文章<a href="https://www.bilibili.com/read/cv14558199" target="_blank" rel="noopener">CMU 15-445/645-笔记-03-数据库存储-part1</a></p>
</blockquote>
<a id="more"></a>
<p><img src="./Cover.png" alt></p>
<ul>
<li><p>课程目标</p>
<p>  <img src="./1.png" alt></p>
<ol>
<li>DBMS 是怎么用磁盘上的文件来表示数据库的（主要是这个）</li>
<li>DBMS 是怎么管理内存的，是怎么在磁盘间来回移动数据的</li>
</ol>
</li>
<li><p>课程大纲</p>
<p>  <img src="./2.png" alt></p>
<p>  上述展示的就是一个数据库中应该包含的东西，一个数据库就是建立在这些层面之上</p>
</li>
<li><p>面向磁盘的数据库架构</p>
<p>  <img src="./3.png" alt></p>
<p>  由于这门课是面向磁盘（Disk-Oriented）的数据库管理系统，即数据库的主要存储位置都是放在磁盘上的，意味着每次执行查询时，所要访问的数据都不在内存（Memory）中。所以在设计这个数据库管理软件时，要基于一些假设来设计一系列的组件，来保护这个数据库系统，使其免于数据丢失、保存无效或错误的数据等情况。</p>
<p>  此外还需要区分</p>
<ol>
<li>易失性存储</li>
<li><p>非易失性存储</p>
<p>简单来讲就是，我们所要的 数据系统 管理了数据从非易失性存储到易失性存储的移动</p>
<p>计算机的存储结构如图所示</p>
<p><img src="./4.png" alt></p>
</li>
<li><p>越上面的容量越小，速度越快，也越贵</p>
</li>
<li><p>越下面的容量越大，速度越慢，也越便宜</p>
<p><img src="./5.png" alt></p>
<p>注意这里在 DRAM 和 SSD 有条分界线，这里就是易失性和非易失性存储的分界</p>
<p>需要稳定的能量（电能）维持它所存储的东西的存储设备，叫做易失性存储，那么反之就是非易失性存储</p>
</li>
<li><p>如果数据是保存在易失性存储设备中，那么它就支持 快速随机访问，即无论在什么位置访问数据，访问数据的顺序是怎么样的，访问的速度都大体一致</p>
</li>
<li>如果数据是保存在非易失性存储设备中，由于它们具备的是 块寻址（非字节寻址） 能力，无法准确地得到数据的 位大小的数据（32bit, 64bit），所能得到的是包含要访问的数据的 块（Block） 或者 页（Page）</li>
<li><p>但是在非易失性存储设备中，比起随机读取不同位置上的内容，它能更有效率地去读取一段连续的 块 中的内容。所以对于非易失性存储来讲，是希望按顺序读取的数据量越大越好</p>
<p>Memory 和 Disk 的区分</p>
<p><img src="./6.png" alt></p>
<p>现在已经没人用磁带机来存数据了，但是可用来做容灾</p>
<p>Network Storage 现在指类似于 Amazon 的 EBS 或者 S3 之类的东西</p>
<p>实际上在分割线处还有新的一类存储设备，它被称之为非易失性内存（Non-Volatile Memory）</p>
<p><img src="./7.png" alt></p>
<p>比如 Intel 的 傲腾（Optane）内存，牙膏厂虽然是第一个发布这种内存的厂商，但这类技术的研究已经有 15-20 年左右的历史了</p>
<p>它可以像 DRAM 一样，可以插在 DIMM 槽内，却具备 字节寻址 能力，也可以像 SSD 那样，断电也能持久保存数据。</p>
<p>但残念的是，目前这种既能又能的存储设备并没有被广泛应用</p>
<p>顺便老师在课上写的这本书有卖吗？</p>
<p><img src="./8.png" alt></p>
<p>一张关于各种存储设备的访问耗时表</p>
<p><img src="./9.png" alt></p>
</li>
</ol>
</li>
<li><p>系统设计目标</p>
<p>  <img src="./10.png" alt></p>
<p>  目标就是，给应用程序提供一种错觉，即这个系统能提供足够的内存，能把整个数据库导入到内存中。并且最小化每次从磁盘读取/查询内容所带来的影响</p>
<p>  比如这种最小化的方式可以通过以下几种方式达到</p>
<ol>
<li>允许在同一时间运行不同的线程/查询</li>
<li>缓存</li>
<li><p>提前计算某些数据</p>
<p>一个访问磁盘数据的示意图</p>
<p><img src="./11.png" alt></p>
<p>可以看到有几个关键的地方，Directory、Buffer、Page</p>
<p>那么这个有点像什么呢？– 虚拟内存</p>
<p>那么操作系统能做这件事，为什么还这样设计而不直接使用操作系统来做呢？</p>
<p><img src="./12.png" alt><br><img src="./13.png" alt></p>
<blockquote>
<p>注意 mmap 指的是 maps files or devices into memory</p>
</blockquote>
<p>虽然操作系统可以利用虚拟内存通过 mmap 来映射到文件，但是这只适用于 只读 的访问，对于有多个 writer 的情况就复杂很多了</p>
<p><img src="./14.png" alt></p>
<p>因为操作系统并不知道某些 pages 必须要先于其他 pages ，从内存刷到磁盘，这里有一个竞争的关系</p>
<p>那么有没有解决方案呢？有的</p>
<p><img src="./15.png" alt></p>
</li>
<li><p>使用 madvise 告诉 OS 怎么去访问某些页面（顺序/随机读取）</p>
</li>
<li>使用 mlock 阻止 pages 被 OS 回收（尽管可以被锁定但并不能阻止它被写出到磁盘）</li>
<li><p>使用 msync 告诉 OS 要把数据刷到磁盘中</p>
<p>使用 mmap 和 部分使用 mmap 的 Database</p>
<p><img src="./16.png" alt></p>
</li>
<li><p>实际上 MemSQL 已经完全摆脱了 mmap</p>
</li>
<li>SQLite 有一个特殊的引擎，在嵌入式设备上 mmap 是可选的，默认情况下用不到</li>
<li>InfluxDB 只有在只读缓存上才使用 mmap</li>
<li><p>mongoDB 第一次被开发出来时，它的默认存储引擎用的就是 mmap，但为了让这个引擎能正常工作，开发人员也做了很多无用功，因为这里面存在着巨大的瓶颈，然后等他们筹到很多钱之后，就把 mmap 干掉了，再然后他们买了一个叫做 WiredTiger 的非 mmap 的存储引擎</p>
<p>注意这张图里面少了很多主流的 Database，比如 MySQL，Oracle，DB2 以及 SQL server，这些数据库都没有使用 mmap，因为 mmap 是一个糟糕的想法，因为缺少人为写代码去控制这种行为。</p>
<p>所以如果 mmap 是一个好的想法，那么这群土豪（指 mongoDB）手下的顶级工程师肯定能证明这的确是，然后并没有（哈哈哈哈好好笑）</p>
<p>老师痛恨 mmap</p>
<p><img src="./17.png" alt></p>
<p>毕竟操作系统啥也不懂，它只看到了一些读写和调用（</p>
</li>
</ol>
</li>
<li><p>文件存储</p>
<p>  <img src="./18.png" alt></p>
<p>  数据库其实就是磁盘上的一堆文件，SQLite 把数据库存储为一个文件，而其他大部分数据库比如 PostgreSQL 则会把这些分为多个文件来存储，因为数据库可能非常大，甚至可能有 PB 级别的数据量，你不会想要对这么大的一个文件做错误修复</p>
<p>  现在的一些”企业级”的数据库系统还支持自定义的专属文件系统，但近些年的一些数据库系统已经不支持了，因为非常不值得，要管理这种文件系统是一个很大的坑，同时也大大降低了可移植性。</p>
</li>
<li><p>存储管理器</p>
<p>  <img src="./19.png" alt></p>
<p>  存储管理器也叫存储引擎，它负责维护磁盘上的数据库文件。</p>
<p>  某些高端数据库系统在文件系统之上还有一个 shim 层，它允许数据库去做一些磁盘的调度，这就像是可以通过一堆线程来对彼此邻近的区块进行写入，也可以将这些区块合并后做一次写入请求。</p>
</li>
<li><p>Database Pages</p>
<p>  <img src="./20.png" alt></p>
<p>  一个 page 的集合，就是这一堆文件的一个组织形式。本质上来讲，一个 page 就是一个固定大小的数据块</p>
<p>  self-contained 的意思是，page 的内容必须存储在 page 本身内。比如 Orcale 就需要将描述该 page 中内容的所有元数据，和这些内容数据一起保存在该 page 中，避免数据库故障的时候你找不到，这样即便丢了一个 page，也不会影响其他的 page</p>
<p>  indirection 层允许将一个 page ID 映射到某个集合中一个文件的某个位置。相当于记录一个相对位置，方便文件整体移动后，只要知道整体文件的初始位置，依然可以通过该相对位置即 page ID 找到某个文件某个位置的数据所对应的 page。因为一个 page 的大小是固定的，page ID * page Size 即为 offset</p>
<p>  一些 page 的概念</p>
<p>  <img src="./21.png" alt></p>
<p>  Database Page 大小各有不同</p>
<p>  <img src="./22.png" alt></p>
<p>  但我们更需要关注的是 Hardware Page 的大小，因为它是原子的，即一次只能写入这么大的 page 数据，如果超过了，那么剩下的数据就会丢失写不进去，写入失败也不会回滚，数据就会损坏</p>
<p>  高级数据库可以设定它们自己 page 的大小</p>
<p>  那么为什么有些数据库系统使用的是空间更大的 page 呢？</p>
<p>  这里是有一些权衡的，比如在数据库系统的内部，通过内存中的 Page 目录将 page 映射到内存或者磁盘上的某个位置，如果现在用一个 page ID 来表示一个更大量的数据，那么一个表所占用的大小就会变小。因为固定容量下，一个 ID 表示的数据量越大，那么它所需要的 ID 数也越小。比如 CPU 中 TLB（页表缓存），如果尝试去匹配所有的 page，那么 page 表将会变得非常的大，然后就会出现 cache misses 的现象。因为 page ID 表示的数据范围太小，在高速缓存中无法全部命中。所以这里可以通过更少的 page ID 来表示更多的数据</p>
</li>
<li><p>Page 存储架构</p>
<p>  <img src="./23.png" alt></p>
<p>  比较重要的就是 Heap File Organization</p>
<ul>
<li><p>Database Heap</p>
<p>  <img src="./24.png" alt></p>
<p>  数据库中的 heap 文件是一个无序的 page 集合，即可以以随机的顺序把 tuple 数据存储在里面</p>
<p>  链表来实现一个 page 是很 low 的，更好的方案是使用 Page 目录</p>
</li>
<li><p>Heap File: 链表</p>
<p>  <img src="./25.png" alt></p>
<p>  这里的例子中，如果要支持反向查找，那还得是一个双向链表</p>
<p>  如果需要在 page 中 insert 一些东西，那么还是需要对这个链表做遍历，直到找到 free page 为止，在这个位置 insert。为什么需要遍历，因为有些 page 的剩余空间可大可小，所以需要遍历到那个足以容纳下要 insert 的数据的一个剩余空间里面去</p>
<p>  写数据时需要注意的问题，即数据写一半，写满一个出了问题，后一半还没来得及写，数据就会损坏，所以要保证写数据的原子性和完整性，需要做很多工作</p>
<p>  写入数据崩溃，如何查找原因？使用 checksum，类似于 CRC 或者 md5</p>
</li>
<li><p>Heap File: Page 目录</p>
<p>  <img src="./26.png" alt><br>  <img src="./27.png" alt></p>
<p>  Page 目录是一个通常的做法，好处是假如想要插入一些数据时，没必要像链表那样对整个链表做一次遍历，只需要在 Page 目录中做查找就可以。例子中的每个小格中不仅有对应 page 所在位置，也包含了 page 剩余空间的信息</p>
</li>
<li><p>Page 头</p>
<p>  <img src="./28.png" alt></p>
</li>
<li><p>Page 层</p>
<p>  <img src="./29.png" alt></p>
<ol>
<li><p>面向 tuple 的组织方式</p>
<p> <img src="./30.png" alt></p>
<p> 这种组织方式是一个 bad idea，为什么呢？</p>
<ul>
<li>如果 tuple 都是固定长度的，那么要增删 tuple 的话，通过将其移到一个新的空间来取代这个老的空间就可以了不是么（联想到了 V8 的新生代老生代的 GC 算法了）</li>
<li>如果 tuple 不是固定长度的，那么你插入 tuple<br>的那个位置可能就没有足够的空间</li>
<li><p>每次要增删 tuple 时，都需要维护顶部的元数据，也就是 Num Tuples，告诉你哪个位置能插数据，或者遍历整个 page 看看哪里能插</p>
<p>但更好的方式是使用 slotted pages</p>
<p><img src="./31.png" alt><br><img src="./32.png" alt></p>
<p>在顶部有一个称之为 slot 数组 的东西，在底部则用来保存想要保存的数据</p>
<p>本质上来讲，slot 数组是将一个特定的 slot 映射到 page 上的某个 offset 上，根据这个 offset，就能找到想找的哪个 tuple</p>
<p>注意 slot 存的是 offset</p>
<p><img src="./33.png" alt></p>
<p>而填充 page 的方式是</p>
</li>
<li>从前往后对 slot 数组进行填充</li>
<li><p>从后往前对数据进行填充</p>
<p>什么是 page 已满，指的是数据占用了该 page 的一半以上的大小，再也无法存入任何信息了</p>
<p>当然也可以用一种 Postgres 中的 vaccum 的操作来整理数据库，或者使用压缩，也可以对数据库进行扫描并整理碎片</p>
<p>对于这种例子来讲，肯定是不能把视频存在数据库里面的，因为单个 page 根本放不下它。</p>
<p>一般来讲，要存 tuple 不应该分散地存在多个 page 上，因为维护元数据很麻烦。最好是当我们想要去访问这个 tuple 的时候，它就在这个 page 上。</p>
<p>为什么需要这么组织结构呢？</p>
<p>因为不管是将数据库文件中的 page 移动到磁盘还是网络上，系统的其他部分都不会关心这个 page 实际移动到了哪里，因为有 page ID 的存在，就可以通过 Page 目录来找到它实际所保存的位置，而这些 indirection 层避免了这些位置的更新会传播到系统的其他上层部分。比如某些 GC 算法，只需要保证对象间的引用关系就好，对象存在内存的哪个位置会随着 GC 的进行而变化，page ID 有有点像是在维护这个引用关系</p>
</li>
</ul>
</li>
<li><p>日志结构的组织方式<br> // Todo:<br> 主要这里 3-1 没有讲到</p>
</li>
</ol>
</li>
</ul>
</li>
<li><p>Tuple 层</p>
<blockquote>
<p>注: 课程时间不够，这里是简略版本</p>
</blockquote>
<p>  <img src="./34.png" alt></p>
<p>  一个 tuple 基本上就是一串字节，数据库的工作就是再次解释这些字节的实际含义</p>
<ul>
<li><p>Tuple 头</p>
<p>  <img src="./35.png" alt></p>
<p>  通常没必要将该 tuple 的元数据保存在这个 tuple 里面，因为更高级的元数据信息保存在这个 tuple 对应的 page 中，但可以可以放在 catalog page 里</p>
</li>
<li><p>Tuple Data</p>
<p>  <img src="./36.png" alt></p>
<p>  通常大部分数据库系统会按照它们创建时的顺寻进行存储，我们知道在关系模型中没必要这么做，但是大部分系统都做了</p>
</li>
<li><p>Denormalized Tuple Data</p>
<p>  <img src="./37.png" alt></p>
<p>  如果来自不同表的数据保存在同一个 page 中，会发生什么问题？<br>  注意这里大部分数据库系统都不会这么做，因为如果想让 page 变得独立，那么也就不应该去保存一大堆关于不同表的额外的元数据。当对表进行反范式化设计或者对表进行 prejoin 时，就会出现上述图中的情况，也就是数据冗余，一个 page 中存在多个表数据，更新、删除、或者压缩都要对多个表进行处理</p>
<p>  而数据库规范基本上就是讲如何讲数据库拆分到不同的表中（使用外键时就自然拆分了）</p>
<p>  下面是一个反范式化的处理例子，将 bar 的 tuple 直接内嵌在 foo 的 tuple 中</p>
<p>  因为每个 bar 表中的 tuple 复制了 a 属性，如果将它打包进 foo 表的 tuple 中，就没必要重复记录这些数据了，foo 表所拥有的这些列对其他表来说是独一无二的，就像是 prejoin 一样，将 tuple 彼此包装在一起。这样，应用程序依然觉得，这个 db 里面有两张单独的表，但在 db 内部，page 实际上会将它们合并在一起</p>
<p>  <img src="./38.png" alt><br>  <img src="./39.png" alt><br>  <img src="./40.png" alt></p>
<p>  但这并不是什么新鲜东西，早在 1970 年代，IBM 在发明它们第一个关系型数据库 System R 的时候，就引入了这个概念</p>
<p>  然而当 IBM 做出了 DB2 之后，这个方式就被废弃掉了，因为维护它很操蛋</p>
<p>  System R 是 IBM 发布的第一个关系型数据库，但 IBM 并没有将它商业化，也没有卖掉，10 多年之后，IBM 抽取了 System R 中的部分代码，做出了 DB2</p>
<p>  实际上在更现代的数据库系统中也出现了这种反范式化的设计</p>
<p>  <img src="./41.png" alt></p>
<ol>
<li>G 家的 Cloud Spanner，如果你定义了一个 Protobuf API，那么你就可以将两张不同表的数据合并在同一个 tuple 中</li>
<li>10 年前有一个叫 Akiban 的初创公司，他们把他们的存储引擎卖给了 MySQL，MySQL 就可以做到这种反范式化的操作。然后他们被 Foundation DB 收购，之后 Foundation DB 又被苹果收购</li>
<li>一些文档型数据库或者 JSON 数据库也能做到。比如你在定义你的 JSON document 时，就可以预先对相关属性进行 join 操作</li>
</ol>
</li>
</ul>
</li>
<li><p>记录 ID</p>
<p>  <img src="./42.png" alt></p>
<p>  保存元数据的大小</p>
<ul>
<li>PostgreSQL CTID（4 bytes）</li>
<li>SQLite ROWID（8 bytes）</li>
<li>Oracle ROWID（10 bytes）</li>
</ul>
</li>
<li><p>结论</p>
<p>  <img src="./43.png" alt></p>
</li>
</ul>
]]></content>
      <categories>
        <category>Database</category>
      </categories>
      <tags>
        <tag>Database</tag>
      </tags>
  </entry>
  <entry>
    <title>CMU-15-445-645-笔记-02-高级SQL</title>
    <url>/2022/06/05/CMU-15-445-645-%E7%AC%94%E8%AE%B0-02-%E9%AB%98%E7%BA%A7SQL/</url>
    <content><![CDATA[<blockquote>
<p>注: 本文首发我的 b 站专栏文章<a href="https://www.bilibili.com/read/cv14530555" target="_blank" rel="noopener">CMU 15-445/645-笔记-02-高级SQL</a></p>
</blockquote>
<a id="more"></a>
<p><img src="./Cover.png" alt></p>
<ul>
<li><p>课程目标</p>
<p>  <img src="./1.png" alt></p>
</li>
<li><p>Relational Languages<br>  <img src="./2.png" alt></p>
</li>
<li><p>SQL 的历史<br>  <img src="./3.png" alt></p>
<ul>
<li>除了 IBM 推出的 SQL 之外，还有另一个主流是由伯克利推出的 Ingres</li>
<li>而 PostgreSQL 是由开发 Ingres 那帮人开发的，所以才被称之为 “Post” “gre” “SQL”，与 “In” “gres” 对应，因为是在 Ingres 之后才出现的</li>
<li>开发 Ingres 那帮人有自己的语言，叫 Quel</li>
<li>英国有个人为他的编程语言也取名叫 SQL，IBM 因此与这个人产生版权以及商标纠纷</li>
<li>当 IBM 推出了 DB2 和 SQL 时，Oracle 也在同时支持 SQL</li>
<li>SQL 一直在发展，推出很多新特性<br>  <img src="./4.png" alt></li>
<li>现在只有非常少的数据库系统通过 SQL:2016 标准</li>
</ul>
</li>
<li><p>SQL 并不是一门单一的语言，它是一些东西的集合</p>
<p>  <img src="./5.png" alt></p>
<ul>
<li>DML: 类似 insert/update/delete/select 命令</li>
<li>DDL: 跟 schema 有关，通过定义 schema 创建表来存数据</li>
<li>DCL: 跟安全性授权相关</li>
<li>lists，也就是列表，可以有重复元素，是有序的</li>
<li>sets, 也就是集合，没有重复元素，是无序的</li>
<li>bags, 允许元素重复，无序</li>
</ul>
</li>
<li><p>Example Database</p>
<p>  <img src="./6.png" alt></p>
</li>
<li><p>Aggregates 聚合函数</p>
<p>  <img src="./7.png" alt></p>
<p>  <img src="./8.png" alt></p>
<p>  用 “<em>“ 代替 login<br>  “</em>“ 是 SQL 中的特殊关键字，代表该 tuple 中所有属性</p>
<p>  <img src="./9.png" alt></p>
<p>  更进一步，用 “1” 代替 “*”，每数一个 tuple，tuple 的数量就 +1</p>
<p>  <img src="./10.png" alt></p>
<p>  一般来讲建议使用 “COUNT(1)”</p>
<ul>
<li><p>可以在单个查询中放入多个聚合函数</p>
<p>  <img src="./11.png" alt></p>
</li>
<li><p>DISTINCT<br>  得到去重数据时使用</p>
<p>  <img src="./12.png" alt></p>
</li>
<li><p>一个错误的例子，在聚合函数之外输出其他 columns 会 undefined</p>
<p>  <img src="./13.png" alt></p>
</li>
<li><p>如何解决上面的错误例子？使用 GROUP BY</p>
<p>  <img src="./14.png" alt></p>
<p>  基于某个属性把想要的 tuple 放到一起<br>  物以类聚的结果</p>
<p>  <img src="./15.png" alt></p>
<p>  新增一个 s.name</p>
<p>  <img src="./16.png" alt></p>
</li>
<li><p>数据过滤，使用 HAVING</p>
<p>  <img src="./17.png" alt></p>
</li>
<li><p>所谓查询优化，可以用 GROUP BY 来做，统计小于某个值的一些集合的数量，或者通过 HAVING 做一些过滤操作，那么要查找的数据集就小了，自然也就快了</p>
</li>
</ul>
</li>
<li><p>字符串操作<br>  不同数据库对字符串的处理</p>
<p>  <img src="./18.png" alt></p>
<ul>
<li><p>SQL 标准规范有说，所有的字符串，例如 varchar、char、和 text field，它们必须区分大小写，并且使用 单引号 来进行声明</p>
</li>
<li><p>‘%’ 和 ‘_’</p>
<p>  <img src="./19.png" alt></p>
<ul>
<li>‘%’: 匹配一个或者多个字符</li>
<li>‘_’: 匹配一个字符</li>
</ul>
</li>
<li><p>对于字符串函数、数学函数和日期函数来讲，它们可以出现在查询中的任意位置</p>
<p>  <img src="./20.png" alt></p>
<p>  你可以把它放在 SELECT/HAVING/或者其他条件语句中等</p>
</li>
<li><p>‘||’<br>  SQL 标准下可以使用 ‘||’ 把字符串连起来</p>
<p>  <img src="./21.png" alt></p>
</li>
<li><p>Postgres 和 Oracle 大概是所有数据库系统中遵循 SQL 标准做的最好的</p>
<ul>
<li>Postgres ~= Oracle &gt; SQL server &gt; DB2</li>
<li>SQLite 还行</li>
<li>MySQL 最差</li>
</ul>
</li>
</ul>
</li>
<li><p>DATE/TIME 操作</p>
<p>  <img src="./22.png" alt></p>
<p>  注意这里记录用的是 时间戳，但是当你对时间进行操作，提取其中的信息时，结果会变得不可靠</p>
<p>  比如对日期进行加减处理，三个数据库 SQL 的不同写法</p>
<ol>
<li>PostgreSQL</li>
<li>MySQL</li>
<li><p>SQLite</p>
<p><img src="./23.png" alt></p>
<p>SQLite 居然是最流行的。。。最初由 Richard Hipp 和其他两人开发，手机安卓应用很多前端数据库就用的是 SQLite，很多桌面应用比如 Photoshop 和 ILLustrator，内部也运行 SQLite</p>
<p>顺便互联网在美国兴起的时间居然是 2000 年代早期。。。</p>
<p>MySQL 是 Oracle 的，所以 Oracle 有 MySQL 的版权，但 SQLite 没有</p>
</li>
</ol>
</li>
<li><p>输出重定向</p>
<p>  <img src="./24.png" alt></p>
<p>  即你输出的结果可以保存到另一张表中</p>
<ul>
<li>可以用 INTO</li>
<li>或者用 CREATE TABLE</li>
<li><p>或者用 INSERT INTO</p>
<p>  <img src="./25.png" alt></p>
</li>
</ul>
</li>
<li><p>输出控制</p>
<p>  <img src="./26.png" alt></p>
<p>  如果想要输出结果变得有序，使用 ORDER BY，因为 SQL 是基于 bag<br>  代数，它是无序的，所以需要使用这个</p>
<p>  想要在输出列表中加属性，可以接 DESC/ASC</p>
<p>  <img src="./27.png" alt></p>
<p>  限制输出可以用 LIMIT</p>
<p>  <img src="./28.png" alt></p>
<p>  可以在 LIMIT 后面加 OFFSET</p>
<p>  <img src="./29.png" alt></p>
<p>  OFFSET 的意思是，在限制返回 tuple 的数量之前，需要先跳过多少个 tuple，当跳过这么多你设置的 tuple 之后，再开始返回数据</p>
</li>
<li><p>嵌套查询（难的优化的东西来了！）<br>  即在查询的内部再嵌套一个查询</p>
<p>  <img src="./30.png" alt></p>
<p>  一个嵌套查询例子，SELECT 嵌 SELECT（实际上这也可以用 JOIN 来实现）</p>
<p>  <img src="./31.png" alt></p>
<p>  为什么这种方式很慢，实际上这里可以理解为有俩 for 循环查询，因为要对这个表里面每个 tuple 遍历一遍，然后对于每个 tuple 也要遍历一遍，用 JOIN 可以优化</p>
<p>  用 IN 来优化</p>
<p>  <img src="./32.png" alt></p>
<p>  其他查询优化操作符</p>
<p>  <img src="./33.png" alt></p>
<p>  使用 ANY 来优化</p>
<p>  <img src="./34.png" alt></p>
<p>  SELECT 嵌套也可以不用写在 WHERE 中</p>
<p>  <img src="./35.png" alt></p>
<p>  一个查询没有学生注册的所有课程的例子，注意这个例子中使用了 NOT EXIST，逻辑相当于取了个反</p>
<p>  <img src="./36.png" alt></p>
<p>  内部查询可以引用外部查询的东西，但是反过来不行</p>
</li>
<li><p>window 函数<br>  window 函数会对一个 tuple 子集进行函数计算，并将它们聚合成一个结果。输出每一行数据，并在其后面追加一个聚合字段所表示的数据</p>
<p>  <img src="./37.png" alt></p>
<p>  这里的 OVER 有点像 GROUP BY 的意思</p>
<p>  一个例子<br>  <img src="./38.png" alt></p>
<p>  输出结果如下</p>
<p>  <img src="./39.png" alt></p>
<p>  可以看到后面增加了一个 row_num 的字段</p>
<ul>
<li>OVER 关键字的作用是当计算 window 函数时，指定一种组合 tuple 的方式</li>
<li><p>使用 PARTITION BY 指定 group</p>
<p>  <img src="./40.png" alt></p>
<p>  输出如下</p>
<p>  <img src="./41.png" alt></p>
<p>  根据 cid 对它们进行分组，每一组内按 row_num 的顺序排列</p>
</li>
<li><p>在 window grouping 中也可以使用 ORDER BY</p>
<p>  <img src="./42.png" alt></p>
</li>
<li><p>一个例子，查询每门课中最高分的学生</p>
<p>  <img src="./43.png" alt></p>
<p>  在这个内部查询（红色部分表示的）中，遍历整个 enrolled 表，对于每个 tuple，基于 cid 来对它们进行分组</p>
<p>  RANK() 这个聚合函数会对每一个组进行 rank 排序</p>
<p>  注意此处的 ‘ranking.rank’ 实际上并不存在于数据库中，它只存在于这个查询之中（感觉像是一个临时变量</p>
<p>  最终的结果如下，PostgreSQL 支持这个语句</p>
<p>  <img src="./44.png" alt></p>
<p>  RANK() 函数会根据排序后每个 tuple 在输出列表中出现的现后顺序来进行计算</p>
<p>  如果是 SQL 为 <code>SELECT *, RANK() OVER() AS rank FROM enrolled;</code>，那么就是如下的结果</p>
<p>  <img src="./45.png" alt></p>
<p>  rank 处的值都是 1，因为这里面并没有排序，所以所有记录中的 rank 都是 1</p>
<p>  这里的例子中，如果没有 ORDER BY，就没有 rank</p>
</li>
</ul>
</li>
<li><p>CTE（Common Table Expressions）公用表表达式<br>  这个感觉有点像是可以把一些公用的东西抽出来，然后给其他 SQL 引用的感觉</p>
<p>  <img src="./46.png" alt></p>
<p>  它和嵌套查询非常类似，可以将一个查询的输出结果作为另一个查询的输入，但某些 功能 CTE 能做，嵌套查询做不到</p>
<ul>
<li><p>一个更复杂的例子</p>
<p>  <img src="./47.png" alt></p>
<p>  将输出的 col1 和 col2 与 cteName 中的查询语句中的 name 进行绑定，然后在下面的 SELECT 语句中就可以直接引用 col1 和 col2</p>
</li>
<li><p>例子，在 enrolled 表中找到最大的学生 id</p>
<p>  <img src="./48.png" alt></p>
<p>那么问题来了，这个跟嵌套查询有啥区别呢？<br>在 CTE 中可以递归，但是嵌套查询不能（所以感觉像是声明了一个函数类似<br>  东西？）<br>比如打印 1 到 10，注意: 不带 ALL 的 UNION 操作会将重复结果移除</p>
<p><img src="./49.png" alt></p>
<p>主要逻辑就是调用之前的 CTE 中的 tuple 作为输出结果。<br>在这个例子中，会生成只有一个属性的表（counter），调用一个 SELECT 来获取这个 tuple，然后对它进行 +1，这样就生成了一个新的 tuple。接着继续上述操作，直到 WHERE 条件无法匹配为止</p>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>总结</p>
<p>  <img src="./50.png" alt></p>
<p>  在理想情况下，可以无需将数据存放到本地，或者来回移动，就能对整个查询进行计算</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Database</category>
      </categories>
      <tags>
        <tag>Database</tag>
      </tags>
  </entry>
  <entry>
    <title>CMU-15-445-645-笔记-04-数据库存储-part2</title>
    <url>/2022/06/05/CMU-15-445-645-%E7%AC%94%E8%AE%B0-04-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%98%E5%82%A8-part2/</url>
    <content><![CDATA[<blockquote>
<p>注: 本文首发我的 b 站专栏文章<a href="https://www.bilibili.com/read/cv14558880" target="_blank" rel="noopener">CMU 15-445/645-笔记-04-数据库存储-part2</a></p>
</blockquote>
<a id="more"></a>
<p><img src="./Cover.png" alt></p>
<blockquote>
<p>注意：这节课是 3-1 的延续</p>
</blockquote>
<ul>
<li><p>课程目标</p>
<p>  <img src="./1.png" alt></p>
</li>
<li><p>日志结构（Log-Structured）的文件组织</p>
<p>  <img src="./2.png" alt></p>
<p>  主要是存储如何创建 tuple 以及修改 tuple 的相关信息，比如增删改查的操作</p>
<p>  <img src="./3.png" alt></p>
<p>  这些记录会以文本文件的形式保存，读起来就像是日志记录一样</p>
<p>  为什么要这么做？</p>
<p>  循序写入/读取/访问的速度要远比随机访问快得多。如果使用 Slotted Pages 的方式，假设要更新 10 个在不同 page 上的 tuple，那就必须在这 10 个 page 上来写入并更新这些 tuple。但如果使用的是 Log-Structured 文件组织这种形式，把这要更新的 10 个 tuple 的语句写在单个 page 上，就一次性能搞定全部了。</p>
<p>  Log-Structured 文件组织这种想法也并不新颖，它是在 1980 年代末，1990 年代初出现的。虽然出现的晚，但最近十年这种技术开始起飞。比如在 HDFS 或者 S3 中，这些分布式文件系统就只支持这种追加的方式，即没办法进行随机更新，能做的就是追加记录</p>
<p>  但这种方式有明显缺陷，是什么呢？</p>
<p>  是 读取</p>
<p>  如果现在要去读取某个 tuple，那么就需要回头去在日志中查找这个 tuple</p>
<p>  <img src="./4.png" alt></p>
<p>  有几种方式可以加快访问的速度</p>
<ol>
<li><p>建立索引，可以通过索引跳到日志中特定的 offset 处，就能找到对应的数据</p>
<p> <img src="./5.png" alt></p>
</li>
<li><p>定期压缩 log</p>
<p> 重新遍历一遍 log，对里面的内容进行筛选压缩，而对于每个 tuple，只需要一条记录即可</p>
<p> 把这种</p>
<p> <img src="./6.png" alt></p>
<p> 变成这种</p>
<p> <img src="./7.png" alt></p>
<p> 有以下几个数据库用这种方式</p>
<p> <img src="./8.png" alt></p>
<ul>
<li>HBase</li>
<li>Cassandra</li>
<li>LevelDB</li>
<li><p>RocksDB</p>
<p>有许多分布式数据库系统使用了这种技术，并且是用 Go 写的。比如 CockroachDB 使用了 RocksDB 存储管理器作为底层，它的分布式执行层都是用 Go 来写，但在它内部使用的 RocksDB 用的是 C++。而 RocksDB 是 Meta 的，但它是基于 LevelDB 改进后的产物，而 LevelDB 是 G 家的。Meta 把 LevelDB 拿过来，首先做的事情就是干掉 mmap，然后才有的 RocksDB。</p>
<p>LevelDB 至今还活着，但很多人用的还是 RocksDB</p>
</li>
</ul>
</li>
</ol>
</li>
<li><p>Tuple 存储</p>
<p>  <img src="./9.png" alt></p>
<p>  例如 Integer 和 Float 这些固定长度的东西，在大部分数据库系统中其表达方式和 C/C++ 使用的方式是一样的</p>
<p>  <img src="./10.png" alt></p>
<p>  因为这通常是由 IEEE-754（二进制浮点数算数标准） 标准所定义的</p>
<p>  IEEE-754 是一种行业标准，用来表示数字和 CPU 的规范，比如 Integer 和 Float 应该是多少个字节，是大端对齐还是小端对齐之类的</p>
<p>  对于那些可变长度的类型，例如 VARCHAR/VARBINARY/TEXT/BLOB 来说，通常情况下它们里面会有一个 header，这个 header 会有 保存的 blob 的长度，如果是一个很大的值，那后面还会跟一个 checksum。紧接着跟着的就是字节序列了。</p>
<p>  对于时间类型来讲，大多数数据库系统通常会去保存从 1970 年 1 月 1 日起的秒数/毫秒数/微秒数来处理时间。本质上这些数据库系统保存的依然是完整的时间戳。</p>
<p>  对于定点数字（Fixed Point Value）来说，非常依赖于 C++ 或者底层硬件所提供给我们的数字</p>
<p>  <img src="./11.png" alt></p>
<p>  Float, Real/Double 或者可变精度的数字，这些都是 CPU 或者 C++ 给的不精确的数字</p>
<p>  而对可变精度数字执行操作的速度要比任意精度数字快得多，因为 CPU 拥有能高效执行这些操作的指令。比如，CPU 通过 1 条指令就能对俩浮点数进行加减运算，但处理定点数字时就需要一大堆指令来处理了</p>
<p>  虽然处理可变精度数字相对快，但这里也存在舍入误差，因为在 IEEE-754 标准中，并没有任何办法能够将十进制数 准确 地存入硬件，也只能使用一个大概的数字</p>
<p>  一个浮点数精度的例子，假如我想要的时小数点后 20 位的数，那么用 GCC 编译出来是啥结果呢？</p>
<p>  <img src="./12.png" alt></p>
<p>  因为硬件只能近似逼近或者说模拟 0.3 这个浮点数，没有办法真正精确地去表示这个数</p>
<p>  所以为了解决这个舍入误差的问题，就需要固定精度的数字了</p>
<p>  <img src="./13.png" alt></p>
<p>  可以把值作为 VARCHAR 类型（不是 string）来储存，然后通过一些元数据来表示，这里是小数点，那里是精度范围，接着另一边是舍入信息，这些东西都放在 tuple 里面，同时也是该 tuple 字节数组的一部分</p>
<p>  Postgres 一段源码</p>
<p>  <img src="./14.png" alt></p>
<p>  当声明一个 Fixed point DECIMAL 时，Postgres 就像上图中那个方式来存这个 struct，这里面包含了关于 DECIMAL 的一些额外的元数据</p>
<p>  <img src="./15.png" alt></p>
<p>  用红色标注出来的部分，其实是一个用来表示 REAL 类型值的字符串</p>
<p>  那么为什么操作 DECIMAL 会慢呢？下面是一段做加法的源码</p>
<p>  <img src="./16.png" alt></p>
<p>  可以看到，这并不是用一条指令就能完成的，它需要一系列的 switch 条件才能完成，比如说要判断它的正负、是不是 0，或者两个数字是否相等。但是如果是 REAL 或者是一个浮点数做加法时，CPU 只需要一条指令就能完成。</p>
<p>  所以如果不想因为精度问题丢失数据，那就用 Fixed Point DECIMAL</p>
</li>
<li><p>大数值</p>
<p>  <img src="./17.png" alt></p>
<p>  如果想要保存的东西因为体积太大而无法放在一个单一 page 上，该怎么办？<br>  有两种方式</p>
<ol>
<li><p>用 overflow page 来解决<br> 在这个例子中，如果这个 tuple 中的 c 对应的 data 太大了，那么就通过一个指针来指向保存 c 对应的 data 的那个 overflow page</p>
<p> <img src="./18.png" alt></p>
<p> 如果 overflow page 也放不下这个数据，那么同样可以通过 overflow 指针来指向某些其他 page 来解决这个问题</p>
<p> 正常情况下，overflow page 是无法通过常规手段进行操作的，所以要尽量避免</p>
<p> 在 Postgres 中，大部分时候，这些 overflow page 是 只读，或者几乎都用来读，很少往上面去写东西。所以大部分对 overflow page 的优化，都受到和常规 data page 或者 tuple page 一样的保护</p>
</li>
<li><p>用 外部存储 来解决</p>
<p> <img src="./19.png" alt><br> <img src="./20.png" alt></p>
<p> 基本思路是，不会把该属性的数据保存在 tuple 内部，而是往这个里面保存一个指针或者是一个文件路径，它们指向存放该数据的本地磁盘/网络存储/外部存储设备的位置</p>
<p> 有些系统对此进行了支持，例如 Oracle，DB2，以及巨硬</p>
<p> 对于 DBMS 来讲，它无法对外部存储文件中的内容做修改</p>
<ol>
<li>没有持久化保护</li>
<li><p>没有事务保护</p>
<p>有一篇 10 前年的论文，由很多在微软工作的数据库专家撰写的，叫 《TO BLOB or Not TO BLOB: Large Object Storage in a Database or a Filesystem?》</p>
<p>BLOB 的意思是二进制大对象，是可变长度的二进制数据</p>
<p>在 2000 年代，任何小于 256KB 的东西，我们都倾向于将它保存在一个 overflow page 上，任何大于 256KB 的，我们都倾向于将他保存在外部存储文件中</p>
<p>之前有个做 SQLite 相关工作的来 CMU 搞了一场讲座，他表示对许多手机应用来讲，最好将图像的缩略图存储在数据库系统中，尽管某些图片的大小甚至有 1MB，因为从数据库中读取这些记录会更快，因为它们已经将文件打开，就不用去根据指针在文件系统中查找文件，然后使用 f.open 来打开文件获取数据了</p>
<p>但是，如果将一大堆视频文件保存在高端的企业磁盘上，那就真的是浪费钱了。所以解决办法是把这些文件弄成块 （chuck），保存在 HDFS 或者使用更便宜的网络存储服务– AWS 的 S3 上面，那么数据库系统就不会因为为了维护这堆文件而负担过重了。</p>
</li>
</ol>
</li>
</ol>
</li>
<li><p>系统 Catalogs</p>
<p>  <img src="./21.png" alt></p>
<p>  系统 catalogs 是关于数据库相关信息的元数据，它里面存放了表名，索引等等</p>
<p>  很多数据库系统都会将它们的 catalog 用另一张表来保存</p>
<p>  <img src="./22.png" alt></p>
<p>  大部分数据库系统会通过 STANDARD INFORMATION_SCHEMA 这个 API 把 catalog 暴露出来，因为 1980 年代每个这种 API 每个数据库给的都不一样，所以后面出了 ANSI 标准使得每个数据库系统都必须支持这个 API</p>
<ul>
<li><p>访问表 Schema<br>  访问当前数据库的所有表</p>
<p>  <img src="./23.png" alt></p>
<p>  访问当前数据库某张表的 schema</p>
<p>  <img src="./24.png" alt></p>
<p>  schema，当在数据库中做查询以及构建索引时，就会用到它</p>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>Wikipedia 简化版本表例子</p>
<p>  <img src="./25.png" alt></p>
</li>
<li><p>workload<br>  在数据库系统中，我们所关心的 workload 主要有两类</p>
<ol>
<li><p>OLTP</p>
<p> <img src="./26.png" alt></p>
<p> On-line Transaction Processing，即联机事务处理</p>
<p> 思路是，从外部世界拿到新数据之后，将它们放入到数据库系统中，而在查询/更新时，数据库只会去读取/更新一小部分数据，然后不断地重复类似的操作</p>
<p> 比如 Amazon 的 storefront，当你在网站上买东西的时候，就可以当作是对应用程序的 OLTP。购物网站会大量地进行添加商品、结账、更新账户信息等操作，但是对于顾客个人来说，只需要查询/更新他自己的那一部分数据。</p>
</li>
<li><p>OLAP</p>
<p> <img src="./27.png" alt></p>
<p> On-line Analytical Processing，即联机分析处理</p>
<p> 当数据库已经从 OLTP 应用程序中收集到一大堆数据时，现在要分析这堆数据，并从中推断出新的信息（数据科学？？）。同时 aka 商务智能（business intelligence）/决策支持（dicision support）/大数据（big data）</p>
<p> 在 OLAP 的情况下，数据库不会去更新数据，但是会读取大量的数据，要做大量的 join 操作</p>
<p>一张 workload characterization 图</p>
<p><img src="./28.png" alt></p>
<p>从图中可以看出</p>
</li>
</ol>
<ul>
<li>OLTP 擅长简单的查询，但是会做大量的写操作</li>
<li>OLAP 会做大量的读操作，但它们会更复杂</li>
<li><p>HTAP（Hybrid Transaction Analytical Processing）混合事务分析处理，综合 OLTP 和 OLAP 的产物</p>
<p>对于传统的 NoSQL 系统，mongoDB、Cassandra 以及 Redis 来讲，它们应该属于靠近 OLTP 那块，即主要往数据库里面塞入新数据</p>
<p>在某些分析方面，mongoDB 对此做了部分支持</p>
<p>而 MySQL 和 PostgreSQL 支持一些属于 OLAP 类型的查询</p>
<p>但这些比起列存储数据库来讲，就没那么高效了</p>
<p>NoSQL 是在 2000 年末出现的，有很多公司做这个，比如 G 家就为此投入了大量的资金，它们推出了 HBase、 BigTable 以及 Hadoop。它们不会去执行 SQL，也不会进行事务处理，更不会进行 join 操作，但是这就是它们能拓展的原因。</p>
<p>最终这帮人构建出了 NoSQL 数据库系统，比如 mongoDB 和 Cassandra，它们都试着遵循某种设计模式，以此来支持现代的软件 2.0 或 web 2.0 应用。</p>
<p>Hadoop 具备 OLAP 能力，而像 BigTable，Cassandra，mongoDB 具备的则是 OLTP 能力</p>
<p>后来人们也想在 NoSQL 系统上执行 SQL，进行事务处理，进行 join 操作，NewSQL 因此应运而生</p>
<p>Wiki 上 NewSQL 相关信息的第一个系统 H-Store 就是老师开发的，因为这个页面是老师写的（笑</p>
<p>搞 SQL 那帮人一开始表示它们不会去使用 SQL，认为 SQL 太垃圾了，除了 mongoDB 支持某些 SQL 的变体，其他的系统都不支持 SQL，但后面他们又改口说 NoSQL 的意思是 Not only SQL。。。（草，这算是技术圈的风水轮流转吗）</p>
<p>人们在 1970/80 以及 2000 年代都觉得 SQL 是一种糟糕的东西，但它一直都没有退出历史舞台。</p>
</li>
</ul>
</li>
<li><p>数据存储模型</p>
<p>  那么什么样的存储模型才能更有效地支持这些 workload 呢？</p>
<p>  <img src="./29.png" alt></p>
<ul>
<li><p>n-ary 存储模型（N-Ary Storage Model NSM）</p>
<p>  <img src="./30.png" alt></p>
<p>  以行（Row）的形式展示的 tuple，这被称为 n-ary 存储模型</p>
<p>  基本思路是，将单个 tuple 中的所有属性取出，并将它们连续地存储在 page 中</p>
<p>  一个 OLTP 的想法，因为要去访问的数据量在粒度上要足够的小，即一次取一行数据，而这一行数据会按照定义连续存储，这样就能访问到单个实体，拿到对应的信息。如果它是一行数据，就会非常高效，因为只需要跳到那个 page，找到那个数据就完事了。<br>  <img src="./31.png" alt><br>  <img src="./32.png" alt></p>
<p>  让一个 tuple 的所有数据连续地放在一起是读取数据时最有效的方式，因为用索引 index 就可以直接查了，而对于插入操作也是如此</p>
<p>  但为什么行储存是一个糟糕的想法呢？比如如下的一个查询例子</p>
<p>  <img src="./33.png" alt></p>
<p>  在上图的查询中，不得不去读取整个 page，而在非易失性存储设备中，它是一个基于阻塞的 API（EXTRACT ？？？），没办法直接得到这些数据，需要拿到整个 page 之后才行。现在为了执行这条查询，就有了这些我们根本不会去访问的列，但为了得到实际需要的两列（hostname 和 lastLogin），不得不从磁盘中拿到它们（整个 page）并将它们放到内存里（这里的意思应该指内存里面多了 Useless Data）。这是个 bad idea，因为它浪费了硬件的性能。</p>
<p>  <img src="./34.png" alt></p>
<ol>
<li>优势<ul>
<li>访问整个 tuple 时，插入/更新/删除数据都很快</li>
<li>利于查询整个 tuple 的属性</li>
</ul>
</li>
<li>劣势<ul>
<li>但如果要进行一些分析型的查询以及做些 OLAP 的工作，并且要去扫描整张表大部分的内容时，it will suck。因为这需要往内存塞一大堆不需要的数据</li>
</ul>
</li>
</ol>
</li>
<li><p>列存储模型（Decomposition Storage Model DSM）</p>
<p>  <img src="./35.png" alt></p>
<p>  在列存储模型中，并不会将单个 tuple 的全部属性放在单个 page 中，而是将横跨所有的 tuple 中单个属性的所有的值保存在单个 page 中。即把单个列的所有的值连续的保存在一起。</p>
<p>  那么要做 OLAP 的话，只需要读取给定表中部分属性的集合就好了</p>
<p>  <img src="./36.png" alt><br>  <img src="./37.png" alt></p>
<p>  把 tuple 属性拆开来，一个 page 就放一种 tuple 属性</p>
<p>  <img src="./38.png" alt></p>
<p>  对于前面的查找的情况，现在就只需要扫描两个 pages 即可，而不是扫描整个 pages</p>
<blockquote>
<p>注意: 这里图的颜色配反了，下面的图应该要黑蓝换一下</p>
</blockquote>
<p>  顺便列存储也有利于数据的压缩（如果有重复的值存在），因为每个 page 下的属性的类型都是一致的，那么说明它所占空间每一块对于 page 存储的数据来说都是均匀的，大小一致，而行存储则可能往往相反</p>
<p>  那么应该怎样从一个 page 中找到一个匹配项呢</p>
<p>  有 2 种方案，但通常会选择第一种</p>
<p>  <img src="./39.png" alt></p>
<ol>
<li>使用固定长度的 offset（推荐）<br> offset * 每个属性的 size 就能找到位置，比如前面说过的 row ID，page ID 和 slot number 就是这么做的</li>
<li><p>对于列中的每个值都保存一个主键或者时标识符（不推荐）<br> 通过 (key + value) * offset 的形式去查找，但是本身存储开销很大，因为得为每个值用额外的 32/64 bit 的空间来保存它们的 id，非常浪费</p>
<p><img src="./40.png" alt></p>
</li>
<li><p>优势</p>
<ul>
<li>进行 OLAP 查询时，可降低垃圾 I/O 的数量</li>
<li>利于压缩数据，这样在查询上性能就会更好</li>
</ul>
</li>
<li><p>劣势<br> 读取单个 tuple 时候就会很慢，因为需要把不同列的数据拼在一起，这样才能得到一个完整的 tuple，然而对于行储存直接拿就行，同样的对 tuple 进行更新/删除，代价也更高</p>
<p>同样的，列存储也不是什么新想法</p>
<p><img src="./41.png" alt></p>
</li>
<li><p>瑞士军方当时构建了一个叫做 Cantor 的系统，在 1970 年代，因为他们使用了别的语言来写的，所以这玩意儿没被叫做数据库，但它实际上就是个列存储数据库。</p>
</li>
<li>1980 年代，有篇 paper 提到了列存储模型，同时也提到了更多细节，比如短格式（short format）、存储模型的意义</li>
<li>Sybase IQ 是 Sybase 公司推出的专门为数据仓库设计的关系型数据库，IQ 的架构与大多数关系型数据库不同，有用于支持大量并发用户的即时查询的特殊设计。可能是最著名的第一个实现列存储的商用数据库。这是一个内存型列存储数据库，Sybase 把它作为普通的行存储数据库系统的加速器发布，这样他们就可以进行 HTAP 处理并具备同步的能力，但它并没有被广泛采用，因为它被当作行存储数据库的插件而不是作为一个独立的产品来卖</li>
<li>到了 2000 年代，列存储数据库才真正起飞，Vertica 由 Michael Stonebraker 创立，他之前参与过 PostgreSQL 和 Ingres 这些数据库的开发。之后他的公司被 HP 收购，VectorWise 是 MonetDB （MonetDB 是一个开源的面向列的数据库管理系统，它被设计用来为较大规模数据，比如几百万行和数百列级别的数据库表，提供高性能查询的支持） 的内存版。MonetDB 以前是欧洲的一个学术项目，但现在到处都在用它，它是 2000<br>年代出现的第一个列存储数据库系统</li>
<li>之后列存储很快就出名了，因为人们发现这是构建用于数据分析型数据库系统的正确方式</li>
</ol>
</li>
</ul>
</li>
</ul>
<p>那么有没有结合行存储和列存储方式的数据库系统呢？有的，比如 MySQL，在创建表时，可以告诉它用行存储，在创建另一张表时可以告诉它用列存储，所以本质上来说 MySQL 有俩独立的存储管理器，以及俩独立的执行引擎来处理，所以这种就被成为混合数据库系统。虽然有些数据库对于 OLTP 和 OLAP 都支持，但真正牛逼飞起的还没几个。。。</p>
<p>基本上，人们在前端 OLTP 系统中所运行的是 MySQL、mongoDB 或者其他数据库系统，然后你把数据传输给后端数据仓库（back-end data warehouse），然后基本上，当这堆数据不再需要的时候，就可以把 OLTP 这块老的数据给修剪掉了。这可以通过 MySQL + Vertica 这俩独立数据库做到。或者就使用单个混合型数据库，Splice machine 可以做，MySQL 也能做</p>
<ul>
<li><p>结论</p>
<p>  <img src="./42.png" alt></p>
<p>  简单规则，make life easier and better。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Database</category>
      </categories>
      <tags>
        <tag>Database</tag>
      </tags>
  </entry>
</search>

<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Stay Hungry</title>
  
  <subtitle>对，跑快一些，再快一些</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://strugglebak.github.io/"/>
  <updated>2022-06-06T03:31:21.377Z</updated>
  <id>https://strugglebak.github.io/</id>
  
  <author>
    <name>strugglebak</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>zcc-编译器开发总结-part2-Front-End</title>
    <link href="https://strugglebak.github.io/2022/06/06/zcc-%E7%BC%96%E8%AF%91%E5%99%A8%E5%BC%80%E5%8F%91%E6%80%BB%E7%BB%93-part2-Front-End/"/>
    <id>https://strugglebak.github.io/2022/06/06/zcc-编译器开发总结-part2-Front-End/</id>
    <published>2022-06-06T03:25:45.000Z</published>
    <updated>2022-06-06T03:31:21.377Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>注意：本系列文章是 <a href="https://github.com/strugglebak/zcc" target="_blank" rel="noopener">zcc 编译器</a> 总结系列文章，本系列文章并不打算呈现所有的代码细节（主要是细节太多了，全部呈现既不现实文章也看着冗长而没有意义）。因为是总结性质的文章，所以更多是分享实现的过程中个人感兴趣的点</p></blockquote><a id="more"></a><h2 id="scanner"><a href="#scanner" class="headerlink" title="scanner"></a>scanner</h2><blockquote><p>这里对应 <a href="https://github.com/strugglebak/zcc" target="_blank" rel="noopener">zcc</a> 中的 <code>scan.c</code> 文件</p></blockquote><p>无论怎么样，编译器最开始要进行的工作，就是对输入的代码文件进行扫描，这里核心的逻辑有 2 点</p><ol><li>扫描时需要跳过不需要的字符</li><li>对每个扫描到的字符做一个状态的映射</li></ol><p>1 的逻辑很简单，先预读取一个字符，如果这个字符是 <code>&#39; &#39;</code>/ <code>\t</code> / <code>\n</code> / <code>\r</code> / <code>\f</code> 之类的字符就还是继续读取，而继续读取的核心就是调用 <code>fgetc</code> 这个函数，参数传的就是代码文件路径，这个逻辑是被写在 <code>next</code> 函数里面的</p><p>2 的逻辑也比较简单，先建立一个 <code>Token</code> 数据结构，如下</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Token</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> token;</span><br><span class="line">  <span class="keyword">int</span> integer_value;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其中 <code>Token</code> 成员 <code>token</code> 用来存储对扫描到的字符的一个 <strong>状态的映射</strong>，比如 <code>EOF</code> 对应 <code>TOKEN_EOF</code>，<code>+</code> 对应 <code>TOKEN_INCREASE</code> 等等</p><p>那么，什么是 <em>“状态的映射”</em>?<br>其实这里用到的技术就是 <strong>有限状态机</strong> 了，例如，这里用一张图解释下 <code>xxx += 1</code> 这个语句，在解析时是怎么构造有限状态机的</p><p><img src="./1.png" alt></p><ol><li>start 状态: 状态 1</li><li>identifier 状态: 在状态 1 时，如果当前扫描到的字符是个<em>字母</em>，就迁移到状态 2，如果继续扫描还是<em>字母</em>就保持在状态 2，如果不是就返回到状态 1</li><li>operator “+” 状态: 在状态 1 时，如果当前扫描到的字符是 “+”，就迁移到状态 3</li><li>operator “+=” 状态: 在状态 3 时，如果当前扫描到的字符时 “=”，就迁移到状态 4</li><li>integer literal 状态: 在状态 1 时，如果当前扫描到的字符是个 <em>数字</em>，就迁移到状态 5，如果继续扫描还是<em>数字</em>就保持在状态 5，如果不是就返回到状态 1</li></ol><p>编译器用到状态机是基操了，主要是明确各个语句/字符的目的，为后续的处理做一个整体的铺垫</p><p>而 <code>integer_value</code> 属于一个保留字段，可以用来存储数字的数值，也可以用来保存 <code>switch case</code> 语句中 <code>case</code> 的数量</p><p>现在有 <code>Token</code> 这个数据结构，2 的逻辑也就很明了了，就是将代码里的各种需要解析的特殊符号，将其与 <code>enum</code> 声明的 <code>TOKEN_XX</code> 对应起来，便于后续语句的处理</p><p>这里也有一个小的优化的点，<code>scan.c</code> 中有一个函数是 <code>put_back</code>，而 <code>put_back</code> 里面用到了一个全局变量 <code>putback_buffer</code>，用来保存字符。这个在 <code>next</code> 函数里的作用是减少调用 <code>fgetc</code> 的次数，如果 <code>putback_buffer</code> 里面已经存了一个字符的时候就直接返回 <code>putback_buffer</code> 里面的东西。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// scan.c</span></span><br><span class="line">...</span><br><span class="line"><span class="comment">// 从文件中陆续读取下一个字符</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">next</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> c;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (putback_buffer) &#123;</span><br><span class="line">    c = putback_buffer;</span><br><span class="line">    putback_buffer = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> (c);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回了上一次读取后的值之后，再次从文件刚刚的位置的下一位读取</span></span><br><span class="line">  c = fgetc(input_file);</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (c);</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>那么什么时候应该用这个 <code>put_back</code> 函数呢?</p><p>一般情况而言，在扫描状态下，如果一个特殊字符后面可能跟着另一个特殊字符，比如 <code>+</code> 可能跟 <code>+</code>/<code>=</code> 变成 <code>++</code>/<code>+=</code>，就需要用到 <code>put_back</code>，而 <code>put_back</code> 是跟 <code>next</code> 配合使用的。即扫描到字符 <code>+</code> 时，先提前调用 <code>next</code> 函数获取到下一个字符，如果不是 <code>++</code>/<code>+=</code> 这种情况，那么调用 <code>put_back</code> 将这个字符放入到全局变量 <code>putback_buffer</code> 中。因为已经提前判断好情况了，所以下一次调用 <code>next</code> 时就直接返回 <code>putback_buffer</code> 里的字符就好了，也就没必要调用 <code>fgetc</code> 去读取文件的状态了</p><p>以上就是一个 <code>scanner</code> 的主要逻辑，当然里面还有更多的细节，比如</p><ul><li>如何处理不同进制的数字?</li><li>如何处理 <code>identifier</code> 也就是标识符?</li><li>如何转义 <code>\</code> 开头的字符?</li></ul><p>等这里就不再细说了，很细的技术细节不再本文的讨论范围内，各位有兴趣的可以直接看对应 <a href="https://github.com/strugglebak/zcc/blob/main/scan.c" target="_blank" rel="noopener">源码 scan.c</a></p><h2 id="parser"><a href="#parser" class="headerlink" title="parser"></a>parser</h2><p>这里对应 <a href="https://github.com/strugglebak/zcc/blob/main/parser.c" target="_blank" rel="noopener">源码 parser.c</a></p><p>这里要说一点的是，目前来讲，用到的 <code>parser</code> 的核心算法，是类似于 <em>precedence climbing</em> 的一种广义的 <a href="https://en.wikipedia.org/wiki/Operator-precedence_parser#Pratt_parsing" target="_blank" rel="noopener">Pratt parsing</a> 算法，而它也是基于<em>递归下降算法</em>的，在了解这个算法之前，得先说明下 <em>precedence climbing</em> 算法是什么，以及它解决了什么问题</p><p><em>precedence climbing</em> 算法属于 <em>操作符优先级</em> 算法，这个算法的核心在于，它将一个 <em>表达式</em> 看作一系列嵌套的 <em>子表达式</em> 的集合，如果 <em>子表达式</em> 里面有操作符，那么这个 <em>子表达式</em> 则具有与这个操作符相对应的优先级</p><p>比如如下的例子，假定例子中 <code>+</code>/<code>*</code>/<code>^</code> 操作符的优先级分别为 <code>1</code>/<code>2</code>/<code>3</code>，优先级越高，那么这个 <em>子表达式</em> 越优先被执行</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">2 + 3 ^ 2 * 3 + 4</span><br><span class="line"></span><br><span class="line">|---------------|   : prec 1</span><br><span class="line">    |-------|       : prec 2</span><br><span class="line">    |---|           : prec 3</span><br></pre></td></tr></table></figure><p>然而二元操作符是有结合性的，有 <strong>左结合</strong> 和 <strong>右结合</strong></p><p>比如下面这种就是 <strong>左结合</strong>，在计算值的时候应该 <strong>从左往右</strong> 计算</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">2 + 3 + 4 === (2 + 3) + 4</span><br></pre></td></tr></table></figure><p>而下面这种就是 <strong>右结合</strong>，在计算值的时候应该 <strong>从右往左</strong> 计算</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">2 ^ 3 ^ 4 = 2 ^ (3 ^ 4)</span><br></pre></td></tr></table></figure><p>这里再补充一点，朴素的 <em>递归下降</em> 算法有 2 个经典的问题，即</p><ol><li><strong>左递归</strong></li><li><strong>结合性</strong> 问题</li></ol><p><strong>左递归</strong> 问题是指，如果在 BNF 中，产生式的第一个元素是它自身，那么程序就会无限的递归下去，比如一个加法的 BNF 如下</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">additive_expression:</span><br><span class="line">    : <span class="built_in">integer</span></span><br><span class="line">    | additive_expression <span class="string">'+'</span> <span class="built_in">integer</span></span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line"><span class="built_in">integer</span></span><br><span class="line">    :  TOKEN_INGETER_LITERAL</span><br><span class="line">    ;</span><br></pre></td></tr></table></figure><p><code>additive_expression</code> 里面套一个 <code>additive_expression</code>，这种 BNF 写法其实是有问题的，因为如果匹配不到 <code>integer</code>，它下一步就会去<strong>优先匹配 <code>additive_expression</code></strong>，这也就是没有将语法规则定义好，按照这种规则进行递归解析自然会出现无限递归的情况。</p><p>那么如何解决所谓的左递归问题? 前面也说了，<strong>把 BNF 语法规则定义好</strong> 就 OK 了，比如 <code>additive_expression</code> 应该定义如下</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">additive_expression</span><br><span class="line">    : multiplicative_expression</span><br><span class="line">    | multiplicative_expression <span class="string">'+'</span> additive_expression</span><br><span class="line">    | multiplicative_expression <span class="string">'-'</span> additive_expression</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">multiplicative_expression</span><br><span class="line">    : <span class="built_in">integer</span></span><br><span class="line">    | <span class="built_in">integer</span> <span class="string">'*'</span> multiplicative_expression</span><br><span class="line">    | <span class="built_in">integer</span> <span class="string">'/'</span> multiplicative_expression</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line"><span class="built_in">integer</span></span><br><span class="line">    :  TOKEN_INGETER_LITERAL</span><br><span class="line">    ;</span><br></pre></td></tr></table></figure><p>即 <strong>任何一个加法表达式要么是一个乘法表达式自身，要么是一个乘法表达式 加上/减去 另一个 加法表达式</strong>，注意上面 BNF 规则中 <code>additive_expression</code> 和 <code>multiplicative_expression</code> 的匹配顺序，<strong>都不是优先匹配自身</strong> 的，它们基本都 <strong>放在 “+-*/“ 操作符后面</strong> 去了，那么在匹配时就不会出现左递归问题了</p><p>但是这里仍然有一个问题，就是 <em>结合性</em> 的问题，比如在计算</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">2 + 3 + 4</span><br></pre></td></tr></table></figure><p>时，它实际上是在计算</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">2 + (3 + 4)</span><br></pre></td></tr></table></figure><p>这下本来是一个 <em>左结合</em> 的操作符，但现在被当作 <em>右结合</em> 处理了，这是不对的，在一些复杂的计算表达式中会出现 bug</p><p>而为了解决这种 bug，有人提出了 <em>precedence climbing</em> 算法，这种算法的核心原理如下图</p><p><img src="./2.png" alt></p><blockquote><p>注意上图中 <em>黄色</em> 区域那边是一个 <code>parse_expression</code> 递归，而 <em>蓝色</em> 区域则是一个 <code>while</code> 循环</p></blockquote><p>使用上述算法，细心推测不难发现，<strong>假如把操作符的优先级和它是 左结合 或者是 右结合 特性定义好，那么就可以消除递归下降带来的 结合性 问题</strong></p><p>这种算法真的是异常的优雅，代码的逻辑其实并不是很难懂，但是通过 <strong>操作符的优先级</strong> 就可以巧妙的解决左右结合这种 bug</p><p>说完了原理，再来说说 <code>parser.c</code> 中基于这个算法的实现细节</p><p>首先是定义操作符的优先级，值越大的优先级越高，值相等的优先级相等</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> operation_precedence_array[] = &#123;</span><br><span class="line">  <span class="number">0</span>, <span class="number">10</span>,              <span class="comment">// EOF =</span></span><br><span class="line">  <span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span>, <span class="comment">// += -= *= /= %=</span></span><br><span class="line">  <span class="number">15</span>,                 <span class="comment">// \? 三元操作符</span></span><br><span class="line">  <span class="number">20</span>, <span class="number">30</span>,             <span class="comment">// || &amp;&amp;</span></span><br><span class="line">  <span class="number">40</span>, <span class="number">50</span>, <span class="number">60</span>,         <span class="comment">// | ^ &amp;</span></span><br><span class="line">  <span class="number">70</span>, <span class="number">70</span>,             <span class="comment">// == !=</span></span><br><span class="line">  <span class="number">80</span>, <span class="number">80</span>, <span class="number">80</span>, <span class="number">80</span>,     <span class="comment">// &lt; &gt; &lt;= &gt;=</span></span><br><span class="line">  <span class="number">90</span>, <span class="number">90</span>,             <span class="comment">// &lt;&lt; &gt;&gt;</span></span><br><span class="line">  <span class="number">100</span>, <span class="number">100</span>,           <span class="comment">// + -</span></span><br><span class="line">  <span class="number">110</span>, <span class="number">110</span>, <span class="number">110</span>       <span class="comment">// \* / %</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后还需要一个检查是否是右结合操作符的函数 <code>check_right_associative</code></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">check_right_associative</span><span class="params">(<span class="keyword">int</span> token)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (token &gt;= TOKEN_ASSIGN &amp;&amp; token &lt;= TOKEN_ASSGIN_DIVIDE) &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意上面通过 <code>enum</code> 定义的 <code>TOKEN_XX</code> 是有顺序的，所以可以这么做右结合性操作符的判断</p></blockquote><p>最后是一个确定操作符优先级的函数 <code>operation_precedence</code></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">operation_precedence</span><span class="params">(<span class="keyword">int</span> operation_in_token)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> precedence;</span><br><span class="line">  ...</span><br><span class="line">  precedence = operation_precedence_array[operation_in_token];</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">return</span> (precedence);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后就是 <code>parser.c</code> 的核心函数 <code>converse_token_2_ast</code>，它的大致代码长这样</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">struct ASTNode *<span class="title">converse_token_2_ast</span><span class="params">(<span class="keyword">int</span> previous_token_precedence)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化左子树</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 碰到特殊字符就 return</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(</span><br><span class="line">    (operation_precedence(node_operation_type) &gt; previous_token_precedence) ||</span><br><span class="line">    (check_right_associative(node_operation_type) &amp;&amp;</span><br><span class="line">     operation_precedence(node_operation_type) == previous_token_precedence)</span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="comment">// 递归地构建右子树</span></span><br><span class="line">    right = converse_token_2_ast(operation_precedence(node_operation_type));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 传入右子树，构建左子树</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 碰到特殊字符就 break 这个 while 循环</span></span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回左子树</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是的， <code>converse_token_2_ast</code> 函数的主要作用就是解析语句并构建对应的 ast，如果解析到的是右结合性操作符，那么需要判定函数传入的上一个操作符的优先级跟当前的操作符优先级是否相等，这个其实跟上面说的 <code>precedence climbing</code> 算法的逻辑是一样的</p><p>以上，<code>parser.c</code> 的核心算法介绍完毕，也基本上是这个编译器的核心算法了，并不算很复杂。其实这个算法早在 <em>Clang</em> 中就有对应的应用，<em>Clang</em> 的 front-end 部分就是手写的递归下降算法，然后使用 <code>precedence climbing</code> 算法来更有效率地解析表达式</p><blockquote><p>注意，其他 parser 相关算法如 <code>RD</code> parser、auto-generated <code>LL(k)</code> parser、auto-generated <code>LR</code> pasrser、TODP、shunting 等不在本文的讨论范围内。</p></blockquote><h2 id="Symbol-Table"><a href="#Symbol-Table" class="headerlink" title="Symbol Table"></a>Symbol Table</h2><p><code>Symbol Table</code>，也就是 <em>符号表</em>，这个玩意儿在本项目中是用来处理 <em>变量名</em> 的。注意这里提到的 <em>变量名</em> 是广义的，在代码文件中，每个 <code>identifier</code>、<code>const</code> 常量、<code>function</code> 函数名等都与之相关，而 <code>Symbol Table</code> 里面就存放着有关这些 <em>变量名</em> 的信息</p><h3 id="Symbol-Table-设计"><a href="#Symbol-Table-设计" class="headerlink" title="Symbol Table 设计"></a>Symbol Table 设计</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SymbolTable</span> &#123;</span></span><br><span class="line">  <span class="keyword">char</span> *name;           <span class="comment">// 每个变量的名字</span></span><br><span class="line">  <span class="keyword">int</span> storage_class;    <span class="comment">// 每个变量的 存储类</span></span><br><span class="line">  <span class="keyword">int</span> structural_type;  <span class="comment">// 每个变量的 结构类型</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里简单说一下 <code>storage_class</code> 和 <code>structural_type</code> 的作用。</p><ul><li><p><code>storage_class</code> 在这里主要是用来定义变量或者函数的可见范围以及生命周期，在本编译器种，有如下的几种 <code>class</code></p>  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> &#123;</span><br><span class="line">  STORAGE_CLASS_GLOBAL = <span class="number">1</span>,             <span class="comment">// 全局变量</span></span><br><span class="line">  STORAGE_CLASS_LOCAL,                  <span class="comment">// 局部变量</span></span><br><span class="line">  STORAGE_CLASS_EXTERN,                 <span class="comment">// extern 声明的变量</span></span><br><span class="line">  STORAGE_CLASS_STATIC,                 <span class="comment">// static 声明的变量</span></span><br><span class="line">  STORAGE_CLASS_FUNCTION_PARAMETER,     <span class="comment">// 函数参数</span></span><br><span class="line">  STORAGE_CLASS_STRUCT,                 <span class="comment">// struct 声明的变量</span></span><br><span class="line">  STORAGE_CLASS_UNION,                  <span class="comment">// union 声明的变量</span></span><br><span class="line">  STORAGE_CLASS_MEMBER,                 <span class="comment">// struct/union 里面的成员变量</span></span><br><span class="line">  STORAGE_CLASS_ENUM_TYPE,              <span class="comment">// enum 枚举的类型变量名，比如 enum `xxx &#123;...&#125;;` 这个 `xxx` 就是类型变量名</span></span><br><span class="line">  STORAGE_CLASS_ENUM_VALUE,             <span class="comment">// enum 枚举的值，比如 `enum xxx &#123;a, b&#125;;` 这个里面的 `a` 和 `b` 就是枚举值</span></span><br><span class="line">  STORAGE_CLASS_TYPEDEF                 <span class="comment">// typedef 声明的变量</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p><code>structural_type</code> 在这里主要是用来确定要比较的两个类型是否等价，在本编译器中，它有如下的几种 <code>type</code></p>  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> &#123;</span><br><span class="line">  STRUCTURAL_VARIABLE,  <span class="comment">// 变量类型</span></span><br><span class="line">  STRUCTURAL_FUNCTION,  <span class="comment">// 函数类型</span></span><br><span class="line">  STRUCTURAL_ARRAY      <span class="comment">// 数组类型</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><p>最开始的设计，其实是一个这样的数组</p><p><img src="./3.png" alt></p><p>数组 <strong>index 低位</strong> 存 <em>全局变量名</em>，数组 <strong>index 高位</strong> 存 <em>局部变量名</em>，整个数组的大小最初设置为 <code>1024</code>，分别用一个全局的 <code>global index</code> (指向全局变量)以及一个全局的 <code>local index</code> (指向局部变量) 来对变量进行插入和查找的操作。</p><p>而对于函数来说，它的 <code>symbol</code> 信息分 2 种</p><ul><li>函数自己的变量名</li><li>函数的参数名</li></ul><p>要比较函数的 <em>声明定义</em> 和 <em>调用</em>，主要考虑 3 个问题，即</p><ol><li>函数调用的名字是不是和声明定义的名字一致?</li><li>函数调用的 <em>实参</em> 是不是和声明定义的 <em>形参</em> 一致?</li><li><em>形参</em> 在定义的函数体内被调用时，如何与局部变量区分开?</li></ol><p>如果用数组来存储函数相关的 <code>symbol</code> 信息，那么</p><ul><li>解决上述问题 1 和 2<br>  在解析函数声明定义时，应该要把 函数名 + 函数 <em>形参</em> 存储到 <code>symbol table</code> 数组的 <code>global index</code> 区域，并将其分别标记为 <code>STORAGE_CLASS_GLOBAL</code> + <code>STRUCTURAL_FUNCTION</code> (函数名) 和 <code>STORAGE_CLASS_FUNCTION_PARAMETER</code> (函数 <em>形参</em>)</li><li>解决上述问题 3<br>  对于函数 <em>形参</em> 来说，它同时也要存储到 <code>symbol table</code> 数组的 <code>local index</code> 区域，并将其标记为 <code>STORAGE_CLASS_FUNCTION_PARAMETER</code>，这样它才可以与 <code>local index</code> 区域里面其他的被标记为 <code>STORAGE_CLASS_LOCAL</code> 的局部变量区分开</li></ul><p>但这样就会造成一个问题，即函数的 <em>形参</em> 需要从 <code>symbol table</code> 数组的 <code>global index</code> 区域 <strong>复制</strong> 到 <code>local index</code> 区域，这不仅会造成数组空间的浪费，同时也为开发编译器增加了心智负担：鬼知道这个 <code>global index</code> 区域与 <code>local index</code> 会不会发生重叠，万一各个函数的变量很多呢?</p><p>所以后面稍微做了下 <strong>重构</strong>，将有限空间的 <code>symbol table</code> 数组重构为一个 <strong>单向链表</strong>，其数据结构如下</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SymbolTable</span> &#123;</span></span><br><span class="line">  <span class="keyword">char</span> *name;                   <span class="comment">// 每个变量的名字</span></span><br><span class="line">  <span class="keyword">int</span> storage_class;            <span class="comment">// 每个变量的 存储类</span></span><br><span class="line">  <span class="keyword">int</span> structural_type;          <span class="comment">// 每个变量的 结构类型</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">SymbolTable</span> *<span class="title">next</span>;</span>     <span class="comment">// 指向下一个 symbol table 的指针</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">SymbolTable</span> *<span class="title">member</span>;</span>   <span class="comment">// 指向第一个函数参数、第一个 struct/union/enum 的 member 成员的 symbol table 指针</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于如下的代码</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> var1;</span><br><span class="line"><span class="keyword">int</span> var2;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">(<span class="keyword">int</span> param1, <span class="keyword">int</span> param2)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> var3;</span><br><span class="line">    <span class="keyword">int</span> var4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>symbol table</code> 链表表示如下</p><p><img src="./4.png" alt></p><blockquote><p>注意上图中，<code>global_head</code>、<code>local_head</code> 以及 <code>parameter_head</code> 均为全局指针。 <code>parameter_head</code> 这个全局指针有些特殊，它是优先指向先解析到的函数的 <strong>第一个参数</strong></p></blockquote><p>现在对于每个函数来说，它会有自己的一个链表节点，而它对应的参数也有一个链表，函数的指向其参数的指针 <code>member</code> 指向其参数链表。这样一来就能有效解决数组空间不够的问题</p><h3 id="struct-union-enum-typedef"><a href="#struct-union-enum-typedef" class="headerlink" title="struct/union/enum/typedef"></a>struct/union/enum/typedef</h3><p>对于 <code>struct</code>、<code>union</code>、<code>enum</code> 以及 <code>typedef</code> 定义的变量来说，他们也是遵从 <code>symbol table</code> 链表这个设计的</p><p>但对于 <code>struct</code> 和 <code>union</code>，它们有个特殊情况，即 <code>struct</code> 里面可能会 <strong>嵌套</strong> <code>union</code>/<code>struct</code>，这个时候就需要在 <code>symbol table</code> 中加入一个指针 <code>composite_type</code> 来指向这种嵌套的 <em>复合类型</em></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SymbolTable</span> &#123;</span></span><br><span class="line">  <span class="keyword">char</span> *name;                   <span class="comment">// 每个变量的名字</span></span><br><span class="line">  <span class="keyword">int</span> storage_class;            <span class="comment">// 每个变量的 存储类</span></span><br><span class="line">  <span class="keyword">int</span> structural_type;          <span class="comment">// 每个变量的 结构类型</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">SymbolTable</span> *<span class="title">next</span>;</span>     <span class="comment">// 指向下一个 symbol table 的指针</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">SymbolTable</span> *<span class="title">member</span>;</span>   <span class="comment">// 指向第一个函数参数、第一个 struct/union/enum 的 member 成员的 symbol table 指针</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">SymbolTable</span> *<span class="title">composite_type</span>;</span> <span class="comment">// 指向复合类型 symbol table 的指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比如如下的代码</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">foo</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> f;</span><br><span class="line">  <span class="keyword">union</span> &#123;</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">foo</span> <span class="title">bar</span>;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以用链表表示为下图</p><p><img src="./5.png" alt></p><blockquote><p>注意上图中，<code>NULL</code> 表达的意思不是这个节点为 <code>NULL</code>，而是这个节点的 <code>name</code> 为 <code>NULL</code>，因为在代码中 <code>union</code> 并没有这么表达: <code>union xxx { int a, int b }</code>，所以对于当前的 union 来讲它就是匿名的</p></blockquote><p>而对于 <code>enum</code> 来讲，它的每个节点有 2 种类型: <code>STORAGE_CLASS_ENUM_TYPE</code>(父节点)和 <code>STORAGE_CLASS_ENUM_VALUE</code>(子节点)，如果解析到多个 <code>enum</code>，就按照解析的顺序将它们串起来</p><p>比如如下的代码</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> foo &#123;a, b, c&#125;;</span><br><span class="line"><span class="keyword">enum</span> bar &#123;x, y, z&#125;;</span><br></pre></td></tr></table></figure><p>可以用链表表示为下图</p><p><img src="./6.png" alt></p><p>而对于 <code>typedef</code> 来讲，也是差不多的原理，比如如下的代码</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> FOO;</span><br><span class="line"><span class="keyword">typedef</span> FOO BAR;</span><br><span class="line">BAR x;</span><br></pre></td></tr></table></figure><p>可以用链表表示为下图</p><p><img src="./7.png" alt></p><p>在解析到 <code>BAR x;</code> 时，会去 <code>typedef</code> 链表中查找 <code>BAR</code> 这个节点，如果找到了，那么这个节点的 <code>primitive_type</code> 就是 <code>int</code>，也就相当于找到 <code>x</code> 的类型</p><p>以上这部分的代码在 <a href="https://github.com/strugglebak/zcc/blob/main/declaration.c" target="_blank" rel="noopener">declaration.c</a> 以及 <a href="https://github.com/strugglebak/zcc/blob/main/symbol_table.c" target="_blank" rel="noopener">symbol_table.c</a></p><h2 id="类型检查和转换"><a href="#类型检查和转换" class="headerlink" title="类型检查和转换"></a>类型检查和转换</h2><p>下面说的内容对应源码 <a href="https://github.com/strugglebak/zcc/blob/main/types.c" target="_blank" rel="noopener">types.c</a></p><p>对于本编译器来讲，支持的类型并没有很多，只有简单的几种，如下</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> &#123;</span><br><span class="line">  PRIMITIVE_NONE,</span><br><span class="line">  PRIMITIVE_VOID = <span class="number">16</span>,</span><br><span class="line">  PRIMITIVE_CHAR = <span class="number">32</span>,</span><br><span class="line">  PRIMITIVE_INT = <span class="number">48</span>,</span><br><span class="line">  PRIMITIVE_LONG = <span class="number">64</span>,</span><br><span class="line">  PRIMITIVE_STRUCT = <span class="number">80</span>,</span><br><span class="line">  PRIMITIVE_UNION = <span class="number">96</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在只有这么几种类型的情况下，如果出现指针该怎么解析呢? 这里用了一个取巧的办法</p><p>如果用到指针类型，那么只需要将其对应的 <code>primitive_type</code> + 1 就好。比如 <code>char</code> 解析后的类型值是 32，那么其对应的 <code>char *</code> 指针类型值就是 33</p><p>如果需要对指针类型取得它指向的值的类型，那么只需要将其对应的 <code>primitive_type</code> - 1 就好。比如 <code>char *foo = &quot;x&quot;;</code>，变量 <code>foo</code> 的类型是 <code>char *</code>，那么 <code>*foo</code> 的类型值就是 <code>char</code>，也就是 32</p><p>这里对应的函数分别是 <code>pointer_to</code> 和 <code>value_at</code></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pointer_to</span><span class="params">(<span class="keyword">int</span> primitive_type)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> ((primitive_type &amp; <span class="number">0xf</span>) == <span class="number">0xf</span>)</span><br><span class="line">    error_with_digital(<span class="string">"Unrecognised in pointer_to: primitive type"</span>, primitive_type);</span><br><span class="line">  <span class="keyword">return</span> (primitive_type + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">value_at</span><span class="params">(<span class="keyword">int</span> primitive_type)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> ((primitive_type &amp; <span class="number">0xf</span>) == <span class="number">0x0</span>)</span><br><span class="line">    error_with_digital(<span class="string">"Unrecognised in value_at: primitive type"</span>, primitive_type);</span><br><span class="line">  <span class="keyword">return</span> (primitive_type - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来讲讲 zcc 编译器是如何做类型检查和转换的</p><h3 id="隐式类型检查和转换"><a href="#隐式类型检查和转换" class="headerlink" title="隐式类型检查和转换"></a>隐式类型检查和转换</h3><p>下面说的内容对应源码 <a href="https://github.com/strugglebak/zcc/blob/main/types.c#L29" target="_blank" rel="noopener">types.c 中的 modify_type 函数</a></p><p>类型检查，基本思路就是检查 <em>左值</em> 和 <em>右值</em> 的类型是否相等，如果不相等就做兼容/转换的处理</p><p>对于解析 <code>if (x &amp;&amp; y)</code> 或者 <code>if (x || y)</code> 这种情况</p><blockquote><p>注意其中的 ，<code>x</code> 是作为左值存在的，而 <code>y</code> 是作为右值存在的。</p></blockquote><ul><li>如果 <code>x</code> 本来被声明为 <code>void x</code>，那么这个左值应该与任何右值都不兼容</li><li>如果 <code>x</code> 的类型是 <code>char *</code>，右值 <code>y</code> 的类型是 <code>char</code>，那么这两个值都应该不兼容</li></ul><p>最好是要么 <code>x</code> 和 <code>y</code> 都是 <code>char</code>/<code>int</code>/<code>long</code> 类型的，要么它们都是 <code>char *</code>/<code>int *</code>/<code>long*</code> 型的</p><p>而对于不是 <code>if (x &amp;&amp; y)</code> 或者 <code>if (x || y)</code> 这种情况，也就是 <code>x = y</code> 这种情况，那么需要有如下的判断</p><ul><li><p><code>x</code> 和 <code>y</code> 都是 <code>char</code>/<code>int</code>/<code>long</code> 类型</p><ul><li>如果是 <code>char x</code> 和 <code>char y</code> 这种情况，正常通过</li><li>如果是 <code>char x</code> 和 <code>int y</code> 这种情况，不正常，需要报错</li><li><p>如果是 <code>int x</code> 和 <code>char y</code> 这种情况，虽然不正常，但需要做转换，转换的方式就是将 <code>char y</code> 转换成 <code>int y</code>，最后赋值给 <code>int x</code></p><p><img src="./8.png" alt></p><p>注意这个 ast 图中的 <code>lvalue</code> 和 <code>rvalue</code> 的左右顺序颠倒了，主要是方便后面 back-end 生成汇编代码时(back-end 是对 ast 进行 <strong>后序遍历</strong> 生成汇编代码)，能确保 <code>rvalue</code> 在 <code>lvalue</code> 之前生成，因为操作顺序应该是:</p></li></ul><ol><li>先将 <code>y</code> 的值 load 进某个寄存器</li><li>然后将存储 <code>y</code> 的值的寄存器里面的值取出来，放入 <code>x</code> 所在的寄存器的位置</li></ol></li><li><p><code>x</code> 和 <code>y</code> 都是 <code>char *</code>/<code>int *</code>/<code>long *</code> 类型</p><ul><li>如果是 <code>char *x</code> 和 <code>char *y</code> 这种情况，正常通过</li><li><p>如果是 <code>(void *) x</code>这种情况，也正常通过</p><p>指针之间相互传的是地址，对于本编译器来说，地址的大小都是固定的，所以暂不考虑 <code>char *</code> 和 <code>long *</code> 之间相互传地址中的兼容问题</p></li></ul></li></ul><p>还有一种情况跟指针相关，比如 <code>int *y</code> 和 <code>char x</code>，当它们在执行 <code>y + x</code>、<code>y - x</code>、<code>y += x</code>、<code>y -=x</code>，即指针的加减操作时，需要做类型的 “转换”</p><p>这种情况的 ast 如下图所示</p><p><img src="./9.png" alt></p><blockquote><p>注意上图中，<code>x</code> 和 <code>y</code> 均为 <code>rvalue</code>，也就是都是右值</p></blockquote><p>为什么指针也需要?</p><ul><li>假设是 <code>char *y</code> 和 <code>char x</code> 的加减操作，那么对于 <code>y</code> 来讲，它需要加减的是 <strong>1 个 <code>x</code> 单位</strong></li><li>假设是 <code>int *y</code> 和 <code>char x</code> 的加减操作，那么对于 <code>y</code> 来讲，它需要加减的是 <strong>4 个 <code>x</code> 单位</strong></li><li>假设是 <code>long *y</code> 和 <code>char x</code> 的加减操作，那么对于 <code>y</code> 来讲，它需要加减的是 <strong>8 个 <code>x</code> 单位</strong></li></ul><p>可以看到里面单位相当于是一个 2^n 倍的关系，这个在汇编里可以用算术左移来实现这个关系</p><p>在汇编里面的操作顺序是</p><ol><li>将 <code>x</code> 的值 load 进某个寄存器</li><li>然后将 <code>y</code> 的值也就是地址 load 进某个寄存器</li><li>在执行 <code>+</code> 操作时，发现 <code>y</code> 是 <code>int *</code> 类型的，需要将 <code>x</code> 的值从其对应寄存器里面取出，并进行 <strong>算术左移操作</strong>，算术左移 2 位后，再对指针 <code>y</code> 进行 <code>+</code> 操作</li></ol><p>至于为什么一定要是 <code>1</code>/<code>4</code>/<code>8</code> 这种关系，是因为我们定义 <code>char</code> 是 1 个 byte 的空间，而 <code>int</code> 是 4 个 byte 的空间，对于 <code>long</code> 则是 8 个 byte 的空间</p><p>所以主要是依据这个来跟 <code>char *</code>、<code>int *</code>、<code>long *</code> 指针的 <strong>寻址范围</strong>做一个区分，那么也就自然能够区分这几个指针了。如果不做区分，不同的指针在寻址时会出现重叠的问题，那么编译出来的程序自然也会有 bug</p><h3 id="显式类型检查和转换"><a href="#显式类型检查和转换" class="headerlink" title="显式类型检查和转换"></a>显式类型检查和转换</h3><p>下面说的内容对应源码中的 <a href="https://github.com/strugglebak/zcc/blob/main/declaration.c" target="_blank" rel="noopener">declaration.c</a> 中的 <a href="https://github.com/strugglebak/zcc/blob/main/declaration.c#L275" target="_blank" rel="noopener">convert_literal_token_2_integer_value</a> 函数以及 <a href="https://github.com/strugglebak/zcc/blob/main/declaration.c#L307" target="_blank" rel="noopener">convert_type_casting_token_2_primitive_type</a> 函数</p><p>首先我想举出几个例子，碰到哪些语句类型检查可以过呢?</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.</span></span><br><span class="line"><span class="keyword">char</span> *str = <span class="string">" "</span>;</span><br><span class="line"><span class="comment">// 2.</span></span><br><span class="line"><span class="keyword">char</span> *str = (<span class="keyword">void</span> *)<span class="number">0</span>;</span><br><span class="line"><span class="comment">// 3.</span></span><br><span class="line"><span class="keyword">int</span> str = <span class="number">255</span>;</span><br></pre></td></tr></table></figure><p>上面 3 条语句均可以通过</p><ul><li>对于 <code>char *str = &quot; &quot;;</code> 来说，<code>=</code> 左边的类型是 <code>char *</code>，<code>=</code> 右边是一个 <code>AST_STRING_LITERAL</code> 类型的字符串，类型检查通过</li><li><p>对于 <code>char *str = (void *)0;</code> 来说，这是一个显式的转换，<code>=</code> 左边的类型是 <code>char *</code>，<code>=</code> 右边是一个 <code>(void *)0</code> 也就是 <code>NULL</code>，所以通过</p><p>  注意它所形成的 ast 如下图所示</p><p>  <img src="./10.png" alt></p><p>  那么如何判定这个节点是否是 <code>(void *)0</code> 呢，只需要知道这个节点的左子节点的类型是否是 <code>AST_INTEGER_LITERAL</code> 并且当前节点值为 0 即可</p></li><li>对于 <code>int str = 255;</code>来说，<code>=</code> 左边的类型是 <code>int</code>，<code>=</code> 右边的类型是一个 <code>char</code>，因为一个 <code>int str</code> 放得下一个 <code>(char)255</code>，所以通过</li></ul><p>那么反过来，碰到哪些语句类型检查不可以通过呢?</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.</span></span><br><span class="line"><span class="keyword">char</span> str = <span class="number">3000</span>;</span><br><span class="line"><span class="comment">// 2.</span></span><br><span class="line"><span class="keyword">char</span> *str = <span class="number">54</span>;</span><br></pre></td></tr></table></figure><p>上面两条语句均不可以通过</p><ul><li>对于 <code>char str = 3000;</code> 来说，<code>=</code> 左边的类型是 <code>char</code>，<code>=</code> 右边的类型是 <code>int</code>，因为一个 <code>char str</code> 放不下一个 <code>(int)3000</code>，所以不通过</li><li>对于 <code>char *str = 54;</code> 来说，<code>=</code> 左边的类型是 <code>char *</code>，<code>=</code> 右边的类型是 <code>char</code>，并且 <code>54</code> 的类型虽然是 <code>AST_INTEGER_LITERAL</code>，可是它的值不为 0，它不是类似于 <code>(void *)0</code> 那样的强制转换，所以不通过</li></ul><p>然后，若需要强制转换，那么该怎么做呢?</p><p>其实很简单，比如要解析如下的语句</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> *str = (<span class="keyword">void</span> *)<span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>得先提取出 <code>=</code> 右边括号中的 <code>void</code>，再提取出 <code>*</code>，结合形成 <code>void *</code> 获得当前的类型，拿到这个结果后再返回给 <code>char *str</code>，此时在构建 ast 时，<code>str</code> 的类型就不再是 <code>char *</code> 而是 <code>void *</code> 了</p><h2 id="Dangling-Else-问题"><a href="#Dangling-Else-问题" class="headerlink" title="Dangling Else 问题"></a>Dangling Else 问题</h2><p>下面说的内容对应源码中 <a href="https://github.com/strugglebak/zcc/blob/main/statement.c#L185" target="_blank" rel="noopener">statement.c 中的 parse_if_statement 函数</a></p><p><em>Dangling Else</em> 问题是指，如果一个 if-else 语句中，存在嵌套的 if-else 语句，如果 parser 根据其 BNF 解析时，能产生多个 ast，那么我们有理由认为这个语法是有歧义的</p><p>比如，对于 c 来说，它的一部分 BNF 如下</p><figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line">statement = ...</span><br><span class="line">   <span class="string">| selection_statement</span></span><br><span class="line"></span><br><span class="line">selection_statement = ...</span><br><span class="line">   <span class="string">| IF ( expression ) statement</span></span><br><span class="line">   <span class="string">| IF ( expression ) statement ELSE statement</span></span><br></pre></td></tr></table></figure><p>那可以根据上面的 BNF 规则可以写出如下的代码</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (a) <span class="keyword">if</span> (b) s; <span class="keyword">else</span> s2;</span><br></pre></td></tr></table></figure><p>但 parser 不这么想，因为这既可以被解析成</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (a) &#123;</span><br><span class="line">  <span class="keyword">if</span> (b) s;</span><br><span class="line">  <span class="keyword">else</span> s2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以被解析成</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (a) &#123;</span><br><span class="line">  <span class="keyword">if</span> (b) s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> s2;</span><br></pre></td></tr></table></figure><p>那么应该选取哪个呢? 在 c 里面选的是就近原则，即 <code>else</code> 应该与离它最近的一个 <code>if</code> 匹配。而对于我们的 zcc 编译器，也是如此</p><p>那么在 zcc 里面是如何实现这种就近原则呢?</p><p>首先看关键代码</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// statement.c</span></span><br><span class="line"><span class="function">struct ASTNode *<span class="title">parse_if_statement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">ASTNode</span> *<span class="title">condition_node</span>, *<span class="title">true_node</span>, *<span class="title">false_node</span> = <span class="title">NULL</span>;</span></span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 条件为 true 的代码部分</span></span><br><span class="line">  true_node = parse_single_statement();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 条件为 false 的代码部分</span></span><br><span class="line">  <span class="keyword">if</span> (token_from_file.token == TOKEN_ELSE) &#123;</span><br><span class="line">    scan(&amp;token_from_file);</span><br><span class="line">    false_node = parse_single_statement();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么 <code>parse_single_statement</code> 做了什么事情?</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// statement.c</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> struct ASTNode *<span class="title">parse_single_statement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">SymbolTable</span> *<span class="title">composite_type</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">ASTNode</span> *<span class="title">statement</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span>(token_from_file.token) &#123;</span><br><span class="line">    <span class="keyword">case</span> TOKEN_IF:</span><br><span class="line">      <span class="keyword">return</span> (parse_if_statement());</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 其他 statement 对应的解析</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很明显，这是一个递归。即如果在解析 <code>if</code> statement 时，只要遇到一个 <code>else</code> 关键字，就直接进行 <strong>递归</strong> 处理，并生成这个 <code>else</code> 的 ast。<code>else</code> 的 ast 作为一个 <code>false_node</code>，与其最近的 <code>if</code> 解析成的 <code>true_node</code> 组成 ast 的 middle 和 right 节点，而 left 节点就是最近的 <code>if</code> 括号中的语句，这个语句被解析成 <code>condition_node</code></p><p>比如上面提到的代码</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (a) <span class="keyword">if</span> (b) s; <span class="keyword">else</span> s2;</span><br></pre></td></tr></table></figure><p>会被解析成如下的 ast</p><p><img src="./11.png" alt></p><p>可以看到 ast 中最下面的 <code>AST_IF</code> 节点包含了 <code>s</code> 和 <code>s2</code> 节点，那么在后序遍历生成汇编代码时，解析这个 ast 就贯彻了 <strong>if else 就近匹配</strong> 的原则</p><h2 id="while-for-switch-case-statement-的解析"><a href="#while-for-switch-case-statement-的解析" class="headerlink" title="while/for/switch case statement 的解析"></a>while/for/switch case statement 的解析</h2><h3 id="AST-GLUE"><a href="#AST-GLUE" class="headerlink" title="AST_GLUE"></a>AST_GLUE</h3><p>为什么需要一个 <code>AST_GLUE</code> 这种类型的节点? 因为在解析代码语句时，会解析成各种各样的 statement，比如 <code>if</code> statement、<code>while</code> statement、<code>for</code> statement、<code>switch case</code> statement 等等，这样一个 <code>AST_GLUE</code> 类型的节点的作用是把它们 “粘连” 起来</p><p>比如下图</p><p><img src="./12.png" alt></p><p>对应于代码 <a href="https://github.com/strugglebak/zcc/blob/main/statement.c#L447" target="_blank" rel="noopener">parse_compound_statement</a></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">struct ASTNode *<span class="title">parse_compound_statement</span><span class="params">(<span class="keyword">int</span> in_switch_statement)</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">ASTNode</span> *<span class="title">left</span> = <span class="title">NULL</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">ASTNode</span> *<span class="title">tree</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    tree = parse_single_statement();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (tree) &#123;</span><br><span class="line">      <span class="keyword">if</span> (left != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        left = create_ast_node(AST_GLUE, PRIMITIVE_NONE, left, <span class="literal">NULL</span>, tree, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        left = tree;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>parse_single_statement</code> 就是对类似于 <code>if</code> / <code>while</code> / <code>for</code> / <code>switch case</code> 等 statement 语句的处理(主要是将其转换成 ast)</p><h3 id="while-statement"><a href="#while-statement" class="headerlink" title="while statement"></a>while statement</h3><p>上面说到了 <code>if</code> statement 的解析，相对于 <code>if</code>，<code>while</code> 则好解析得多</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// statement.c</span></span><br><span class="line"><span class="function">struct ASTNode *<span class="title">parse_while_statement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">ASTNode</span> *<span class="title">condition_node</span>, *<span class="title">statement_node</span> = <span class="title">NULL</span>;</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// while 里面都是语句，所以直接解析即可</span></span><br><span class="line">  statement_node = parse_single_statement();</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>parse_single_statement</code> 里面也是跟解析 <code>if</code> statement 一样的递归</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// statement.c</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> struct ASTNode *<span class="title">parse_single_statement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">SymbolTable</span> *<span class="title">composite_type</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">ASTNode</span> *<span class="title">statement</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span>(token_from_file.token) &#123;</span><br><span class="line">    <span class="keyword">case</span> TOKEN_WHILE:</span><br><span class="line">      <span class="keyword">return</span> (parse_while_statement());</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 其他 statement 对应的解析</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于 <code>while</code> statement 来说，它的 ast 总体如下</p><p><img src="./13.png" alt></p><p>没有 middle 节点，这个节点为 <code>NULL</code></p><h3 id="for-statement"><a href="#for-statement" class="headerlink" title="for statement"></a>for statement</h3><p>对于解析 <code>for</code> statement 来说，就需要 <code>AST_GLUE</code> 节点了，因为 <code>for</code> statement 就是 <code>while</code> statement 的变种，比如</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; <span class="number">10</span> ; i = i + <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"xxx"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码，可以看作是</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">i = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span>(i &lt; <span class="number">10</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"xxx"</span>);</span><br><span class="line">    i = i + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么它构成的 ast 则可以表示为下图</p><p><img src="./14.png" alt></p><p>对应代码 <a href="https://github.com/strugglebak/zcc/blob/main/statement.c#L269" target="_blank" rel="noopener">parse_for_statement</a></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// statement.c</span></span><br><span class="line"><span class="function">struct ASTNode *<span class="title">parse_for_statement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">ASTNode</span></span></span><br><span class="line"><span class="class">    *<span class="title">condition_node</span>, *<span class="title">statement_node</span>,</span></span><br><span class="line"><span class="class">    *<span class="title">pre_operation_statement_node</span>, *<span class="title">post_operation_statement_node</span>,</span></span><br><span class="line"><span class="class">    *<span class="title">tree</span> = <span class="title">NULL</span>;</span></span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">  pre_operation_statement_node = parse_expression_list(TOKEN_SEMICOLON);</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  post_operation_statement_node = parse_expression_list(TOKEN_RIGHT_PAREN);</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  statement_node = parse_single_statement();</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 自底向上递归地创建上图中表示的 ast 节点</span></span><br><span class="line">  tree = create_ast_node(AST_GLUE, PRIMITIVE_NONE, statement_node, <span class="literal">NULL</span>, post_operation_statement_node, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">  tree = create_ast_node(AST_WHILE, PRIMITIVE_NONE, condition_node, <span class="literal">NULL</span>, tree, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">  <span class="keyword">return</span> (create_ast_node(AST_GLUE, PRIMITIVE_NONE, pre_operation_statement_node, <span class="literal">NULL</span>, tree, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>parse_single_statement</code> 中也一样对 <code>for</code> statement 进行了递归处理</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// statement.c</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> struct ASTNode *<span class="title">parse_single_statement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">SymbolTable</span> *<span class="title">composite_type</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">ASTNode</span> *<span class="title">statement</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span>(token_from_file.token) &#123;</span><br><span class="line">    <span class="keyword">case</span> TOKEN_FOR:</span><br><span class="line">      <span class="keyword">return</span> (parse_for_statement());</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 其他 statement 对应的解析</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么代码中 <code>pre_operation_statement_node</code> 和 <code>post_operation_statement_node</code> 代表什么呢? 它们代表要解析的代码</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; <span class="number">10</span> ; i = i + <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"xxx"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>中出现的 <code>i = 1;</code> 和 <code>i = i + 1;</code>，它们通过调用 <a href="https://github.com/strugglebak/zcc/blob/main/parser.c#L295" target="_blank" rel="noopener">parse_expression_list 函数</a> 分别生成如下的 ast</p><ul><li><code>i = 1;</code><br>  <img src="./15.png" alt></li><li><code>i = i + 1;</code><br>  <img src="./16.png" alt></li></ul><h3 id="if-while-for-中没有操作符的条件语句问题"><a href="#if-while-for-中没有操作符的条件语句问题" class="headerlink" title="if/while/for 中没有操作符的条件语句问题"></a>if/while/for 中没有操作符的条件语句问题</h3><p>前面讲完了 <code>if</code> / <code>while</code> / <code>for</code> 是怎么解析生成其对应的 ast 的，但这个里面并没有说到类似于 <code>if (a)</code> / <code>while(a)</code> / <code>for(; a ;)</code> 这种条件语句，要是这里面没有 <code>&gt;</code> / <code>&lt;</code> / <code>==</code> 等这种情况下，如何判断 <code>a</code> 的 true or false?</p><p>碰到这种情况，解决的方法也很简单，在 <code>contidion_node</code> 的基础上加一个 <code>AST_TO_BE_BOOLEAN</code> 节点，即把 <code>a</code> 变成</p><p><img src="./17.png" alt></p><p>后续在 back-end 阶段再针对这个 <code>AST_TO_BE_BOOLEAN</code> 做处理就可以了</p><h3 id="switch-case-statement"><a href="#switch-case-statement" class="headerlink" title="switch case statement"></a>switch case statement</h3><p>下面要说的内容基于代码 <a href="https://github.com/strugglebak/zcc/blob/main/statement.c#L31" target="_blank" rel="noopener">parse_switch_statement</a></p><p>对于 <code>switch case</code> 这样的 statement 语句来讲，要构建的 ast 类似于下图</p><p><img src="./18.png" alt></p><p>在实现的过程中主要需要考虑几点</p><ol><li>如果是 <code>switch(xxx) {}</code> 这种情况，需要立刻停止解析</li><li>需要检查 <code>default</code> 之后是否还有 <code>case</code> 或者 <code>default</code></li><li>对于 <code>case 1:</code> 这个语句来讲，这个 <code>1</code> 必须是 <code>AST_INTEGER_LITERAL</code> 的类型</li><li>不允许有重复的 <code>case</code>，比如 <code>case 1:</code> 后面又跟了一个 <code>case 1:</code> 之类</li></ol><p>注意以上几点之后，解析的逻辑也就很简单了，基本上是按照 <code>switch case</code> statement 的代码顺序，先生成一个 <code>switch</code> 的头节点，再根据代码的书写将 <code>case</code> 和 <code>default</code> 节点生成出来并按照上图中 ast 那样的结构进行拼接，最终生成一个完整的 <code>swith case</code> 的 ast</p><p>这边就不再过多的描述代码细节了，因为逻辑比较简单</p><h2 id="break-continue-问题"><a href="#break-continue-问题" class="headerlink" title="break/continue 问题"></a>break/continue 问题</h2><p>对于 <code>break</code> 和 <code>continue</code> 来说，下面的代码是不成立的</p><p>比如</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为它们都没有进入 <code>while</code> 和 <code>for</code> statement 里的循环，那么如何解决这种情况呢? 很简单，加一个全局的 <code>loop_level</code> 变量，这个变量是用来标记要解析的 <code>while</code> 和 <code>for</code> statement 里面嵌套的层数。如果 <code>loop_level</code> 是 <code>0</code>，说明一层循环也没有进去，如果这时候解析到了 <code>break</code>/<code>continue</code>，就应该报错</p><p>那么代码就是这么写</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// statement.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 解析类似 break; 这样的语句</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> struct ASTNode *<span class="title">parse_break_statement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (loop_level == <span class="number">0</span>)</span><br><span class="line">    error(<span class="string">"no loop or switch to break out from"</span>);</span><br><span class="line">  scan(&amp;token_from_file);</span><br><span class="line">  verify_semicolon();</span><br><span class="line">  <span class="keyword">return</span> (create_ast_leaf(AST_BREAK, PRIMITIVE_NONE, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 解析类似 continue; 这样的语句</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> struct ASTNode *<span class="title">parse_continue_statement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (loop_level == <span class="number">0</span>)</span><br><span class="line">    error(<span class="string">"no loop to continue out from"</span>);</span><br><span class="line">  scan(&amp;token_from_file);</span><br><span class="line">  verify_semicolon();</span><br><span class="line">  <span class="keyword">return</span> (create_ast_leaf(AST_CONTINUE, PRIMITIVE_NONE, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以每次都要在解析 <code>while</code> 和 <code>for</code> statement 语句中更新对应的 <code>loop_level</code></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// statement.c</span></span><br><span class="line"></span><br><span class="line"><span class="function">struct ASTNode *<span class="title">parse_while_statement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  loop_level++;</span><br><span class="line">  statement_node = parse_single_statement();</span><br><span class="line">  loop_level--;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">struct ASTNode *<span class="title">parse_for_statement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  loop_level++;</span><br><span class="line">  statement_node = parse_single_statement();</span><br><span class="line">  loop_level--;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意到这里用到了 <strong>回溯</strong>，因为不可能在解析完一个 <code>while</code> 或者 <code>for</code> statement 之后，<code>loop_level</code> 还一直增长，应该是进入一个循环时就增加，出来一个循环时就减少，这样才方便判断解析到对应位置时究竟嵌套了多少层，那么也就知道这个位置适不适合放一个 <code>break</code>/<code>continue</code></p><p>而说到 <code>switch case</code> 这个语句，它里面的 <code>break</code> 同样只能存在于 <code>switch case</code> 中，至少要被一个 <code>switch case</code> 包裹住，道理跟之前说的一样，这里同样的加入一个全局变量 <code>switch_level</code> 来做标记</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> struct ASTNode *<span class="title">parse_switch_statement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  switch_level++;</span><br><span class="line">  <span class="comment">// 解析一个完整的 switch case 语句</span></span><br><span class="line">  <span class="keyword">while</span> (continue_loop) &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">  switch_level--;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而对于 <code>break</code> 语句而言，它的报错条件又多了一个，即 <code>switch_level</code> 不能为 0</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// statement.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 解析类似 break; 这样的语句</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> struct ASTNode *<span class="title">parse_break_statement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (loop_level == <span class="number">0</span> &amp;&amp; switch_level == <span class="number">0</span>)</span><br><span class="line">    error(<span class="string">"no loop or switch to break out from"</span>);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么什么时候应该将 <code>loop_level</code> 和 <code>switch_level</code> 初始化为 0 呢? 我们知道无论是 <code>while</code>/<code>for</code>/<code>switch case</code> statement 语句，它们最终都是要被 <strong>函数</strong> 所包裹起来的。在进入这个函数之前，应该要将它们初始化为 0。在走出这个函数之后，如果遇到新的函数，那么也应该将它初始化为 0，所以就对应于代码</p><p><a href="https://github.com/strugglebak/zcc/blob/main/declaration.c#L793" target="_blank" rel="noopener">declaration.c 中的 parse_function_declaration 函数</a></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">struct SymbolTable *<span class="title">parse_function_declaration</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">int</span> primitive_type,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">char</span> *function_name,</span></span></span><br><span class="line"><span class="function"><span class="params">  struct SymbolTable *composite_type,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">int</span> storage_class</span></span></span><br><span class="line"><span class="function"><span class="params">)</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// 如果是新函数那么应该初始化 loop level 和 switch level</span></span><br><span class="line">  loop_level = <span class="number">0</span>;</span><br><span class="line">  switch_level = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  verify_left_brace();</span><br><span class="line">  tree = parse_compound_statement(<span class="number">0</span>);</span><br><span class="line">  verify_right_brace();</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上基本就解决了 <code>break</code>/<code>continue</code> 中会出现的问题</p><h2 id="前缀-后缀操作符的处理"><a href="#前缀-后缀操作符的处理" class="headerlink" title="前缀/后缀操作符的处理"></a>前缀/后缀操作符的处理</h2><p>所谓的 <em>前缀</em> 操作符，就是 <code>&amp;</code>/<code>*</code>/<code>-</code>/<code>~</code>/<code>!</code>/<code>++</code>/<code>--</code> 这样的操作符在一个变量之前的情况，比如 <code>++y</code>、<code>*y</code> 等，而 <em>后缀</em> 操作符就是相反的情况(除了 <code>&amp;</code>/<code>*</code>/<code>-</code>/<code>~</code>/<code>!</code>)，比如 <code>y++</code>、<code>y--</code>，但还有 2 个特殊情况，比如</p><ul><li>解析到 <code>y[</code> 时，则看作是在解析数组，这个时候它要去访问数组里面的某个元素</li><li>解析到 <code>y.</code> 或者 <code>y-&gt;</code> 时，则看作是在解析 <code>struct</code>/<code>union</code>，这个时候它要去访问 <code>struct</code>/<code>union</code> 里的某个成员变量</li></ul><p>由于前缀操作符是在变量的前面，所以前缀操作符是优先被扫描的，那么 <strong>前缀操作符的优先级是大于后缀操作符</strong> 的。如果在扫描时，匹配不到 <code>&amp;</code>/<code>*</code>/<code>-</code>/<code>~</code>/<code>!</code>/<code>++</code>/<code>--</code> 这些符号，构建不了前缀操作符的 ast，那么就应该退而求其次，构建后缀操作符的 ast</p><p>对于解析有前缀操作符的表达式来说，可以 <em>递归</em> 地构建 ast，因为可能一个变量前面可能有多种前缀操作符的组合; 而对于解析有后缀操作符的表达式来说，可以 <em>循环</em> 地构建 ast，因为目前来讲除了解析数组和 <code>struct</code>/<code>union</code> 里面的 元素/成员 之外，就只剩下 <code>++</code> 和 <code>--</code>(目前语法还不考虑连续 <code>++</code> 和 <code>--</code> 的情况)</p><h3 id="数组元素中的偏移"><a href="#数组元素中的偏移" class="headerlink" title="数组元素中的偏移"></a>数组元素中的偏移</h3><p>对于 <code>int b[25];</code> 数组以及数组下标 <code>b[3]</code> 中的 <code>3</code> 来说，需要将这个 <code>char</code> 类型的 <code>3</code> 转变成 <code>int</code> 类型的 <code>3</code>(在本编译器中，所有的 integer literal 都默认是 <code>char</code> 类型)，也就是说，每当数组做访问时，比如访问 <code>b[3]</code>，在编译器看来是访问到了 <code>b[3 * 4]</code> 这个位置，即访问的单位不是 <code>1</code> 而是 <code>4</code> 了，而这个 <code>3 * 4</code> 所代表的，就是基于数组 <em>基地址</em> 的 <strong>偏移</strong></p><p>对于</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">b[<span class="number">3</span>] = <span class="number">12</span>;</span><br></pre></td></tr></table></figure><p>这样的语句，它生成的 ast 如下图</p><p><img src="./19.png" alt></p><p>在生成汇编时，<code>b</code> 节点，也就是 <code>AST_IDENTIFIER_ADDRESS</code> 节点，存储了这个数组的 <em>基地址</em> 信息，在经过 <code>AST_PLUS</code> 节点，会将这个 <em>基地址</em> 和已经 <em>scale</em> 成 <code>4</code> 倍的 <code>3</code> <strong>加起来</strong>，就得到了真正的 <code>b[3]</code> 所在的地址。最后再经过 <code>AST_DEREFERENCE_POINTER</code> 节点，<strong>拿到这个 <code>b[3]</code> 所在的地址的寄存器的位置</strong>，将 <code>12</code> load 进这个寄存器，即完成了赋值的操作</p><blockquote><p>注意之所以 <code>b[3]</code> 能被赋值，是因为此时的 <code>b[3]</code> 默认是一个 <em>左值</em>，如果需要它变成一个 <em>右值</em>，那么只需要在解析类似于 <code>a = b[3];</code> 这种情况时，将其置为 <em>右值</em> 即可</p></blockquote><p>那么对于语句</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a;</span><br><span class="line">a = b[<span class="number">3</span>];</span><br></pre></td></tr></table></figure><p>其对应的 ast 如下图</p><p><img src="./20.png" alt></p><p>那么在汇编里面的表现就是，<strong>将 <code>b[3]</code> 所在的地址的寄存器的位置里面的值，move 到 a 所在的寄存器里面去</strong></p><p>这里顺便说一句，对于指针来讲，处理解引用的过程和数组的操作类似，因为在 C 中，数组本身就可以看作是一个指针，这里就不再过多赘述了</p><h3 id="struct-union-成员变量中的偏移"><a href="#struct-union-成员变量中的偏移" class="headerlink" title="struct/union 成员变量中的偏移"></a>struct/union 成员变量中的偏移</h3><p><code>struct</code>/<code>union</code> 变量里面的成员变量也存在 <strong>偏移</strong>，比如</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fred</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> x;</span><br><span class="line">  <span class="keyword">char</span> y;</span><br><span class="line">  <span class="keyword">long</span> z;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>看上去 <code>x</code> 是占 <code>4</code> 个字节，而 <code>y</code> 是占 <code>1</code> 个字节，<code>z</code> 是占 <code>8</code> 个字节</p><p>但实际上这个 <code>fred</code> 占几个字节呢?</p><p>是 <code>16</code>，即 <code>4 + 4 + 8</code></p><p>这里涉及到一个 <em>内存对齐</em> 问题，不过后面在讲 back-end 的工作时会详细地说到 这个算法，这里简单说下，其实就是在解析 <code>struct fred</code> 时，对它里面的 <code>member</code> 成员的类型以及它的类型大小做一个判断，对其内存做一个简单的 <em>向上对齐</em>，<code>char y</code> 要对齐 <code>int x</code>，所以 <code>char y</code> 的位置占有 <code>4</code> 个字节</p><p>那么</p><ul><li>在访问 <code>fred</code> struct 里面的 <code>x</code> 时，需要跨越 <code>0</code> 个单位，因为 <code>x</code> 所在的位置是 <em>基地址</em></li><li>在访问 <code>fred</code> struct 里面的 <code>y</code> 时，需要跨越 <code>4</code> 个单位，因为要跨越的 <code>x</code> 是 <code>int</code> 是 <code>4</code> 个字节</li><li>在访问 <code>fred</code> struct 里面的 <code>z</code> 时，需要跨越 <code>8</code> 个单位，因为要跨越的 <code>y</code> 虽然是 <code>char</code>，但它实际上内存是向上对齐的，即向 <code>int x</code> 对齐，是 <code>4 + 4</code></li></ul><p>对于下面的代码</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fred</span> <span class="title">var2</span>;</span></span><br><span class="line">var2.x = <span class="number">12</span>;</span><br><span class="line">var2.y = <span class="string">'c'</span>;</span><br><span class="line">var2.z = <span class="number">4005</span>;</span><br></pre></td></tr></table></figure><p>其生成的 ast 分别为</p><p><code>var2.x = 12;</code></p><p><img src="./21.png" alt></p><p><code>var2.y = &#39;c&#39;;</code></p><p><img src="./22.png" alt></p><p><code>var2.z = 4095;</code></p><p><img src="./23.png" alt></p><p>通过上面 3 个图，可以很直观地看到 <code>offset</code> 偏移量在访问不同的 <code>struct</code>/<code>union</code> <code>member</code> 成员变量时是如何变化的</p><p>而根据 ast 寻找 <code>struct</code>/<code>union</code> 的过程跟数组那个是差不多的，区别只是计算 <code>offset</code> 的方式不同</p><ul><li>数组是通过数组变量声明的类型进行 <code>scale</code> 来计算</li><li><code>struct</code>/<code>union</code> 是通过其成员变量的类型进行 <em>内存对齐</em> 来计算</li></ul><blockquote><p>注意，对于 <code>union</code> 类型来说，其 <code>offset</code> 都是 <code>0</code>，这个就不再赘述了</p></blockquote><h2 id="peek-scan"><a href="#peek-scan" class="headerlink" title="peek scan"></a>peek scan</h2><p>这里的 <code>peek</code> 指的是 <strong>提前 scan 一些字符</strong>，以便于一些情况的判断，比如</p><ul><li>解析类似于 <code>int xxx(void) {}</code> 这种函数与 <code>int xxx(int a, int b) {}</code> 之间的区分，也就是扫描函数参数</li><li>解析类似于 <code>char *a = &quot;hello&quot; &quot;world&quot;;</code> 这种连续的字符串的赋值时</li></ul><p>这 2 种情况下，由于 <code>scan.c</code> 之前用的是一个全局的指针变量 <code>token_from_file</code>，再次调用 <code>scan</code> 函数时，<code>token_from_file</code> 里面的 <code>token</code> 会变化，会影响后续的 <code>scan</code> 工作，所以这里另外用了一个全局的指针变量 <strong><code>look_ahead_token</code></strong>，用这个来替代就不会有问题，即在需要 peek 字符串时调用 <code>scan</code> 函数，但参数传的是 <code>look_ahead_token</code></p><p>那么，代价是什么呢? 当然是需要对 <code>scan.c</code> 中的 <code>scan</code> 函数做适当修改，其实也很简单</p><p><a href="https://github.com/strugglebak/zcc/blob/main/scan.c#L315" target="_blank" rel="noopener">在 scan.c 中加入 look_ahead_token</a></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// scan.c</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">scan</span><span class="params">(struct Token *t)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> c, token_type;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果提前找到了 token，就直接返回这个 token</span></span><br><span class="line">  <span class="keyword">if</span> (look_ahead_token.token) &#123;</span><br><span class="line">    t-&gt;token = look_ahead_token.token;</span><br><span class="line">    t-&gt;token_string = look_ahead_token.token_string;</span><br><span class="line">    t-&gt;integer_value = look_ahead_token.integer_value;</span><br><span class="line">    look_ahead_token.token = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相当于是这里用 <code>look_ahead_token</code> 做了一个 “拦截”</p><h2 id="如何解析函数的递归调用"><a href="#如何解析函数的递归调用" class="headerlink" title="如何解析函数的递归调用"></a>如何解析函数的递归调用</h2><p>如果是有函数递归调用，怎么解析呢?</p><p>这个其实非常简单，甚至是不需要考虑的问题，因为函数本身就是由一些复合语句组成，而复合语句中可能会存在函数调用，只要解决了 <strong>函数声明和定义</strong> 以及 <strong>函数调用</strong> 的问题，那么这个问题也就相当于解决了。注意，编译器主要是对代码的 <em>翻译</em>，不会出现解析一段递归的代码而递归地去生成 ast。那么什么时候去执行这段需要进行递归处理的 ast 呢? 那自然是 back-end 的工作了</p><p>对于函数声明和定义来说，它大体上需要建立如下的 ast</p><p><img src="./24.png" alt></p><p>而对于解析函数的递归调用，比如经典的斐波那契代码</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span> (n);</span><br><span class="line">    <span class="keyword">return</span> (fib(n - <span class="number">1</span>) + fib(n - <span class="number">2</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"fib(10) = %d\n"</span>, fib(<span class="number">10</span>));</span><br><span class="line">  <span class="keyword">return</span> (<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 <code>fib</code> 函数会被解析为如下的 ast</p><p><img src="./25.png" alt></p><p>从上图可以看出，只要遵循后序遍历，在生成汇编代码的时候即可以生成对应的递归代码，相当于最后是用汇编实现了一遍这个递归代码</p><p>这里还需要注意的是，对于函数调用来说，比如 <code>func_name(param1, param2, param3, param4);</code>，<strong>它的参数有可能是一个值，也可能是一个表达式</strong>，所以对于这种 <code>AST_FUNCTION_CALL</code> 的节点来说，要构建如下的 ast</p><p><img src="./26.png" alt></p><p>对于这个 ast 来讲，就有必要 <strong>从右往左</strong> 做一个循环遍历，那么这么遍历的结果就是 <code>param4</code> &gt; <code>param3</code> &gt; <code>param2</code> &gt; <code>param1</code>，这样做的目的主要是为了后面生成汇编代码时，保证这些参数的 <strong>入栈顺序</strong> 正确</p><h2 id="如何解析头文件"><a href="#如何解析头文件" class="headerlink" title="如何解析头文件"></a>如何解析头文件</h2><p>以下要说的内容基于 <a href="https://github.com/strugglebak/zcc/blob/main/scan.c#L39" target="_blank" rel="noopener">scan.c 下的 next 函数</a></p><p>引入的头文件，一般会经过 gcc 编译器的 <em>预处理</em>，比如</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br></pre></td></tr></table></figure><p>这个引入的 <code>stdio.h</code>，大概会被 <strong>预处理器</strong> 解析成下面这样</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"># <span class="number">1</span> <span class="string">"z.c"</span></span><br><span class="line">...</span><br><span class="line"># <span class="number">1</span> <span class="string">"z.c"</span></span><br><span class="line"># <span class="number">1</span> <span class="string">"include/stdio.h"</span> <span class="number">1</span></span><br><span class="line"># <span class="number">1</span> <span class="string">"include/stddef.h"</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">size_t</span>;</span><br><span class="line"># <span class="number">5</span> <span class="string">"include/stdio.h"</span> <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> * FILE;</span><br><span class="line"></span><br><span class="line"><span class="function">FILE *<span class="title">fopen</span><span class="params">(<span class="keyword">char</span> *pathname, <span class="keyword">char</span> *mode)</span></span>;</span><br><span class="line">...</span><br><span class="line"># <span class="number">2</span> <span class="string">"z.c"</span> <span class="number">2</span></span><br></pre></td></tr></table></figure><p>这里只需要关注以 <code>#</code> 开头的语句，比如 <code># 1 &quot;include/stdio.h&quot; 1</code>，<code># 1</code> 表示当前解析的 <code>include/stdio.h</code> 这个文件解析到第 1 行了，最后面那个 <code>1</code> 不需要管他</p><p>那么基本上逻辑就是，<strong>对以 <code>#</code> 开头的语句，每一行进行逐行扫描，获取到它当前的解析到的第几行的位置，以及当前解析的文件路径</strong></p><p>那么拿到这两个有什么用呢? 主要是为了方便做后续的错误报错提示，解析到第几行，哪个文件报错是编译器需要提示给用户看的</p><p>同时，这里也是起到了对以 <code>#</code> 这种开头的语句的 <strong>过滤</strong> 作用，代码细节就不详细讲了，因为逻辑很简单，大家有兴趣的可以直接看源码</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li><code>scanner</code> 就是做分词的作用，主要逻辑就是将一些看上去能分开的词拆解成一些能用的上的 token 的这么一个流程</li><li><code>parser</code> 用到了一个巧妙的优先级算法实现操作符的左右结合性的问题，而对于左递归问题，需要把 BNF 定义好</li><li>类型检查和转换分隐式和显示，这个是整个编译器中比较绕的部分，但基本上也是根据左值右值的类型做判断和取舍，并最终生成 ast 的这么一个流程</li><li>Dangling Else 问题其实在解析时取一个就近原则就可以解决</li><li>对于不同的 statement 语句，需要从整体上将它们抽离出来，并用一个 <code>AST_GLUE</code> 节点将它们粘连起来</li><li><code>break</code>/<code>continue</code> 问题的解决方案之一就是看嵌套的深度</li><li>由于有类型检查和转换，所以对于不同类型的数组和不同类型的 <code>struct</code>/<code>union</code> 成员变量，就需要有对应的偏移量的处理</li><li>函数的递归调用问题其实已经在解析函数声明定义和调用这方面解决掉了</li><li>引入 <code>gcc</code> 预处理后，就可以引入头文件了，但是也要对这个被预处理器解析后的头文件进行处理才可以走正常的 parser 过程</li></ol><p>可以看到，在 front-end 端需要注意的细节有很多，但主要就是以上这些，其他的一些细节没有细讲是觉得没有必要。</p><p>在本篇的内容中，充斥的解释的图最多的还是 ast，由此可见在写 front-end parser 的过程中，通过 BNF 构建 ast 非常重要。不借助 BNF 工具写确实非常繁琐，但是同时也能最大程度的帮助理解这些工具的一些原理性的东西，以后用工具的时候就不会摸不着头脑了</p><p>以上</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;注意：本系列文章是 &lt;a href=&quot;https://github.com/strugglebak/zcc&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;zcc 编译器&lt;/a&gt; 总结系列文章，本系列文章并不打算呈现所有的代码细节（主要是细节太多了，全部呈现既不现实文章也看着冗长而没有意义）。因为是总结性质的文章，所以更多是分享实现的过程中个人感兴趣的点&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="编译原理" scheme="https://strugglebak.github.io/categories/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="编译原理" scheme="https://strugglebak.github.io/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>zcc-编译器开发总结-part1-前言</title>
    <link href="https://strugglebak.github.io/2022/06/05/zcc-%E7%BC%96%E8%AF%91%E5%99%A8%E5%BC%80%E5%8F%91%E6%80%BB%E7%BB%93-part1-%E5%89%8D%E8%A8%80/"/>
    <id>https://strugglebak.github.io/2022/06/05/zcc-编译器开发总结-part1-前言/</id>
    <published>2022-06-05T15:34:52.000Z</published>
    <updated>2022-06-05T15:36:54.922Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>注意：本系列文章是 <a href="https://github.com/strugglebak/zcc" target="_blank" rel="noopener">zcc 编译器</a> 总结系列文章，本系列文章并不打算呈现所有的代码细节（主要是细节太多了，全部呈现既不现实文章也看着冗长而没有意义）。因为是总结性质的文章，所以更多是分享实现的过程中个人感兴趣的点</p></blockquote><a id="more"></a><h2 id="编译器大体流程"><a href="#编译器大体流程" class="headerlink" title="编译器大体流程"></a>编译器大体流程</h2><p>大体流程都比较简单，其实就是经典的 3 个步骤</p><ol><li>词法分析</li><li>语法分析</li><li>语义分析</li><li>生成汇编代码</li><li>初始编译器编译链接执行</li></ol><p>词法分析：也就是写一个分词/扫描器，对整个要编译的文件进行扫描，将一些特殊的 <code>token</code> 比如符号或者数字等提取出来，然后将它们置为各种各样的 <code>state</code>，方便接下来的处理</p><p>语法分析：这个时候有了上面的词法分析，可以对整个语句的 <strong>语法</strong> 和 <strong>结构</strong> 进行分析了，比如整个语句要不要加分号，if 语句后面要不要接小括号之类的，整个语法应该怎么来，不符合语法的就报错</p><p>语义分析：所谓语义，就是语句中实际的含义，而这个含义必须是 <strong>绝对明确</strong> 的，比如 <code>int xxx = 1;</code>，它的 <em>语义</em> 就是 <em>把一个 32 位的整型常量存储到变量 xxx 中</em>，那么 <code>1</code> 这个有被明确定义成所谓的 <strong>32 位的整型常量</strong> 吗？语义分析部分要做的，就是确定这些东西的 <em>类型</em>，即所谓的 <strong>类型检查</strong>。这也是语义分析贯穿始终的一个步骤。而判断的点基本有</p><ol><li>判断表达式/变量的声明类型</li><li>判断变量赋值时是否有隐式的转换</li><li>如果有隐式转换则转，没有则报错</li><li>…</li></ol><p>生成汇编代码：这个没什么好说的，也算是编译器 back-end 的工作了，基本上在 <code>zcc</code> 的代码实现中，就是基于语法分析和语义分析之后生成的 ast，生成对应的汇编代码。然后再让最初始的编译器，编译这段汇编代码，然后执行</p><h2 id="那么-zcc-主要做了哪些事情"><a href="#那么-zcc-主要做了哪些事情" class="headerlink" title="那么 zcc 主要做了哪些事情"></a>那么 zcc 主要做了哪些事情</h2><ol><li>有一个 <code>scan.c</code>，这个就是用来扫描代码文件并生成对应的 <code>token</code>，同时对每个扫描到的 <code>token</code> 生成对应的 <code>state</code></li><li>有一个 <code>parser.c</code>，主要根据 <code>token</code> 将语句拆成一个个的 <code>node</code>，然后将这些 <code>node</code> 组装成 一个 <code>token</code> 类型的 ast</li><li>有一个 <code>statement.c</code>，主要根据关键字比如 <code>if</code>/<code>while</code>/<code>return</code> 等等把对应的语句组装成一个 <code>ast</code> 类型的 ast</li><li>有一个 <code>declaration.c</code>，这个算是最重要的文件，解析和判断各种语句的声明定义，并根据解析好的 ast 生成汇编代码</li><li>有一个 <code>generator.c</code> 以及 <code>generator_core.c</code>，用于生成汇编代码的工具函数文件</li></ol><p>那么 zcc 是严格按照编译器大体流程来的吗，是的，也不全是，似乎在大多数人的印象中，这几个步骤都是先对一整个代码文件进行分析，分析完成后再进行后面的操作，比如先把代码文件分析成 <code>token</code>，然后后面再基于这个操作进行语法和语义分析。诚然这也是编译器的一种写法，然而本 zcc 编译器则是 <strong>分析一小段代码 -&gt; 解析成 token -&gt; 生成这部分的一个 ast 节点 -&gt; 再分析一小段代码 -&gt; 解析成 token -&gt; 然后和上一个 ast 节点组合生成一个新的 ast 节点</strong> 这样的一种循环，直到对 <code>main</code> 函数的解析结束（这个时候分析到文件结尾了），文件的全部 ast 已经组装完成，这个时候再对这部分 ast 生成对应的汇编。</p><blockquote><p>这里引用《编译原理之美》的一张图，解析 <code>int age = 45; ...</code>，可以表达我上面所说的情况<br><img src="./1.png" alt></p></blockquote><p>所以相对于前面的那种方式而言，在编写编译器的过程中代码组织会相对简单（目前暂不考虑所谓的性能问题）</p><h2 id="本系列文章总结的主体内容"><a href="#本系列文章总结的主体内容" class="headerlink" title="本系列文章总结的主体内容"></a>本系列文章总结的主体内容</h2><p>目前的规划如下</p><ol><li>zcc 编译器的 front-end 端有哪些值得注意的点</li><li>zcc 编译器的 back-end 端的一些原理</li><li>zcc 编译器的 middle-end 端如何实现的(对的，本编译器实现了一个比较简单的优化过程)</li><li>zcc 编辑器是如何将文件 <em>链接</em> 起来然后编译的</li><li>展望一下编译器还能继续做哪些事情(可能会写)</li></ol><p>大致就这些</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;注意：本系列文章是 &lt;a href=&quot;https://github.com/strugglebak/zcc&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;zcc 编译器&lt;/a&gt; 总结系列文章，本系列文章并不打算呈现所有的代码细节（主要是细节太多了，全部呈现既不现实文章也看着冗长而没有意义）。因为是总结性质的文章，所以更多是分享实现的过程中个人感兴趣的点&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="编译原理" scheme="https://strugglebak.github.io/categories/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="编译原理" scheme="https://strugglebak.github.io/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>CMU-15-445-645-笔记-08-树索引-part2</title>
    <link href="https://strugglebak.github.io/2022/06/05/CMU-15-445-645-%E7%AC%94%E8%AE%B0-08-%E6%A0%91%E7%B4%A2%E5%BC%95-part2/"/>
    <id>https://strugglebak.github.io/2022/06/05/CMU-15-445-645-笔记-08-树索引-part2/</id>
    <published>2022-06-05T15:22:34.000Z</published>
    <updated>2022-06-05T15:26:23.508Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>注: 本文首发我的 b 站专栏文章<a href="https://www.bilibili.com/read/cv14653843" target="_blank" rel="noopener">CMU 15-445/645-笔记-08-树索引-part2</a></p></blockquote><a id="more"></a><p><img src="./Cover.png" alt></p><ul><li><p>课程目标</p><p>  <img src="./1.png" alt></p></li><li><p>B+ Tree: 重复的 Key</p><p>  <img src="./2.png" alt></p><ol><li><p>在索引中插入的 key 后面追加它所对应的 tuple 的 record ID<br> 例子</p><p> <img src="./3.png" alt></p><p> 注意，数据库系统实际所保存的是 key 和 record ID 这样的组合，所以这里 insert 6 先做的是前缀搜索</p><p> 比如现在要插入 6，找到对应的叶子节点</p><p> <img src="./4.png" alt></p><p> 因为 6 &lt;= insert 6 &lt; 7，所以要对这个叶子节点进行拆分</p><p> <img src="./5.png" alt></p><p> 大部分人会选择实现第 1 种方式，因为这种方式不会对数据结构进行任何改动，不管是唯一索引还是非唯一索引，所有东西都和之前的一样。缺点就是要将 record ID 作为 key 的额外元素保存起来，而这就会增加索引的 size</p></li><li><p>将重复的 key 保存在 overflow 的叶子节点上，但这种方式是违反 B+ Tree 设计规则的。这里并不是将叶子节点进行水平扩展去容纳新的 entry，而是将叶子节点进行垂直拓展，在给定的叶子节点下面添加这些 overflow page  ，即跟之前讨论的 chained hash 表差不多的思路<br> 比如现在要插入 6，找到对应的叶子节点</p><p> <img src="./6.png" alt></p><p> 现在不需要对那个叶子节点做拆分，而是在这个节点上加一个 overflow page，然后把 6 插入到这个 overflow page 上，该叶子节点只需要有一个指针指向这个 overflow page 即可</p><p> <img src="./7.png" alt></p><p> 继续插入 7 和 6，都是在这个 overflow page 下，注意此时的 overflow 存放 6 和 7 的顺序，它是无序的，但这是 OK 的</p><p> <img src="./8.png" alt></p><p> 第 2 种方式更复杂，因为这就意味着必须处理沿着叶子节点进行扫描时所发生的情况，比如如何向下处理这些 overflow page。</p><p>默认情况下，在 MySQL 和大多数数据库系统中，如果创建了一个索引，那么这个索引使用的就会是 B+ Tree 或者其他 tree 数据结构</p><p>在 PostgreSQL 中，可以强制让它使用 hash 索引，比如这样的语句</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">CREATE INDEX idx_emails_hash ON emails USING HASH (email);</span><br></pre></td></tr></table></figure><p>也可以强制使用 B+ Tree 索引，比如如下的语句</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">CREATE INDEX idx_emails_tree ON emails USING BTREE (email);</span><br></pre></td></tr></table></figure><p>但当执行查询时，query planner 在某些查询上并不会使用索引，但在执行其他查询时会去使用索引。如果使用的是 hash 索引，那么就必须使用完整的 key 或者该 key 中完整的元素去做查找</p><p>比如在 hash 索引里做查询时，可以使用 <a href="mailto:&#39;00@00.00" target="_blank" rel="noopener">&#39;00@00.00</a>‘ 这种精确的匹配的查询条件去查，但是使用 ‘00@00%’ 这种模糊匹配就不行</p><p><img src="./9.png" alt></p><p>顺便，如果无法通过索引来找到它们想要的，那么数据库系统会始终默认使用循序扫描来查找</p><p><img src="./10.png" alt><br><img src="./11.png" alt></p><p>如果查询语句中有一个 OR 子句，那么可以看到这里能够使用 2  个索引来进行扫描，即用其中一个索引来尝试找到想要找的数据，接着再使用另一个索引来，然后将它们的结果合并在一起</p><p>而这就是 bitmapOr 所做的事情</p><p>bitmap index（位图索引）会尝试找到所有匹配的结果，然后通过存储的 record ID 集合来维护这个庞大的 bitmap，通过该 bit 可以拿到所匹配的 record 的 offset 值。再然后它将这 2 个索引所产生的结果放在一起，并生成输出结果</p><p>table clustering 指的是，通过聚簇索引来对表中的 tuple ，强制按照某种顺序排列</p><p>使用 CLUSTER 命令会强迫 PostgreSQL 根据索引定义来对整个表重新排序</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">CLUSTER emails USING idx_emails_tree</span><br></pre></td></tr></table></figure><p>但这是一个一次性的 操作</p><p>在 MySQL、SQL Server 和 Oracle 中使用聚簇索引时，能确保不管往数据库中插入的值的顺序是怎么样的，底层的物理存储会是有序的</p><p>那么为什么有些时候在不适用索引的情况下，查找的时间复杂度依然是 O(log n) 呢？因为当整张表的 tuple 是根据某个字段进行有序插入的，那么就可以根据二分来对某一条数据进行查找</p><p>为什么不使用 tuple 插入时的时间戳来代替 record ID 这样的设计呢？</p><p>因为可能会遇上闰秒和闰年，以及如果本地始终比较慢，先插入了一些数据，经过时间校正后又插入一波数据，那么时间戳可能存在重复</p></li></ol></li><li><p>Implicit 索引</p><p>  <img src="./12.png" alt></p><p>  所有数据库系统都会自动为主键做唯一性约束</p><p>  <img src="./13.png" alt></p><p>  当创建表时，如果主键唯一，那么和运行上图中的那些命令的效果是一样的</p><p>  即当创建表时，它就会去创建这些索引</p><p>  而对于外键来讲，数据库就不会做这些事情了</p><p>  <img src="./14.png" alt><br>  <img src="./15.png" alt></p><p>  这种做法会报错，因为在没有索引的情况下，无法强行使用引用完整性约束（referential integrity constraint）</p><p>  相反，只能在该处添加一个 UNIQUE 关键字，这会让数据库自动去构建一个索引</p><p>  <img src="./16.png" alt></p></li><li><p>部分索引（Partial Indexes）</p><p>  <img src="./17.png" alt></p><p>  对于许多应用程序而言，可能不需要在整个表上使用索引，而是在某些数据子集上进行索引</p><p>  比如如下的语句，只在对应的条件下才建立索引</p><p>  <img src="./18.png" alt></p><p>  <img src="./19.png" alt></p><p>  如果其他查询中没有这个 WuTang，那就没法使用索引</p><p>  这种方式非常常见，比如可以通过不同索引将不同日期范围的数据分开，在每个月份上建立索引，这样可以以想要的顺序在该月份中进行快速查找</p><p>  使用一个部分索引可以避免一堆不需要的数据去污染 Buffer 池，同时树的高度也会变得更低，这样就有利于更快的查找</p></li><li><p>覆盖索引（Covering Indexes）</p><p>  <img src="./20.png" alt></p><p>  覆盖索引指的是，响应查询需求的结果中所需要的所有的字段，都能在索引本身中找到</p><p>  不需要将一个索引声明为覆盖索引，数据库系统会自动帮你做这件事</p><p>  比如下面的查询，可以从这个索引中准确地找到 a 和 b 字段，也不需要去看实际的 tuple 是什么样的（可以直接越过查询 tuple，因为索引已经给出来了？注意这里要找的 tuple 都是放在表堆 table heap 里面的，它们并不是叶子节点，叶子节点都是索引。找 tuple 的过程是指，通过 B+ Tree 拿到 page ID 和 offset，然后到 Buffer 池中找到这个 page 对应的 tuple）</p><p>  <img src="./21.png" alt></p><p>  在通过 page ID 和 page 表进行查找时，可能需要一次磁盘 I/O，而覆盖索引无须这样去查看底层 tuple</p></li><li><p>索引包含列（Indexes include colunms）</p><p>  <img src="./22.png" alt></p><p>  <img src="./23.png" alt></p><p>  在上图这个例子中，在 a 和 b 上建立了索引，所有的 inner node 上只保存了 key a 和 b，当进行查找时，只需对 a 和 b 进行检查即可，但当落到叶子节点上时，也能得到在该叶子节点上每个 entry 的 c 属性的值</p><p>  <img src="./24.png" alt></p><p>  如上图，先对 a 进行查找，然后顺着往下，当沿着叶子节点进行扫描时，可以看看打包放在叶子节点中 c 属性的值，然后根据条件来判断该值，找到对应的 tuple</p><p>  尽管可以通过 where 里面的 c 来进行查找，但它不在 inner node 中，所以这并不会让索引整体的 size 变得更大</p></li><li><p>函数式/表达式索引（Functional/Expression Indexes）</p><p>  <img src="./25.png" alt></p><p>  它的思路是，通过该 key 衍生出来的某些值而不是通过 key 自身的值来进行查找</p><p>  <img src="./26.png" alt></p><p>  注意，dow 指的是 day of week，这里表示的是从 login 字段中提取出星期几，2 就是星期二，0 就是星期日，1 就是星期一</p><p>  而这样创建索引是不对的，因为创建索引时没给出条件，即 users(login) 中，哪些条件是符合 dow From login 为星期二的 tuple 的，没给出条件就会为所有的这些 tuple 创建索引</p><p>  <img src="./27.png" alt></p><p>  所以所有放在 where 里的东西，都可以对其建立索引</p></li></ul><p><img src="./28.png" alt></p><p>在整个树形结构中，key 会被多次复制，同时为了判断该 key 是否存在于表中，就必须跑到叶子节点上，遍历它们，因为 inner node 可能会保存那些不再存在于 tree 中的 key 的拷贝，它们要用这些 key 当作路标</p><p>如果 Buffer 池中并没有缓存要找的叶子节点中所在的 page，那么就会出现 page miss 的情况，那么在向下遍历 tree 时，就会得去磁盘上对每个节点进行查找</p><p>所以，如果不去遍历 tree 的底部叶子节点，在 tree 的顶部就能知道 key 是否存在于表中的话，就很棒了</p><p>而这就是 Trie 索引能够去做的事情</p><ul><li><p>Trie 索引</p><p>  <img src="./29.png" alt></p><p>  radix tree 是 trie tree 的一种特殊版本，没人会在数据库中使用 trie，他们用的都是 radix tree</p><p>  trie tree 会保存 key 的 digit，即 key 中的某些原子子集，比如一个字节或者一个 bit 之类的</p><p>  思路是，将所有的 key 分解，将这些分解后的 digit 一个个地存放在 tree 中的不同层里，因为可能会遇到重复的 digit，那么在每一层保存它一次即可</p><p>  一个 key 就对应一条路径，不同的遍历不同的向下路线就能将这些 digit 拼凑出不同的 key 来</p><p>  B+ Tree 是 1973 年被 IBM 发明出来的，而 Trie Tree 是由一名法国老哥在 1959 年发明出来的，但他没有以此来命名这个 Tree，而是由另一位 CS 领域的著名研究人员 Edward Fredkin，在一两年后，他给这个 Tree 结构起名叫 Trie，它是 Retrieval Tree 的简写</p></li><li><p>Trie 索引的属性</p><p>  <img src="./30.png" alt></p><p>  Trie 的形状取决于 key 的分布以及它们的长度，它是一个确定的数据结构，不管插入 key 的顺序如何，最终都会得到相同的物理数据结构也就是节点布局</p><p>  而 B+ Tree 则不同，它如果进行重建了，将这些 key 插入到另一个 tree 中，最终可能会得到不同的节点布局</p><p>  Trie Tree 不需要像 B+ Tree 那样进行重新平衡（垂直层面可能可以进行平衡，但水平层面确实不行）</p><p>  Trie 中，操作的复杂度都是 O(K)，K 指的是 key 的长度</p><p>  对于点查询来讲，Trie 的速度要比 B+ Tree 快的多，但如果是扫描，那么就相反，因为 Tire 需要通过回溯来进行查找</p></li><li><p>Trie Key Span</p><p>  <img src="./31.png" alt></p><p>  span 这个术语可以以同样的方式用在 B+ Tree 的节点上</p><p>  span 其实就是树枝向外分叉的个数，即在树的每层每个节点中 digit 的个数</p><p>  span 被用来决定是否对每个节点进行扇出（fan-out）操作</p><p>  比如 fan-out 的量为 n，那么就是每个节点最多有 n 条路线，这会决定 Trie 在每一层所保存的 digit 的数量</p><p>  一个 1 bit trie 的例子</p><p>  <img src="./32.png" alt></p><p>  这个位置，所有 key 的前 10 位都是 0，并且它们向下走的方向都是一致的，而且前 10 位里面没有 1</p><p>  <img src="./33.png" alt></p><p>  但是到达上图中的那个位置时，对于 K10，它在这个位置的数字是 0，所以它就该走左边这条路线，对于 K25 和 K31，它们在这个位置的值都是 1，所以它们应该走右边这条路线</p><p>  <img src="./34.png" alt></p><p>  现在来看上图中 K10 的剩余部分，走的路线就是 1010，走到尽头就是一个 record ID，它指向了对应的 tuple</p><p>  <img src="./35.png" alt></p><p>  而对于另一边也是一样的</p><p>  查找思路和普通的 trie 都差不多，这里只是比对 1 bit</p><p>  实际上这里可以有优化的点，比如，如何减少 Trie 的 size 呢？</p><p>  不需要使用空间来标记这些 0 和 1</p><p>  <img src="./36.png" alt></p><p>  它实际上应该像上图那样，要做的只是保存这些指针。如果 bit 是 0，那么它的 offset 也是 0，如果 bit 是 1，那么它的 offset 也是 1</p><p>  这就是水平压缩，它能减少每个 Trie 节点 size 的大小</p><p>  那么另一种压缩方式是啥呢？</p><p>  <img src="./37.png" alt></p><p>  一旦到了图中画橘色框的位置，就没有其他 key 能匹配这些路径了，那么橘框位置就无须存储任何东西（这些可以用栈来存储），因为路线已经出来足以分辨哪些是 K10、K25 和 K31</p><p>  <img src="./38.png" alt></p><p>  上图中，从左往右，第一个 Tuple Pointer 处那个位置，只匹配了 K10 这个 key</p><blockquote><p>注意：这里可以理解为一种懒比较策略，在比较前 11 位 bit 时，就可以将 K10 从 K25 和 K31 中分辨出来，而比较到前 13 位时，就可以将 K25 和 K31 分辨出来，而没有必要再继续一位一位地比较下去了</p></blockquote><p>  是垂直压缩，即移除掉了无用分支路径，看似有多条路径，但只有 1 条是存储了明确的 key 的路线</p></li><li><p>对 Radix Tree 进行修改</p><p>  insert HAIR</p><p>  <img src="./39.png" alt></p><p>  delete HAT</p><p>  <img src="./40.png" alt></p><p>  delete HAVE</p><p>  <img src="./41.png" alt></p><p>  删除 HAVE 后可以选择将 IR 和 A 放在一起</p><p>  <img src="./42.png" alt></p><p>  德国的 Tableau 推出了一款叫 Hyper 的系统，它能够兼容 PostgreSQL，而这个系统是基于 Trie 构建出来的，</p></li></ul><p><img src="./43.png" alt></p><p>对于 B+ Tree 和 hash 表来讲，当用它们进行关键字搜索时，效果都不太好，因为这里面属于模糊查找，即要找的是某个属性中的一个子元素</p><p>对于 B+ Tree 来讲，在单个属性中，必须使用该属性完整的值进行查找，不能只使用它里面的部分值进行查找，比如它的前 16 bit</p><p><img src="./44.png" alt><br><img src="./45.png" alt></p><p>如果试着在 content 这个字段上构建索引，会是一个 bad idea，因为它会尝试使用表中这个属性里的 整个内容，来构建出 B+ Tree，然后有些 content 的 size 是按照 KB 来算的</p><p>这样做的结果就是，根据一个 key 做查找时，会返回整篇文章，这无疑是很蠢的</p><p>倒排索引（Inverted Indexes）可以解决这个问题</p><ul><li><p>倒排索引（Inverted Indexes）</p><p>  <img src="./46.png" alt></p><p>  aka 全文搜索索引（full-text search index）/ 词语索引（concordance）</p><p>  倒排索引会将 word（这里指文字/单词，不是 CPU 中的字节序列） 映射到英语或者其他自然语言的词汇中，映射到包含这些单词的 record 上</p><p>  全文搜索数据库有很多，比如那个最出名的 ElasticSearch，它是建立在 Lucene 之上的 DBMS，而 Lucene 是由一个发明了 Hadoop 的人编写的，ElasticSearch 为搜索时用到的索引提供了一个服务端接口工具。Sphinx 也用到了 Lucene。Xapain 是一个 C++ 标准库，也是用来进行全文搜索和索引查找的，比 MySQL 的全文搜索索引好</p><ul><li><p>查询类型</p><p>  以下几种查询类型都无法在 B+ Tree 中进行，但可以在倒排索引中进行</p><p>  <img src="./47.png" alt></p><ol><li>词组搜索</li><li>近似搜索</li><li>通配符搜索</li></ol></li><li><p>如何去构建倒排索引</p><p>  <img src="./48.png" alt></p><p>  最简单的方式就是将这个单词映射到一个 record ID 上，也可以将这个单词周围的其他单词也加进去，距离其他单词由多远这样的信息也可以加进去</p><p>  如果倒排索引是内置的，那么每次更新时要确保更新了倒排索引<br>  如果倒排索引是外置的，可以将它作为计划任务来执行，或者是将更新推送给对应的系统，比如 ES</p><p>  通常更新是分批进行的，因为对倒排索引进行更新的代价非常高昂</p></li></ul></li><li><p>结论</p><p>  <img src="./49.png" alt></p><p>  这里还有另一类索引没有讨论，比如地理空间索引（Geo-Spatial Indexes），R-Tree，Quad-Tree 和 KD-Tree，这些在视频数据库和图数据库中非常常见，CMU 15-826 有对应的内容</p><p>  倒排索引相关课程在 CMU 11-442/11-642，其实也就是搜索引擎的内容</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;注: 本文首发我的 b 站专栏文章&lt;a href=&quot;https://www.bilibili.com/read/cv14653843&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;CMU 15-445/645-笔记-08-树索引-part2&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Database" scheme="https://strugglebak.github.io/categories/Database/"/>
    
    
      <category term="Database" scheme="https://strugglebak.github.io/tags/Database/"/>
    
  </entry>
  
  <entry>
    <title>CMU-15-445-645-笔记-07-树索引-part1</title>
    <link href="https://strugglebak.github.io/2022/06/05/CMU-15-445-645-%E7%AC%94%E8%AE%B0-07-%E6%A0%91%E7%B4%A2%E5%BC%95-part1/"/>
    <id>https://strugglebak.github.io/2022/06/05/CMU-15-445-645-笔记-07-树索引-part1/</id>
    <published>2022-06-05T14:40:51.000Z</published>
    <updated>2022-06-05T15:19:38.324Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>注: 本文首发我的 b 站专栏文章<a href="https://www.bilibili.com/read/cv14653694" target="_blank" rel="noopener">CMU 15-445/645-笔记-07-树索引-part1</a></p></blockquote><a id="more"></a><p><img src="./Cover.png" alt></p><ul><li><p>课程目标</p><p>  <img src="./1.png" alt></p></li><li><p>表索引</p><p>  <img src="./2.png" alt></p><p>  做一定范围扫描的查询需要用到表索引，在这种情况下，hash 表并不能满足要求，因为 hash 表只能用来进行单个 key 的查找</p><p>  <img src="./3.png" alt></p><p>  那么表索引是什么？</p><p>  简单来讲，表索引就是 表中属性 的 子集 的一个 副本，它以一种更高效的方式存储，以方便能做更高效的查询操作（相比循序扫描来说）</p><p>  注意，表索引是该表的一个副本，它必须和表保持同步。比如如果表中的某个 tuple 有更新，那么这个更新也应该反映到对应的索引上</p><p>  表索引的操作对于应用开发人员来讲，是完全透明的</p><p>  <img src="./4.png" alt></p><p>  虽然大量的索引可以让查询变得更快，但维护这个表索引也需要一定的代价，所以就存在 trade-off。比如大量的索引会占用 page 和 Buffer 池的空间，将它写出到磁盘时，就会占用磁盘空间。如果表里面有 1000 条索引，现在要进行插入操作，那么就必须对这些索引更新 1000 次，直到这些索引被修改完成，这个插入操作才会被认为已经完成了。</p><p>  在做查询操作时，DBMS 自己会去选择对于查询来讲最优的索引，即查询优化</p></li><li><p>B+ Tree</p><p>  <img src="./5.png" alt></p><p>  有一类数据结构叫做 B-Trees（B 树家族），在它里面，有一种特定的数据结构，叫做 B-Tree。</p><p>  实际上 B-Tree 和 B+ Tree 是不同的数据结构</p><p>  B-Tree 是在 1971 年提出的，2 年后的 1973 年提出的 B+ Tree，那个时候并没有什么 paper 去描述什么是 B+ Tree，不过 1979 年倒是有篇 paper 做了对 B+ Tree 和 B-Tree 的描述</p><p>  顺便，IBM 在 1973 年发明了 B+ Tree</p><p>  然后在 70-80 年代间，出现了它们的很多变种，比如 B* Tree 是 B-Tree 的变种，而 B^link - Tree 是在 1981 年出现的，由 CMU 首发</p><p>  <img src="./6.png" alt></p><p>  即 《Efficent Locking for Concurrent Operations on B-Trees》，作者 Philip Lehman，现在依然在 CMU</p><p>  数据库系统一般用的是 B+ Tree 而不是 B-Tree，虽然 PostgreSQL 文档中写的是用 B-Tree，但实际上它用的就是 B+ Tree</p><p>  <img src="./7.png" alt></p><p>  B+ Tree 是一种自平衡的树形数据结构，B means Balance</p><p>  基本思想是，往 B+ Tree 中插入数据时，它会保证数据的有序性，这允许我们可以沿着叶子节点进行高效的搜索或者循序扫描，插入和删除的时间复杂度都是 O(log n)，因为 B+ Tree 是平衡的，所以它的复杂度始终是 O(log n)，即对于一个叶子节点上的任何 key 来说，不管它距离根节点有多远，时间复杂度始终是 O(log n)</p><p>  B+ Tree 是这样一种数据结构，它能在磁盘非常缓慢，并且内存有限的情况下，进行高效地索引查找</p><p>  相比于 B-Tree，B+ Tree 有一个很棒的优势，就是当遍历到 B+ Tree 底部时，可以沿着叶子节点进行循序扫描，无须回过头再递归遍历。因为从上到下，按范围找到了树的父节点下指代的某段区域叶子节点，结果就在这个范围内，循序扫描就好了</p><p>  一篇被很多人引用的 paper – 《The Ubiquitous B-Tree》</p><p>  那么 B+ Tree 有哪些属性呢？</p><p>  <img src="./8.png" alt></p><p>  B+ Tree 被认为是一种多路查找树（Multi-way search tree），意味着在树中的每个节点处，它可以通过 M 条（也不完全总是 M 条）不同的路线到达其他节点</p><p>  注意，这里的 平衡 指的是，任何叶子节点到根节点始终是 O(log n)</p><p>  这里，每个节点必须保证至少是半满的，对于能存放自节点中 key 的数量来说，B+ Tree 中节点所管理的 key 的数量至少为 M/2 - 1 个（这里的 M 指树的高度），但 key 的数量必须小于 M - 1。删除的时候，如果节点不处于半满的状态，那么就得将周围得数据移到这个节点中，让它变成半满的状态</p><p>  如果一个 inner node 中有 k 个 key，那么对于这个 inner node 来讲就有 k + 1 个非空 children 节点</p><p>  例子</p><p>  <img src="./9.png" alt></p><p>  在任何 inner node 中，它们并没有 sibling pointer，但叶子节点有</p><p>  <img src="./10.png" alt></p><p>  inner node 是 key 和 指针 的结合体，inner node 里面的指针始终指向的是另一个节点，如果什么也没有就指向 null，key 就是在任意属性上构建的索引。当使用一个给定的 key 来进行搜索时，可以通过比对这些 inner node 中 key 的大小来决定该往哪边遍历</p><p>  <img src="./11.png" alt></p><p>  对于叶子节点，它有 key 也有 value，这个 value 可以是一个 tuple 的 record ID，也可以是 tuple 自身</p><p>  inner node 主要保存的是指针，而叶子节点主要保存的是数据</p><p>  <img src="./12.png" alt></p><p>  每个 B+ Tree 的节点其实就是一个 key/value 对 数组。如果你是在叶子节点上，那么可以通过 key 来判断这是不是你要的东西；如果是在 inner node 上，那么可以通过 key 来判断你是往左走还是往右走</p><p>  例子</p><p>  <img src="./13.png" alt></p><p>  图中可以看出，B+ Tree 中叶子节点里，key/value 对是分开存储的，但这里的 key/value 始终都在同一个 page 上，分开存的原因是它们的大小不一样</p><p>  使用二分查找并不需要用到 value，只需要用到的是 key，分开来可以更高效地在 key 之间跳转，而 value 通常情况下是固定长度的，可能是 32/64 bit 长度的 record ID。</p><p>  <img src="./14.png" alt></p><p>  它的工作方式是，无论 key 数组中的 offset 值是什么，它始终对应了 value 数组中的某些 offset 值</p><p>  <img src="./15.png" alt></p><p>  叶子节点通常有 2 种值</p><ol><li>record ID</li><li><p>Tuple 数据</p><p>Tuple 数据实际上是存放在叶子节点上的，第二索引把 record ID 作为值存起来</p><p>MySQL 和 SQLite 大概就是方案 2 存法，而 Oracle 和 SQL Server 默认情况下使用的是方案 1（也就是说它们也可以选择方案 2）</p></li></ol></li><li><p>B-Tree vs. B+ Tree</p><p>  <img src="./16.png" alt></p><p>  在 B-Tree 中，value 可以存放在树的任何位置，即任何 inner node 可以保存 record ID 或者 tuple 之类的 value</p><p>  而在 B+ Tree 中，value 只能放在叶子节点中</p><p>  那这意味着什么呢？</p><ol><li>在 B-Tree 中，不会有任何重复的 key</li><li><p>在 B+ Tree 中，在 inner node 中会存放所有的路标，也就是说会有重复的 key。此外如果删除了 B+ Tree 上的一个 key，也是基本上是从叶子节点上移除，并且把这个 key 保存在 inner node 中。因为如果要查找其他的 key，还可以通过这条路线往下查找</p><p>相比之下，B-Tree 更加经济，占用的空间也少。但当使用多个线程来进行更新操作时，代价会更加昂贵。比如修改/删除某个 inner node 里面相关指针的指向，在并发操作下是需要保护的</p><p>在 B+ Tree 中，只会对叶子节点进行修改，可能需要将修改结果向上传播，那么只需要一个方向上的指针就可以做到</p></li></ol></li><li><p>B+ Tree 插入</p><p>  <img src="./17.png" alt></p><p>  插入就是先从 inner node 上根据二分查找对应的 key，小的走左边大的走右边，然后找到叶子节点中有空间的位置进行插入。如果这个叶子节点没空间了，那么就必须拆分这个叶子节点</p><p>  怎么拆分呢？</p><p>  找到叶子节点的中间位置，将中间位置左边的所有 key 放入一个节点，中间位置右边所有的 key 放入另一个节点，然后更新父节点，让它包含中间这个 key。接着让一个额外指针来指向刚刚添加的新节点</p><p>  对于一次插入来说，可能就需要重新整理下整个树了</p><p>  一个 B+ Tree 的可视化 demo</p><p>  <a href="https://cmudb.io/btree" target="_blank" rel="noopener">https://cmudb.io/btree</a></p><p>  注意这里 degree 的意思是，从节点处最多能出来几条路线，比如 degree = 3，对于 inner node 来讲，最多只能保存 2 个 key</p><p>  插入是一个递归的过程，随着插入更多的元素，会继续对节点进行拆分，并将这些变化向上传递</p><p>  如果有重复的 key 怎么办？</p><p>  <img src="./18.png" alt></p><p>  那么就会是如上图那样的结构，在真实的系统中，重复的 key 可以存在，只需要维护拥有同一个 key 下多个 entry 所对应的值，即每个 entry 对应一个唯一值即可</p></li><li><p>B+ Tree 删除</p><p>  <img src="./19.png" alt></p><p>  删除操作会导致节点上保存的 key 的数量小于半满的情况，这就会违反在 B+ Tree 中必须遵守的原则，因此就得做拆分的逆向操作，也就是 合并</p><p>  一个简单技巧就是看下临近的其他叶子节点中的元素，并尝试从它们中抢一个 key 过来，以此让树变得平衡</p><p>  只要兄弟节点和这个要抢别人 key 的节点有相同的父节点，那么就可以去抢，因为这就不需要对上面那些节点做任何重新平衡的操作了</p><p>  合并的工作方式是，向下遍历，会维护一个 stack，里面包含了它向下遍历元素的记录。实际上在向下遍历时，会进行 latch crabbing 或者是 coupling 之类的事情。</p></li><li><p>B+ Tree in Practice</p><p>  <img src="./20.png" alt></p><p>  通常情况下，使用 B+ Tree 保存的数据，实际上只有大概 67% 是有用的，其他的都是初始数据或者未知数据</p></li><li><p>聚簇索引（Clustered Indexes）</p><p>  <img src="./21.png" alt></p><p>  一张表的数据堆在一起，就是 table heap，而 table heap 是无序的</p><p>  当创建一张表时，可以定义一个索引，数据库系统会保证索引会对 page 中 tuple 的物理布局进行匹配排序，即对磁盘上实际数据重新组织以按指定的一个或多个列的值排序</p><p>  这对于一些任务是有利的，比如一大堆根据主键来进行范围查找的任务，在这些任务中，如果知道 tuple 保存的顺序是跟主键一致的，那就只需要遍历某个叶子节点下所包含的一小部分 page，就可以找到要查找的数据。如果不一致，那么拿到的每个 record ID （表中每条数据）都有可能指向另一个 page，在读数据时就要进行大量的随机 I/O</p><p>  注意，聚簇索引也会将 tuple 保存在索引中</p><p>  在 MySQL 中，如果没有定义主键，那它会帮你定义一个，会使用 row ID 或者 record ID 之类的东西作为主键，对于调用 MySQL 的应用开发者来说，它们是透明的</p><p>  在 PostgreSQL 中，在对表使用聚簇索引时，它并不会按照这个索引的顺序来维护，即磁盘上保存的表的数据一开始是排好序的，但随着时间的推移，它就会乱序</p></li><li><p>在 B+ Tree 上查找</p><p>  <img src="./22.png" alt></p><p>  如果一个查询条件包括 a、b、c 3 个，B+ Tree 支持除了 c 之外即只有 a 和 b 两个的查询，同时也支持只有 b 一个的查询，但这是 hash 索引做不到的，因为在不使用 c 的情况下，hash 索引对 a 和 b 进行 hash 后的位置会跳转到某个随机的位置上</p><p>  不是所有数据库系统都支持这种查找，但有许多是支持前缀查找（即只查 a 和 b），所有的系统都支持中间的这个 b 类似的查找</p><p>  例子</p><p>  假设在 2 个列或者 2 个属性上定义一个索引，即复合键（composite key），注意这并不是在 1 列上定义索引，而是使用 2 列来进行索引定义</p><p>  <img src="./23.png" alt></p><p>  比如要找 （A，B） 这样的查询</p><p>  <img src="./24.png" alt></p><p>  用条件进行比对和二分查找，就能找到那个对应的 entry</p><p>  但是如果要找 （A，*）这样的前缀查询</p><p>  <img src="./25.png" alt></p><p>  在找到对应的叶子节点后，需要对叶子节点进行循序扫描，直到找到第一个元素 &gt; A 的情况才停止查找</p><p>  比较难实现的是找 （*，B）这样的后缀查询</p><p>  需要尝试在根节点处弄清楚需要去查看这个树的哪一部分，然后通过替换 * 来进行查找</p><p>  <img src="./26.png" alt></p><blockquote><p>注意上图中这里 C 中的列表也需要遍历</p></blockquote><p>  Oracle 把这种查找叫做 skip scan</p><p>  一本 Goetz Graefe 写的关于 B+ Tree 的参考书</p><p>  <img src="./27.png" alt></p><p>  这本书写的所有关于 B+ Tree 的现代技术和优化方法，都可以在真实的系统或者是 B+ Tree 中进行使用</p></li><li><p>Node Size</p><p>  <img src="./28.png" alt></p><p>  一般来讲，可以将 B+ Tree 中的一个 node 当作是表中的 page 来看待，一个 node 的大小可能等于一个 page 的大小</p><p>  如果使用的磁盘速度很慢，那么当构建树上的索引时，会希望这个节点 size 更大一点</p><p>  但如果跳到不同节点间随机 I/O 的速度非常快，那么节点就可以使用更小的 size</p><p>  注意寻址速度 内存 &gt; SSD &gt; HDD，寻址不需要加锁，但读写需要</p><p>  对于叶子节点上的扫描来讲，由于用的是耗时长的循序扫描，那么这种就更适合 size 更大的节点</p></li><li><p>合并临界点</p><p>  <img src="./29.png" alt></p><p>  当节点没有达到半满状态的情况下，可能实际上不需要立即进行合并操作，因为可能下次操作是插入数据，之前做了合并现在又拆开来，那么就会有代价</p><p>  然而合并操作的代价是高昂的，拆分的代价也同样昂贵</p><p>  随着时间的推移，树可能变得不平衡，但可以在后台使用类似 GC 的东西来对它做重新平衡的操作，或者直接重建这个树</p><p>  比如很多高端商用企业级数据库，周末时关闭数据库，重建它们所有的索引，简单来讲这就是它们重新平衡这个树的方式（草）</p></li><li><p>可变长度 key</p><p>  在节点中保存可变长度的 key 是一个问题，下面是它的相对应的解决方法</p><p>  <img src="./30.png" alt></p><ol><li>虽然保存指针的方式会使得保存的数据量变少，但是访问会很慢，在内存很贵的 1980 年代，人们尝试在内存型数据库中使用这个方法，但现在没人用了</li><li>使用可变长度的节点的意思是，允许一个节点的大小根据它保存的东西来变化，这是一个 bad idea，因为在 Buffer 池和磁盘中 page 的大小应该始终保持一致，这样才无须担心该如何找到空闲的空间把数据放进去，同样现在也没人用这个方法了</li><li>使用填充（padding），不管是什么 key，都使用 null 或者 0 对其填充，以此来适合节点大小。虽然有一些数据库系统采用了这个方法，然而这存在 trade-off，虽然数据能保存，但空间被浪费掉了，这也是为什么说确保 schema 的正确定义是非常重要的。</li><li><p>更为常见的方法是使用一个间接映射，把 key 指针放在 key 数组中，注意，这里的指针指的是 2 个在该节点中对应的 offset 值，而不是指向其他任何 page，它看起来应该像下图</p><p> <img src="./31.png" alt></p><p> 注意这里的 key map 是有序的</p><p> 布局和 slotted page 中的 tuple 很像</p><p> 这里的 key + value 是从后往前存储，而 sorted key map 则是从前往后存储</p><p> 如果这个节点没有足够的空间来存数据，那么可以使用一个 overflow page 接着存</p><p> 那么如何优化才能让这个查找变得更快呢？</p><p> 通常来讲，sorted key map 数组中只有 16bit 大小的空间，所以一个可能性的优化是，将每个字符串的首字母放在 sorted key map 中</p><p> <img src="./32.png" alt></p><p> 在查找时，如果 key 无法和这里的第一个字符准确匹配，那么也没有遍历下去的必要了</p><p> 注意，这个优化都是在内存中做的，因为可以避免 cache miss，同时让二分查找或其他查找变得更快</p></li></ol></li><li><p>非唯一索引</p><p>  <img src="./33.png" alt></p><ol><li><p>可以复制 key，复制的 key 会被拆分到另一个节点中，但必须要小心这种情况，而且也要确保读取了所需要的一切数据</p><p> <img src="./34.png" alt></p><p> 比如上图中有重复的 K1，如果要再插入一个 K1，就把 sorted key 中其他元素重新移动排序，那么就依然还能工作，因为里面存放的 offset 值没有发生改变</p></li><li><p>用一个 value 列表，只保存 key 一次，然后在节点中使用一个单独的区域来保存给定 key 的所有 value</p><p> <img src="./35.png" alt></p><p> 比如 K1 有其中一个对应的 value 列表，sorted key 中 K1 通过一个指针指向了该节点里某个 offset 处</p><p>第 1 种方法更常用</p></li></ol></li><li><p>节点内的搜索方式</p><p>  <img src="./36.png" alt></p><p>  interpolation 的意思是指，如果知道要查找的 key 的大概的大小，同时也知道这些 key 的分布信息，就可以用简单的数学方法来进行处理（这里是不是存储的时候就要符合某些数学规律？）</p><p>  <img src="./37.png" alt></p><p>  比如，数组中存有 7 个 key，而 key 的值最大为 10，如果要找的是 8，那么就可以用上面的公式，因为这个数据的存储规律是单调递增的，所以可以这么算</p><p>  但是这种情况，不适用于浮点数和字符串的查找</p></li><li><p>优化</p><p>  <img src="./38.png" alt></p><ol><li><p>压缩数据</p><p> <img src="./39.png" alt></p><p> 前缀压缩（prefix compression），它是基于 key 都是有序排列的</p><p> 在很多数据集中，很有可能会出现保存在同一节点上的 key 彼此之间会非常相似，因为被排过序了</p><p> 比如例子中的 robbed/robing/robot，它们都有共同的前缀 rob，所以对于每一个 key 而言，没必要反复复制或存储这个冗余字符串 rob，而是将它提取出来</p><p> <img src="./40.png" alt></p><p> 这也被成为 Prefix Tree（也就是 Trie Tree）</p><p> Meta 在它内部的 MySQL 中都做了这个优化，这引起了性能上的巨大差异，因为这样做节省了大量的空间，在数据库中，重复的数据实在是太多了</p><p> 另一种类似的优化是在聚簇索引中，我们知道所有的 tuple 都放在磁盘或者 page 中，那么同样在索引中，它们是以排序存在的，那么 tuple 有可能在同一个节点上，它们的 record ID 会使用相同的 page ID，这个时候也没必要把这种情况下单个 tuple 的 page ID 反复存放在一个节点中，而是只保存一次 page ID，然后将它们的 offset 值或者 slot 分开存放</p></li><li><p>后缀截断（suffix truncation）</p><p> <img src="./41.png" alt></p><p> 基本思路是，无须在 inner node 中存储完整的 key 值，来判断向左走还是向右走，而是在 inner node 中存储能够区分 key 的唯一前缀即可，然后将剩余的后缀抛弃掉</p><p> <img src="./42.png" alt></p><p> 注意在下面的节点中，得依然存储整个 key</p><p> 前缀压缩远比后缀截断常用</p></li><li><p>Bulk Insert</p><p> <img src="./43.png" alt></p><p> 很多时候，人们会这么做，打开所有索引，批量加载数据，并将数据插入表中，然后回过头来添加索引，但当你插入新数据时不应该去维护索引，因为这么做代价太高了</p><p> 如果提前就有了所有的 key，就可以用一种很简单的优化方式来构建索引，不会像之前那样自上而下地去构建它，而是自下而上地去做这件事</p><p> 怎么做呢？</p><p> 对于一组已知的 key 来说，可以对其先排序</p><p> <img src="./44.png" alt></p><p> 然后将它们排列在叶子节点上，正确地填入到叶子节点中</p><p> <img src="./45.png" alt></p><p> 然后自下而上，只需要使用中间 key 来填充 inner node，并生成对应的指针</p><p> <img src="./46.png" alt></p><p> 这是任何主流数据库系统都支持的一种标准技术</p><p> 使用批量插入（bulk insert）来构建索引，速度会非常快</p></li></ol><ul><li><p>Pointer Swizzling</p><p>  <img src="./47.png" alt></p><p>  实际上，在数据库实现的 B+ Tree 中，节点保存的指针并不是原始的内存指针，而是 page ID</p><p>  比如查找 key &gt; 3 的数据，怎么去找上图中右下的节点找数据呢？</p><p>  在根节点处，保存了该索引的 page ID</p><p>  <img src="./48.png" alt></p><p>  然后需要跑到下面的 Buffer 池中找 page #2，如果它不在内存中，Buffer 池应该返回一个指向它的指针</p><p>  <img src="./49.png" alt></p><p>  如果拿到了这个指针，就可以对节点进行遍历了</p><p>  而对于兄弟节点的遍历也是一样的</p><p>  <img src="./50.png" alt></p><p>  但这样做的代价很高，因为必须使用 latch 来保护 Buffer 池中的 hash 表，要花很多步骤才能拿到这个指针</p><p>  所以为了解决上述问题，pointer swizzling 的思路是（或者说假设是），如果内存中所有的 page 都是固定住的话，那么它们永远不会移动到另一个内存地址上去</p><p>  比如下图中，节点不会保存 page ID，而是保存 page 指针</p><p>  <img src="./51.png" alt></p><p>  这样就不用访问 Buffer 池，也会避免上面的一些问题</p><p>  当然这样做也要确保一件事情，那就是，如果要将它从内存中移除，也就是将它写出到磁盘上，那么就不要保存 page 指针，因为当它再放入内存时，地址就变了</p><p>  所以这里也无须将 page ID 完全不要，可以通过一点额外的元数据来表示，这就是我们想要的指针，而不是 page ID</p><p>  对于树的上层部分，比如根节点或者是树的第二层处的节点，它们的使用频率都非常高，因为都需要经过它们才能访问到下一级的节点的数据，所以将这些上层节点数据对应的 page 固定住可能并没有什么大问题，比起整个树的 size 来讲，这些上层节点所占的体积还是比较小的。那么针对这种情况就可以使用这种优化策略，因为 page 固定，指针始终有效</p><p>  这种方式实际上非常普遍，很多主流数据库系统中都使用了这种方法</p></li></ul></li><li><p>结论</p><p>  <img src="./52.png" alt></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;注: 本文首发我的 b 站专栏文章&lt;a href=&quot;https://www.bilibili.com/read/cv14653694&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;CMU 15-445/645-笔记-07-树索引-part1&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Database" scheme="https://strugglebak.github.io/categories/Database/"/>
    
    
      <category term="Database" scheme="https://strugglebak.github.io/tags/Database/"/>
    
  </entry>
  
  <entry>
    <title>CMU-15-445-645-笔记-06-Hash表</title>
    <link href="https://strugglebak.github.io/2022/06/05/CMU-15-445-645-%E7%AC%94%E8%AE%B0-06-Hash%E8%A1%A8/"/>
    <id>https://strugglebak.github.io/2022/06/05/CMU-15-445-645-笔记-06-Hash表/</id>
    <published>2022-06-05T14:01:32.000Z</published>
    <updated>2022-06-05T14:13:27.950Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>注: 本文首发我的 b 站专栏文章<a href="https://www.bilibili.com/read/cv14598675" target="_blank" rel="noopener">CMU 15-445/645-笔记-06-Hash表</a></p></blockquote><a id="more"></a><p><img src="./Cover.png" alt></p><ul><li><p>课程目标</p><p>  <img src="./1.png" alt></p></li><li><p>目前已经讲过的内容</p><p>  <img src="./2.png" alt></p></li><li><p>数据结构</p><p>  <img src="./3.png" alt></p><p>  memcache 本质上来讲就是一个超大的 hash table，而 MySQL 的 innodb 引擎使用的是 B+ tree，它们将 tuple 存储在 B+ tree 的叶子节点上</p><p>  临时数据也可以用数据结构来维护（就是缓存），比如在执行一个查询时，为了高效地计算某些东西，可以在运行时构建一个数据结构，放入所需数据，完成查询的执行，然后将这个临时数据结构丢弃掉</p><p>  表索引（table index）也有对应的数据结构，即使用 tuple 中的 key 来构建一个词汇表，有些像书中的目录，这样就能很快地找到那个对应的单个元素，也没必要对整个数据库进行循环扫描了</p></li><li><p>设计数据结构</p><p>  <img src="./4.png" alt></p><ol><li>如何弄一个数据结构，使得无须对该数据结构进行大改或者每次要重新转换整个数据结构的情况下，支持快速读写</li><li><p>该如何让多个线程或者多个查询去访问这个数据结构，并且该数据结构表示的数据不会再物理存储层面出现问题，因为同时被线程修改的某个地址的数据会变成脏数据，从而让它们访问到某些无效的 page 或者是某些无效的内存位置</p><p>这里最关心的应该还是数据结构的 物理完整性，而不是 逻辑完整性</p></li></ol></li><li><p>Hash 表</p><p>  <img src="./5.png" alt></p><p>  hash 表是一个抽象的数据类型，它可以提供无序的关联数据的实现（unordered associative array implementation）的 API</p><p>  注意，hash 函数并不会一直让我们精确地找到我们想要找的东西，因为这会产生 hash 碰撞，但至少它能让我们找到正确的位置，然后我们知道该如何在周围找到我们想要的那个数据</p><p>  hash 表操作时间复杂度最坏的情况为什么是 O(n) 呢？这是因为 key 通过 hash 都碰撞到一起，放在一个数据/队列/链表中了，所以这个时候就需要遍历查找想要的那个 key</p><p>  虽然 hash 表操作平均时间复杂度为 O(1)，但不同的 hash 函数执行时间可能不一样，有些快有些慢，在面对超大规模基数的数据查询时，慢的 hash 函数会导致整个应用需要付出大量的金钱，比如商业交易这一场景</p><ul><li><p>静态 Hash 表</p><p>  <img src="./6.png" alt></p><p>  一个最简单的 hash 表如上图所示，它其实就是一个巨大的数组，看起来就像是一大块内存</p><p>  数组中每个 offset 位置都对应了一个给定的元素</p><p>  通过对 key 进行 hash，即将 key 与所有元素数量进行取模（如果该 key 对应这个数组的下标），就会得到它对应的 offset 值</p><p>  <img src="./7.png" alt><br>  <img src="./8.png" alt></p><p>  但实际上 hash 表并不完全是这样，hash 表需要保存的是一些指向这些原始的 key 所在位置的指针</p><p>  <img src="./9.png" alt></p><p>  对于这种 hash 表而言，存在的问题是什么呢？</p><ol><li>需要提前知道 hash 表中元素的数量</li><li><p>key 与 key 之间没有碰撞（collision）</p><p>碰撞 指的是，对 key 进行 hash 后的结果指向了同一个 slot</p><p><img src="./10.png" alt></p><p>完美 hash 函数（perfect hash function）是一种存在于研究文献中的一种理论上的东西，因为在实际工作中，如果 key1 != key2，那么有可能 hash(key1) = hash(key2)。实际上能实现所谓完美 hash 函数的方式是通过另一张 hash 表将一个 key 映射到另一个 hash value 上（这种方式真的很蠢，因为速度会很慢），比如 Java 中的 concurrentHashmap，第一次 hash 是为了分区，第二次 hash 是为了确定具体位置，但也不能保证完美</p></li></ol><p>那么该如何在摈弃上述两个假设的前题下实现一个 hash 表呢？</p><p><img src="./11.png" alt></p><p>要实现一个 hash 表，它的数据结构应该是由 2 部分组成</p></li></ul><ol><li><p>hash 函数<br> 该函数将任意的 key 映射到一个较小范围的 integer value 上，同时该函数会生成一个 32/64 bit 的唯一 hash 值（也可能不唯一）</p><p> hash 函数的速度和碰撞率之间要做取舍</p></li><li><p>hashing scheme<br> 即当在 hash 表中遇上 hash 碰撞时，用 hashing scheme 来处理这种问题，hashing scheme 是一种机制或者说步骤</p><p> 同样的，这个也需要在内存和计算（速度）之间做取舍，即时间换空间，空间换时间。</p></li></ol><ul><li><p>Hash 函数</p><p>  <img src="./12.png" alt></p><p>  hash 函数就是一个速度很快的函数，将任意的 byte array 或者任意的 key 传入函数，它就会返回一个 32/64 bit 的 integer</p><p>  比如一些著名的 hash 函数，比如 SHA-256/MD5</p><p>  实际上 SHA-256 是不可逆的加密 hash 函数，它是一种使用了 公钥/私钥 的东西</p><p>  对于 MD5 来说，可以将任意的 key 传入它的 hash 函数，然后返回一个 32 bit 的唯一 hash 值，它本来应该是不可逆的，但现在因为有人破解了它，所以可逆</p><p>  在数据库系统中，如果要做 hash 表，那么我们对它的加密性并不在意，所以也不会去用 SHA-256（用这个加密速度也超慢）</p><p>  MD5 是一种单向散列（one-way hash），可以将它作为构建 hash 表的 hash 函数，但没必要因为它还是非常慢。同时它也是不安全的，因为可以通过彩虹表对它进行破解</p><p>  一些 hash 函数图</p><p>  <img src="./13.png" alt></p><ul><li>CRC-64 是 1975 年被发明出来的，它的碰撞率虽然合理，但是速度非常非常慢</li><li>MurmurHash，从数据库层面来讲，它的诞生开启了现代 hash 函数的时代。它在 2008 年诞生，是开源的。G 家在 2010 年早期采用了 MurmurHash，并对其做了改进，使得长度更短的 key 可以获得更快的速度，然后 G 家就发布了 CityHash。2014 年时他们由基于这个做了改进，然后发布了 FarmHash，它的碰撞率比 CityHash 更低</li><li><p>Meta 的 XXHash 的速度更快，碰撞率最低（这里指的是 XXHash 3）</p><p>2 张 hash 函数的 benchmark 图</p><p><img src="./14.png" alt><br><img src="./15.png" alt></p><p>从上图可以看到，当 key 的大小为 32 byte 和 64 byte 时，FarmHash、CityHash、XXHash3 都出现了非常漂亮的尖峰，这是因为它们进行计算处理的 key 都刚好填满单个 Cache Line（CPU 和主存之间数据传输的最小单位）。当从内存中读取一次数据时，将 64 byte 大小的 key 放入 Cache 中，这样就可以一次性操作所有从该缓存中找到的数据，即一次操作一整个 Cache line 中的数据。当 key 的大小超过 64 byte 后，CityHash 和 FarmHash 就会切换到另一种不同的算法上，导致速度上会有些不同</p><p>所以在数据库系统中，尽可能多地去使用 XXHash3</p></li></ul></li><li><p>静态 Hashing Schemes</p><p>  <img src="./16.png" alt></p><p>  注意，此处讨论的内容跟所使用的 hash 函数没有关系，所有的 hashing scheme 的工作方式都是一样的，因为这是做完 hash 计算，跳转到某个位置时才做的</p><p>  Cuckoo 和 Robin Hood Hashing 都是基于 Linear Probe Hashing 做的改进版</p><p>  注意这些都是 静态 Hashing Schemes，意味着在分配内存时，一开始就得知道要保存的 key 的数量，在某些情况下，可以猜出这个 hash 取模的基数有多大（key % n，n 就是这个基数）。在进行查询处理或者使用 hash 表进行 join 操作时，需要知道在 hash 表中大概要对多少个 key 进行 hash，然后就可以进行内存分配了</p><p>  如果 hash 表容量快满了，就必须对其进行扩容，基本上是扩展到原来的 2 倍。即将第一个 hash 表中所有的 key 复制到第二个 hash 表上，但这样做代价非常高（所有元素重新打散并 hash 存储，代价很高）</p><p>  理想情况下，如果大概知道 hash 表的容量上限是多少，也就没必要去做扩容的操作了</p><ol><li><p>Linear Probe Hashing</p><p> <img src="./17.png" alt></p><p> Linear Probe Hashing 有时也叫 Open Addressing，即开地址法，它就是一个大型的 slot 表，通过 hash 函数来跳转到该表中的某个 offset 值上，或者是在该表中添加一些 slot</p><p> Python 的 Dictionary 背后的数据结构其实就是 hash 表，它就是一个使用了 Linear Probe Hashing 的 hash 表</p><p> 如何解决 hash 碰撞？如果在进行 hash 计算所得到的 slot 位置上已经有数据在上面，那么就挨着这条数据往下扫描，直到遇到下一个能插入数据的空 slot 为止（空的 slot 指没有找到 key 对应的 value）</p><p> 一个例子</p><p> <img src="./18.png" alt><br> <img src="./19.png" alt></p><p> slot 上会保留原始的 key/value 对，原始的 key 会有所保留的原因是，当要开始查找时，如果有多个 entry（key/value 对），那么就必须在 slot 上往下扫描，我们需要知道在该 slot 中存放的 key 是不是我们想要的那个，毕竟也没法保证根据 hash 计算得到的 slot 表中的位置就是我们想要的那个准确位置</p><p> 比如对 C 进行 hash，但此时 C 落在了之前 A 的位置</p><p> <img src="./20.png" alt></p><p> 所以此时就直接跳到 A 的下一个位置，然后把 entry（这里指 key/value 对） 插入到那个位置上</p><p> <img src="./21.png" alt></p><p> 比如插入 E 也是一样的</p><p> <img src="./22.png" alt></p><p> 那么假设要删除 C，应该怎么做呢？</p><p> <img src="./23.png" alt><br> <img src="./24.png" alt></p><p> 先对 C 进行 hash，hash 完后，找到的是 A 所在的位置，但这并不是要删除的那个数据，于是继续往下扫描，找到了 C，直接移除</p><p> <img src="./25.png" alt></p><p> 但是这里会有一个问题</p><p> <img src="./26.png" alt></p><p> 如果去查找 D，那么它会发现 C 的位置是一个空 slot，那么它就认为它的查找已经完成了，即便这个 D 所对应的数据是在下面的</p><p> 所以有两种方式来做移除</p><ol><li><p>tombstone<br> 即在原来 C 的位置上放一个这个标记，表示这里没有一个 logic entry 了，但从物理上来讲，这个 slot 是被占用了</p><p> <img src="./27.png" alt></p><p> 当查找 D 时，会落到这个有 tombstone 标记的 slot 上面</p><p> <img src="./28.png" alt></p><p> 然后虽然这个 slot 中没有数据，但它确实不是空 slot，所以直接跳到下一个</p><p> 但，这就浪费了空间。这需要后续清理掉，并用上 fill factor（填充因子）</p></li><li><p>data movement<br> <img src="./29.png" alt><br> 就是做数据移动，看到有空数据往上移动</p><p> <img src="./30.png" alt></p><p> 但要记住这个 slot 表是 环形 的</p><p> <img src="./31.png" alt></p><p> 技术上来讲，B 应该是在 F 后面的，虽然物理上不是，如果像上图中那样，将 B 移动到箭头所指向的位置，可能会导致某些错误发生</p><p> <img src="./32.png" alt></p><p> 因为 B 原来 hash 的位置是在上面，如果移动到下面的位置，在查找 B 时，会看到那里啥都没有</p><p> 所以大部分情况下都会去使用 tombstone，数据移动这种方式实际上很复杂</p><p>在实战中，一般使用 n 或者 2n 作为 slot 的数量，n 为要放入 key 的数量</p></li></ol></li><li><p>Robin Hood Hashing</p><p> 在了解这个之前，得先了解 Non-Unique Keys，即非唯一 Key，因为在实际的数据集中，没办法假设所有的 Key 都是唯一的，所以需要在 hash 表中对它们进行处理，有 2 种方法可以做到</p><p> 第 1 种方法是，维护一个单独的链表，上面保存了所有的值。即在 hash 表中的 key 会指向属于该 key 的单独链表，该链表上所保存的 value 对应的都是同一个 key</p><p> <img src="./33.png" alt></p><p> 第 2 种方法是，保存冗余的 key，这也是最常见的。即在 slot 数组中不断地复制这个 key</p><p> <img src="./34.png" alt></p><p> 在实战中，第 2 种方法用的多</p><p> Bobin Hood Hashing 是在 1985 年提出的，出自当时一篇无人问津的 paper，然后过去 10 年，它在 Hacker News 上出现过几次。而 Bobin Hood（罗宾汉）是一个英国的民间传说，讲述的是一个劫富济贫的侠盗的故事。那么 Bobin Hood Hashing 做的事情也是类似的，就是会让那些 “poor” key 从 “rich” key 身上偷取 slot</p><p> <img src="./35.png" alt></p><p> Number of Positions（距离数）表示的是你所在的位置与你第一次进行 hash 所计算出的位置之间的距离差。</p><p> 距离数越大，越 “poor”，反之越 “rich”</p><p> 基本思路是，对整个 hash 表进行平衡，尝试让每个 key 都尽可能靠近它原本所在的位置。即对所有的 key 来讲，在全局状态下尽可能快地找到它们，而不是针对于某一个。</p><p> 一个例子</p><p> <img src="./36.png" alt></p><p> 在插入数据 A 时，可以记录下数据 A 实际所在的位置与第一次 hash 计算出的原始位置所差的跳转次数</p><p> 第一次插入 A 时，跳转次数为 0，所以是 A | val[0]，对于 B 也是一样</p><p> C 要插入时，本来要插 A 的位置，但因为 A 的位置不是空的，所以它插入到 A 的下一位</p><p> <img src="./37.png" alt></p><p> 所以是 C | val[1]，因为 C 当前所在的位置距离它第一次通过 hash 所得出的位置相差 1 个单位</p><p> 对于 D 来说也是一样的</p><p> <img src="./38.png" alt></p><p> 而对于 E</p><p> <img src="./39.png" alt></p><p> 因为 E 需要跳转 2 次才能达到 D 跳转一次的位置（D 跳转一次就到它原本第一次 hash 计算出来的位置了），E[2] &gt; D[1]，所以 E 比 D 要更 “poor”，所以 E 就要去 偷 D 所在的 slot 的位置，并插入其中</p><p> <img src="./40.png" alt></p><p> 那么现在就只能将 D 插入到 E 的下面了，并将 D | val[1]，更新为 D | val[2]</p><p> <img src="./41.png" alt></p><p> 而 F 就是放到 D 下面</p><p> <img src="./42.png" alt></p><p> 这种方法会使得写入或者插入的代价更高，因为这种方式进行了多次写入的操作，而 Linear Probe Hashing 只需要一次写入</p><p> 但是在该算法下，需要对更多的条件进行检查，看看能否将一个放到另一个的位置上，只要有一次条件误判，就会付出巨大的代价。更多的写入操作带来更多的缓存无效。所以在实战中，还是优先使用 Linear Probe Hashing，它依然是最快的方法</p></li><li><p>Cuckoo Hashing</p><p> <img src="./43.png" alt></p><p> 思路是，使用多个 hash 表，然后要做的是该判断往哪个 hash 表中插入 key，即哪个 hash 表能提供一个空余的 slot</p><p> 在 Cuckoo Hashing 中，查找和删除的时间复杂度始终是 O(1)，这意味着当进行查找时，始终都会跳到 hash 表上，准确地找到那个数据</p><p> 但插入操作的代价可能更高，因为要判断是在 hash 表 1 中还是 hash 表 2 中进行存储等操作</p><p> 例子</p><p> 注意大多数人在使用 Cuckoo Hashing 时，通常都只使用 2 个 hash 表</p><p> 对于 Cuckoo Hashing 中的每个 hash 表来说，必须为 hash 函数提供一个单独的 hash seed，拿到 key 之后，对它 hash 2 次（这里对同一个 key，给 hash 函数不同的 seed，那么就会生成不同的 hash 值）</p><p> <img src="./44.png" alt></p><p> 这个时候要插入 B 了</p><p> <img src="./45.png" alt></p><p> 但是在 hash 表 1 中，对应的位置已经有 A 了，这个时候就选择 hash 表 2 插入</p><p> <img src="./46.png" alt></p><p> 这个时候插入 C</p><p> <img src="./47.png" alt></p><p> 但现在 hash1(C) 和 hash2(C) 的位置都被 A 和 B 占了，这个时候该怎么办呢？</p><p> 答案是随机选一个，这里选的是 hash 表 2，然后移除掉 B，插入 C</p><p> <img src="./48.png" alt></p><p> 那么 B 怎么办呢？重新 hash 一下 B，抢走 A 的 slot</p><p> <img src="./49.png" alt></p><p> 那么 A 怎么办呢？重新 hash 一下 A，把 A 放到 hash 表 2 中的一个空 slot 的地方</p><p> <img src="./50.png" alt></p><p> 但这个方式存在 递归碰撞，即有可能在碰到最后一个元素后，又碰到最初的那个元素去了，这种情况下，需要扩容（卧槽，这 tm 扩容。。。）</p></li></ol></li><li><p>动态 Hash 表</p><p>  <img src="./51.png" alt></p><p>  动态 hash 表能够在无须重建整个东西的情况下，根据需要调整大小，比如 chained hash table，这是最常用的一种动态 hash 表</p><ol><li><p>Chained Hash 表</p><p> <img src="./52.png" alt></p><p> 也叫 chained hashing/bucket hash table，里面主要维护了一个包含了 bucket 的链表，通过将具有相同 hash key 的所有元素放入相同的 bucket 来解决冲突，也就是在 bucket list 末尾追加，所以每个 bucket chain 都可以永远扩容下去</p><p> 所以要查找的话，也只能循环扫描了</p><p> 例子</p><p> <img src="./53.png" alt></p><p> 可以将这些 bucket 当作是 page</p></li><li><p>Extendible Hashing</p><p> <img src="./54.png" alt></p><p> 基于 chained hash 表的思想，但是不同于它的无限扩容，Extendible Hashing 要做是将链表逐步拆分</p><p> 这里 “拆分” 的意思也跟 “重建” 差不多，也要进行一波扩容并重新 hash 的操作，但这里只是对 某个独立的局部 进行操作</p><p> 要拆分的只是那些要 overflow 的 chain，而不是整个 hash 表</p><p> 拆分完那些 overflowed bucket 之后，在其对应的 slot array 中，允许多个 slot 指向同一个 bucket chain</p><p> 优势是，在移动数据时，只需要移动那些 overflowed 的 bucket 就行</p><p> 例子</p><p> 要有 1 个 全局 counter，它负责 bit 的数量，即负责需要看几个 bit 才能去找对应的 bucket</p><p> <img src="./55.png" alt></p><p> 而对于每个 bucket chain 或者每个 bucket，给它们一个局部的 counter，表示需要看几个 bit 才能找到该位置</p><p> <img src="./56.png" alt></p><p> 在这个例子中，第 1 个 bucket 中的局部 counter 的值是 1，表示只需要看 1 bit 就能定位到这个 bucket</p><p> 这就是为啥你看那个蓝色圈出来的 bit，看 00 和 01 时，它们俩都会映射到同一个 bucket，因为它们第 1 个 bit 都是 0，因为这个 bucket 存在 overflow 的情况，还没有对它进行拆分</p><p> 另外 2 个 bucket 拥有的分别是蓝色圈出来的 10 和 11，因为它们的局部 counter 的值是 2，也就是说需要看 2 个 bit 才行</p><p> 现在假设要查找 A</p><p> <img src="./57.png" alt></p><p> 注意这里生成的 hash 是一堆 bit 序列</p><p> 然后看下全局 counter，它会检查这个 hash 函数生成的 bit 序列中的前多少位，以此来决定要跳转到哪个 bucket</p><p> <img src="./58.png" alt></p><p> 例子中全局 counter 的值是 2，那么只需要看这个 bit 序列的前 2 位，即 01，然后在 slot array 中查找</p><p> <img src="./59.png" alt></p><p> 找到 01，跟着指针，就找到了对应的那个 bucket</p><p> <img src="./60.png" alt></p><p> 如果这个时候要插入 B</p><p> <img src="./61.png" alt></p><p> 因为全局 counter 是 2，那么看 B 的前 2 位，是 10，跟着 slot array 中 10 指的位置，第 2 个 bucket 那儿有一个空余的位置，插入它即可</p><p> 如果这个时候要插入 C</p><p> <img src="./62.png" alt></p><p> C 目前要插入的位置是第 2 个 bucket，但是此时第 2 个 bucket 没空间了，它变成 overflowed 的了，所以现在必须要对它进行拆分</p><p> 怎么拆分呢？</p><p> 先把全局 counter 增加到 3</p><p> <img src="./63.png" alt></p><p> 然后将 slot array 扩容到原来的 2 倍，这样就可以处理 3 bit 的情况了</p><p> <img src="./64.png" alt></p><p> 注意，这个 slot array 的扩容操作代价很低，因为这只是一个指针数组，可以在上面用一个 latch 来保护它，调整完大小再将数据放回去，无须移动 bucket 中的数据</p><p> <img src="./65.png" alt></p><p> 如上图，对 bucket 进行重构，将保存在这些单个 page 上的数据进行拆分，并根据局部 counter 中的值，将它们重新映射</p><p> 现在再尝试插入 C</p><p> <img src="./66.png" alt></p><p> 3 个 bit，C 的 hash 结果的前 3 位是 101，找到 slot array 中 101 的位置，跟着它的指针，即能找到对应位置插入</p><p> 注意这里并没有对全部的 bucket 进行拆分，而只是拆分了之前那个 overflowed 的 bucket，即之前的第 2 个</p><p> 删除操作其实就是将插入操作逆向执行</p><p> 每个 bucket 就是 page</p><p> Buffer 池中可能存储的是一张表下涉及的多个 page 的数据条目，也可能是多个表下的部分数据条目</p></li><li><p>Linear Hashing</p><p> <img src="./67.png" alt></p><p> Extendible Hashing 存在一个小问题，就是要拆分 overflowed bucket 时，需要将 slot array 扩容为原来的 2 倍大，在调整 slot array 的大小时，需要在上面使用一个 latch，这样能保证直到重新分配完所有的数据为止，其他人不会对其进行读写</p><p> 这会成为一个性能瓶颈，因为这个 hash 表同一时间可能会被多个人访问</p><p> Linear Hashing 的思路是，只需要去重新分配那些 overflowed bucket 即可，没必要去用一个全局的 latch 来阻止所有人访问这个 hash 表</p><p> 那么如何做到呢？</p><p> Linear Hashing 会去维护多个 hash 函数，这些 hash 函数的工作方式和之前讲到的 Cuckoo Hashing 中相同，用不同的 seed 对给定的 key 生成不同的 hash 值，然后找到那个对应的 bucket</p><p> 这里需要维护一个新的东西，叫 split pointer，它会去跟踪那个要进行 split 的 overflowed bucket</p><p> 例子</p><p> <img src="./68.png" alt></p><p> 初始状态下，这个 split pointer 指向 slot array 的第 0 个</p><p> <img src="./69.png" alt></p><p> 此处 hash 函数中的 n 即拥有的 entry 的数量</p><p> 假设现在要去查找 key 为 6 的相关数据</p><p> <img src="./70.png" alt></p><p> 6 % 4 = 2，那么在 slot array 中就是 2 所在的位置，顺着其指针找，找到第 3 个 bucket，然后在 bucket 中顺序查找比对 key，就找到了对应的位置</p><p> 假设现在要插入 17</p><p> <img src="./71.png" alt></p><p> 那么 17 % 4 就是 1，找到 slot array 中 1 所在的位置，顺着其指针找，找到第 2 个 bucket，但在这个 bucket 中，没有空余的 slot，那么怎么办呢？创建一个 overflow bucket，在这个上面放 17 这个值</p><p> <img src="./72.png" alt></p><p> 因为现在创建了一个 overflowed bucket，就相当于触发了一次 overflow，所以现在不管这个 split pointer 指向的是哪个 bucket，对应 bucket 现在都要进行一次拆分，比如图中的第一个 bucket，哪怕这个 bucket 还可以存数据</p><p> 拆分的工作方式是这样的</p><p> <img src="./73.png" alt></p><p> 在 slot array 的地方再增加一个 entry，也就是新增了一个格子 4。用一个新的 hash 函数，即 key % 2n，而这个 split pointer 会帮助我们跟踪，该使用第 1 个还是第 2 个 hash 函数，它也会告诉我们，在 slot array 中，拆分 bucket 的距离有多远</p><p> <img src="./74.png" alt></p><p> 然后在 slot array 为 4 的位置，新增一个 bucket，把 20 放入这个新增的 bucket 中。</p><p> <img src="./75.png" alt></p><p> 然后将这个 split pointer 下移一个单位</p><p> 那么如果此时再想进行一次查找时，首先用第一个 hash 函数对其进行 hash</p><p> <img src="./76.png" alt></p><p> 如果此时 hash 得到的结果所指向的位置时在 split pointer 所在的这条分界线之上，那么就知道正在查找的那个 bucket 已经被拆分了</p><p> <img src="./77.png" alt></p><p> 因此现在就应该使用第 2 个 hash 函数来去找数据，因为数据肯定不在原来要拆分的那个 bucket 上</p><p> 如果是查找 9 ，逻辑也是一样的</p><p> <img src="./78.png" alt></p><p> 9 % 4 = 1，因为在 1 所在 slot array 的那个位置 在 split pointer 分界线之下，所以它是没有被拆分的，所以使用第一个 hash 函数是对的，那么就可以顺着指针直接去找了</p><p> 然而算法最糟糕的情况是，每个人都往同一个 bucket 中插入数据，这会导致它花了很长时间对 bucket 进行拆分，但使用一个具备低碰撞率的优秀 hash 函数的话，可以解决这个问题</p><p> 如果进行删除操作，split pointer 会往回移动，不过如果要实现会相当棘手</p><p> 例子</p><p> 假设现在要删除 20</p><p> <img src="./79.png" alt></p><p> 如果用第 1 个 hash，那么它算出来就是 0，但此处的位置是在 split pointer 的分界线之上，所以需要用第 2 个 hash</p><p> <img src="./80.png" alt></p><p> 于是在 slot array 的 4 这个位置，delete 对应的 bucket 里的 20</p><p> <img src="./81.png" alt></p><p> 那么这个 bucket 就空了，如果要回收，就是反向操作</p><p> 首先清掉这个空 bucket，并且清掉指针</p><p> <img src="./82.png" alt></p><p> 然后将 split pointer 往回移动一个单位</p><p> <img src="./83.png" alt></p><p> 现在，分界线消失了，第 2 个 hash 函数也没了，内存回收完毕</p><p> <img src="./84.png" alt></p><p> （这里 4 的消失，我认为也是随着指针清空然后这个也被 remove 掉了）</p><p> 如果回收完后 紧接着 是下面这种情况，在 overflowed bucket 中插入一个 21</p><p> <img src="./85.png" alt></p><p> 就会触发 overflow（因为 slot array 的位置 1 对应的 bucket 放不下，要放到其 overflow bucket 中），那么又要根据算法拆分 bucket</p><p> 算法做了很多事情让插入更快，但很难做到快速删除</p></li></ol></li></ul></li><li><p>结论</p><p>  <img src="./86.png" alt></p><p>  hash 表没办法比较 key 的大小，所以不适合用于表索引的一些场景</p><p>  相反，在创建索引时，最常用的就是 B+ Tree</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;注: 本文首发我的 b 站专栏文章&lt;a href=&quot;https://www.bilibili.com/read/cv14598675&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;CMU 15-445/645-笔记-06-Hash表&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Database" scheme="https://strugglebak.github.io/categories/Database/"/>
    
    
      <category term="Database" scheme="https://strugglebak.github.io/tags/Database/"/>
    
  </entry>
  
  <entry>
    <title>CMU-15-445-645-笔记-05-Buffer池与内存管理</title>
    <link href="https://strugglebak.github.io/2022/06/05/CMU-15-445-645-%E7%AC%94%E8%AE%B0-05-Buffer%E6%B1%A0%E4%B8%8E%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <id>https://strugglebak.github.io/2022/06/05/CMU-15-445-645-笔记-05-Buffer池与内存管理/</id>
    <published>2022-06-05T13:51:27.000Z</published>
    <updated>2022-06-05T13:58:23.653Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>注: 本文首发我的 b 站专栏文章<a href="https://www.bilibili.com/read/cv14580880" target="_blank" rel="noopener">CMU 15-445/645-笔记-05-Buffer池与内存管理</a></p></blockquote><a id="more"></a><p><img src="./Cover.png" alt></p><ul><li><p>课程目标</p><p>  <img src="./1.png" alt></p></li><li><p>上节课回顾</p><p>  <img src="./2.png" alt></p><p>  画红线的部分</p><ol><li>想要能够去支持超出我们所拥有的内存容量大小的数据库</li><li>最小化在磁盘上执行查询时速度缓慢带来的影响</li></ol><ul><li><p>数据库 Workloads</p><p>  <img src="./3.png" alt></p><p>  HTAP（混合事务分析处理 Hybrid Transaction Analytical Processsing），是几年前 Gartner 发明的一个新流行词，它所描述的是既做 OLTP 又做 OLAP 的数据库系统</p></li><li><p>Bifurcated Environment</p><p>  <img src="./4.png" alt></p><p>  一般数据库的标准配置是这样的</p><ol><li>前端 OLTP 数据库</li><li><p>后端 OLAP 大型数据仓库（back-end data warehouse）</p><p>这两者有时候被称为 Data Silo，即数据孤岛，数据存储相互独立，彼此之间不会真的交流</p><p><img src="./5.png" alt></p><p>然后就可以进行 ETL（Extract Transform Load） 的操作，即将业务系统的数据经过抽取、清洗、转换之后加载到数据仓库的过程</p><p>以 Zynga 这家游戏公司为例，Zynga 收购了很多游戏初创公司，比如 FarmVille，它买下这些公司时，会去运行他们自己的前端 OLTP 数据库，只有他们将这些数据放入他们的后端大型仓库时，他们才能更高地分析出怎么做才能让你们在 FarmVille 上买东西</p><p>等后端 OLAP 数据仓库拿到分析后的信息数据后，就推到前端 OLTP 数据库中，并对外暴露</p><p><img src="./6.png" alt></p><p>所以 HTAP 基本上在做一些平常只能在 OLAP 端所做的，可以直接在前端的 Data Silo 里面做这些，并且不用等数据传回到后端数据仓库了</p><p>这可以用 MySQL、PostgreSQL、mongoDB 来做前端数据库，可以用 Hadoop、Spark、Greenplum、Vertica 来做后端数据仓库</p></li></ol></li><li><p>数据库存储</p><p>  <img src="./7.png" alt></p><ol><li>空间管理<br> 这里指的是在哪里将数据写入磁盘</li><li>时间管理<br> 这里指的是什么时候将 pages 读入内存</li></ol></li><li><p>面向磁盘的 DBMS</p><p>  <img src="./8.png" alt></p><p>  如果执行引擎在请求 page 时，内存中没有足够的空余来容纳我们需要的那个 page，这个时候就必须要决定哪个 page 进行写出操作，即 “remove”，而这正是 Buffer 池要解决的问题</p><p>  系统的其他部分无须知道或者关系哪些东西在内存里，哪些东西不在，它只会等它需要拿到的东西，然后返回一个指针给到执行引擎</p></li></ul></li><li><p>Buffer 池的组织</p><p>  <img src="./9.png" alt></p><p>  Buffer 池需要我们在数据库系统内部分配一块很大的内存，就是调用 malloc，拿到一些内存块，并将从磁盘中读取到的所有的 pages 都放到这个里面去。注意这段内存完全是由数据库系统来控制，而不是交给操作系统来做。</p><p>  然后，这段内存区域被分成一个个固定大小的 chunk，它被称为 frame，frame 对应的是之前提到的 slot（slot 存储的虽然是对应 tuple 的 offset，但对外来看，相当于指代了一段存储区域），即 Buffer 池内存区域中的区块或者是 chunk，frame 里存放的是 page</p><p>  当数据库系统发出一个请求 page 的请求，会发生啥呢？</p><p>  <img src="./10.png" alt></p><p>  首先会去看 Buffer 池中有没有这个 page，如果没有就拷贝一份到内存中，也就是其中一个 frame</p><p>  <img src="./11.png" alt></p><p>  注意 Buffer 池中 page 的顺序可能和磁盘上的顺序不一致，所以在此之上，就需要一个额外的 indirection 层，如果需要某个特定的 page，只要通过这个 indirection 层就能知道这个 page 在哪个 frame 中</p></li><li><p>Buffer 池元数据</p><p>  <img src="./12.png" alt></p><p>  page 表其实就是一个 hash 表，用来跟踪在内存中有哪些 page，可以通过 page 表和 page ID 找到在 frame 中对应的那个 page</p><p>  数据库系统必须维护一些额外的元数据，以此来跟踪当前 Buffer 池中的 page 发生了什么</p><p>  要跟踪的有俩</p><ol><li>Dirty Flag<br> 这个 flag 表示的是，从磁盘读取到这个 page 后，这个 page 是否被修改过，比如查询或者事务对其修改过</li><li><p>Pin/引用计数<br> 这个表示 想要使用该 page 的当前线程数量/正在对该 page 进行的 查询 的数量（这里又联想到 GC），page 目前还在被强引用，说明此时不应该将 page 写出到磁盘上</p><p><img src="./13.png" alt></p><p>比如在上图的例子中，如果不想让 page3 从 Buffer 池中移除掉，就把他 Pin 住</p><p><img src="./14.png" alt><br><img src="./15.png" alt></p><p>如果想要去读取一个不在当前内存中的 page2，那么就要在这个 page 表中加上一个 latch 锁，这样 Buffer 池就可以从磁盘中拿到这个 page2，然后更新 page 表里面指向 page2 的指针。为什么要加锁？因为同一时间可能有多个线程在跑，资源会有冲突</p><p>这也解释了为什么 mmap is suck，因为操作系统不会管你是不是在用 page2，它可能会提前将 page2 写出到磁盘</p></li></ol></li></ul><ul><li><p>Locks vs. Latches</p><p>  <img src="./16.png" alt></p><p>  以数据库的语义来讲，lock 是某种高级逻辑原语（high-level logical primitive），它会去保护数据库中的逻辑内容，比如 tuple、表以及数据库，事务在运行时会去持有这个 lock</p><p>  latch 是一种低级保护原语（low-level protection primitive），它用来保护数据库系统内部的关键部分，比如物理数据结构、内存区域</p><p>  在执行操作 （operation）期间，数据库会持有这些 latch，用来保护某些东西</p><p>  如果在执行操作时，没能拿到对应的 latch，那么这个操作就会被中止，同时也不需要关心回滚问题</p><p>  在操作系统的语义里面，latch 就相当于 mutex，mutex 也被用来保护一些关键内容，但是在 latch 中所使用的 mutex 实现其实是 spin lock（自旋锁）</p></li><li><p>Page 表 vs. Page 目录</p><p>  <img src="./17.png" alt></p><p>  Page 表是内存中的内部映射，它将 page ID 映射到它们在 Buffer 池中 frame 的位置，这个没必要做持久化，但必须要保证它是线程安全的。因为如果系统崩溃了，恢复后 Buffer 池里面的东西丢了就丢了，对数据库而言没有影响</p><p>  Page 目录是用来找到 page 在数据库文件中的位置，对 Page 目录做出的所有改变都必须持久化，它们必须要被写到磁盘上。因为如果系统崩溃了，恢复后我们需要知道在哪里可以找到之前的 page</p></li><li><p>Buffer 池内存分配策略</p><p>  <img src="./18.png" alt></p><ol><li><p>全局策略<br> 即这个策略能使整个要试着执行的 workload 都受益，比如查看所有运行在该系统上的查询/事务，选择哪些内容应该存储到内存</p></li><li><p>局部策略<br> 针对每个单个查询/事务，让其进行得更快的最佳方法</p><p>大多数数据库系统可能会试着尽量同时采取全局和局部优化策略</p></li></ol><ul><li><p>Buffer 池优化</p><p>  <img src="./19.png" alt></p><ol><li><p>多 Buffer 池</p><p> <img src="./20.png" alt></p><p> 可以在每个 Buffer 池上使用局部策略，这样就可以为放入的数据进行量身定制，比如让每个表都有一个 Buffer 池，当处于以下情况时，</p><ul><li>在某些表中可能会进行一系列的循环扫描</li><li>在某些表中可能会进行索引查询</li><li><p>某个时刻需要跳转到某个 page 上（表内查询）</p><p>就可以根据这 2 种 workload 类型来决定使用不同的替换策略，比如让一个 Buffer 池处理索引，另一个 Buffer 池处理表</p><p>这么做同时也会减少那些尝试访问 Buffer 池的不同线程之间争抢 latch 锁的情况，比如，如果有多个 page 表，那么每条线程就能在同一时间访问不同的 page 表，因此它们就不会去争抢这些 latch（这我是有点怀疑的，是不是一定要 page 表的数量要大于线程数？？）</p><p>Oracle、DB2、Sybase、SQL server、Informix 这些全都支持多 Buffer 池， MySQL 的做法是，对于一个给定的 page ID，它会通过 round-robin hash 来判断这个数据在哪，放在哪个 Buffer 池里面。</p><p><img src="./21.png" alt><br><img src="./22.png" alt></p><p>有 2 种方式来使用这些</p></li><li><p>Buffer 池通过管理和维护数据库对象（Database Object）的 record ID，来管理数据库对象，即将数据库对象的 record ID 维护到一个列表中，这样就能根据每个 ID 找到对应的对象条目。通过 record ID 能找到 Object ID、page ID、slot number，通过 Object ID 能找到对应的 Buffer 池，通过 page ID 和 slot number 就能找到对应的数据</p></li><li>传入 record ID，通过 hash 来确定数据在 Buffer 池中的位置，通过取模来确定在哪个 Buffer 池里</li></ul></li><li><p>Pre-Fetching（预取）</p><p> <img src="./23.png" alt></p><p> 当处理完 page1 后，如果要继续请求 page2 或 page3 的数据，通过 pre-fetching 的方式，它已经在 Buffer 池中了，那么也无序停顿去从磁盘中把相关 page 取出然后写入到 Buffer 池内存中</p><p> 另外，mmap 也是可以做到 pre-fetching 的</p><p> 有一个 index game 例子（这个例子主要是讲操作系统怎么去做 pre-fetching 的）</p><p> <img src="./24.png" alt></p><p> <img src="./25.png" alt></p><p> index-page3 和 index-page5 它们在磁盘上并没有连续排列在一起，所以操作系统会尝试去 pre fetch page2 和 page3，但实际上并不需要 page2，需要的是 page5，但是还没有 pre fetch 到它。出现这个的原因是操作系统并不知道查询要去做什么，因为操作系统做的是 索引扫描（像例子中的树那样的一个结构，需要 dfs 遍历），它不像数据库系统那样做的是 按照顺序扫描</p><p> 而对于 Buffer 池的 pre-fetching 来讲，这不是没有代价的，因为需要跟踪一些额外的元数据</p></li><li><p>扫描共享 scan sharing</p><p> <img src="./26.png" alt></p><p> 这个优化策略想的是，查询之间可以利用彼此的结果，某个查询可以复用另一个查询从磁盘中读取到的数据，也可以将该数据用于其他的查询</p><p> 但这和结果缓存（result caching）的方式不同，结果缓存指的是，当运行完全相同的查询时，计算出了某些结果，然后将这些结果缓存起来，遇到相同的查询时就再展示出来，而不是去重新执行这个查询</p><p> 而扫描共享的工作方式是，当允许将多个查询附加到一个单个游标（这个游标指的是上文所说的移动的 Q1 箭头 →）上，即将这些查询注册到这个游标数据结构管理的一个集合中时，扫描 pages，并将它们放入 Buffer 池中</p><p> 这有点像是那种 发布/订阅 的模式：我想知道你是否拿到了一个新的 page，然后你就可以去通知可能在等待这个 page 的线程，即便这个线程并不是真的要去拿到这个 page 去读取数据</p><p> <img src="./27.png" alt></p><p> DBMS 开始工作后，如果一个查询开始了一次扫描，然后它意识到这里有另一个查询也在做相同的扫描，它就将它自己附加到第一个查询的游标上，当这个查询拿到 page 时，它就通知我们该查询拿到了这个 page，我们也就可以去访问它了</p><p> 所以第二个查询出现的位置必须被跟踪到，记录好这个位置后，拿到数据即可返回，然后继续走原来剩余的逻辑</p><p> 知道了第一个查询结束时的游标位置，如果那里可能还有其他数据需要回去读取，就能直接回到之前那个点上，去获取剩余的数据</p><p> 这项技术只有 DB2 和 SQL server 完全支持，而 Oracle 支持一种基本的扫描共享技术，称之为游标共享（Cursor Sharing），但只有当有 2 个查询在同一时刻执行时，它才会有效</p><p> 两个相同查询的例子</p><p> <img src="./28.png" alt></p><p> 假设第一个查询 Q1，它要计算 SUM，那么它需要从磁盘中遍历整个 pages，然后将遍历的 page 写出到 Buffer 池中，按照惯例，此时 Buffer 池中已满，它需要将 page0 移除掉，并替换上 page3</p><p> <img src="./29.png" alt></p><p> 替换成功后，继续扫描，但是这个时候，第二个查询 Q2 出现了，它也想从磁盘中遍历整个 pages</p><p> <img src="./30.png" alt></p><p> 在没有扫描共享的情况下，就会出问题，因为此时 Buffer 池已满，对于 Q2 来讲它需要的是 Buffer 池中的 page0，但是刚刚 page0 已经被 Buffer 池扔回到磁盘里面去了，那么 Q2 这个查询就 gg 了</p><p> 所以在有扫描共享的情况下，Q2 只需要跳到 Q1 目前所在的位置，并且去读取 Q1 要读的相同的数据，并计算出 Q2 所找的那部分数据的结果</p><p> <img src="./31.png" alt><br> <img src="./32.png" alt></p><p> 而当 Q1 结束时，Q1 的游标就消失了，Q2 查询从头开始</p><p> <img src="./33.png" alt><br> <img src="./34.png" alt></p><p> 直到遍历到 page2，Q2 结束，这就是 Q2 扫描的路径</p><p> 那么每个查询在读取数据的同时也在计算中间结果，它们也需要一块内存区域去存放这些数据，而这个内存区域跟这个 Buffer 池是分开的，但通常情况下，这块内存区域也可以由一个 Buffer 池所支持。但它到底是在一个全局 Buffer 池中还是在这个查询所私有的 Buffer 池中，还得取决于具体实现</p><p> 如果在扫描 Buffer 池中的数据，并更新中间结果时，可能会遇上内存溢出，为了腾出空间保留中间结果，会将 Buffer 池中的 page 数据刷出到磁盘</p><p> 通过 locks 可以对一些 pages 进行跟踪管理是否允许对这些 pages 进行读写，或者时将 locks 应用于一些数据库对象上</p><p> 如果将 Q2 的查询修改下，让它去计算 100 条数据的平均值</p><p> <img src="./35.png" alt></p><p> 这里并没有明确说这里要的是否是 前 100 个 tuple 的数据。因为现在 Q2 的游标是在 page2 处，所以遍历可以从 page3 开始，然后看下这前 3 个 page 中前 100 个 tuple，计算出结果。但如果从 page0 开始扫描计算，那可能会得到一个不同的结果。但因为关系模型中数据库是无序的，所以根据关系模型，这是没问题的。</p></li><li><p>Buffer 池 Bypass</p><p> <img src="./36.png" alt></p><p> 思路是，分配一小块内存给执行查询的那条线程，当它从磁盘中读取 page 时，如果该 page 不在 Buffer 池中，那么它将会把这个 page 从磁盘写入本地内存而不是 Buffer 池。当查询完成时，所有的这些 page 都会被丢弃掉。</p><p> 这么做是为了避免去 page 表中进行查询所带来的开销，因为 page 表中对应的条目是带锁的。</p><p> 在 Informix 中，这叫做 “Light Scans”，主流数据库都支持它</p><p> 注意，只有当操作的是中间结果以及查询扫描的量不大的场景才适用</p></li></ol></li></ul></li><li><p>操作系统 Page 缓存</p><p>  <img src="./37.png" alt></p><p>  数据库所有的磁盘操作都是通过最底层的 OS API 来做的，比如 fopen/fread/fwrite 等。默认情况下，操作系统会维护它自己的文件系统缓存，比如，当从磁盘读取一个 page 时，OS 会去在它的文件系统缓存中保存一份副本，写入到 Buffer 池中时，里面就会有另一个副本。但大部分数据库系统不会让 OS 对要读取的文件进行任何缓存处理，因为它们要自己管理内存。</p><p>  但是，唯一利用操作系统 page 缓存的就是 PostgreSQL，因为从它们工程师的角度看，他们就无须再管理一个额外的缓存，他们依然有他们自己的 Buffer 池，但没有那么大，这样就不会去使用系统中所有的内存。但像 MySQL 或 Oracle 就会</p><p>  htop</p><p>  <img src="./38.png" alt></p><p>  Mem 部分，橙条代表操作系统的 page 缓存，绿条代表该计算机上运行的进程的实际使用物理内存</p><p>  使用如下命令清除 OS page 缓存</p>  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sync; <span class="built_in">echo</span> 3 &gt; /proc/sys/vm/drop_caches</span><br></pre></td></tr></table></figure><p>  <img src="./39.png" alt></p><p>  可以看到机器使用的总内存已经下降到 3GB 左右</p><p>  顺便，如果 Buffer 池的大小小于要读取的数据库表的大小的话，那么在 Buffer 池中命中 pages 的数量，要小于在磁盘中读取 pages 的数量</p><p>  <img src="./40.png" alt></p><p>  比如上图中，从磁盘读取的 27932 &gt;&gt; Buffer 池中的 16316</p><p>  这取决于 Buffer 池的大小，如果把 Buffer 池大小设置（下图为修改 PostgreSQL 的配置文件，修改项为 shared_buffers）为比要读取的数据库表大小还大，那么</p><p>  <img src="./41.png" alt><br>  <img src="./42.png" alt></p><p>  Buffer 池就会命中（hit）全部的 pages，因为给了数据库系统合适大小的内存量，对于这个查询而言，就没必要去从磁盘拿 page 了</p><p>  hit 的意思是找的东西在 Buffer 池中的数量</p><p>  pg_prewarm 会告诉数据库系统去读取磁盘上该表的所有数据，并将他放入 Buffer 池中（SELECT pg_prewram(‘testreals’)）</p><p>  为什么其他主流数据库系统不依赖操作系统 page 缓存呢？因为假设在 OS page cache 中放入一个 page，而在 Buffer 池中放入该 page 的一个副本，如果这个时候要对 Buffer 池中修改这个 page 部分，那么 OS page cache 和 Buffer 池中的 page 就不再是同一个东西了，OS page cache 中存的就是老 page 数据，那么这个数据就冗余了。</p><p>  同时，不同数据库支持的操作系统也不一样，如果都用操作系统 page 缓存，那么可能出现性能上的差异，为了保证跨 OS 间的一致性，必须要把这个交给数据库系统本身来管理</p><p>  如果使用的是 Direct IO，这就会告诉操作系统不要去缓存任何东西，这样数据库系统就始终得跑到磁盘上去获取数据了</p><p>  操作系统 page 缓存是磁盘和数据库之间的东西</p></li><li><p>Buffer 替换策略</p><p>  <img src="./43.png" alt></p><p>  如果现在需要讲一个 page 放入内存中，但是内存里没有空间放它，这个时候该怎么办呢？</p><p>  在替换策略中，最重要的就是 准确性，因为要确保移除的 page 是在未来不太会被用到的那些 page</p><ol><li>运行某些算法来弄清楚该移除哪个 page 会比读取 page 时所花的时间要长</li><li><p>跟踪大量额外的元数据也会带来开销，因为可能会出现跟踪的元数据的体积比 page 本身还要大</p><p>非常高端的、价格很昂贵的企业级数据库和开源数据库之间有什么区别呢？</p></li><li><p>高端数据库拥有非常复杂的替换策略，它们会跟踪统计 page 的相关使用数据，会尝试从查询实际所做的事情中推断出最好的决策</p></li><li>开源数据库的某些比较新的系统中，它们在这方面并没有做的像高端数据库那么好，它们就只能做些简单版的东西了</li></ol><ul><li><p>Least-Recently Used（LRU）</p><p>  一种使用起来超简单的技术就是 LRU，即跟踪一个 page 最后一次被访问时的时间戳，然后只要看哪个 page 拥有的时间戳是最老的，哪个就应该要被移除掉</p><p>  那么此时就可以维护一个单独的数据结构，比如队列，根据 page 的时间戳进行排序</p></li><li><p>Clock<br>  一个 LRU 的近似算法，就是 Clock</p><p>  <img src="./44.png" alt></p><p>  在 Clock 中，没必要去追踪每个 page 的时间戳，相反，唯一需要去跟踪的信息是每个 page 的标志位（reference bit），它会告诉你自从上次检查过该 page 后，这个 page 是否被访问了，所以你需要将你的 page 弄成一个环形的 Buffer，like a clock。在一圈时钟这个时间段内，如果标志位没有变化，就可以从 Buffer 池中移除这个 page。</p><p>  <img src="./45.png" alt></p><p>  假设某些查询访问了 page1，那么此时 page1 的标志位会被设置成 1，注意这里无论多少查询访问过这个 page1 多少次，这里的值始终都被设置为 1，因为标志位不是计数器。</p><p>  当现在需要去移除 page 时</p><p>  <img src="./46.png" alt><br>  <img src="./47.png" alt></p><p>  clock 会从 page1 这个地方开始走起来，当看到 page1 的标志位为 1 时，说明这个 page1 被访问过，所以不应该去移除掉 page1，但现在只是将 page1 的标志位设置成 0。然后走向下一个 page2。此时它发现 page2 的标志位是 0，就可以将 page2 移除掉（因为它不是 1，如果是 1 会被先设置成 0 然后遍历下一个 page）</p><p>  使用 Clock 算法的优点是，在移除 page 时，不会精确地移除最近最少使用的那个 page。</p><p>  在某些查询上表现得很好，比如点查询（point query）时访问单个东西</p></li><li><p>问题</p><p>  <img src="./48.png" alt></p><p>  但 Clock 和 LRU 都容易受到 sequential flooding 带来的影响</p><p>  这意味着，当进行读取每个 page 的特殊扫描时，这可能会污染 page 缓存，可能会将接下来真正要用到的 page 从 Buffer 池中移除掉。因为它扫描并读取了一堆 page，所有的这些 page 的时间戳都会比实际想要的那个 page 要新。因为要被移除的那些 page 应该是 最近 被使用的，而不是 最近最少 被使用的</p><p>  例子</p><p>  Q1 是一个点查询，它读取了 page0，并放入了 Buffer 池中</p><p>  <img src="./49.png" alt></p><p>  接着有另一个遍历查询 Q2，它会读取所有的 page</p><p>  <img src="./50.png" alt></p><p>  现在想要在 Buffer 池中给 page3 分配一个空间，如果用的是 LRU，那么它会指出 page0 是 Buffer 池中最近最少使用的 page，那么移除掉 page0，放入 page3</p><p>  <img src="./51.png" alt></p><p>  但是在 workload 中，会有不断地去执行类似于 Q1 那样的查询</p><p>  <img src="./52.png" alt></p><blockquote><p>注意上图中，在 Disk Pages 上的红色 Q2 应为 Q3</p></blockquote><p>  不断的执行 Q3，它要读的是 page0。但是之前 page0 已经从 Buffer 池中被移除掉了，这样就 fucked up 了。</p><p>  而真正应该要被移除的应该是 page1 和 page2，因为 Q2 会去读取更多的数据，而其他查询（Q1 和 Q3）并不会到 Buffer 池中读取这些数据（page 0 之后的 page）</p></li><li><p>更好的策略：LRU-K</p><p>  <img src="./53.png" alt></p><p>  思路是，将最近使用过 1 次的判断标准扩展为最近使用过 K 次，没有达到 K 次访问的数据并不会被缓存。访问记录不能无限记录，当访问次数达到 K 次后，将 数据索引 从 历史队列 移到 缓存队列 中</p><p>  相比于 LRU 比较时间戳，LRU-K 看的是时间戳时间的间隔，统计哪一个 page 的上一次和下一次的访问的时间间隔最长，那么哪一个 page 就是最近最少使用的</p></li><li><p>更好的策略：本地化（Localization）</p><p>  <img src="./54.png" alt></p><p>  使用多个 Buffer 池，让每个查询本地化，即每个 Buffer 池能对应住一个查询，那么对于单个查询来讲，只会去移除对于这个查询而言最近最少使用的那个 page，而不是对于整个查询而言最近最少使用的那个 page</p></li><li><p>更好的策略：优先级提示（Priority Hints）</p><p>  <img src="./55.png" alt></p><p>  有索引时，就知道查询时如何进行扫描的，也能知道哪些不同的 page 被访问了，可以使用这个信息来判断该移除哪些 page</p><p>  例子，假设有一个 Insert 的操作 Q1，对应的表里面有一个全局的计数器，每次 Insert 时，它就会加 1</p><blockquote><p>注意这里索引的存储结构一般是类似 B+ Tree 的结构</p></blockquote><p>  <img src="./56.png" alt></p><p>  如果根据这个 id 从小到大排序，意味着遍历始终是沿着树的右侧往下走，去拿到这些 page 的</p><p>  <img src="./57.png" alt></p><p>  因此这个时候就应该提示 Buffer 管理器，这些被红色框圈起来的 page 就应该试着待在内存中</p></li><li><p>处理 Dirty Pages</p><p>  <img src="./58.png" alt></p><p>  在 page 上有一个 dirty bit，它表示自从上次它被放入 Buffer 池中后，是否还有查询对该 page 的内容做了修改。</p><p>  快的方式：如果一个 page 在 Buffer 池中不是 dirty 的，直接 drop 掉它就好<br>  慢的方式：如果一个 page 在 Buffer 池中是 dirty 的话，在将该空间重新用于新的 page 之前，必须将这个 page 安全地写回磁盘</p><p>  而这是有 trade-off 的，因为一大堆不是 dirty 的 page，可能最近需要用到它，所以直接 drop 掉会带来后面重新读取磁盘并写入内存的 I/O 影响。</p><p>  而如果不想要 drop 掉这些不是 dirty 的 page，那就要花点代价将 dirty page 从 Buffer 池中移除掉，然后复用移除掉的这些空间。但是这么做就需要 2 次磁盘 I/O 了，一次 I/O 是用来写出 dirty page，从 Buffer 池中移除，另一次 I/O 则是读取那个想要的 page（感觉和上面那个 drop 非 dirty page 的情况差不多）</p></li><li><p>后台写操作（Background Writing）</p><p>  <img src="./59.png" alt></p><p>  为了避免 必须立即 将 page 写出以便在 Buffer 池中释放可用空间的问题，在数据库系统中有一条执行定时任务的线程，它会在 Buffer 池中找出那些被标记为 dirty 的 page，将它们写出到磁盘上，然后可以将这些 page 标记为 clean。那么当使用替换策略去决定该移除哪个 page 时，就有一堆 clean 的 page 可以 drop 掉了。</p><p>  但是这个操作要小心，因为在该 dirty page 对应的修改操作写入日志之前，我们不希望将这些 dirty page 写出到磁盘</p><p>  同样的，这也是 mmap 无法做到的事情</p></li></ul></li><li><p>其他内存池</p><p>  <img src="./60.png" alt></p></li><li><p>结论</p><p>  <img src="./61.png" alt></p><p>  这节课的重点在于我们该如何去管理内存并做得比 OS 更好</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;注: 本文首发我的 b 站专栏文章&lt;a href=&quot;https://www.bilibili.com/read/cv14580880&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;CMU 15-445/645-笔记-05-Buffer池与内存管理&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Database" scheme="https://strugglebak.github.io/categories/Database/"/>
    
    
      <category term="Database" scheme="https://strugglebak.github.io/tags/Database/"/>
    
  </entry>
  
  <entry>
    <title>CMU-15-445-645-笔记-04-数据库存储-part2</title>
    <link href="https://strugglebak.github.io/2022/06/05/CMU-15-445-645-%E7%AC%94%E8%AE%B0-04-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%98%E5%82%A8-part2/"/>
    <id>https://strugglebak.github.io/2022/06/05/CMU-15-445-645-笔记-04-数据库存储-part2/</id>
    <published>2022-06-05T13:35:59.000Z</published>
    <updated>2022-06-05T13:44:02.314Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>注: 本文首发我的 b 站专栏文章<a href="https://www.bilibili.com/read/cv14558880" target="_blank" rel="noopener">CMU 15-445/645-笔记-04-数据库存储-part2</a></p></blockquote><a id="more"></a><p><img src="./Cover.png" alt></p><blockquote><p>注意：这节课是 3-1 的延续</p></blockquote><ul><li><p>课程目标</p><p>  <img src="./1.png" alt></p></li><li><p>日志结构（Log-Structured）的文件组织</p><p>  <img src="./2.png" alt></p><p>  主要是存储如何创建 tuple 以及修改 tuple 的相关信息，比如增删改查的操作</p><p>  <img src="./3.png" alt></p><p>  这些记录会以文本文件的形式保存，读起来就像是日志记录一样</p><p>  为什么要这么做？</p><p>  循序写入/读取/访问的速度要远比随机访问快得多。如果使用 Slotted Pages 的方式，假设要更新 10 个在不同 page 上的 tuple，那就必须在这 10 个 page 上来写入并更新这些 tuple。但如果使用的是 Log-Structured 文件组织这种形式，把这要更新的 10 个 tuple 的语句写在单个 page 上，就一次性能搞定全部了。</p><p>  Log-Structured 文件组织这种想法也并不新颖，它是在 1980 年代末，1990 年代初出现的。虽然出现的晚，但最近十年这种技术开始起飞。比如在 HDFS 或者 S3 中，这些分布式文件系统就只支持这种追加的方式，即没办法进行随机更新，能做的就是追加记录</p><p>  但这种方式有明显缺陷，是什么呢？</p><p>  是 读取</p><p>  如果现在要去读取某个 tuple，那么就需要回头去在日志中查找这个 tuple</p><p>  <img src="./4.png" alt></p><p>  有几种方式可以加快访问的速度</p><ol><li><p>建立索引，可以通过索引跳到日志中特定的 offset 处，就能找到对应的数据</p><p> <img src="./5.png" alt></p></li><li><p>定期压缩 log</p><p> 重新遍历一遍 log，对里面的内容进行筛选压缩，而对于每个 tuple，只需要一条记录即可</p><p> 把这种</p><p> <img src="./6.png" alt></p><p> 变成这种</p><p> <img src="./7.png" alt></p><p> 有以下几个数据库用这种方式</p><p> <img src="./8.png" alt></p><ul><li>HBase</li><li>Cassandra</li><li>LevelDB</li><li><p>RocksDB</p><p>有许多分布式数据库系统使用了这种技术，并且是用 Go 写的。比如 CockroachDB 使用了 RocksDB 存储管理器作为底层，它的分布式执行层都是用 Go 来写，但在它内部使用的 RocksDB 用的是 C++。而 RocksDB 是 Meta 的，但它是基于 LevelDB 改进后的产物，而 LevelDB 是 G 家的。Meta 把 LevelDB 拿过来，首先做的事情就是干掉 mmap，然后才有的 RocksDB。</p><p>LevelDB 至今还活着，但很多人用的还是 RocksDB</p></li></ul></li></ol></li><li><p>Tuple 存储</p><p>  <img src="./9.png" alt></p><p>  例如 Integer 和 Float 这些固定长度的东西，在大部分数据库系统中其表达方式和 C/C++ 使用的方式是一样的</p><p>  <img src="./10.png" alt></p><p>  因为这通常是由 IEEE-754（二进制浮点数算数标准） 标准所定义的</p><p>  IEEE-754 是一种行业标准，用来表示数字和 CPU 的规范，比如 Integer 和 Float 应该是多少个字节，是大端对齐还是小端对齐之类的</p><p>  对于那些可变长度的类型，例如 VARCHAR/VARBINARY/TEXT/BLOB 来说，通常情况下它们里面会有一个 header，这个 header 会有 保存的 blob 的长度，如果是一个很大的值，那后面还会跟一个 checksum。紧接着跟着的就是字节序列了。</p><p>  对于时间类型来讲，大多数数据库系统通常会去保存从 1970 年 1 月 1 日起的秒数/毫秒数/微秒数来处理时间。本质上这些数据库系统保存的依然是完整的时间戳。</p><p>  对于定点数字（Fixed Point Value）来说，非常依赖于 C++ 或者底层硬件所提供给我们的数字</p><p>  <img src="./11.png" alt></p><p>  Float, Real/Double 或者可变精度的数字，这些都是 CPU 或者 C++ 给的不精确的数字</p><p>  而对可变精度数字执行操作的速度要比任意精度数字快得多，因为 CPU 拥有能高效执行这些操作的指令。比如，CPU 通过 1 条指令就能对俩浮点数进行加减运算，但处理定点数字时就需要一大堆指令来处理了</p><p>  虽然处理可变精度数字相对快，但这里也存在舍入误差，因为在 IEEE-754 标准中，并没有任何办法能够将十进制数 准确 地存入硬件，也只能使用一个大概的数字</p><p>  一个浮点数精度的例子，假如我想要的时小数点后 20 位的数，那么用 GCC 编译出来是啥结果呢？</p><p>  <img src="./12.png" alt></p><p>  因为硬件只能近似逼近或者说模拟 0.3 这个浮点数，没有办法真正精确地去表示这个数</p><p>  所以为了解决这个舍入误差的问题，就需要固定精度的数字了</p><p>  <img src="./13.png" alt></p><p>  可以把值作为 VARCHAR 类型（不是 string）来储存，然后通过一些元数据来表示，这里是小数点，那里是精度范围，接着另一边是舍入信息，这些东西都放在 tuple 里面，同时也是该 tuple 字节数组的一部分</p><p>  Postgres 一段源码</p><p>  <img src="./14.png" alt></p><p>  当声明一个 Fixed point DECIMAL 时，Postgres 就像上图中那个方式来存这个 struct，这里面包含了关于 DECIMAL 的一些额外的元数据</p><p>  <img src="./15.png" alt></p><p>  用红色标注出来的部分，其实是一个用来表示 REAL 类型值的字符串</p><p>  那么为什么操作 DECIMAL 会慢呢？下面是一段做加法的源码</p><p>  <img src="./16.png" alt></p><p>  可以看到，这并不是用一条指令就能完成的，它需要一系列的 switch 条件才能完成，比如说要判断它的正负、是不是 0，或者两个数字是否相等。但是如果是 REAL 或者是一个浮点数做加法时，CPU 只需要一条指令就能完成。</p><p>  所以如果不想因为精度问题丢失数据，那就用 Fixed Point DECIMAL</p></li><li><p>大数值</p><p>  <img src="./17.png" alt></p><p>  如果想要保存的东西因为体积太大而无法放在一个单一 page 上，该怎么办？<br>  有两种方式</p><ol><li><p>用 overflow page 来解决<br> 在这个例子中，如果这个 tuple 中的 c 对应的 data 太大了，那么就通过一个指针来指向保存 c 对应的 data 的那个 overflow page</p><p> <img src="./18.png" alt></p><p> 如果 overflow page 也放不下这个数据，那么同样可以通过 overflow 指针来指向某些其他 page 来解决这个问题</p><p> 正常情况下，overflow page 是无法通过常规手段进行操作的，所以要尽量避免</p><p> 在 Postgres 中，大部分时候，这些 overflow page 是 只读，或者几乎都用来读，很少往上面去写东西。所以大部分对 overflow page 的优化，都受到和常规 data page 或者 tuple page 一样的保护</p></li><li><p>用 外部存储 来解决</p><p> <img src="./19.png" alt><br> <img src="./20.png" alt></p><p> 基本思路是，不会把该属性的数据保存在 tuple 内部，而是往这个里面保存一个指针或者是一个文件路径，它们指向存放该数据的本地磁盘/网络存储/外部存储设备的位置</p><p> 有些系统对此进行了支持，例如 Oracle，DB2，以及巨硬</p><p> 对于 DBMS 来讲，它无法对外部存储文件中的内容做修改</p><ol><li>没有持久化保护</li><li><p>没有事务保护</p><p>有一篇 10 前年的论文，由很多在微软工作的数据库专家撰写的，叫 《TO BLOB or Not TO BLOB: Large Object Storage in a Database or a Filesystem?》</p><p>BLOB 的意思是二进制大对象，是可变长度的二进制数据</p><p>在 2000 年代，任何小于 256KB 的东西，我们都倾向于将它保存在一个 overflow page 上，任何大于 256KB 的，我们都倾向于将他保存在外部存储文件中</p><p>之前有个做 SQLite 相关工作的来 CMU 搞了一场讲座，他表示对许多手机应用来讲，最好将图像的缩略图存储在数据库系统中，尽管某些图片的大小甚至有 1MB，因为从数据库中读取这些记录会更快，因为它们已经将文件打开，就不用去根据指针在文件系统中查找文件，然后使用 f.open 来打开文件获取数据了</p><p>但是，如果将一大堆视频文件保存在高端的企业磁盘上，那就真的是浪费钱了。所以解决办法是把这些文件弄成块 （chuck），保存在 HDFS 或者使用更便宜的网络存储服务– AWS 的 S3 上面，那么数据库系统就不会因为为了维护这堆文件而负担过重了。</p></li></ol></li></ol></li><li><p>系统 Catalogs</p><p>  <img src="./21.png" alt></p><p>  系统 catalogs 是关于数据库相关信息的元数据，它里面存放了表名，索引等等</p><p>  很多数据库系统都会将它们的 catalog 用另一张表来保存</p><p>  <img src="./22.png" alt></p><p>  大部分数据库系统会通过 STANDARD INFORMATION_SCHEMA 这个 API 把 catalog 暴露出来，因为 1980 年代每个这种 API 每个数据库给的都不一样，所以后面出了 ANSI 标准使得每个数据库系统都必须支持这个 API</p><ul><li><p>访问表 Schema<br>  访问当前数据库的所有表</p><p>  <img src="./23.png" alt></p><p>  访问当前数据库某张表的 schema</p><p>  <img src="./24.png" alt></p><p>  schema，当在数据库中做查询以及构建索引时，就会用到它</p></li></ul></li></ul><ul><li><p>Wikipedia 简化版本表例子</p><p>  <img src="./25.png" alt></p></li><li><p>workload<br>  在数据库系统中，我们所关心的 workload 主要有两类</p><ol><li><p>OLTP</p><p> <img src="./26.png" alt></p><p> On-line Transaction Processing，即联机事务处理</p><p> 思路是，从外部世界拿到新数据之后，将它们放入到数据库系统中，而在查询/更新时，数据库只会去读取/更新一小部分数据，然后不断地重复类似的操作</p><p> 比如 Amazon 的 storefront，当你在网站上买东西的时候，就可以当作是对应用程序的 OLTP。购物网站会大量地进行添加商品、结账、更新账户信息等操作，但是对于顾客个人来说，只需要查询/更新他自己的那一部分数据。</p></li><li><p>OLAP</p><p> <img src="./27.png" alt></p><p> On-line Analytical Processing，即联机分析处理</p><p> 当数据库已经从 OLTP 应用程序中收集到一大堆数据时，现在要分析这堆数据，并从中推断出新的信息（数据科学？？）。同时 aka 商务智能（business intelligence）/决策支持（dicision support）/大数据（big data）</p><p> 在 OLAP 的情况下，数据库不会去更新数据，但是会读取大量的数据，要做大量的 join 操作</p><p>一张 workload characterization 图</p><p><img src="./28.png" alt></p><p>从图中可以看出</p></li></ol><ul><li>OLTP 擅长简单的查询，但是会做大量的写操作</li><li>OLAP 会做大量的读操作，但它们会更复杂</li><li><p>HTAP（Hybrid Transaction Analytical Processing）混合事务分析处理，综合 OLTP 和 OLAP 的产物</p><p>对于传统的 NoSQL 系统，mongoDB、Cassandra 以及 Redis 来讲，它们应该属于靠近 OLTP 那块，即主要往数据库里面塞入新数据</p><p>在某些分析方面，mongoDB 对此做了部分支持</p><p>而 MySQL 和 PostgreSQL 支持一些属于 OLAP 类型的查询</p><p>但这些比起列存储数据库来讲，就没那么高效了</p><p>NoSQL 是在 2000 年末出现的，有很多公司做这个，比如 G 家就为此投入了大量的资金，它们推出了 HBase、 BigTable 以及 Hadoop。它们不会去执行 SQL，也不会进行事务处理，更不会进行 join 操作，但是这就是它们能拓展的原因。</p><p>最终这帮人构建出了 NoSQL 数据库系统，比如 mongoDB 和 Cassandra，它们都试着遵循某种设计模式，以此来支持现代的软件 2.0 或 web 2.0 应用。</p><p>Hadoop 具备 OLAP 能力，而像 BigTable，Cassandra，mongoDB 具备的则是 OLTP 能力</p><p>后来人们也想在 NoSQL 系统上执行 SQL，进行事务处理，进行 join 操作，NewSQL 因此应运而生</p><p>Wiki 上 NewSQL 相关信息的第一个系统 H-Store 就是老师开发的，因为这个页面是老师写的（笑</p><p>搞 SQL 那帮人一开始表示它们不会去使用 SQL，认为 SQL 太垃圾了，除了 mongoDB 支持某些 SQL 的变体，其他的系统都不支持 SQL，但后面他们又改口说 NoSQL 的意思是 Not only SQL。。。（草，这算是技术圈的风水轮流转吗）</p><p>人们在 1970/80 以及 2000 年代都觉得 SQL 是一种糟糕的东西，但它一直都没有退出历史舞台。</p></li></ul></li><li><p>数据存储模型</p><p>  那么什么样的存储模型才能更有效地支持这些 workload 呢？</p><p>  <img src="./29.png" alt></p><ul><li><p>n-ary 存储模型（N-Ary Storage Model NSM）</p><p>  <img src="./30.png" alt></p><p>  以行（Row）的形式展示的 tuple，这被称为 n-ary 存储模型</p><p>  基本思路是，将单个 tuple 中的所有属性取出，并将它们连续地存储在 page 中</p><p>  一个 OLTP 的想法，因为要去访问的数据量在粒度上要足够的小，即一次取一行数据，而这一行数据会按照定义连续存储，这样就能访问到单个实体，拿到对应的信息。如果它是一行数据，就会非常高效，因为只需要跳到那个 page，找到那个数据就完事了。<br>  <img src="./31.png" alt><br>  <img src="./32.png" alt></p><p>  让一个 tuple 的所有数据连续地放在一起是读取数据时最有效的方式，因为用索引 index 就可以直接查了，而对于插入操作也是如此</p><p>  但为什么行储存是一个糟糕的想法呢？比如如下的一个查询例子</p><p>  <img src="./33.png" alt></p><p>  在上图的查询中，不得不去读取整个 page，而在非易失性存储设备中，它是一个基于阻塞的 API（EXTRACT ？？？），没办法直接得到这些数据，需要拿到整个 page 之后才行。现在为了执行这条查询，就有了这些我们根本不会去访问的列，但为了得到实际需要的两列（hostname 和 lastLogin），不得不从磁盘中拿到它们（整个 page）并将它们放到内存里（这里的意思应该指内存里面多了 Useless Data）。这是个 bad idea，因为它浪费了硬件的性能。</p><p>  <img src="./34.png" alt></p><ol><li>优势<ul><li>访问整个 tuple 时，插入/更新/删除数据都很快</li><li>利于查询整个 tuple 的属性</li></ul></li><li>劣势<ul><li>但如果要进行一些分析型的查询以及做些 OLAP 的工作，并且要去扫描整张表大部分的内容时，it will suck。因为这需要往内存塞一大堆不需要的数据</li></ul></li></ol></li><li><p>列存储模型（Decomposition Storage Model DSM）</p><p>  <img src="./35.png" alt></p><p>  在列存储模型中，并不会将单个 tuple 的全部属性放在单个 page 中，而是将横跨所有的 tuple 中单个属性的所有的值保存在单个 page 中。即把单个列的所有的值连续的保存在一起。</p><p>  那么要做 OLAP 的话，只需要读取给定表中部分属性的集合就好了</p><p>  <img src="./36.png" alt><br>  <img src="./37.png" alt></p><p>  把 tuple 属性拆开来，一个 page 就放一种 tuple 属性</p><p>  <img src="./38.png" alt></p><p>  对于前面的查找的情况，现在就只需要扫描两个 pages 即可，而不是扫描整个 pages</p><blockquote><p>注意: 这里图的颜色配反了，下面的图应该要黑蓝换一下</p></blockquote><p>  顺便列存储也有利于数据的压缩（如果有重复的值存在），因为每个 page 下的属性的类型都是一致的，那么说明它所占空间每一块对于 page 存储的数据来说都是均匀的，大小一致，而行存储则可能往往相反</p><p>  那么应该怎样从一个 page 中找到一个匹配项呢</p><p>  有 2 种方案，但通常会选择第一种</p><p>  <img src="./39.png" alt></p><ol><li>使用固定长度的 offset（推荐）<br> offset * 每个属性的 size 就能找到位置，比如前面说过的 row ID，page ID 和 slot number 就是这么做的</li><li><p>对于列中的每个值都保存一个主键或者时标识符（不推荐）<br> 通过 (key + value) * offset 的形式去查找，但是本身存储开销很大，因为得为每个值用额外的 32/64 bit 的空间来保存它们的 id，非常浪费</p><p><img src="./40.png" alt></p></li><li><p>优势</p><ul><li>进行 OLAP 查询时，可降低垃圾 I/O 的数量</li><li>利于压缩数据，这样在查询上性能就会更好</li></ul></li><li><p>劣势<br> 读取单个 tuple 时候就会很慢，因为需要把不同列的数据拼在一起，这样才能得到一个完整的 tuple，然而对于行储存直接拿就行，同样的对 tuple 进行更新/删除，代价也更高</p><p>同样的，列存储也不是什么新想法</p><p><img src="./41.png" alt></p></li><li><p>瑞士军方当时构建了一个叫做 Cantor 的系统，在 1970 年代，因为他们使用了别的语言来写的，所以这玩意儿没被叫做数据库，但它实际上就是个列存储数据库。</p></li><li>1980 年代，有篇 paper 提到了列存储模型，同时也提到了更多细节，比如短格式（short format）、存储模型的意义</li><li>Sybase IQ 是 Sybase 公司推出的专门为数据仓库设计的关系型数据库，IQ 的架构与大多数关系型数据库不同，有用于支持大量并发用户的即时查询的特殊设计。可能是最著名的第一个实现列存储的商用数据库。这是一个内存型列存储数据库，Sybase 把它作为普通的行存储数据库系统的加速器发布，这样他们就可以进行 HTAP 处理并具备同步的能力，但它并没有被广泛采用，因为它被当作行存储数据库的插件而不是作为一个独立的产品来卖</li><li>到了 2000 年代，列存储数据库才真正起飞，Vertica 由 Michael Stonebraker 创立，他之前参与过 PostgreSQL 和 Ingres 这些数据库的开发。之后他的公司被 HP 收购，VectorWise 是 MonetDB （MonetDB 是一个开源的面向列的数据库管理系统，它被设计用来为较大规模数据，比如几百万行和数百列级别的数据库表，提供高性能查询的支持） 的内存版。MonetDB 以前是欧洲的一个学术项目，但现在到处都在用它，它是 2000<br>年代出现的第一个列存储数据库系统</li><li>之后列存储很快就出名了，因为人们发现这是构建用于数据分析型数据库系统的正确方式</li></ol></li></ul></li></ul><p>那么有没有结合行存储和列存储方式的数据库系统呢？有的，比如 MySQL，在创建表时，可以告诉它用行存储，在创建另一张表时可以告诉它用列存储，所以本质上来说 MySQL 有俩独立的存储管理器，以及俩独立的执行引擎来处理，所以这种就被成为混合数据库系统。虽然有些数据库对于 OLTP 和 OLAP 都支持，但真正牛逼飞起的还没几个。。。</p><p>基本上，人们在前端 OLTP 系统中所运行的是 MySQL、mongoDB 或者其他数据库系统，然后你把数据传输给后端数据仓库（back-end data warehouse），然后基本上，当这堆数据不再需要的时候，就可以把 OLTP 这块老的数据给修剪掉了。这可以通过 MySQL + Vertica 这俩独立数据库做到。或者就使用单个混合型数据库，Splice machine 可以做，MySQL 也能做</p><ul><li><p>结论</p><p>  <img src="./42.png" alt></p><p>  简单规则，make life easier and better。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;注: 本文首发我的 b 站专栏文章&lt;a href=&quot;https://www.bilibili.com/read/cv14558880&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;CMU 15-445/645-笔记-04-数据库存储-part2&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Database" scheme="https://strugglebak.github.io/categories/Database/"/>
    
    
      <category term="Database" scheme="https://strugglebak.github.io/tags/Database/"/>
    
  </entry>
  
  <entry>
    <title>CMU-15-445-645-笔记-03-数据库存储-part1</title>
    <link href="https://strugglebak.github.io/2022/06/05/CMU-15-445-645-%E7%AC%94%E8%AE%B0-03-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%98%E5%82%A8-part1/"/>
    <id>https://strugglebak.github.io/2022/06/05/CMU-15-445-645-笔记-03-数据库存储-part1/</id>
    <published>2022-06-05T13:29:29.000Z</published>
    <updated>2022-06-05T13:34:51.221Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>注: 本文首发我的 b 站专栏文章<a href="https://www.bilibili.com/read/cv14558199" target="_blank" rel="noopener">CMU 15-445/645-笔记-03-数据库存储-part1</a></p></blockquote><a id="more"></a><p><img src="./Cover.png" alt></p><ul><li><p>课程目标</p><p>  <img src="./1.png" alt></p><ol><li>DBMS 是怎么用磁盘上的文件来表示数据库的（主要是这个）</li><li>DBMS 是怎么管理内存的，是怎么在磁盘间来回移动数据的</li></ol></li><li><p>课程大纲</p><p>  <img src="./2.png" alt></p><p>  上述展示的就是一个数据库中应该包含的东西，一个数据库就是建立在这些层面之上</p></li><li><p>面向磁盘的数据库架构</p><p>  <img src="./3.png" alt></p><p>  由于这门课是面向磁盘（Disk-Oriented）的数据库管理系统，即数据库的主要存储位置都是放在磁盘上的，意味着每次执行查询时，所要访问的数据都不在内存（Memory）中。所以在设计这个数据库管理软件时，要基于一些假设来设计一系列的组件，来保护这个数据库系统，使其免于数据丢失、保存无效或错误的数据等情况。</p><p>  此外还需要区分</p><ol><li>易失性存储</li><li><p>非易失性存储</p><p>简单来讲就是，我们所要的 数据系统 管理了数据从非易失性存储到易失性存储的移动</p><p>计算机的存储结构如图所示</p><p><img src="./4.png" alt></p></li><li><p>越上面的容量越小，速度越快，也越贵</p></li><li><p>越下面的容量越大，速度越慢，也越便宜</p><p><img src="./5.png" alt></p><p>注意这里在 DRAM 和 SSD 有条分界线，这里就是易失性和非易失性存储的分界</p><p>需要稳定的能量（电能）维持它所存储的东西的存储设备，叫做易失性存储，那么反之就是非易失性存储</p></li><li><p>如果数据是保存在易失性存储设备中，那么它就支持 快速随机访问，即无论在什么位置访问数据，访问数据的顺序是怎么样的，访问的速度都大体一致</p></li><li>如果数据是保存在非易失性存储设备中，由于它们具备的是 块寻址（非字节寻址） 能力，无法准确地得到数据的 位大小的数据（32bit, 64bit），所能得到的是包含要访问的数据的 块（Block） 或者 页（Page）</li><li><p>但是在非易失性存储设备中，比起随机读取不同位置上的内容，它能更有效率地去读取一段连续的 块 中的内容。所以对于非易失性存储来讲，是希望按顺序读取的数据量越大越好</p><p>Memory 和 Disk 的区分</p><p><img src="./6.png" alt></p><p>现在已经没人用磁带机来存数据了，但是可用来做容灾</p><p>Network Storage 现在指类似于 Amazon 的 EBS 或者 S3 之类的东西</p><p>实际上在分割线处还有新的一类存储设备，它被称之为非易失性内存（Non-Volatile Memory）</p><p><img src="./7.png" alt></p><p>比如 Intel 的 傲腾（Optane）内存，牙膏厂虽然是第一个发布这种内存的厂商，但这类技术的研究已经有 15-20 年左右的历史了</p><p>它可以像 DRAM 一样，可以插在 DIMM 槽内，却具备 字节寻址 能力，也可以像 SSD 那样，断电也能持久保存数据。</p><p>但残念的是，目前这种既能又能的存储设备并没有被广泛应用</p><p>顺便老师在课上写的这本书有卖吗？</p><p><img src="./8.png" alt></p><p>一张关于各种存储设备的访问耗时表</p><p><img src="./9.png" alt></p></li></ol></li><li><p>系统设计目标</p><p>  <img src="./10.png" alt></p><p>  目标就是，给应用程序提供一种错觉，即这个系统能提供足够的内存，能把整个数据库导入到内存中。并且最小化每次从磁盘读取/查询内容所带来的影响</p><p>  比如这种最小化的方式可以通过以下几种方式达到</p><ol><li>允许在同一时间运行不同的线程/查询</li><li>缓存</li><li><p>提前计算某些数据</p><p>一个访问磁盘数据的示意图</p><p><img src="./11.png" alt></p><p>可以看到有几个关键的地方，Directory、Buffer、Page</p><p>那么这个有点像什么呢？– 虚拟内存</p><p>那么操作系统能做这件事，为什么还这样设计而不直接使用操作系统来做呢？</p><p><img src="./12.png" alt><br><img src="./13.png" alt></p><blockquote><p>注意 mmap 指的是 maps files or devices into memory</p></blockquote><p>虽然操作系统可以利用虚拟内存通过 mmap 来映射到文件，但是这只适用于 只读 的访问，对于有多个 writer 的情况就复杂很多了</p><p><img src="./14.png" alt></p><p>因为操作系统并不知道某些 pages 必须要先于其他 pages ，从内存刷到磁盘，这里有一个竞争的关系</p><p>那么有没有解决方案呢？有的</p><p><img src="./15.png" alt></p></li><li><p>使用 madvise 告诉 OS 怎么去访问某些页面（顺序/随机读取）</p></li><li>使用 mlock 阻止 pages 被 OS 回收（尽管可以被锁定但并不能阻止它被写出到磁盘）</li><li><p>使用 msync 告诉 OS 要把数据刷到磁盘中</p><p>使用 mmap 和 部分使用 mmap 的 Database</p><p><img src="./16.png" alt></p></li><li><p>实际上 MemSQL 已经完全摆脱了 mmap</p></li><li>SQLite 有一个特殊的引擎，在嵌入式设备上 mmap 是可选的，默认情况下用不到</li><li>InfluxDB 只有在只读缓存上才使用 mmap</li><li><p>mongoDB 第一次被开发出来时，它的默认存储引擎用的就是 mmap，但为了让这个引擎能正常工作，开发人员也做了很多无用功，因为这里面存在着巨大的瓶颈，然后等他们筹到很多钱之后，就把 mmap 干掉了，再然后他们买了一个叫做 WiredTiger 的非 mmap 的存储引擎</p><p>注意这张图里面少了很多主流的 Database，比如 MySQL，Oracle，DB2 以及 SQL server，这些数据库都没有使用 mmap，因为 mmap 是一个糟糕的想法，因为缺少人为写代码去控制这种行为。</p><p>所以如果 mmap 是一个好的想法，那么这群土豪（指 mongoDB）手下的顶级工程师肯定能证明这的确是，然后并没有（哈哈哈哈好好笑）</p><p>老师痛恨 mmap</p><p><img src="./17.png" alt></p><p>毕竟操作系统啥也不懂，它只看到了一些读写和调用（</p></li></ol></li><li><p>文件存储</p><p>  <img src="./18.png" alt></p><p>  数据库其实就是磁盘上的一堆文件，SQLite 把数据库存储为一个文件，而其他大部分数据库比如 PostgreSQL 则会把这些分为多个文件来存储，因为数据库可能非常大，甚至可能有 PB 级别的数据量，你不会想要对这么大的一个文件做错误修复</p><p>  现在的一些”企业级”的数据库系统还支持自定义的专属文件系统，但近些年的一些数据库系统已经不支持了，因为非常不值得，要管理这种文件系统是一个很大的坑，同时也大大降低了可移植性。</p></li><li><p>存储管理器</p><p>  <img src="./19.png" alt></p><p>  存储管理器也叫存储引擎，它负责维护磁盘上的数据库文件。</p><p>  某些高端数据库系统在文件系统之上还有一个 shim 层，它允许数据库去做一些磁盘的调度，这就像是可以通过一堆线程来对彼此邻近的区块进行写入，也可以将这些区块合并后做一次写入请求。</p></li><li><p>Database Pages</p><p>  <img src="./20.png" alt></p><p>  一个 page 的集合，就是这一堆文件的一个组织形式。本质上来讲，一个 page 就是一个固定大小的数据块</p><p>  self-contained 的意思是，page 的内容必须存储在 page 本身内。比如 Orcale 就需要将描述该 page 中内容的所有元数据，和这些内容数据一起保存在该 page 中，避免数据库故障的时候你找不到，这样即便丢了一个 page，也不会影响其他的 page</p><p>  indirection 层允许将一个 page ID 映射到某个集合中一个文件的某个位置。相当于记录一个相对位置，方便文件整体移动后，只要知道整体文件的初始位置，依然可以通过该相对位置即 page ID 找到某个文件某个位置的数据所对应的 page。因为一个 page 的大小是固定的，page ID * page Size 即为 offset</p><p>  一些 page 的概念</p><p>  <img src="./21.png" alt></p><p>  Database Page 大小各有不同</p><p>  <img src="./22.png" alt></p><p>  但我们更需要关注的是 Hardware Page 的大小，因为它是原子的，即一次只能写入这么大的 page 数据，如果超过了，那么剩下的数据就会丢失写不进去，写入失败也不会回滚，数据就会损坏</p><p>  高级数据库可以设定它们自己 page 的大小</p><p>  那么为什么有些数据库系统使用的是空间更大的 page 呢？</p><p>  这里是有一些权衡的，比如在数据库系统的内部，通过内存中的 Page 目录将 page 映射到内存或者磁盘上的某个位置，如果现在用一个 page ID 来表示一个更大量的数据，那么一个表所占用的大小就会变小。因为固定容量下，一个 ID 表示的数据量越大，那么它所需要的 ID 数也越小。比如 CPU 中 TLB（页表缓存），如果尝试去匹配所有的 page，那么 page 表将会变得非常的大，然后就会出现 cache misses 的现象。因为 page ID 表示的数据范围太小，在高速缓存中无法全部命中。所以这里可以通过更少的 page ID 来表示更多的数据</p></li><li><p>Page 存储架构</p><p>  <img src="./23.png" alt></p><p>  比较重要的就是 Heap File Organization</p><ul><li><p>Database Heap</p><p>  <img src="./24.png" alt></p><p>  数据库中的 heap 文件是一个无序的 page 集合，即可以以随机的顺序把 tuple 数据存储在里面</p><p>  链表来实现一个 page 是很 low 的，更好的方案是使用 Page 目录</p></li><li><p>Heap File: 链表</p><p>  <img src="./25.png" alt></p><p>  这里的例子中，如果要支持反向查找，那还得是一个双向链表</p><p>  如果需要在 page 中 insert 一些东西，那么还是需要对这个链表做遍历，直到找到 free page 为止，在这个位置 insert。为什么需要遍历，因为有些 page 的剩余空间可大可小，所以需要遍历到那个足以容纳下要 insert 的数据的一个剩余空间里面去</p><p>  写数据时需要注意的问题，即数据写一半，写满一个出了问题，后一半还没来得及写，数据就会损坏，所以要保证写数据的原子性和完整性，需要做很多工作</p><p>  写入数据崩溃，如何查找原因？使用 checksum，类似于 CRC 或者 md5</p></li><li><p>Heap File: Page 目录</p><p>  <img src="./26.png" alt><br>  <img src="./27.png" alt></p><p>  Page 目录是一个通常的做法，好处是假如想要插入一些数据时，没必要像链表那样对整个链表做一次遍历，只需要在 Page 目录中做查找就可以。例子中的每个小格中不仅有对应 page 所在位置，也包含了 page 剩余空间的信息</p></li><li><p>Page 头</p><p>  <img src="./28.png" alt></p></li><li><p>Page 层</p><p>  <img src="./29.png" alt></p><ol><li><p>面向 tuple 的组织方式</p><p> <img src="./30.png" alt></p><p> 这种组织方式是一个 bad idea，为什么呢？</p><ul><li>如果 tuple 都是固定长度的，那么要增删 tuple 的话，通过将其移到一个新的空间来取代这个老的空间就可以了不是么（联想到了 V8 的新生代老生代的 GC 算法了）</li><li>如果 tuple 不是固定长度的，那么你插入 tuple<br>的那个位置可能就没有足够的空间</li><li><p>每次要增删 tuple 时，都需要维护顶部的元数据，也就是 Num Tuples，告诉你哪个位置能插数据，或者遍历整个 page 看看哪里能插</p><p>但更好的方式是使用 slotted pages</p><p><img src="./31.png" alt><br><img src="./32.png" alt></p><p>在顶部有一个称之为 slot 数组 的东西，在底部则用来保存想要保存的数据</p><p>本质上来讲，slot 数组是将一个特定的 slot 映射到 page 上的某个 offset 上，根据这个 offset，就能找到想找的哪个 tuple</p><p>注意 slot 存的是 offset</p><p><img src="./33.png" alt></p><p>而填充 page 的方式是</p></li><li>从前往后对 slot 数组进行填充</li><li><p>从后往前对数据进行填充</p><p>什么是 page 已满，指的是数据占用了该 page 的一半以上的大小，再也无法存入任何信息了</p><p>当然也可以用一种 Postgres 中的 vaccum 的操作来整理数据库，或者使用压缩，也可以对数据库进行扫描并整理碎片</p><p>对于这种例子来讲，肯定是不能把视频存在数据库里面的，因为单个 page 根本放不下它。</p><p>一般来讲，要存 tuple 不应该分散地存在多个 page 上，因为维护元数据很麻烦。最好是当我们想要去访问这个 tuple 的时候，它就在这个 page 上。</p><p>为什么需要这么组织结构呢？</p><p>因为不管是将数据库文件中的 page 移动到磁盘还是网络上，系统的其他部分都不会关心这个 page 实际移动到了哪里，因为有 page ID 的存在，就可以通过 Page 目录来找到它实际所保存的位置，而这些 indirection 层避免了这些位置的更新会传播到系统的其他上层部分。比如某些 GC 算法，只需要保证对象间的引用关系就好，对象存在内存的哪个位置会随着 GC 的进行而变化，page ID 有有点像是在维护这个引用关系</p></li></ul></li><li><p>日志结构的组织方式<br> // Todo:<br> 主要这里 3-1 没有讲到</p></li></ol></li></ul></li><li><p>Tuple 层</p><blockquote><p>注: 课程时间不够，这里是简略版本</p></blockquote><p>  <img src="./34.png" alt></p><p>  一个 tuple 基本上就是一串字节，数据库的工作就是再次解释这些字节的实际含义</p><ul><li><p>Tuple 头</p><p>  <img src="./35.png" alt></p><p>  通常没必要将该 tuple 的元数据保存在这个 tuple 里面，因为更高级的元数据信息保存在这个 tuple 对应的 page 中，但可以可以放在 catalog page 里</p></li><li><p>Tuple Data</p><p>  <img src="./36.png" alt></p><p>  通常大部分数据库系统会按照它们创建时的顺寻进行存储，我们知道在关系模型中没必要这么做，但是大部分系统都做了</p></li><li><p>Denormalized Tuple Data</p><p>  <img src="./37.png" alt></p><p>  如果来自不同表的数据保存在同一个 page 中，会发生什么问题？<br>  注意这里大部分数据库系统都不会这么做，因为如果想让 page 变得独立，那么也就不应该去保存一大堆关于不同表的额外的元数据。当对表进行反范式化设计或者对表进行 prejoin 时，就会出现上述图中的情况，也就是数据冗余，一个 page 中存在多个表数据，更新、删除、或者压缩都要对多个表进行处理</p><p>  而数据库规范基本上就是讲如何讲数据库拆分到不同的表中（使用外键时就自然拆分了）</p><p>  下面是一个反范式化的处理例子，将 bar 的 tuple 直接内嵌在 foo 的 tuple 中</p><p>  因为每个 bar 表中的 tuple 复制了 a 属性，如果将它打包进 foo 表的 tuple 中，就没必要重复记录这些数据了，foo 表所拥有的这些列对其他表来说是独一无二的，就像是 prejoin 一样，将 tuple 彼此包装在一起。这样，应用程序依然觉得，这个 db 里面有两张单独的表，但在 db 内部，page 实际上会将它们合并在一起</p><p>  <img src="./38.png" alt><br>  <img src="./39.png" alt><br>  <img src="./40.png" alt></p><p>  但这并不是什么新鲜东西，早在 1970 年代，IBM 在发明它们第一个关系型数据库 System R 的时候，就引入了这个概念</p><p>  然而当 IBM 做出了 DB2 之后，这个方式就被废弃掉了，因为维护它很操蛋</p><p>  System R 是 IBM 发布的第一个关系型数据库，但 IBM 并没有将它商业化，也没有卖掉，10 多年之后，IBM 抽取了 System R 中的部分代码，做出了 DB2</p><p>  实际上在更现代的数据库系统中也出现了这种反范式化的设计</p><p>  <img src="./41.png" alt></p><ol><li>G 家的 Cloud Spanner，如果你定义了一个 Protobuf API，那么你就可以将两张不同表的数据合并在同一个 tuple 中</li><li>10 年前有一个叫 Akiban 的初创公司，他们把他们的存储引擎卖给了 MySQL，MySQL 就可以做到这种反范式化的操作。然后他们被 Foundation DB 收购，之后 Foundation DB 又被苹果收购</li><li>一些文档型数据库或者 JSON 数据库也能做到。比如你在定义你的 JSON document 时，就可以预先对相关属性进行 join 操作</li></ol></li></ul></li><li><p>记录 ID</p><p>  <img src="./42.png" alt></p><p>  保存元数据的大小</p><ul><li>PostgreSQL CTID（4 bytes）</li><li>SQLite ROWID（8 bytes）</li><li>Oracle ROWID（10 bytes）</li></ul></li><li><p>结论</p><p>  <img src="./43.png" alt></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;注: 本文首发我的 b 站专栏文章&lt;a href=&quot;https://www.bilibili.com/read/cv14558199&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;CMU 15-445/645-笔记-03-数据库存储-part1&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Database" scheme="https://strugglebak.github.io/categories/Database/"/>
    
    
      <category term="Database" scheme="https://strugglebak.github.io/tags/Database/"/>
    
  </entry>
  
  <entry>
    <title>CMU-15-445-645-笔记-02-高级SQL</title>
    <link href="https://strugglebak.github.io/2022/06/05/CMU-15-445-645-%E7%AC%94%E8%AE%B0-02-%E9%AB%98%E7%BA%A7SQL/"/>
    <id>https://strugglebak.github.io/2022/06/05/CMU-15-445-645-笔记-02-高级SQL/</id>
    <published>2022-06-05T13:00:10.000Z</published>
    <updated>2022-06-05T13:22:48.483Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>注: 本文首发我的 b 站专栏文章<a href="https://www.bilibili.com/read/cv14530555" target="_blank" rel="noopener">CMU 15-445/645-笔记-02-高级SQL</a></p></blockquote><a id="more"></a><p><img src="./Cover.png" alt></p><ul><li><p>课程目标</p><p>  <img src="./1.png" alt></p></li><li><p>Relational Languages<br>  <img src="./2.png" alt></p></li><li><p>SQL 的历史<br>  <img src="./3.png" alt></p><ul><li>除了 IBM 推出的 SQL 之外，还有另一个主流是由伯克利推出的 Ingres</li><li>而 PostgreSQL 是由开发 Ingres 那帮人开发的，所以才被称之为 “Post” “gre” “SQL”，与 “In” “gres” 对应，因为是在 Ingres 之后才出现的</li><li>开发 Ingres 那帮人有自己的语言，叫 Quel</li><li>英国有个人为他的编程语言也取名叫 SQL，IBM 因此与这个人产生版权以及商标纠纷</li><li>当 IBM 推出了 DB2 和 SQL 时，Oracle 也在同时支持 SQL</li><li>SQL 一直在发展，推出很多新特性<br>  <img src="./4.png" alt></li><li>现在只有非常少的数据库系统通过 SQL:2016 标准</li></ul></li><li><p>SQL 并不是一门单一的语言，它是一些东西的集合</p><p>  <img src="./5.png" alt></p><ul><li>DML: 类似 insert/update/delete/select 命令</li><li>DDL: 跟 schema 有关，通过定义 schema 创建表来存数据</li><li>DCL: 跟安全性授权相关</li><li>lists，也就是列表，可以有重复元素，是有序的</li><li>sets, 也就是集合，没有重复元素，是无序的</li><li>bags, 允许元素重复，无序</li></ul></li><li><p>Example Database</p><p>  <img src="./6.png" alt></p></li><li><p>Aggregates 聚合函数</p><p>  <img src="./7.png" alt></p><p>  <img src="./8.png" alt></p><p>  用 “<em>“ 代替 login<br>  “</em>“ 是 SQL 中的特殊关键字，代表该 tuple 中所有属性</p><p>  <img src="./9.png" alt></p><p>  更进一步，用 “1” 代替 “*”，每数一个 tuple，tuple 的数量就 +1</p><p>  <img src="./10.png" alt></p><p>  一般来讲建议使用 “COUNT(1)”</p><ul><li><p>可以在单个查询中放入多个聚合函数</p><p>  <img src="./11.png" alt></p></li><li><p>DISTINCT<br>  得到去重数据时使用</p><p>  <img src="./12.png" alt></p></li><li><p>一个错误的例子，在聚合函数之外输出其他 columns 会 undefined</p><p>  <img src="./13.png" alt></p></li><li><p>如何解决上面的错误例子？使用 GROUP BY</p><p>  <img src="./14.png" alt></p><p>  基于某个属性把想要的 tuple 放到一起<br>  物以类聚的结果</p><p>  <img src="./15.png" alt></p><p>  新增一个 s.name</p><p>  <img src="./16.png" alt></p></li><li><p>数据过滤，使用 HAVING</p><p>  <img src="./17.png" alt></p></li><li><p>所谓查询优化，可以用 GROUP BY 来做，统计小于某个值的一些集合的数量，或者通过 HAVING 做一些过滤操作，那么要查找的数据集就小了，自然也就快了</p></li></ul></li><li><p>字符串操作<br>  不同数据库对字符串的处理</p><p>  <img src="./18.png" alt></p><ul><li><p>SQL 标准规范有说，所有的字符串，例如 varchar、char、和 text field，它们必须区分大小写，并且使用 单引号 来进行声明</p></li><li><p>‘%’ 和 ‘_’</p><p>  <img src="./19.png" alt></p><ul><li>‘%’: 匹配一个或者多个字符</li><li>‘_’: 匹配一个字符</li></ul></li><li><p>对于字符串函数、数学函数和日期函数来讲，它们可以出现在查询中的任意位置</p><p>  <img src="./20.png" alt></p><p>  你可以把它放在 SELECT/HAVING/或者其他条件语句中等</p></li><li><p>‘||’<br>  SQL 标准下可以使用 ‘||’ 把字符串连起来</p><p>  <img src="./21.png" alt></p></li><li><p>Postgres 和 Oracle 大概是所有数据库系统中遵循 SQL 标准做的最好的</p><ul><li>Postgres ~= Oracle &gt; SQL server &gt; DB2</li><li>SQLite 还行</li><li>MySQL 最差</li></ul></li></ul></li><li><p>DATE/TIME 操作</p><p>  <img src="./22.png" alt></p><p>  注意这里记录用的是 时间戳，但是当你对时间进行操作，提取其中的信息时，结果会变得不可靠</p><p>  比如对日期进行加减处理，三个数据库 SQL 的不同写法</p><ol><li>PostgreSQL</li><li>MySQL</li><li><p>SQLite</p><p><img src="./23.png" alt></p><p>SQLite 居然是最流行的。。。最初由 Richard Hipp 和其他两人开发，手机安卓应用很多前端数据库就用的是 SQLite，很多桌面应用比如 Photoshop 和 ILLustrator，内部也运行 SQLite</p><p>顺便互联网在美国兴起的时间居然是 2000 年代早期。。。</p><p>MySQL 是 Oracle 的，所以 Oracle 有 MySQL 的版权，但 SQLite 没有</p></li></ol></li><li><p>输出重定向</p><p>  <img src="./24.png" alt></p><p>  即你输出的结果可以保存到另一张表中</p><ul><li>可以用 INTO</li><li>或者用 CREATE TABLE</li><li><p>或者用 INSERT INTO</p><p>  <img src="./25.png" alt></p></li></ul></li><li><p>输出控制</p><p>  <img src="./26.png" alt></p><p>  如果想要输出结果变得有序，使用 ORDER BY，因为 SQL 是基于 bag<br>  代数，它是无序的，所以需要使用这个</p><p>  想要在输出列表中加属性，可以接 DESC/ASC</p><p>  <img src="./27.png" alt></p><p>  限制输出可以用 LIMIT</p><p>  <img src="./28.png" alt></p><p>  可以在 LIMIT 后面加 OFFSET</p><p>  <img src="./29.png" alt></p><p>  OFFSET 的意思是，在限制返回 tuple 的数量之前，需要先跳过多少个 tuple，当跳过这么多你设置的 tuple 之后，再开始返回数据</p></li><li><p>嵌套查询（难的优化的东西来了！）<br>  即在查询的内部再嵌套一个查询</p><p>  <img src="./30.png" alt></p><p>  一个嵌套查询例子，SELECT 嵌 SELECT（实际上这也可以用 JOIN 来实现）</p><p>  <img src="./31.png" alt></p><p>  为什么这种方式很慢，实际上这里可以理解为有俩 for 循环查询，因为要对这个表里面每个 tuple 遍历一遍，然后对于每个 tuple 也要遍历一遍，用 JOIN 可以优化</p><p>  用 IN 来优化</p><p>  <img src="./32.png" alt></p><p>  其他查询优化操作符</p><p>  <img src="./33.png" alt></p><p>  使用 ANY 来优化</p><p>  <img src="./34.png" alt></p><p>  SELECT 嵌套也可以不用写在 WHERE 中</p><p>  <img src="./35.png" alt></p><p>  一个查询没有学生注册的所有课程的例子，注意这个例子中使用了 NOT EXIST，逻辑相当于取了个反</p><p>  <img src="./36.png" alt></p><p>  内部查询可以引用外部查询的东西，但是反过来不行</p></li><li><p>window 函数<br>  window 函数会对一个 tuple 子集进行函数计算，并将它们聚合成一个结果。输出每一行数据，并在其后面追加一个聚合字段所表示的数据</p><p>  <img src="./37.png" alt></p><p>  这里的 OVER 有点像 GROUP BY 的意思</p><p>  一个例子<br>  <img src="./38.png" alt></p><p>  输出结果如下</p><p>  <img src="./39.png" alt></p><p>  可以看到后面增加了一个 row_num 的字段</p><ul><li>OVER 关键字的作用是当计算 window 函数时，指定一种组合 tuple 的方式</li><li><p>使用 PARTITION BY 指定 group</p><p>  <img src="./40.png" alt></p><p>  输出如下</p><p>  <img src="./41.png" alt></p><p>  根据 cid 对它们进行分组，每一组内按 row_num 的顺序排列</p></li><li><p>在 window grouping 中也可以使用 ORDER BY</p><p>  <img src="./42.png" alt></p></li><li><p>一个例子，查询每门课中最高分的学生</p><p>  <img src="./43.png" alt></p><p>  在这个内部查询（红色部分表示的）中，遍历整个 enrolled 表，对于每个 tuple，基于 cid 来对它们进行分组</p><p>  RANK() 这个聚合函数会对每一个组进行 rank 排序</p><p>  注意此处的 ‘ranking.rank’ 实际上并不存在于数据库中，它只存在于这个查询之中（感觉像是一个临时变量</p><p>  最终的结果如下，PostgreSQL 支持这个语句</p><p>  <img src="./44.png" alt></p><p>  RANK() 函数会根据排序后每个 tuple 在输出列表中出现的现后顺序来进行计算</p><p>  如果是 SQL 为 <code>SELECT *, RANK() OVER() AS rank FROM enrolled;</code>，那么就是如下的结果</p><p>  <img src="./45.png" alt></p><p>  rank 处的值都是 1，因为这里面并没有排序，所以所有记录中的 rank 都是 1</p><p>  这里的例子中，如果没有 ORDER BY，就没有 rank</p></li></ul></li><li><p>CTE（Common Table Expressions）公用表表达式<br>  这个感觉有点像是可以把一些公用的东西抽出来，然后给其他 SQL 引用的感觉</p><p>  <img src="./46.png" alt></p><p>  它和嵌套查询非常类似，可以将一个查询的输出结果作为另一个查询的输入，但某些 功能 CTE 能做，嵌套查询做不到</p><ul><li><p>一个更复杂的例子</p><p>  <img src="./47.png" alt></p><p>  将输出的 col1 和 col2 与 cteName 中的查询语句中的 name 进行绑定，然后在下面的 SELECT 语句中就可以直接引用 col1 和 col2</p></li><li><p>例子，在 enrolled 表中找到最大的学生 id</p><p>  <img src="./48.png" alt></p><p>那么问题来了，这个跟嵌套查询有啥区别呢？<br>在 CTE 中可以递归，但是嵌套查询不能（所以感觉像是声明了一个函数类似<br>  东西？）<br>比如打印 1 到 10，注意: 不带 ALL 的 UNION 操作会将重复结果移除</p><p><img src="./49.png" alt></p><p>主要逻辑就是调用之前的 CTE 中的 tuple 作为输出结果。<br>在这个例子中，会生成只有一个属性的表（counter），调用一个 SELECT 来获取这个 tuple，然后对它进行 +1，这样就生成了一个新的 tuple。接着继续上述操作，直到 WHERE 条件无法匹配为止</p></li></ul></li></ul><ul><li><p>总结</p><p>  <img src="./50.png" alt></p><p>  在理想情况下，可以无需将数据存放到本地，或者来回移动，就能对整个查询进行计算</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;注: 本文首发我的 b 站专栏文章&lt;a href=&quot;https://www.bilibili.com/read/cv14530555&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;CMU 15-445/645-笔记-02-高级SQL&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Database" scheme="https://strugglebak.github.io/categories/Database/"/>
    
    
      <category term="Database" scheme="https://strugglebak.github.io/tags/Database/"/>
    
  </entry>
  
  <entry>
    <title>CMU-15-445-645-笔记-01-课程简介与关系模型</title>
    <link href="https://strugglebak.github.io/2022/06/04/CMU-15-445-645-%E7%AC%94%E8%AE%B0-01-%E8%AF%BE%E7%A8%8B%E7%AE%80%E4%BB%8B%E4%B8%8E%E5%85%B3%E7%B3%BB%E6%A8%A1%E5%9E%8B/"/>
    <id>https://strugglebak.github.io/2022/06/04/CMU-15-445-645-笔记-01-课程简介与关系模型/</id>
    <published>2022-06-04T08:37:28.000Z</published>
    <updated>2022-06-05T12:53:10.772Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>注: 本文首发我的 b 站专栏文章<a href="https://www.bilibili.com/read/cv14530070" target="_blank" rel="noopener">CMU 15-445/645-笔记-01-课程简介与关系模型</a></p></blockquote><a id="more"></a><p><img src="./Cover.png" alt></p><ul><li>课程目标</li></ul><p><img src="./1.png" alt></p><ul><li>参考书推荐用 《Database System Concepts》</li><li>该课程主要是手写 Database Storage Manager 而不是 Database System（因为项目不支持 SQL 解析）</li><li><p>数据库拓展研究</p><p>  <img src="./2.png" alt></p></li><li><p>用 CSV（Comma-Seperated Value）文件存 database</p></li><li><p>怎么用呢，举个例子</p><p>  <img src="./3.png" alt></p></li><li><p>但这种方式是有问题的</p><ul><li>每个专辑的 entry 中的 artist 都是一样的么？</li><li>Ice Cube 没有拼写错误？</li><li>如果别人在文件里重写了一个无效的 string 怎么办呢？</li><li>如果一张专辑里面有多个 artist，那么怎么存储这些数据呢？</li><li>如何查询数据？</li><li>多线程同一时间写同一个文件怎么办？</li><li>如何保证数据安全（在写数据的时候机器故障咋办？）</li><li><p>Database Management System 的作用</p><p>  <img src="./4.png" alt></p></li></ul></li><li><p>1970 年 Ted Codd 提出的关系型模型（Relational Model）是为了解决之前数据库不断重构数据结构，以及数据结构转存之后不断销毁数据的问题</p></li><li>关系模型三板斧如下<ul><li>用简单数据结构存数据</li><li>用高级语言访问数据</li><li>大型数据库的物理存储策略基于 Database Management System 的实现</li></ul></li><li>这种思想把 逻辑层 和 物理层 完全解耦</li><li><p>关系型数据模型并不是唯一的数据模型</p><p>  <img src="./5.png" alt></p><p>  比如如下</p><p>  <img src="./6.png" alt></p><ul><li>Relational（MySQL, PostgreSQL，Oracle，DB2，SQL server，SQLite）</li><li>Key/Value，Graph，Document， Column-family（NoSQL）</li><li>Array/Matrix（Mathine Learning）</li><li>Hierarchical，Network （Obsolete / Rare）旧时代的余晖。。。</li></ul></li><li><p>关系型模型可以对任何东西进行建模</p></li><li><p>关系型模型主要关注三个方面</p><p>  <img src="./7.png" alt></p></li></ul><ul><li><p>一个 关系（relation） 是一个无序的集合，这个集合包含代表 entities 的属性的关系（relationship），比如</p><p>  <img src="./8.png" alt></p></li><li><p>tuple 在 关系 中就是一个 属性值 的集合</p></li><li><p>原始关系模型中，所有的值必须保证原子性或者它必须是一个单个属性值（比如只能是一个 String，一个 int，或者一个 float等，不能是数组或者嵌套的对象等）</p></li><li>NULL 这个属性值代表未知，SQL 查询会遇到麻烦</li><li>主键 Primary Key，唯一标识记录的 id</li><li>外键 Foreign Key，用于指定一张表中的属性必须存在于另一张表中</li><li>注意 relation 和 table 语义一样</li><li><p>一个外键的例子</p><p>  <img src="./9.png" alt></p></li><li><p>如何从 Database 中取数据？<br>  通过 DML （Data Manipulation Languages）</p><p>  <img src="./10.png" alt></p></li></ul><ul><li>Relational Algebra 关系代数</li><li><p>Ted Codd 提出了在 Relational Algebra 中的其中基本运算符</p><p>  <img src="./11.png" alt></p><ul><li><p>SELECT</p><p>  <img src="./12.png" alt></p></li><li><p>PROJECTION<br>  即 SELECT b_id-100, a_id FROM R WHERE a_id=’2’</p><p>  <img src="./13.png" alt></p></li><li><p>UNION<br>  <img src="./14.png" alt></p></li><li><p>INTERSECTION<br>  <img src="./15.png" alt></p></li><li><p>DIFFERENCE<br>  <img src="./16.png" alt></p></li><li><p>PRODUCT<br>  <img src="./17.png" alt></p></li><li><p>JOIN<br>  即 SELECT * FROM R NATURAL JOIN S;</p><p>  <img src="./18.png" alt></p></li></ul></li></ul><ul><li><p>一些后续研究的额外的操作符</p><p>  <img src="./19.png" alt></p></li><li><p>一些优化策略</p><p>  <img src="./20.png" alt></p></li><li><p>关系型模型与任何查询语言的实现无关，实际上当 Ted Codd 在他写关系型模型论文时并没有提出 SQL，他提出了 关系代数，并推出了自己的语言叫 Alpha，与（1970）同年推出的 SQL、Ingres （伯克利）、Quel 都是竞争对手。</p></li><li><p>SQL 只是一个标准</p></li><li><p>结论</p><p>  <img src="./21.png" alt></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;注: 本文首发我的 b 站专栏文章&lt;a href=&quot;https://www.bilibili.com/read/cv14530070&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;CMU 15-445/645-笔记-01-课程简介与关系模型&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Database" scheme="https://strugglebak.github.io/categories/Database/"/>
    
    
      <category term="Database" scheme="https://strugglebak.github.io/tags/Database/"/>
    
  </entry>
  
  <entry>
    <title>Fast-Properties-in-V8-(翻译)</title>
    <link href="https://strugglebak.github.io/2021/11/23/Fast-Properties-in-V8-%E7%BF%BB%E8%AF%91/"/>
    <id>https://strugglebak.github.io/2021/11/23/Fast-Properties-in-V8-翻译/</id>
    <published>2021-11-23T06:21:51.000Z</published>
    <updated>2022-06-04T08:13:28.728Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>注：该文章翻译自 <a href="https://v8.dev/blog/fast-properties" target="_blank" rel="noopener">Fast properties in V8</a> V8 的关于对象属性内存分配策略的官方文章，文章有翻译的不是很清楚的地方，欢迎各位指正</p></blockquote><a id="more"></a><p>在这篇博客文章中，我们将解释 V8 在内部是怎么处理 JavaScript properties 的。从 JavaScript 的角度来看，properties 只有几个必要的区别。JavaScript 对象与字典类似，使用 string 作为 key 和任意 object 作为 value。但是<a href="https://tc39.es/ecma262/#sec-ordinaryownpropertykeys" target="_blank" rel="noopener">在对象的迭代过程中</a>，规范对于以整数作为 index 的 properties 和其他 properties 的迭代方式是不同的。除此(迭代方式)之外，不同 properties 的表现基本相同，与它们是否以整数作为 index 无关。</p><p>但出于性能和内存的考虑，V8 底层确实依赖 properties 的几种不同表现。在这篇博客中，我们将解释为了能快速访问动态添加的 properties ，V8 是怎么做的。了解 properties 的工作方式对于解释 V8 中的<a href="https://mrale.ph/blog/2012/06/03/explaining-js-vms-in-js-inline-caches.html" target="_blank" rel="noopener">内联缓存(inline caches)</a>之类的优化工作至关重要。</p><p>这篇文章解释了 V8 对以整数作为 index 的 properties 和具名 properties 做处理的区别。然后我们展示了 V8 在添加具名 properties 时如何去维护隐藏类(HiddenClasses)，通过维护隐藏类可以快速识别一个对象的特征。接着我们将继续深入介绍如何根据用法优化具名 properties 来快速访问或修改。在最后一节中，我们将详细谈谈 V8 是怎么处理以整数作为 index 的 properties 或数组 index 的。</p><h2 id="具名-properties-和-elements"><a href="#具名-properties-和-elements" class="headerlink" title="具名 properties 和 elements"></a>具名 properties 和 elements</h2><p>让我们开始分析一个非常简单的对象，例如 <code>{ a：&#39;foo&#39;, b：&#39;bar&#39; }</code>。该对象具有两个具名 properties，<code>&#39;a&#39;</code> 和 <code>&#39;b&#39;</code>。对于 properties 名字来说它没有任何的数组 index。数组 index 这种 properties(通常称为 elements)是数组上最为突出的特点。例如数组 <code>[&#39;foo&#39;，&#39;bar&#39;]</code> 有两个数组 index properties：<code>0</code>，其对应 value 为 <code>&#39;foo&#39;</code>；<code>1</code>，其对应 value 为 <code>&#39;bar&#39;</code>。V8 主要用这个对 properties 做第一层的区分。</p><p>下图显示了一个基本的 JavaScript 对象在内存中的样子。</p><p><img src="./1.png" alt></p><p><strong>elements</strong>和<strong>properties</strong>存在两个单独的数据结构中，这样在不同使用模式下添加/访问 properties 和 elements 会更加有效。</p><p><strong>elements</strong>主要用于各种 <a href="https://tc39.es/ecma262/#sec-properties-of-the-array-prototype-object" target="_blank" rel="noopener">Array.prototype 方法</a>，例如 <code>pop</code> 或 <code>slice</code>。鉴于这些函数是在连续范围内去访问 properties 的，在大多数情况下 V8 内部会把它们看作简单数组。在本文的稍后部分会说明，为了节省内存我们是怎么将这些简单数组转变成稀疏字典(sparse dictionary)的形式的。</p><p>具名 properties 以类似的方式存在单独的数组中。但与 elements 不同，我们不能简单地用 key 来推断它们在 properties 数组中的位置，我们需要一些其他元数据。在 V8 中，每个 JavaScript 对象都会关联一个隐藏类。隐藏类 存放了有关对象特征的信息，除此之外，还存放了 properties 名字 对应 properties 数组 index 的 map。为了使事情复杂化，有时我们使用字典而不是简单数组来表示 properties。我们将在专用部分中对此进行详细说明。</p><p>本节内容：</p><ul><li><strong>以整数作为 index 的数组的 properties</strong> 存在单独的 <strong>elements store</strong>中。</li><li><strong>具名 properties</strong>存在<strong>properties store</strong>中。</li><li><strong>Elements</strong>和<strong>properties</strong>可以是数组或字典。</li><li>每个 JavaScript 对象都有一个关联的隐藏类，用于保存对象特征的信息。</li></ul><h2 id="隐藏类-HiddenClasses-和描述符数组-DescriptorArrays"><a href="#隐藏类-HiddenClasses-和描述符数组-DescriptorArrays" class="headerlink" title="隐藏类(HiddenClasses)和描述符数组(DescriptorArrays)"></a>隐藏类(HiddenClasses)和描述符数组(DescriptorArrays)</h2><p>在解释了 elements 和 具名 properties 的常规区别之后，我们需要看一下隐藏类在 V8 中的工作方式。此隐藏类存了一个对象的元信息，包括对象上的属性数量以及对对象原型的引用。隐藏类在概念上类似于典型的面向对象编程语言中的类。但在基于原型的语言（例如 JavaScript）中，通常不可能预先知道这个类。因此在这种情况下，V8 会即时创建隐藏类，并随着对象的变化而动态更新。隐藏类用于标识对象特征，也对 V8 编译器的优化和内联缓存起到非常重要的作用。例如，如果优化编译器可以通过隐藏类确保兼容的对象结构，那么它就可以直接访问到对象的内联属性。</p><p>让我们来看看隐藏类的重要部分。</p><p><img src="./2.png" alt></p><p>在 V8 中，JavaScript 对象的第一个字段指向隐藏类。(实际上，在 V8 堆上并由垃圾回收器管理的任何对象都是这种情况。)就 properties 而言，最重要的信息是位于 隐藏类的第三个 bit 的字段，这个字段用来存放 properties 的数量和能访问到描述符数组的指针。描述符数组中包含有关具名 properties 的信息，像这个 properties 的名字和 value 的存储位置之类的。注意，这里我们不跟踪整数 index properties，因此描述符数组中没有条目。</p><p>隐藏类的基本设定是对象具有相同的结构，例如在相同顺序下的相同具名 properties 会共享相同的隐藏类。为此，当对象添加了一个属性时，我们使用不同的隐藏类。在下面的示例中，我们创建一个空对象，并添加三个具名 properties。</p><p><img src="./3.png" alt></p><p>每次添加新属性时，对象的隐藏类都会更改。V8 在后台创建一个将隐藏类连接在一起的转换树。当将属性 <code>&#39;a&#39;</code> 添加到空对象时，V8 知道要采用哪个隐藏类。如果以相同的顺序添加相同的属性，此转换树可确保在最后得到的隐藏类是相同的。以下示例表明，即使在两者之间添加简单的 index properties(也就是整数下标)，转换树也是一样没有变化。</p><p><img src="./4.png" alt></p><p>但是，如果我们创建一个添加了其他属性的新对象，在本例中为属性 <code>&#39;d&#39;</code>，V8 将为新的隐藏类创建一个单独的分支。</p><p><img src="./5.png" alt></p><p>本节内容：</p><ul><li>具有相同结构(相同顺序的相同 properties)的对象具有相同的隐藏类。</li><li>默认情况下，每个添加的新具名属性都会导致创建新的隐藏类。</li><li>添加数组 index 的这种 properties 不会创建新的隐藏类。</li></ul><h2 id="三种不同的具名-properties"><a href="#三种不同的具名-properties" class="headerlink" title="三种不同的具名 properties"></a>三种不同的具名 properties</h2><p>在概述了 V8 如何使用隐藏类记录对象的特征之后，让我们深入研究这些 properties 的实际存储方式。如上面引言中所述，properties 有两种基本类型：<code>named</code> 和 <code>indexed</code>。以下部分介绍具名 properties。</p><p>在 V8 中，像 <code>{a: 1, b: 2}</code> 这样的简单对象可以有不同的内部展示。虽然 JavaScript 对象表现得或多或少像外部的简单字典，但 V8 试图避免字典，因为它们妨碍某些优化，如<a href="https://en.wikipedia.org/wiki/Inline_caching" target="_blank" rel="noopener">内联缓存</a>，我们将在单独的一篇文章中解释。</p><p><strong>对象内 properties</strong>与<strong>普通 properties</strong>：V8 支持所谓的对象内 properties，这些属性直接存储在对象上。这些是 V8 中最快的属性，因为它们无需任何间接访问即可使用。对象内 properties 的个数由对象的初始大小确定。如果添加的 properties 所需要的空间比对象能存储的空间多，它们就会把这些 properties 存到 properties store 中。properties store 里的属性是能被间接访问到的，并且这个 properties store 可以自己增加 property。</p><p><img src="./6.png" alt></p><p><strong>快 properties</strong>与<strong>慢 properties</strong>：下一个重要区别是快 properties 与慢 properties 之间的区别。通常将线性 properties store 中存放的 properties 定义为 “快”。快 properties 仅通过 properties store 中的 index 访问。要得到在 properties store 中的具名 properties 的实际位置，我们必须参考隐藏类上的描述符数组，如前所述。</p><p><img src="./7.png" alt></p><p>但如果一个对象添加和删除了许多属性，它可能会花费大量时间和内存开销来维护描述符数组和隐藏类。因此，V8 还支持所谓的慢 properties。具有慢 properties 的对象，它的 properties store 就是一个独立的字典。所有 properties 元信息不再存储在隐藏类的描述符数组中，而是直接存储在 properties 字典 中。因此不更新隐藏类也可以添加和删除属性。由于内联缓存不适用于字典属性，因此后者通常比快 properties 慢。</p><p>本节内容：</p><ul><li><p>有三种不同的具名 properties 类型：对象内 properties、快 properties、慢 properties/字典 properties。</p><ol><li>对象内 properties 直接存储在对象上，并提供最快的访问。</li><li>快 properties 位于 properties store 中，所有元信息都存储在隐藏类的描述符数组中。</li><li>慢 properties 位于独立的 properties 字典中，不再通过隐藏类共享元信息。</li></ol></li><li><p>慢 properties 允许高效地删除和添加属性，但访问速度比其他两种类型慢。</p></li></ul><h2 id="elements-或数组-index-properties"><a href="#elements-或数组-index-properties" class="headerlink" title="elements 或数组 index properties"></a>elements 或数组 index properties</h2><p>到目前为止，我们已经研究了具名 properties，而没讲数组常用的整数 index properties。整数 index properties 的处理与具名 properties 一样复杂。即使所有 index properties 总是单独存储在 elements store 中，那也有 <a href="https://cs.chromium.org/chromium/src/v8/src/elements-kind.h?q=elements-kind.h&amp;sq=package:chromium&amp;dr&amp;l=14" target="_blank" rel="noopener">20</a> 种不同的 elements 类型!</p><p><strong>Packed or Holey Elements</strong>：V8 作出的第一个主要区别是 elements backing store 里的 item 是 packed 的还是有 hole 的。如果删除一个能用 index 访问到的元素或未定义元素，则会在 backing store 中出现 hole。一个简单的例子是<code>[1,,3]</code>，其中第二项就是一个 hole。以下示例说明了此问题：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> o = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>];</span><br><span class="line"><span class="built_in">console</span>.log(o[<span class="number">1</span>]);          <span class="comment">// 打印 'b'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> o[<span class="number">1</span>];                <span class="comment">// 在 elements store 中引入一个 hole</span></span><br><span class="line"><span class="built_in">console</span>.log(o[<span class="number">1</span>]);          <span class="comment">// 打印 'undefined'; 属性 1 不存在</span></span><br><span class="line">o.__proto__ = &#123;<span class="number">1</span>: <span class="string">'B'</span>&#125;;     <span class="comment">// 在 prototype 上定义属性 1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(o[<span class="number">0</span>]);          <span class="comment">// 打印 'a'</span></span><br><span class="line"><span class="built_in">console</span>.log(o[<span class="number">1</span>]);          <span class="comment">// 打印 'B'</span></span><br><span class="line"><span class="built_in">console</span>.log(o[<span class="number">2</span>]);          <span class="comment">// 打印 'c'</span></span><br><span class="line"><span class="built_in">console</span>.log(o[<span class="number">3</span>]);          <span class="comment">// 打印 undefined</span></span><br></pre></td></tr></table></figure><p><img src="./8.png" alt></p><p>总之，如果这个被操作的数组/对象上没有属性，那就必须要在原型链上继续找。考虑到 elements 是独立的，我们不会在隐藏类上存放当前数组的 index properties 的信息，我们需要一个名为 the_hole 的特殊值来标记不存在的属性。这对于数组方法的性能来说至关重要。如果我们知道没有 hole，即 elements store 已经是 packed 状态，我们就可以执行本地操作而没必要在原型链上去做耗费性能的查找。</p><p><strong>快 elements 或字典 elements</strong>：对 elements 来说，第二个主要区别是它们是快模式还是字典模式。快 elements 是简单的 VM 内部数组，它的属性 index 与 elements store 中的 index 有一个 map 的关系。但这种简单的形式对于非常大的 稀疏/holey 数组是非常浪费的，因为这些数组只有非常少的子项。在这种情况下，我们使用基于字典的形式来节省内存，但代价是访问速度稍慢：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> sparseArray = [];</span><br><span class="line">sparseArray[<span class="number">9999</span>] = <span class="string">'foo'</span>; <span class="comment">// 用字典元素创建一个数组</span></span><br></pre></td></tr></table></figure><p>在此示例中，(从内存中)分配具有 10k 个子项的完整数组将非常浪费。取而代之的是，V8 创建了一个字典，在其中存储 key-value-descriptor 这样的三元组。在这种情况下，key 为 <code>&#39;9999&#39;</code>，value 为 <code>&#39;foo&#39;</code>，descriptor 就使用默认的描述符。鉴于我们没有办法在隐藏类上存储描述符详细信息，每当使用自定义描述符定义 index properties 时，V8 都会使用慢 elements：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> array = [];</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(array, <span class="number">0</span>, &#123;<span class="attr">value</span>: <span class="string">'fixed'</span> configurable: <span class="literal">false</span>&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(array[<span class="number">0</span>]);      <span class="comment">// 打印 'fixed'.</span></span><br><span class="line">array[<span class="number">0</span>] = <span class="string">'other value'</span>;   <span class="comment">// 不能覆盖 index 0.</span></span><br><span class="line"><span class="built_in">console</span>.log(array[<span class="number">0</span>]);      <span class="comment">// 仍然打印 'fixed'.</span></span><br></pre></td></tr></table></figure><p>在此示例中，我们在数组上添加了一个不可配置的属性。此信息存储在慢 elements 字典三元组的描述符部分中。重要的是要注意，数组方法在具有慢 elements 的对象上执行时速度要慢得多。</p><p><strong>Smi</strong> 和 <strong>Double Elements</strong>：在 V8 中快 elements 还有另一个重要的区别。例如，如果仅将整数存储在一个常用的数组中，则 GC 不必查看该数组，因为整数直接编码为所谓的小整数（Small integers – Smis）。另一个特殊情况是仅包含双精度的数组。与 Smis 不同，浮点数通常表示为占用几个字长的完整对象。但对于纯双精度数组来说 V8 存的是原始双精度值，以避免内存和性能开销。以下示例列出了 Smi 和 double 元素的 4 个示例：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a1 = [<span class="number">1</span>,   <span class="number">2</span>, <span class="number">3</span>];  <span class="comment">// Smi Packed</span></span><br><span class="line"><span class="keyword">const</span> a2 = [<span class="number">1</span>,    , <span class="number">3</span>];  <span class="comment">// Smi Holey, a2[1] 在 prototype 上找</span></span><br><span class="line"><span class="keyword">const</span> b1 = [<span class="number">1.1</span>, <span class="number">2</span>, <span class="number">3</span>];  <span class="comment">// Double Packed</span></span><br><span class="line"><span class="keyword">const</span> b2 = [<span class="number">1.1</span>,  , <span class="number">3</span>];  <span class="comment">// Double Holey, b2[1] 在 prototype 上找</span></span><br></pre></td></tr></table></figure><p><strong>特殊 elements</strong>：到目前为止，我们提供的信息涵盖了 20 种不同 elements 类型中的 7 种。为简单起见，我们去掉了定型数组(TypedArrays)中的 9 个 elements 类型，也去掉了多个 String wrapper 中的 elements 类型以及 arguments 对象中的多个特殊 elements 类型。</p><p><strong>ElementsAccessor</strong>：如你所想我们并不想用 C++ 写数组方法 20 遍，为每个<a href="https://v8.dev/blog/elements-kinds" target="_blank" rel="noopener">element 类型</a>写一遍。这里就到了体现 C++ 神奇的地方了。我们构建了 <code>ElementsAccessor</code>，而不是一遍又一遍地实现数组方法，在这里我们只需要实现简单的函数即可访问 backing store 中的元素。<code>ElementsAccessor</code> 需要 <a href="https://en.wikipedia.org/wiki/Curiously_recurring_template_pattern" target="_blank" rel="noopener">CRTP</a> 去对每个数组方法创建指定的版本。因此，如果在数组上调用诸如 <code>slice</code> 之类的方法，V8 内部则会调用用 C++ 编写的内置函数，并通过 <code>ElementsAccessor</code> 将其分派到该函数的指定版本：</p><p><img src="./9.png" alt></p><p>本节内容：</p><ul><li>有快模式和字典模式的 index properties 和 elements。</li><li>快 properties 可以被 packed，它们也可以有 holes，这些 holes 说明一些 index properties 被删掉了。</li><li>elements 的 content 专门用于加快数组方法的执行并减少 GC 开销。</li></ul><p>了解 properties 的工作方式是理解 V8 中许多优化的关键。对于 JavaScript 开发人员来说，有许多内部决策是无法直接看到的，但是它们解释了为什么某些代码模式比其他模式更快。更改 properties 或 elements 类型通常会使 V8 创建不同的隐藏类，这可能导致类型污染，从而 <a href="http://mrale.ph/blog/2015/01/11/whats-up-with-monomorphism.html" target="_blank" rel="noopener">阻止 V8 生成最佳代码</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;注：该文章翻译自 &lt;a href=&quot;https://v8.dev/blog/fast-properties&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Fast properties in V8&lt;/a&gt; V8 的关于对象属性内存分配策略的官方文章，文章有翻译的不是很清楚的地方，欢迎各位指正&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="翻译" scheme="https://strugglebak.github.io/categories/%E7%BF%BB%E8%AF%91/"/>
    
    
      <category term="V8" scheme="https://strugglebak.github.io/tags/V8/"/>
    
  </entry>
  
  <entry>
    <title>Elements-kinds-in-V8-(翻译)</title>
    <link href="https://strugglebak.github.io/2021/11/23/Elements-kinds-in-V8-%E7%BF%BB%E8%AF%91/"/>
    <id>https://strugglebak.github.io/2021/11/23/Elements-kinds-in-V8-翻译/</id>
    <published>2021-11-23T06:17:20.000Z</published>
    <updated>2022-06-04T08:13:28.714Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>注：该文章翻译自<a href="https://v8.dev/blog/elements-kinds" target="_blank" rel="noopener">https://v8.dev/blog/elements-kinds</a> V8 的官方博客，这是关于解释在 V8 中「elements」的类型都有哪些的一篇文章，文章有翻译的不是很清楚的地方，欢迎各位指正</p></blockquote><a id="more"></a><p>JavaScript 对象可以和任何属性有关联。对象属性的名称可以包含任何字符。有趣的是 JavaScript 引擎可以选择名称为纯数字的属性来进行优化，而这个属性其实就是<a href="https://tc39.es/ecma262/#array-index" target="_blank" rel="noopener">数组 index</a>。</p><p>在 V8 中，会特殊处理整数名称的属性（最常见的形式是由 Array 构造函数生成的对象）。尽管很多情况下这些数字索引属性的表现和其他属性一样，但为了优化，V8 将它们和非数字属性分开存储。在内部，V8 甚至给这些属性一个特殊的名称：<em>elements</em>。对象通过<a href="https://v8.dev/blog/fast-properties" target="_blank" rel="noopener">properties</a>可以 map 到一些 value ，而数组通过 index 可以 map 到一些子元素。</p><p>尽管这些内部细节从来没有直接向 JavaScript 开发人员公开，但它们解释了为什么某些代码模式比其他模式更快。</p><h2 id="常见的-elements-类型"><a href="#常见的-elements-类型" class="headerlink" title="常见的 elements 类型"></a>常见的 elements 类型</h2><p>在运行 JavaScript 代码时，V8 会追踪每个数组的 elements 的类型。V8 可以根据这些信息，在对拥有这种 elements 类型的数组进行操作时，进行针对性的优化。例如，当在数组上调用 <code>reduce</code>，<code>map</code> 或 <code>forEach</code> 时，V8 可以根据数组的 elements 类型来优化这些操作。</p><p>以这个数组为例:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br></pre></td></tr></table></figure><p>这个数组的 elements 类型是什么呢？如果用 <code>typeof</code> 来回答，结果就是这个数组含有 <code>number</code> 类型的数。在语言层面，这就是我们能看到的：JavaScript 不会区分整数(integers)，浮点数(floats)和双精度数(doubles)，它们都只是数字。但在引擎层面，我们可以做更精确地区分。该数组的 elements 类型为 <code>PACKED_SMI_ELEMENTS</code>。在 V8 中，术语 <code>Smi</code> 是指用于存储小整数(small integers)的一种特定格式。</p><p>然后，向同一个数组中添加浮点数会把这个数组转为更通用的 elements 类型</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="comment">// elements 类型: PACKED_SMI_ELEMENTS</span></span><br><span class="line">array.push(<span class="number">4.56</span>);</span><br><span class="line"><span class="comment">// elements 类型: PACKED_DOUBLE_ELEMENTS</span></span><br></pre></td></tr></table></figure><p>向数组中添加字符串将再次改变数组 elements 类型</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="comment">// elements 类型: PACKED_SMI_ELEMENTS</span></span><br><span class="line">array.push(<span class="number">4.56</span>);</span><br><span class="line"><span class="comment">// elements 类型: PACKED_DOUBLE_ELEMENTS</span></span><br><span class="line">array.push(<span class="string">'x'</span>);</span><br><span class="line"><span class="comment">// elements 类型: PACKED_ELEMENTS</span></span><br></pre></td></tr></table></figure><p>到目前为止，我们已经看到了 3 种不同的 elements 类型，以下是基本类型</p><ul><li><strong>Sm</strong> all  <strong>i</strong> ntegers，也就是 Smi</li><li>Doubles，用于不能用 Smi 表示的浮点数(floating-point)和整数(integers)</li><li>常规 elements，用于不能表示为 Smi 或双精度值(doubles)的值</li></ul><p>注意，doubles 是 Smi 的一种更通用的变体，常规 elements 是 doubles 之上的另一种泛化。用 Smi 表示的数字集 是 用 double 表示的数字集的子集。</p><p>重点是 elements 类型只向一个方向转化，从特殊的(比如: <code>PACKED_SMI_ELEMENTS</code>) 转向更常规的(比如: <code>PACKED_ELEMENTS</code>)，比如一旦一个数组被标记为是 <code>PACKED_ELEMENTS</code>，它就不能再转化成 <code>PACKED_DOUBLE_ELEMENTS</code> 类型的了。</p><p>目前，我们已经了解到</p><ul><li>V8 会对每个数组赋予一个 elements 类型</li><li>数组的 elements 类型并不是一成不变的 —— 它可以在运行时改变。之前的例子中有从 <code>PACKED_SMI_ELEMENTS</code> 转向 <code>PACKED_ELEMENTS</code> 的</li><li>elements 类型只能从特定类型转向常规类型</li></ul><h2 id="PACKED-和-HOLEY-类型"><a href="#PACKED-和-HOLEY-类型" class="headerlink" title="PACKED 和 HOLEY 类型"></a><code>PACKED</code> 和 <code>HOLEY</code> 类型</h2><p>目前我们只谈到了 packed 类型的数组。在数组中创建 holes (使数组变稀疏)会将其 elements 类型降级成它的 “holey” 版本</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4.56</span>, <span class="string">'x'</span>];</span><br><span class="line"><span class="comment">// elements 类型: PACKED_ELEMENTS</span></span><br><span class="line">array.length; <span class="comment">// 5</span></span><br><span class="line">array[<span class="number">9</span>] = <span class="number">1</span>; <span class="comment">// array[5] 到 array[8] 现在都是 holes</span></span><br><span class="line"><span class="comment">// elements 类型: HOLEY_ELEMENTS</span></span><br></pre></td></tr></table></figure><p>V8 之所以有这种区别，它在优化 packed 类型数组的操作上比 holey 类型数组更积极。在 packed 类型数组上大多数操作都可以有效率地执行。相比之下，在 holey 类型数组上，这些操作就需要在原型链上进行额外的检测，并耗费性能高昂的查询。</p><p>到目前为止，我们已经看到每种基本 elements 类型(即 Smis，double 和常规 elements 类型)都有两种: packed 版本和 holey 版本。它们不仅可以从 <code>PACKED_SMI_ELEMENTS</code> 转变成 <code>PACKED_DOUBLE_ELEMENTS</code>，而且还可以从任何 <code>PACKED</code> 类型转变成其 <code>HOLEY</code> 对应类型。<br>总结一下:</p><ul><li>最常见的 elements 类型有 <code>PACKED</code> 类型和 <code>HOLEY</code> 类型</li><li>在 packed 类型数组上的操作比 holey 类型数组更有效率</li><li>elements 类型可以从 <code>PACKED</code> 类型转变成 <code>HOLEY</code> 类型</li></ul><h2 id="elements-类型-格"><a href="#elements-类型-格" class="headerlink" title="elements 类型 格"></a>elements 类型 格</h2><p>这套标记转换系统被 V8 弄成了一个 <a href="https://zh.wikipedia.org/wiki/%E6%A0%BC_(%E6%95%B0%E5%AD%A6" target="_blank" rel="noopener">格</a>)。下面是只有几个 elements 类型的简化示意图:</p><p><img src="./1.png" alt></p><p>它只能通过格来向下转变。一旦一个 Smis 数组添加了单个浮点数(single floating-point)，即便之后使用 Smi 覆盖该浮点数，它都会被标记为 DOUBLE。同样的，一旦一个数组中出现了 hole，即便之后将这个 hole 补上了，它都会被标记为 holey。</p><p>V8 目前区分了 <a href="https://source.chromium.org/chromium/v8/v8.git/+/ec37390b2ba2b4051f46f153a8cc179ed4656f5d:src/elements-kind.h;l=14" target="_blank" rel="noopener">21 种不同的 elements 类型</a>，每一种都可能有一堆优化</p><p>通常，更特定的 elements 类型支持更细粒度的优化。格中 elements 类型越往下，其对象的操作就会越慢。为了获取最佳性能，避免不太特定的类型的这种不必要的转换，应坚持使用最适合情况的特定 elements 类型。</p><h2 id="性能建议"><a href="#性能建议" class="headerlink" title="性能建议"></a>性能建议</h2><p>大多数情况下，elements 类型的追踪工作是在底层运行的，没必要考虑得那么细。但为了从系统中获取最大收益，以下几件事情是可以做的。</p><h3 id="避免读取超出数组长度的内容"><a href="#避免读取超出数组长度的内容" class="headerlink" title="避免读取超出数组长度的内容"></a>避免读取超出数组长度的内容</h3><p>有点出乎意料(鉴于这篇文章的标题)的是，我们的第 1 个性能建议与 elements 类型追踪没有直接联系(尽管背后发生的事情有点像)。读取超过数组长度的数据会对性能产生惊人的影响，例如当 <code>array.length === 5</code> 时去读 <code>array[42]</code> 的数据。这个例子中数组下标 <code>42</code> 已经越界，数组本身就没这属性，JS 引擎就会耗费昂贵的性能去原型链上找。一旦加载遇到这种情况，V8 会记住 “这个加载需要处理特殊情况”，而且它的速度再也不会像读取到越界之前那么快了。</p><p>不要把循环写成这样:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不要这么写!</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, item; (item = items[i]) != <span class="literal">null</span>; i++) &#123;</span><br><span class="line">  doSomething(item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码读取数组中的所有元素，然后再读取一个元素。直到它发现 <code>undefined</code> 的或 <code>null</code> 元素时才结束。(jQuery 在一些地方就这么干的。)</p><p>相反，用老方式写循环，并不断迭代，直到到达最后一个元素。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> index = <span class="number">0</span>; index &lt; items.length; index++) &#123;</span><br><span class="line">  <span class="keyword">const</span> item = items[index];</span><br><span class="line">  doSomething(item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果循环的对象是可迭代的(比如数组和 <code>NodeLists</code>)就更好了，直接用 <code>for-of</code></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> item <span class="keyword">of</span> items) &#123;</span><br><span class="line">  doSomething(item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于特定数组，也可以用内置 <code>forEach</code></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">items.forEach(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">  doSomething(item);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>现在 <code>for-of</code> 和 <code>forEach</code> 的性能都和老式的 for 循环差不多了。</p><p>避免读取超出数组长度的内容！在这种情况下，V8 的边界检查会失败，检查该属性是否存在也就会失败，然后 V8 就要从原型链上找了。如果之后在计算中不小心使用到了这个值(也就是超出数组长度的值)，影响会更糟，例如:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Maximum</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> max = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt;= array.length; i++) &#123; <span class="comment">// 糟糕的比较</span></span><br><span class="line">    <span class="keyword">if</span> (array[i] &gt; max) max = array[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里，最后一次迭代超出了数组长度，返回结果为 <code>undefined</code>，这既影响了加载，又影响了比较：不再只比较数字，它要处理特殊情况。把终止条件改为正确的 <code>i &lt; array.length</code> 可使本示例的性能提高 6 倍(在有 10,000 个元素的数组上进行测试，迭代次数只减少了 0.01%)。</p><h3 id="避免-elements-类型的变化"><a href="#避免-elements-类型的变化" class="headerlink" title="避免 elements 类型的变化"></a>避免 elements 类型的变化</h3><p>通常，如果需要在一个数组上执行很多操作，试着只用一种元素类型，尽可能是特定类型，这样 V8 可以尽可能对这些操作进行优化。</p><p>这比看上去要难。比如仅向一个 Smi 数组中添加 <code>-0</code> 就能把它变成 <code>PACKED_DOUBLE_ELEMENTS</code>。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> array = [<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, +<span class="number">0</span>];</span><br><span class="line"><span class="comment">// PACKED_SMI_ELEMENTS</span></span><br><span class="line">array.push(<span class="number">-0</span>);</span><br><span class="line"><span class="comment">// PACKED_DOUBLE_ELEMENTS</span></span><br></pre></td></tr></table></figure><p>结果就是，之后对该数组的任何操作的优化都与对 Smi 的优化不一样。</p><p>避免使用 <code>-0</code>，除非明确需要在代码中区分 <code>-0</code> 和 <code>+0</code>。(最好不要这么做)</p><p>对于 <code>NaN</code> 和 <code>Infinity</code> 而言都是一样的。它们都被看作是浮点数(doubles)，所以在一个 <code>SMI_ELEMENTS</code> 数组中添加一个 <code>NaN</code> 或者是 <code>Infinity</code>，这个数组就会变成 <code>DOUBLE_ELEMENTS</code></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> array = [<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>];</span><br><span class="line"><span class="comment">// PACKED_SMI_ELEMENTS</span></span><br><span class="line">array.push(<span class="literal">NaN</span>, <span class="literal">Infinity</span>);</span><br><span class="line"><span class="comment">// PACKED_DOUBLE_ELEMENTS</span></span><br></pre></td></tr></table></figure><p>要对一个整数数组进行大量的操作了，在它初始化时就应考虑下把 <code>-0</code> 变成 <code>0</code>，<code>NaN</code> 和 <code>Infinity</code> 之类的值就应该过滤掉。这样一来，这个数组才会维持在 <code>PACKED_SMI_ELEMENTS</code> 状态。这种一次性标准化后的开销对于后续优化都是值得的。</p><p>实际上，如果要对数字(numbers)数组进行数学操作，可以考虑下 TypedArray。这也有对应的特定的 elements 类型。</p><h3 id="优先使用-array-而不是-array-like-的对象"><a href="#优先使用-array-而不是-array-like-的对象" class="headerlink" title="优先使用 array 而不是 array-like 的对象"></a>优先使用 array 而不是 array-like 的对象</h3><p>有些 JS 里的对象，特别是 DOM，看起来像是数组但其实它们并不是真正意义上的数组。创建的 array-like 的数组就像下面这样</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arrayLike = &#123;&#125;;</span><br><span class="line">arrayLike[<span class="number">0</span>] = <span class="string">'a'</span>;</span><br><span class="line">arrayLike[<span class="number">1</span>] = <span class="string">'b'</span>;</span><br><span class="line">arrayLike[<span class="number">2</span>] = <span class="string">'c'</span>;</span><br><span class="line">arrayLike.length = <span class="number">3</span>;</span><br></pre></td></tr></table></figure><p>这个对象有 <code>length</code> ，也可以通过下标索引访问子元素(就像数组一样!)，但它在其原型链上缺少数组方法，比如 <code>forEach</code>。不过仍可以通过下面的方式在这个对象上调用数组的方法</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.forEach.call(arrayLike, (value, index) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123; index &#125;</span>: <span class="subst">$&#123; value &#125;</span>`</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 先打印 '0: a', 然后打印 '1: b', 最后打印 '2: c'.</span></span><br></pre></td></tr></table></figure><p>这段代码调用 array-like 对象上内置的 <code>Array.prototype.forEach</code> 方法，结果符合预期。但这比在真数组上调用 <code>forEach</code> 慢，而后者在 V8 中已被高度优化。要多次在此对象上使用内置的数组方法的话，就应先把它转成真数组再用：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> actualArray = <span class="built_in">Array</span>.prototype.slice.call(arrayLike, <span class="number">0</span>);</span><br><span class="line">actualArray.forEach(<span class="function">(<span class="params">value, index</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123; index &#125;</span>: <span class="subst">$&#123; value &#125;</span>`</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 先打印 '0: a', 然后打印 '1: b', 最后打印 '2: c'.</span></span><br></pre></td></tr></table></figure><p>这种一次性转换的开销对于后续的优化来讲都是值得的，特别是当对数组执行大量操作时。</p><p><code>arguments</code> 对象是一个 array-like 对象，可以在其上调用数组内置函数，但这种操作不会像对真数组那样做全方位的优化。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> logArgs = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">Array</span>.prototype.forEach.call(<span class="built_in">arguments</span>, (value, index) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123; index &#125;</span>: <span class="subst">$&#123; value &#125;</span>`</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line">logArgs(<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>);</span><br><span class="line"><span class="comment">// 先打印 '0: a', 然后打印 '1: b', 最后打印 '2: c'.</span></span><br></pre></td></tr></table></figure><p>ES2015 rest 参数可以在这里帮个忙。它们可以用真数组，而不是优雅地用 array-like 的 <code>arguments</code> 对象。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> logArgs = <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">  args.forEach(<span class="function">(<span class="params">value, index</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123; index &#125;</span>: <span class="subst">$&#123; value &#125;</span>`</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line">logArgs(<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>);</span><br><span class="line"><span class="comment">// 先打印 '0: a', 然后打印 '1: b', 最后打印 '2: c'.</span></span><br></pre></td></tr></table></figure><p>现在你还有啥借口用 <code>arguments</code> 对象。</p><p>所以一般来讲，尽可能避免使用 array-like 的对象，应尽可能使用真数组。</p><h3 id="避免多态"><a href="#避免多态" class="headerlink" title="避免多态"></a>避免多态</h3><p>如果代码中要处理很多不同的 elements 类型的数组，它可能会导致多态操作，这比只用处理单个 elements 类型的代码要慢。</p><p>看如下示例，里面调用了各种 elements 类型的库函数。(注意下这不是原来的 <code>Array.prototype.forEach</code> 方法，除了本文讨论的对特定 elements 类型的优化，这个示例自己也有一套优化。)</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> each = <span class="function">(<span class="params">array, callback</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> index = <span class="number">0</span>; index &lt; array.length; ++index) &#123;</span><br><span class="line">    <span class="keyword">const</span> item = array[index];</span><br><span class="line">    callback(item);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> doSomething = <span class="function">(<span class="params">item</span>) =&gt;</span> <span class="built_in">console</span>.log(item);</span><br><span class="line"></span><br><span class="line">each([], () =&gt; &#123;&#125;);</span><br><span class="line"></span><br><span class="line">each([<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>], doSomething);</span><br><span class="line"><span class="comment">// `PACKED_ELEMENTS` 调用了 `each` 方法。V8 使用了内联缓存</span></span><br><span class="line"><span class="comment">// (或者说叫 "IC") 记住了这个 `each` 方法是被这个 elements 类型调用的。</span></span><br><span class="line"><span class="comment">// 若不出意外，V8 会乐观地假定在 `each` 方法里访问 `array.length` 和 `array[index]` 时</span></span><br><span class="line"><span class="comment">// 是单一的(比如只接受一种 elements 类型)，之后每次调用 `each` 方法，V8 就会去检查这个类型</span></span><br><span class="line"><span class="comment">// 是不是 `PACKED_ELEMENTS`，如果是，V8 会重用之前生成的代码；</span></span><br><span class="line"><span class="comment">// 如果不是，就需要做更多事情了</span></span><br><span class="line"></span><br><span class="line">each([<span class="number">1.1</span>, <span class="number">2.2</span>, <span class="number">3.3</span>], doSomething);</span><br><span class="line"><span class="comment">// `PACKED_DOUBLE_ELEMENTS` 调用了 `each` 方法。 V8 此时看到，在它的内联缓存里面，</span></span><br><span class="line"><span class="comment">// 给 `each` 方法传的是不同的 elements 类型的数组了，那么在 `each` 方法里访问 `array.length` 和 `array[index]` 时就被打上了多态的标记。</span></span><br><span class="line"><span class="comment">// 现在每次在调用 `each` 方法时 V8 都要去做下额外的检查:</span></span><br><span class="line"><span class="comment">// 1. 这个是不是 `PACKED_ELEMENTS`(就像上面说过的)</span></span><br><span class="line"><span class="comment">// 2. 这个是不是 `PACKED_DOUBLE_ELEMENTS`</span></span><br><span class="line"><span class="comment">// 3. 这个还是不是其他的 elements 类型</span></span><br><span class="line"><span class="comment">// 这就会引起性能上的损耗</span></span><br><span class="line"></span><br><span class="line">each([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], doSomething);</span><br><span class="line"><span class="comment">// `PACKED_SMI_ELEMENTS` 调用了 `each` 方法。这就触发了另一个种程度的多态性。现在在内联缓存中，对于 `each` 方法来说有 3 种不同的 elements 类型。从现在开始每次调用 `each` 方法，就需要另外检查 elements 类型，才能将生成的代码重新用于 `PACKED_SMI_ELEMENTS` 数组，而这都需要以消耗性能为代价才能做的。</span></span><br></pre></td></tr></table></figure><p>内置方法(如 <code>Array.prototype.forEach</code>)可以更有效地处理这种多态性，因此如果对性能敏感，请考虑使用这些内置方法而不是用户手写的库函数</p><p>V8 中关于单态与多态的另一个例子就跟对象的 shape 相关，也就是对象的隐藏类。要了解更多请参考 <a href="https://mrale.ph/blog/2015/01/11/whats-up-with-monomorphism.html" target="_blank" rel="noopener">这篇文章</a></p><h3 id="避免创建-holes"><a href="#避免创建-holes" class="headerlink" title="避免创建 holes"></a>避免创建 holes</h3><p>在真正的代码看来，访问 holey 数组和 packed 数组之间的性能差异通常太小，甚至无法测量。如果性能测试表明在优化的代码中保留每一条机器指令是值得的，那么可以尝试把数组维持在 packed 模式。比如说，我们要创建一个数组</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> array = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">3</span>);</span><br><span class="line"><span class="comment">// 此时这个数组是稀疏的，所以它被标记为 `HOLEY_SMI_ELEMENTS`</span></span><br><span class="line"><span class="comment">// 根据当前的信息这就是最可能的结果</span></span><br><span class="line"></span><br><span class="line">array[<span class="number">0</span>] = <span class="string">'a'</span>;</span><br><span class="line"><span class="comment">// 等等，这是一个字符而不是一个 Smi，所以 elements 类型转成 `HOLEY_ELEMENTS`</span></span><br><span class="line"></span><br><span class="line">array[<span class="number">1</span>] = <span class="string">'b'</span>;</span><br><span class="line">array[<span class="number">2</span>] = <span class="string">'c'</span>;</span><br><span class="line"><span class="comment">// 此时，数组的 3 个位置都被填满了。所以数组是 packed 了(不再是稀疏的了)。</span></span><br><span class="line"><span class="comment">// 然而现在已经不能把这个数组再转成一个特定类型比如 `PACKED_ELEMENTS` 了。</span></span><br><span class="line"><span class="comment">// elements 类型仍然为 `HOLEY_ELEMENTS`</span></span><br></pre></td></tr></table></figure><p>一旦数组被标记为 holey，它将永远保持在 holey 状态，即便之后数组里面有元素了</p><p>创建数组的更好方法是使用如下方式</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> array = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>];</span><br><span class="line"><span class="comment">// elements 类型: PACKED_ELEMENTS</span></span><br></pre></td></tr></table></figure><p>如果事先不知道所有的值，可以创建一个空数组，然后将值 <code>push</code> 进去</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> array = [];</span><br><span class="line"><span class="comment">// …</span></span><br><span class="line">array.push(someValue);</span><br><span class="line"><span class="comment">// …</span></span><br><span class="line">array.push(someOtherValue);</span><br></pre></td></tr></table></figure><p>这种方法确保了数组永远不会转换为 holey elements 类型。因此，V8 可能会为这个数组的某些操作生成更快的优化代码。</p><h2 id="调试-elements-类型"><a href="#调试-elements-类型" class="headerlink" title="调试 elements 类型"></a>调试 elements 类型</h2><p>为了弄明白啥是对象的 elements 类型，可用 d8 的调试版本运行(通过在 debug 模式下<a href="https://v8.dev/docs/build" target="_blank" rel="noopener">从源码进行构建</a>，或使用 <a href="https://github.com/GoogleChromeLabs/jsvu" target="_blank" rel="noopener">jsvu</a> 弄到预编译的二进制文件)</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">out/x64.debug/d8 --allow-natives-syntax</span><br></pre></td></tr></table></figure><p>这将打开一个 d8 REPL，其中可用 <code>%DebugPrint(object)</code> 等<a href="https://cs.chromium.org/chromium/src/v8/src/runtime/runtime.h?l=20&amp;rcl=05720af2b09a18be5c41bbf224a58f3f0618f6be" target="_blank" rel="noopener">特殊函数</a>。输出的 <code>elements</code> 字段显示了传递给 这个 debug 函数的对象的 elements 类型。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">d8&gt; const array = [1, 2, 3]; %DebugPrint(array);</span><br><span class="line">DebugPrint: 0x1fbbad30fd71: [JSArray]</span><br><span class="line"> - map = 0x10a6f8a038b1 [FastProperties]</span><br><span class="line"> - prototype = 0x1212bb687ec1</span><br><span class="line"> - elements = 0x1fbbad30fd19 &lt;FixedArray[3]&gt; [PACKED_SMI_ELEMENTS (COW)]</span><br><span class="line"> - length = 3</span><br><span class="line"> - properties = 0x219eb0702241 &lt;FixedArray[0]&gt; &#123;</span><br><span class="line">    <span class="comment">#length: 0x219eb0764ac9 &lt;AccessorInfo&gt; (const accessor descriptor)</span></span><br><span class="line"> &#125;</span><br><span class="line"> - elements= 0x1fbbad30fd19 &lt;FixedArray[3]&gt; &#123;</span><br><span class="line">           0: 1</span><br><span class="line">           1: 2</span><br><span class="line">           2: 3</span><br><span class="line"> &#125;</span><br><span class="line">[…]</span><br></pre></td></tr></table></figure><p>注意，COW 表示<a href="https://zh.wikipedia.org/wiki/%E5%AF%AB%E5%85%A5%E6%99%82%E8%A4%87%E8%A3%BD" target="_blank" rel="noopener">copy-on-write</a>，这是另一个内部优化。</p><p>在调试构建中可用的另一个有用的 flag 是 <code>--trace-elements-transitions</code>。用上它能让 V8 提示你 elements 类型转换是在啥时发生的。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ cat my-script.js</span><br><span class="line">const array = [1, 2, 3];</span><br><span class="line">array[3] = 4.56;</span><br><span class="line"></span><br><span class="line">$ out/x64.debug/d8 --trace-elements-transitions my-script.js</span><br><span class="line">elements transition [PACKED_SMI_ELEMENTS -&gt; PACKED_DOUBLE_ELEMENTS] <span class="keyword">in</span> ~+34 at x.js:2 <span class="keyword">for</span> 0x1df87228c911 &lt;JSArray[3]&gt; from 0x1df87228c889 &lt;FixedArray[3]&gt; to 0x1df87228c941 &lt;FixedDoubleArray[22]&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;注：该文章翻译自&lt;a href=&quot;https://v8.dev/blog/elements-kinds&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://v8.dev/blog/elements-kinds&lt;/a&gt; V8 的官方博客，这是关于解释在 V8 中「elements」的类型都有哪些的一篇文章，文章有翻译的不是很清楚的地方，欢迎各位指正&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="翻译" scheme="https://strugglebak.github.io/categories/%E7%BF%BB%E8%AF%91/"/>
    
    
      <category term="V8" scheme="https://strugglebak.github.io/tags/V8/"/>
    
  </entry>
  
  <entry>
    <title>手摸手踩坑react-template</title>
    <link href="https://strugglebak.github.io/2021/11/23/%E6%89%8B%E6%91%B8%E6%89%8B%E8%B8%A9%E5%9D%91react-template/"/>
    <id>https://strugglebak.github.io/2021/11/23/手摸手踩坑react-template/</id>
    <published>2021-11-23T04:22:02.000Z</published>
    <updated>2022-06-04T08:13:29.428Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>注意：为了方便统一，本文中出现的安装包依赖的方式均使用 <code>yarn</code> 来安装</p></blockquote><a id="more"></a><h2 id="采取最简便的方式"><a href="#采取最简便的方式" class="headerlink" title="采取最简便的方式"></a>采取最简便的方式</h2><p>如果说搭建一个 react template 最简便的方式，那便是使用官方的 cli，即 <code>create-react-app</code>，因为这边还需要使用 typescript 技术栈，所以在搭建的过程中可以加一个参数 <code>--template typescript</code>，表示使用的模板是 typescript 的模板</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yarn create react-app my-app --template typescript</span><br></pre></td></tr></table></figure><p>然后在项目的目录中执行如下的命令安装依赖</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yarn add typescript @types/node @types/react @types/react-dom @types/jest</span><br></pre></td></tr></table></figure><p>然后生成的目录结构基本上如下所示</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># my-app</span></span><br><span class="line">├── README.md</span><br><span class="line">├── package.json</span><br><span class="line">├── public</span><br><span class="line">│   ├── favicon.ico</span><br><span class="line">│   ├── index.html</span><br><span class="line">│   ├── logo192.png</span><br><span class="line">│   ├── logo512.png</span><br><span class="line">│   ├── manifest.json</span><br><span class="line">│   └── robots.txt</span><br><span class="line">├── src</span><br><span class="line">│   ├── App.css</span><br><span class="line">│   ├── App.test.tsx</span><br><span class="line">│   ├── App.tsx</span><br><span class="line">│   ├── index.css</span><br><span class="line">│   ├── index.tsx</span><br><span class="line">│   ├── logo.svg</span><br><span class="line">│   ├── react-app-env.d.ts</span><br><span class="line">│   ├── serviceWorker.ts</span><br><span class="line">│   └── setupTests.ts</span><br><span class="line">├── tsconfig.json</span><br><span class="line">└── yarn.lock</span><br></pre></td></tr></table></figure><p>其中比较重要的就是 <code>src</code> 以及 <code>tsconfig.json</code> 文件，一个用来存放源码，一个用来定义 <code>tsconfig.json</code> 文件。但这两个文件并不是在最开始搭建的时候一个大障碍，一个比较大的障碍是，使用 cra 创建的项目，如果以后项目的需求变更，就必须使用 <code>config-overide.js</code> 去做一个覆盖原本默认 <code>webpack</code> 配置的配置文件。同时你还需要下载 <a href="https://github.com/timarney/react-app-rewired/blob/master/README_zh.md" target="_blank" rel="noopener"><code>react-app-rewired</code></a> 这个库来重新构建整个项目。考虑到 <code>react-app-rewired</code> 社区中维护的插件/包/库都不是特别的多，并且使用这种过度包装的 package 也比较黑盒，难于调试，所以最后决定使用 <code>yarn eject</code> 抛出该项目的 webpack 配置，手动实现真正自定义的配置和其他的操作(做注释以及方便后面的维护)</p><h3 id="yarn-eject"><a href="#yarn-eject" class="headerlink" title="yarn eject"></a>yarn eject</h3><p>执行 <code>yarn eject</code> 之后，基本上就多了两个文件夹 <code>scripts</code> 以及 <code>config</code></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># scripts</span></span><br><span class="line">├── build.js</span><br><span class="line">├── start.js</span><br><span class="line">└── test.js</span><br></pre></td></tr></table></figure><p>其中的 <code>build.js</code>、<code>start.js</code>、<code>test.js</code> 分别对应 <code>package.json</code> 文件中的 <code>scripts</code> 脚本</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">// package.json</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="attr">"scripts"</span>: &#123;</span><br><span class="line">    <span class="attr">"start"</span>: <span class="string">"node scripts/start.js"</span>,</span><br><span class="line">    <span class="attr">"build"</span>: <span class="string">"node scripts/build.js"</span>,</span><br><span class="line">    <span class="attr">"test"</span>: <span class="string">"node scripts/test.js"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>道理我都明白，<code>start</code> 对应启动一个本地的 devServer 进行调试，而 <code>build</code> 对应打包最终的文件，<code>test</code> 对应代码的测试脚本，但是你特么的为啥要引入这么多个包啊？全部都是函数套函数的形式，你这谁看的懂啊？</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># config</span></span><br><span class="line">├── env.js</span><br><span class="line">├── getHttpsConfig.js</span><br><span class="line">├── jest</span><br><span class="line">│   ├── cssTransform.js</span><br><span class="line">│   └── fileTransform.js</span><br><span class="line">├── modules.js</span><br><span class="line">├── paths.js</span><br><span class="line">├── pnpTs.js</span><br><span class="line">├── webpack.config.js</span><br><span class="line">└── webpackDevServer.config.js</span><br></pre></td></tr></table></figure><p>还有这个所谓的 eject 出来的 <code>webpack</code> 的配置，粗略看了下核心文件 <code>webpack.config.js</code> 中光是配置文件的行数就有 <code>670</code> 行，尽管中间参杂了各种英文的注释，但是对于一个需要配置的新人来说，还是过于繁杂了，光是看到它引入的各种插件也是头疼无比，其实到这个时候，就已经有不详的预感了(对于如此复杂的一个配置，任何修改和添加或者删除都将是灾难性的)</p><h3 id="sass-loader-的-bug"><a href="#sass-loader-的-bug" class="headerlink" title="sass-loader 的 bug"></a>sass-loader 的 bug</h3><p>因为在之前的 xp 项目中(比如 <code>xp-homework</code>)，可以通过 <code>.env</code> 中的环境变量给一个 scss 变量赋值并追加到某个定义好的 scss 文件中，在 <code>xp-homework</code> 项目中的 <code>vue.config.js</code> 有这样的代码</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  ...</span><br><span class="line">  css: &#123;</span><br><span class="line">    loaderOptions: &#123;</span><br><span class="line">      sass: &#123;</span><br><span class="line">        data: <span class="string">`@import "@/styles/variables.scss"; $userSelect: <span class="subst">$&#123;process.env</span></span></span><br><span class="line"><span class="string"><span class="subst">          .VUE_APP_USER_SELECT || <span class="string">'none'</span>&#125;</span>;`</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考 <a href="https://webpack.js.org/loaders/sass-loader/#prependdata" target="_blank" rel="noopener">webpack 中有关 sassloader prependData 属性的文档</a>，里面的解释如下</p><blockquote><p>Prepends Sass/SCSS code before the actual entry file. In this case, the sass-loader will not override the data option but just append the entry’s content.</p></blockquote><p>This is especially useful when some of your Sass variables depend on the environment</p><p>以及里面的函数配置的写法</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    loader: <span class="string">'sass-loader'</span>,</span><br><span class="line">    options: &#123;</span><br><span class="line">      prependData: <span class="function">(<span class="params">loaderContext</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// More information about available properties https://webpack.js.org/api/loaders/</span></span><br><span class="line">        <span class="keyword">const</span> &#123; resourcePath, rootContext &#125; = loaderContext;</span><br><span class="line">        <span class="keyword">const</span> relativePath = path.relative(rootContext, resourcePath);</span><br><span class="line">        <span class="keyword">if</span> (relativePath === <span class="string">'styles/foo.scss'</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="string">'$value: 100px;'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'$value: 200px;'</span>;</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将项目中的 <code>webpack.config.js</code> 中如下的代码</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">if</span> (preProcessor) &#123;</span><br><span class="line">  loaders.push(</span><br><span class="line">    &#123;</span><br><span class="line">      loader: <span class="built_in">require</span>.resolve(<span class="string">'resolve-url-loader'</span>),</span><br><span class="line">      options: &#123;</span><br><span class="line">        sourceMap: isEnvProduction &amp;&amp; shouldUseSourceMap,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      loader: <span class="built_in">require</span>.resolve(preProcessor),</span><br><span class="line">      options: &#123;</span><br><span class="line">        sourceMap: <span class="literal">true</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> loaders;</span><br></pre></td></tr></table></figure><p>改写成</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (preProcessor) &#123;</span><br><span class="line">  <span class="keyword">const</span> loader = &#123;</span><br><span class="line">    loader: <span class="built_in">require</span>.resolve(preProcessor),</span><br><span class="line">    options: &#123;</span><br><span class="line">      sourceMap: <span class="literal">true</span>,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (preProcessor === <span class="string">'sass-loader'</span>) &#123;</span><br><span class="line">    loader.options.prependData = <span class="function">(<span class="params">loaderContext</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123; resourcePath, rootContext &#125; = loaderContext</span><br><span class="line">      <span class="keyword">const</span> relativePath = path.relative(rootContext, resourcePath)</span><br><span class="line">      <span class="keyword">if</span> (relativePath === <span class="string">'src/styles/base.scss'</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">`$userSelect: <span class="subst">$&#123;process.env.REACT_APP_USER_SELECT || <span class="string">'none'</span>&#125;</span>`</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  loaders.push(</span><br><span class="line">    &#123;</span><br><span class="line">      loader: <span class="built_in">require</span>.resolve(<span class="string">'resolve-url-loader'</span>),</span><br><span class="line">      options: &#123;</span><br><span class="line">        sourceMap: isEnvProduction &amp;&amp; shouldUseSourceMap</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    loader</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> loaders</span><br></pre></td></tr></table></figure><p>使用 <code>yarn start</code> 后报如下的错误</p><p><img src="./1.png" alt></p><p>就非常的奇怪，一个比较 trick 的解决方式是，将所有需要引入到 .scss 文件的地方，都改为 .sass，并将其语法也改写成 sass 语法。编译通过。不过这并不是一个好的解决方式，因为定位的问题应该是 sass-loader，可能还有其他的配置，于是去 github 上找了 <a href="https://github.com/webpack-contrib/sass-loader" target="_blank" rel="noopener">sass-loader 的相关配置</a>，找到了这么一段话</p><p><img src="./2.png" alt></p><p>但是看了下，项目中其实是安装了 sass 的，按照道理来说应该会自动使用 sass 来 implementation 才对，但是这里又报错，于是尝试去掉 sass，直接安装 node-sass，问题居然解决了!!!所以如果以后需要用到 sass-loader 的地方，最好还是先安装 node-sass 比较稳妥</p><h3 id="路径-alias-引入失败"><a href="#路径-alias-引入失败" class="headerlink" title="路径 alias 引入失败"></a>路径 alias 引入失败</h3><p>之前在搭建模板的过程中，只是在 <code>tsconfig.json</code> 文件中设置了 <code>baseUrl</code> 以及 <code>paths</code></p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"baseUrl"</span>: <span class="string">"./src"</span>, <span class="comment">// 解析非相对模块名的基准目录</span></span><br><span class="line">  <span class="attr">"paths"</span>: &#123; <span class="comment">// 这个属性就是用来填写编译时对应的 alias 用的</span></span><br><span class="line">    <span class="attr">"@"</span>: [<span class="string">"./src"</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果是在 webpack 中不做设置，那么在编译时 webpack 会报错，所以在该项目中的 <code>webpack.config.js</code> 中也需要做 alias 的配置</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">alias: &#123;</span><br><span class="line">  <span class="string">'@'</span>: path.resolve(__dirname, <span class="string">'../src'</span>),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是设置完后编译，typescript 表示依然找不到模块，这个时候就是 <code>tsconfig.json</code> 配置的问题了。如果你的 <code>baseUrl</code> 中已经写了 <code>./src</code>，那么 <code>paths</code> 应该这么写</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"baseUrl"</span>: <span class="string">"./src"</span>, <span class="comment">// 解析非相对模块名的基准目录</span></span><br><span class="line">  <span class="attr">"paths"</span>: &#123; <span class="comment">// 这个属性就是用来填写编译时对应的 alias 用的</span></span><br><span class="line">    <span class="attr">"@/*"</span>: [<span class="string">"."</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>@/*</code> 表示匹配代码中的以 <code>@/xxx/yyy</code> 这种形式引入模块，由于已经设置了 <code>baseUrl</code>，所以这里 <code>paths</code> 中的配置就自动加上了 <code>baseUrl</code>了。比如引入一个包 <code>import XXX from &#39;@/xxx/yyy&#39;</code>，而你的配置为 <code>&quot;@/*&quot;: [&quot;.&quot;]</code> 的话，它会自动在 <code>./src/xxx/yyy</code> 下去寻找这个模块。另外为了保持格式，我将对应的 webpack 的 alias 以及 tsconfig 的 alias 都做了一一对应，如下</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line">alias: &#123;</span><br><span class="line">  <span class="comment">// 设置 webpack 编译时的 alias</span></span><br><span class="line">  <span class="comment">// ../ 目录的原因是因为当前 src 目录相当于当前 webpack.config.js 的就是上级目录</span></span><br><span class="line">  <span class="string">'@'</span>: path.resolve(__dirname, <span class="string">'../src'</span>),</span><br><span class="line">  <span class="string">'@api'</span>: path.resolve(__dirname, <span class="string">'../src/api'</span>),</span><br><span class="line">  <span class="string">'@assets'</span>: path.resolve(__dirname, <span class="string">'../src/assets'</span>),</span><br><span class="line">  <span class="string">'@components'</span>: path.resolve(__dirname, <span class="string">'../src/components'</span>),</span><br><span class="line">  <span class="string">'@router'</span>: path.resolve(__dirname, <span class="string">'../src/router'</span>),</span><br><span class="line">  <span class="string">'@styles'</span>: path.resolve(__dirname, <span class="string">'../src/styles'</span>),</span><br><span class="line">  <span class="string">'@utils'</span>: path.resolve(__dirname, <span class="string">'../src/utils'</span>),</span><br><span class="line">  <span class="string">'@views'</span>: path.resolve(__dirname, <span class="string">'../src/views'</span>),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">// tsconfig.json</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"baseUrl"</span>: <span class="string">"."</span>, <span class="comment">// 解析非相对模块名的基准目录</span></span><br><span class="line">  <span class="attr">"paths"</span>: &#123; <span class="comment">// 这个属性就是用来填写编译时对应的 alias 用的</span></span><br><span class="line">     <span class="attr">"@/*"</span>: [<span class="string">"./src/*"</span>],</span><br><span class="line">     <span class="attr">"@api/*"</span>: [<span class="string">"./src/api/*"</span>],</span><br><span class="line">     <span class="attr">"@assets/*"</span>: [<span class="string">"./src/assets/*"</span>],</span><br><span class="line">     <span class="attr">"@components/*"</span>: [<span class="string">"./src/components/*"</span>],</span><br><span class="line">     <span class="attr">"@router/*"</span>: [<span class="string">"./src/router/*"</span>],</span><br><span class="line">     <span class="attr">"@styles/*"</span>: [<span class="string">"./src/styles/*"</span>],</span><br><span class="line">     <span class="attr">"@utils/*"</span>: [<span class="string">"./src/utils/*"</span>],</span><br><span class="line">     <span class="attr">"@views/*"</span>: [<span class="string">"./src/views/*"</span>],</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="引入-svg-报错"><a href="#引入-svg-报错" class="headerlink" title="引入 svg 报错"></a>引入 svg 报错</h3><p>虽然现在能够以 img 标签 src 方式引入 svg，如下</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react</span></span><br><span class="line"><span class="string">import logoPng from '</span>@assets/logo.png<span class="string">'</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">class Demo extends React.Component &#123;</span></span><br><span class="line"><span class="string">    return (</span></span><br><span class="line"><span class="string">      &lt;div&gt;</span></span><br><span class="line"><span class="string">        &lt;img src=&#123;logoPng&#125; alt="logo" /&gt;</span></span><br><span class="line"><span class="string">      &lt;/div&gt;</span></span><br><span class="line"><span class="string">    )</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>但是我们更希望能将 svg 当成一个组件的方式引入，如下</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react</span></span><br><span class="line"><span class="string">import Logo from '</span>../../assets/logo.svg<span class="string">'</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">class Demo extends React.Component &#123;</span></span><br><span class="line"><span class="string">    return (</span></span><br><span class="line"><span class="string">      &lt;div&gt;</span></span><br><span class="line"><span class="string">        &lt;Logo /&gt;</span></span><br><span class="line"><span class="string">      &lt;/div&gt;</span></span><br><span class="line"><span class="string">    )</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>最开始是参考 <a href="https://create-react-app.dev/docs/adding-images-fonts-and-files/" target="_blank" rel="noopener">Adding SVGs</a> 这篇文章，它的解决方案如下</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; ReactComponent <span class="keyword">as</span> Logo &#125; <span class="keyword">from</span> <span class="string">'./logo.svg'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &#123;<span class="comment">/* Logo is an actual React component */</span>&#125;</span><br><span class="line">      &lt;Logo /&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>试了下发现是不行的，然后继续搜集线索，发现有个 babel 的插件可以解决这个问题，即 <code>babel-plugin-inline-react-svg</code>，而这是需要在 <code>babel-loader</code> 的 <code>options.plugins</code> 进行配置，如下</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">oneOf: [</span><br><span class="line">  &#123;</span><br><span class="line">    test: <span class="regexp">/\.(js|mjs|jsx|ts|tsx)$/</span>,</span><br><span class="line">    ...</span><br><span class="line">    loader: <span class="built_in">require</span>.resolve(<span class="string">'babel-loader'</span>),</span><br><span class="line">    options: &#123;</span><br><span class="line">      ...</span><br><span class="line">      plugins: [</span><br><span class="line">        <span class="built_in">require</span>.resolve(<span class="string">'babel-plugin-inline-react-svg'</span>), <span class="comment">// 这里只是需要添加这个插件即可</span></span><br><span class="line">        [</span><br><span class="line">          <span class="built_in">require</span>.resolve(<span class="string">'babel-plugin-named-asset-import'</span>),</span><br><span class="line">          &#123;</span><br><span class="line">            loaderMap: &#123;</span><br><span class="line">              svg: &#123;</span><br><span class="line">                ReactComponent:</span><br><span class="line">                  <span class="string">'@svgr/webpack?-svgo,+titleProp,+ref![path]'</span></span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">     ],</span><br><span class="line">  &#125;,</span><br><span class="line">  ...</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>在说 <code>babel-plugin-inline-react-svg</code> 这个插件的原理之前，先说下 <code>babel-plugin-named-asset-import</code> 的原理，这个插件本质上会将如下的语句</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; url <span class="keyword">as</span> logoUrl &#125; <span class="keyword">from</span> <span class="string">'./logo.png'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; ReactComponent <span class="keyword">as</span> Icon &#125; <span class="keyword">from</span> <span class="string">'./icon.svg'</span>;</span><br></pre></td></tr></table></figure><p>转换成</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> logoUrl <span class="keyword">from</span> <span class="string">'url-loader!./logo.png'</span>;</span><br><span class="line"><span class="keyword">import</span> Icon <span class="keyword">from</span> <span class="string">'svgr/webpack?-svgo,+titleProp,+ref!./icon.svg'</span>;<span class="string">"</span></span><br></pre></td></tr></table></figure><p>但是由于这个插件对 svg 的处理，只能是通过 img 的 src 标签引入，所以才需要 <code>babel-plugin-inline-react-svg</code> 这个插件，能把 svg 自动封装成一个组件来使用，原理应该是 babel-loader 在对文件进行处理时，对源码做了一些修改导致的</p><h3 id="新的问题"><a href="#新的问题" class="headerlink" title="新的问题"></a>新的问题</h3><p>但是紧接着又带来了新的问题，<strong>在使用 alias 的方式引入 svg 时，会报错，即 svg 文件对应的路径找不到</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Logo <span class="keyword">from</span> <span class="string">'@assets/logo.svg'</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p><img src="./3.png" alt></p><p>出现这个问题的原因，可能在于 babel-loader 的 plugin 那里，之前我有提到过 <code>babel-plugin-named-asset-import</code> 这个插件的工作原理，有可能是 webpack 在处理 alias 之前，<strong>优先</strong>被这个插件做了处理了，即以上的代码会被转换成</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Logo <span class="keyword">from</span> <span class="string">'svgr/webpack?-svgo,+titleProp,+ref!@assets/logo.svg'</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>这个时候 svgr/webpack 这个 loader 自然就找不到路径为 <code>@assets/logo.svg</code> 的这个模块，于是编译就会报错了。</p><h2 id="所以更好的方式？"><a href="#所以更好的方式？" class="headerlink" title="所以更好的方式？"></a>所以更好的方式？</h2><p>由以上的方式，我们就懂得了一个道理，最 easy 的方式，有的时候往往也是最 hard 的。且不说上面的 svg 引入的问题没有得到完美的解决，要是以后项目逐渐的变得复杂了，需要对项目的基建做修改和升级呢？出了问题之后要怎么维护呢？连现在这个简单的问题的解决方案都如此麻烦的情况下，那万一以后出了更加匪夷所思的问题需要将项目基建整体重构呢? …etc</p><p>基于以上的风险考虑，从项目的可读性和可维护性着想的话，也许最好的方式，就是自己手撸一个 template 出来</p><h3 id="重构-config"><a href="#重构-config" class="headerlink" title="重构 config"></a>重构 config</h3><p>进行重构的操作之前，可以先将依赖包进行删除(包括 package.json 中的)，然后执行如下安装基础包</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安装 typesript</span></span><br><span class="line">yarn add -D typescript</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装 react 相关包</span></span><br><span class="line">yarn add react react-dom react-router-dom</span><br><span class="line">yarn add -D @types/react-router-dom @types/react-dom @types/react</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装 babel 相关包</span></span><br><span class="line">yarn add -D</span><br><span class="line">@babel/core <span class="comment"># babel 核心</span></span><br><span class="line">@babel/plugin-proposal-class-properties <span class="comment"># 支持 class xxx &#123; a = 'xxx' &#125; 这样在类中定义属性</span></span><br><span class="line">@babel/plugin-proposal-decorators <span class="comment"># 支持使用装饰器</span></span><br><span class="line">@babel/plugin-syntax-dynamic-import <span class="comment"># 支持异步加载(improt (xxx))</span></span><br><span class="line">@babel/preset-react  @babel/preset-typescript <span class="comment"># 支持将 react 以及 ts 编译成 js</span></span><br><span class="line">babel-loader</span><br><span class="line">babel-plugin-import <span class="comment"># 若是需要 antd 的包，可以安装这个进行按需加载</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装 html-webpack-plugin</span></span><br><span class="line">yarn add -D html-webpack-plugin</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装 sass 以及 style 配置相关包</span></span><br><span class="line">yarn add -D sass-loader node-sass style-loader css-loader css-modules-typescript-loader</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装 url-loader</span></span><br><span class="line">yarn add -D url-loader</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装 @svgr/webpack</span></span><br><span class="line">yarn add -D @svgr/webpack</span><br></pre></td></tr></table></figure><p>然后需要做的就是删除 config 文件夹下的各种 js 文件，然后新建几个文件</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># config</span></span><br><span class="line">├── devServerConfig.js <span class="comment"># webpack devServer 相关配置</span></span><br><span class="line">├── devServerProxyConfig.js <span class="comment"># webpack devServer proxy 相关配置</span></span><br><span class="line">├── pluginsConfig.js <span class="comment"># webpack plugins 相关配置</span></span><br><span class="line">├── resolveConfig.js <span class="comment"># webpack resolve 相关配置</span></span><br><span class="line">├── rules <span class="comment"># webpack rules 相关配置</span></span><br><span class="line">│   ├── assetsRules.js <span class="comment"># assets 资源文件相关 rules</span></span><br><span class="line">│   ├── fileRules.js <span class="comment"># file 文件相关 rules</span></span><br><span class="line">│   ├── jsRules.js <span class="comment"># js 相关 rules</span></span><br><span class="line">│   └── styleRules.js <span class="comment"># style 相关 rules</span></span><br><span class="line">├── utils.js <span class="comment"># 工具库 js，将一些可能用到公共的函数放到这个里面</span></span><br><span class="line">└── webpack.config.js <span class="comment"># webpack 配置</span></span><br></pre></td></tr></table></figure><p>从整体上看，<code>webpack.config.js</code> 的配置文件只有寥寥几行</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; resolve &#125; = <span class="built_in">require</span>(<span class="string">'./utils'</span>)</span><br><span class="line"><span class="keyword">const</span> jsRules = <span class="built_in">require</span>(<span class="string">'./rules/jsRules'</span>)</span><br><span class="line"><span class="keyword">const</span> styleRules = <span class="built_in">require</span>(<span class="string">'./rules/styleRules'</span>)</span><br><span class="line"><span class="keyword">const</span> fileRules = <span class="built_in">require</span>(<span class="string">'./rules/fileRules'</span>)</span><br><span class="line"><span class="keyword">const</span> assetsRules = <span class="built_in">require</span>(<span class="string">'./rules/assetsRules'</span>)</span><br><span class="line"><span class="keyword">const</span> pluginsConfig = <span class="built_in">require</span>(<span class="string">'./pluginsConfig'</span>)</span><br><span class="line"><span class="keyword">const</span> resolveConfig = <span class="built_in">require</span>(<span class="string">'./resolveConfig'</span>)</span><br><span class="line"><span class="keyword">const</span> devServerConfig = <span class="built_in">require</span>(<span class="string">'./devServerConfig'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@type <span class="type">&#123;import('webpack').Configuration&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    app: resolve(<span class="string">'src/index.tsx'</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: resolve(<span class="string">'dist'</span>),</span><br><span class="line">    filename: <span class="string">'[name].js'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  devServer: devServerConfig,</span><br><span class="line">  resolve: resolveConfig,</span><br><span class="line">  plugins: [...pluginsConfig],</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      ...jsRules,</span><br><span class="line">      ...styleRules,</span><br><span class="line">      ...fileRules,</span><br><span class="line">      ...assetsRules</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结构非常清晰了，相信大家应该都对这个配置挺熟悉了，所以下面就重点来详细说说这几个文件</p><h4 id="utils-js"><a href="#utils-js" class="headerlink" title="utils.js"></a>utils.js</h4><p>源码如下</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@title </span>utils.js</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description </span>这个文件是为了方便路径处理用的</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"></span><br><span class="line">exports.resolve = <span class="function"><span class="params">dir</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> path.join(__dirname, <span class="string">'./../'</span>, dir)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为这里是用 node 启动的，所以我们可以将其当成一个 commonjs 模块，<code>exports.resolve</code> 表示暴露出一个叫 <code>resolve</code> 的模块给外部，里面的逻辑就是将一个 dir 的名字拼凑成上级目录并返回。因为很多地方会用到，所以这里封装成一个模块比较好</p><h4 id="jsRules-js"><a href="#jsRules-js" class="headerlink" title="jsRules.js"></a>jsRules.js</h4><p>源码如下</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@title </span>jsRules.js</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description </span>定义 js 规则</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; resolve &#125; = <span class="built_in">require</span>(<span class="string">'../utils'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// 这里编写 babel 对 .tsx 文件编译的配置</span></span><br><span class="line">    test: <span class="regexp">/\.(j|t)sx?$/</span>, <span class="comment">// 正则匹配以 .jsx 或者 .tsx 结尾的文件</span></span><br><span class="line">    include: resolve(<span class="string">'src'</span>), <span class="comment">// 表示限定范围在 src 目录下</span></span><br><span class="line">    use: [</span><br><span class="line">      &#123;</span><br><span class="line">        loader: <span class="string">'babel-loader'</span>,</span><br><span class="line">        options: &#123;</span><br><span class="line">          babelrc: <span class="literal">false</span>, <span class="comment">// 这里不用 babelrc 文件</span></span><br><span class="line">          presets: [<span class="string">'@babel/preset-typescript'</span>, <span class="string">'@babel/preset-react'</span>],</span><br><span class="line">          plugins: [</span><br><span class="line">            [<span class="string">'@babel/plugin-proposal-decorators'</span>, &#123; <span class="attr">legacy</span>: <span class="literal">true</span> &#125;], <span class="comment">// 支持使用装饰器语法</span></span><br><span class="line">            [<span class="string">'@babel/plugin-proposal-class-properties'</span>, &#123; <span class="attr">loose</span>: <span class="literal">false</span> &#125;], <span class="comment">// 非宽松模式，类属性编译成赋值表达式，而不是 Object.defineProperty 这种形式</span></span><br><span class="line">            <span class="string">'@babel/plugin-syntax-dynamic-import'</span> <span class="comment">// 支持动态引入 import</span></span><br><span class="line">          ]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><a href="https://juejin.im/post/5c822e426fb9a04a0a5ffb49" target="_blank" rel="noopener">为什么不使用 ts-loader 以及 awesome-typescript-loader? 是因为 babel 的编译速度更快</a></p><h4 id="styleRules-js"><a href="#styleRules-js" class="headerlink" title="styleRules.js"></a>styleRules.js</h4><p>源码如下</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@title </span>styleRules.js</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description </span>定义 style 规则</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; resolve &#125; = <span class="built_in">require</span>(<span class="string">'../utils'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// 支持 scss/sass</span></span><br><span class="line">    test: <span class="regexp">/\.(scss|sass)$/</span>,</span><br><span class="line">    use: [</span><br><span class="line">      <span class="string">'style-loader'</span>,</span><br><span class="line">      <span class="string">'css-modules-typescript-loader'</span>, <span class="comment">// 在编写或改动了scss文件后，这个插件会自动生成 xxx.scss.d.ts 文件</span></span><br><span class="line">      &#123;</span><br><span class="line">        loader: <span class="string">'css-loader'</span>,</span><br><span class="line">        options: &#123;</span><br><span class="line">          modules: &#123; <span class="comment">// 支持 css-module</span></span><br><span class="line">            localIdentName: <span class="string">'[local]_[hash:base64:10]'</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        loader: <span class="string">'sass-loader'</span>,</span><br><span class="line">        options: &#123;</span><br><span class="line">          includePaths: [ <span class="comment">// 添加公共样式文件路径，这里 sass-loader 的版本为 7.3.1，请勿瞎升级！！！</span></span><br><span class="line">            resolve(<span class="string">'src/styles'</span>)</span><br><span class="line">          ]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123; <span class="comment">// 支持 less</span></span><br><span class="line">    test: <span class="regexp">/\.less$/</span>,</span><br><span class="line">    use: [</span><br><span class="line">      <span class="string">'style-loader'</span>,</span><br><span class="line">      <span class="string">'css-loader'</span>,</span><br><span class="line">      &#123;</span><br><span class="line">        loader: <span class="string">'less-loader'</span>,</span><br><span class="line">        options: &#123; <span class="comment">// 这里 javascriptEnabled 一定要为 true</span></span><br><span class="line">          javascriptEnabled: <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>这里需要注意的是，如果不做特殊的设置，webpack 的调用 loader 的顺序是从右往左的，即对于上面的支持 sass 的 loader 来说，它的执行顺序如下</p><ol><li>sass-loader: 将 sass|scss 文件编译成 css</li><li>css-loader: 将 css 转化为 commonjs 模块，比如 css 中有 <code>url(./xxx)</code> 的将其转化成 <code>require(./xxx)</code></li><li>css-modules-typescript-loader: 在编写或改动了scss文件后，这个插件会自动生成 xxx.scss.d.ts 文件</li><li>style-loader: 将经过 css-loader 转化成的 js 字符串转化成 style 的内容然后挂在 dom 上</li></ol><p>为什么需要 <code>css-modules-typescript-loader</code> 这个 loader 呢，因为对于 react 来说，我们一般通过这种方式使用一个 css 文件的类</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// index.tsx</span></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> style <span class="keyword">from</span> <span class="string">'./index.scss'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> App = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#123;style.xxx&#125;</span>&gt;</span>你好<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App</span><br></pre></td></tr></table></figure><p>这个时候不做设置，<code>index.tsx</code> 文件会报错说找不到这个 <code>index.scss</code> 模块。这是因为 ts 不认识这个 <code>index.scss</code> 文件，这个时候就需要加 <code>.d.ts</code> 写对应的类型文件才行(毕竟是 ts 的项目。。。)</p><p>可以自己在 <code>src/types</code> 目录下新建这个文件，然后写上</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">declare <span class="built_in">module</span> <span class="string">'*.scss'</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> content: any</span><br><span class="line">  <span class="keyword">export</span> = content</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个时候就可以了，当然我们可以想，不可能每个 scss 文件都这样做，能不能做的自动化一点，可以的，就使用 <code>css-modules-typescript-loader</code> 这个 loader 来帮我们做事情</p><p>那么这里做的 <code>css-module</code> 有什么好处呢？就是 react 中的 <strong>css 的模块化</strong>，<code>local</code> 表示 <strong>类名</strong>，<code>[hash:base64:10]</code> 表示这是一串由 base64 码生成的 hash，并且这个码的长度有 10 位。那么在浏览器上对应的 dom 上就会生成对应的类，这个对应的类下就有对应的 css 了，就形成来 css 的模块化，也就是自行隔离</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">xxx_1oiiefdai &#123;</span><br><span class="line">  background: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="fileRules-js"><a href="#fileRules-js" class="headerlink" title="fileRules.js"></a>fileRules.js</h4><p>源码如下</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@title </span>fileRules.js</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description </span>定义 file 输出文件的规则</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"><span class="keyword">const</span> imageInlineSizeLimit = <span class="built_in">parseInt</span>(</span><br><span class="line">  process.env.IMAGE_INLINE_SIZE_LIMIT || <span class="string">'10000'</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = [</span><br><span class="line">  &#123;</span><br><span class="line">    test: <span class="regexp">/\.(png|jpe?g|gif|bmp)(\?.*)?$/</span>,</span><br><span class="line">    use: [</span><br><span class="line">      &#123;</span><br><span class="line">        loader: <span class="string">'url-loader'</span>,</span><br><span class="line">        options: &#123;</span><br><span class="line">          limit: imageInlineSizeLimit,</span><br><span class="line">          <span class="comment">// 在任意操作系统上使用 POSIX 文件路径时获得一致的结果</span></span><br><span class="line">          name: path.posix.join(<span class="string">'static/media'</span>, <span class="string">'[name].[hash:8].[ext]'</span>)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>这里主要是对 png 等图片格式的处理，这里注意 <code>limit</code> 属性配置，这个属性配置是用来指定文件的最大的 byte 也就是字节数的，若文件的大小超过定义的字节数，那么 webpack 就会使用 file-loader 去处理文件，并且所有的查询参数都会传递给 file-loader。这里在使用 url-loader 时不需要安装 file-loader，因为它本身就依赖 file-loader。<code>name</code> 属性配置表示最终生成的目标资源文件的路径以及名字</p><h4 id="assetsRules-js"><a href="#assetsRules-js" class="headerlink" title="assetsRules.js"></a>assetsRules.js</h4><p>源码如下</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@title </span>assetsRules.js</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description </span>定义资源的规则</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// 支持本地 svg 导入</span></span><br><span class="line">    test: <span class="regexp">/\.svg$/</span>,</span><br><span class="line">    use: [<span class="string">'@svgr/webpack'</span>],</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>终于来了！只要单纯使用这个 loader，便可以解决上文中提到的本地以组件方式引入 svg 的问题！没有其他任何的幺蛾子！非常简单的配置!!!(这里当然也顺便解决了 alias 引入的问题)</p><h4 id="pluginsConfig-js"><a href="#pluginsConfig-js" class="headerlink" title="pluginsConfig.js"></a>pluginsConfig.js</h4><p>源码如下</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@title </span>plugins.js</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description </span>这个文件是为了存放 webpack 插件用的</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>)</span><br><span class="line"><span class="keyword">const</span> &#123; resolve &#125; = <span class="built_in">require</span>(<span class="string">'./utils'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = [</span><br><span class="line">  <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">    template: resolve(<span class="string">'public/index.html'</span>),</span><br><span class="line">    inject: <span class="literal">true</span> <span class="comment">// script 注入到 template 的 body 下</span></span><br><span class="line">  &#125;)</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><code>html-webpack-plugin</code> 一个耳熟能详的插件了，本质上的作用就是将生成的 js 生成 script 标签并且注入到模板页面的 body 中</p><p>当然在这个文件中统一做插件的处理，这样就能够方便的管理配置</p><h4 id="resolveConfig-js"><a href="#resolveConfig-js" class="headerlink" title="resolveConfig.js"></a>resolveConfig.js</h4><p>源码如下</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@title </span>aliases.js</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description </span>webpack 中需要配置的 alias</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> &#123; resolve &#125; = <span class="built_in">require</span>(<span class="string">'./utils'</span>)</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  extensions: [<span class="string">'.js'</span>, <span class="string">'.jsx'</span>, <span class="string">'.ts'</span>, <span class="string">'.tsx'</span>], <span class="comment">// 定义了文件的下标之后，以后 import js 模块的时候可以不用加后缀</span></span><br><span class="line">  alias: &#123; <span class="comment">// 定义 alias</span></span><br><span class="line">    <span class="string">'@'</span>: resolve(<span class="string">'src'</span>),</span><br><span class="line">    <span class="string">'@api'</span>: resolve(<span class="string">'src/api'</span>),</span><br><span class="line">    <span class="string">'@assets'</span>: resolve(<span class="string">'src/assets'</span>),</span><br><span class="line">    <span class="string">'@components'</span>: resolve(<span class="string">'src/components'</span>),</span><br><span class="line">    <span class="string">'@router'</span>: resolve(<span class="string">'src/router'</span>),</span><br><span class="line">    <span class="string">'@styles'</span>: resolve(<span class="string">'src/styles'</span>),</span><br><span class="line">    <span class="string">'@utils'</span>: resolve(<span class="string">'src/utils'</span>),</span><br><span class="line">    <span class="string">'@views'</span>: resolve(<span class="string">'src/views'</span>),</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个文件的配置也很简单，基本就是配置了下 <code>extensions</code> 以及 <code>alias</code> 属性，都是为了方便写代码做的配置。不过这里需要注意的是，对于 <code>extensions</code> 配置，如果引入的是同名的文件，比如在某个文件夹下有两个文件 <code>xxx.js</code>、<code>xxx.jsx</code>，你这边做引入了 <code>import xxx from &#39;xxx&#39;</code>，那么这个时候 webpack 就会采用你 <code>extensions</code> 中配置的第一个后缀名，剩下的不要，也就是说你最终引入的就是 <code>xxx.js</code></p><h4 id="devServerConfig-js"><a href="#devServerConfig-js" class="headerlink" title="devServerConfig.js"></a>devServerConfig.js</h4><p>源码如下</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@title </span>devServerConfig.js</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description </span>devServer 配置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="built_in">require</span>(<span class="string">'./devServerProxyConfig'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> host = process.env.HOST || <span class="string">'0.0.0.0'</span></span><br><span class="line"><span class="keyword">const</span> port = process.env.PORT || <span class="number">3000</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  compress: <span class="literal">true</span>, <span class="comment">// 为所有 served 的文件启用 gzip 压缩</span></span><br><span class="line">  clientLogLevel: <span class="string">'debug'</span>, <span class="comment">// 设置 log 等级，可设置为 'silent' | 'trace' | 'debug' | 'info' | 'warn' | 'error' | 'none' | 'warning'</span></span><br><span class="line">  hot: <span class="literal">true</span>, <span class="comment">// 开启热重载</span></span><br><span class="line">  host,</span><br><span class="line">  overlay: <span class="literal">false</span>, <span class="comment">// 出现编译器错误或警告时，在浏览器中显示全屏覆盖。 如果只想显示编译器错误就置为 true</span></span><br><span class="line">  port,</span><br><span class="line">  proxy,</span><br><span class="line">  quiet: <span class="literal">false</span>, <span class="comment">// 允许 errors 或者 warnings log</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释都写的很清楚了，其实都是些基本的配置</p><h4 id="devServerProxyConfig-js"><a href="#devServerProxyConfig-js" class="headerlink" title="devServerProxyConfig.js"></a>devServerProxyConfig.js</h4><p>源码如下</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@title </span>devServerProxyConfig.js</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description </span>devServer proxy 代理配置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="string">'/xhb_api'</span>: &#123;</span><br><span class="line">    target: <span class="string">'https://demo.xxx.cn'</span>,</span><br><span class="line">    changeOrigin: <span class="literal">true</span>, <span class="comment">// 默认情况下，代理时会保留主机头的来源，您可以将 changeOrigin 设置为 true 来覆盖此行为。</span></span><br><span class="line">    pathRewrite: &#123;</span><br><span class="line">      <span class="string">'^/xhb_api'</span>: <span class="string">'/api'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">'/api'</span>: &#123;</span><br><span class="line">    target: process.env.REACT_APP_API_DOMAIN,</span><br><span class="line">    changeOrigin: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代理配置，跟之前 <code>vue.config.js</code> 中的代理配置很像的，上面第一个代理配置表示 <strong>请求 /xhb_api/users/xxx 类似的接口时，请求本来会被代理到 <a href="https://demo.xxx.cn/xhb_api/user/xxx" target="_blank" rel="noopener">https://demo.xxx.cn/xhb_api/user/xxx</a> 这个上面来，但是因为你写了 pathRewrite，中间的 /xhb_api 会被替换成 /api，也就是说最终的代理地址为 <a href="https://demo.xxx.cn/api/user/xxx" target="_blank" rel="noopener">https://demo.xxx.cn/api/user/xxx</a></strong></p><h3 id="微小的总结"><a href="#微小的总结" class="headerlink" title="微小的总结"></a>微小的总结</h3><p>至此为止，一个基本的基于 react 以及 typescript 的项目就搭建完成了，后续的部分就是对模板进行些许优化的步骤了。不过总体来看，比之前使用 cra eject 的配置清爽了不少，并且由于配置的模块化(而不是函数嵌套似的模块化)，也使得项目本身易于阅读和拓展</p><h3 id="优化配置"><a href="#优化配置" class="headerlink" title="优化配置"></a>优化配置</h3><h4 id="构建加速与构建缓存"><a href="#构建加速与构建缓存" class="headerlink" title="构建加速与构建缓存"></a>构建加速与构建缓存</h4><p>首先需要安装两个 loader</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yarn add -D cache-loader thread-loader</span><br></pre></td></tr></table></figure><p>一般使用 <code>cache-loader</code> 构建缓存，用 <code>thread-loader</code> 构建加速。首先创建 <code>config/loaders.js</code> 文件。然后源码如下所示</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"> * @description 这个文件是为了设置构建缓存和构建加速用的</span><br><span class="line"> *<span class="regexp">/</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">const &#123; resolve &#125; = require('./u</span>tils<span class="string">')</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">// 构建缓存</span></span><br><span class="line"><span class="string">const cacheLoader = &#123;</span></span><br><span class="line"><span class="string">  loader: '</span>cache-loader<span class="string">',</span></span><br><span class="line"><span class="string">  options: &#123;</span></span><br><span class="line"><span class="string">    // 缓存文件路径</span></span><br><span class="line"><span class="string">    cacheDirectory: resolve('</span>.cache-loader<span class="string">')</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">// 构建加速，多线程编译</span></span><br><span class="line"><span class="string">const threadLoader = workerParallelJobs =&gt; &#123;</span></span><br><span class="line"><span class="string">  const options = &#123; workerParallelJobs &#125;</span></span><br><span class="line"><span class="string">  Object.assign(options, &#123;</span></span><br><span class="line"><span class="string">    poolTimeout: 2000</span></span><br><span class="line"><span class="string">  &#125;)</span></span><br><span class="line"><span class="string">  return &#123;</span></span><br><span class="line"><span class="string">    loader: '</span>thread-loader<span class="string">',</span></span><br><span class="line"><span class="string">    options</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">module.exports = &#123;</span></span><br><span class="line"><span class="string">  cacheLoader,</span></span><br><span class="line"><span class="string">  threadLoader</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>构建缓存的原理就是在本地有一个 .cache-loader 的文件夹，所有的需要缓存的玩意儿都放在这个里面，这样每次构建的时候若变化不大就直接取缓存里面的东西输出，可以加快构建的速度。而构建加速就是开启多线程编译。</p><p>因为平常在编译时，需要编译的主要是 js 以及 css 文件，所以应当在 <code>jsRules</code> 以及 <code>styleRules</code> 里引入</p><p><img src="./4.png" alt><br><img src="./5.png" alt></p><p>这里 <code>less-loader</code> 就没有用到 <code>thread-loader</code> 了，因为会报错</p><h4 id="优化打包和抽离-css"><a href="#优化打包和抽离-css" class="headerlink" title="优化打包和抽离 css"></a>优化打包和抽离 css</h4><p>优化打包方面主要用到了两个插件</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yarn add -D terser-webpack-plugin optimize-css-assets-webpack-plugin</span><br></pre></td></tr></table></figure><ul><li>terser-webpack-plugin 是用来优化 js 的压缩过程的，这里没有用到 <code>webpack.optimize.UglifyJsPlugin</code> 的原因是该插件不支持 es6 语法，为了方便就直接使用它了</li><li>optimize-css-assets-webpack-plugin 是用来优化 css 的压缩过程的</li></ul><p>再加上 webpack 本身有对代码分割的 <code>optimization</code> 配置，那么一个优化配置文件 <code>config/optimizationConfig.js</code> 的源码就是如下</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@title </span>optimizationConfig.js</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description </span>定义 webpack 优化配置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> TerserPlugin = <span class="built_in">require</span>(<span class="string">'terser-webpack-plugin'</span>)</span><br><span class="line"><span class="keyword">const</span> OptimizeCSSAssetsPlugin = <span class="built_in">require</span>(<span class="string">'optimize-css-assets-webpack-plugin'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// 将部分清单代码单独打包出来并命名为 manifest</span></span><br><span class="line">  runtimeChunk: &#123;</span><br><span class="line">    name: <span class="string">'manifest'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  splitChunks: &#123; <span class="comment">// 这是 webpack optimization 的优化配置，具体可以参考官网，本质上就是配置需要分离的包</span></span><br><span class="line">    cacheGroups: &#123;</span><br><span class="line">      <span class="keyword">default</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="comment">// 抽离 node_modules 下的公共代码</span></span><br><span class="line">      <span class="comment">// TODO 这里还可以继续抽离代码，待优化</span></span><br><span class="line">      commons: &#123;</span><br><span class="line">        test: <span class="regexp">/[\\/]node_modules[\\/]/</span>,</span><br><span class="line">        name: <span class="string">'commons'</span>,</span><br><span class="line">        chunks: <span class="string">'initial'</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">// 这里还可以为一些其他的包做单独打包的配置，比如</span></span><br><span class="line">      <span class="comment">// antd: &#123;</span></span><br><span class="line">      <span class="comment">//   name: 'antd',</span></span><br><span class="line">      <span class="comment">//   test: /[\\/]node_modules[\\/](antd)[\\/]/,</span></span><br><span class="line">      <span class="comment">//   chunks: 'all',</span></span><br><span class="line">      <span class="comment">//   priority: 9</span></span><br><span class="line">      <span class="comment">// &#125;,</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  minimizer: [</span><br><span class="line">    <span class="comment">// 优化 js 压缩过程</span></span><br><span class="line">    <span class="keyword">new</span> TerserPlugin(&#123;</span><br><span class="line">      <span class="comment">// 开启缓存</span></span><br><span class="line">      cache: <span class="literal">true</span>,</span><br><span class="line">      <span class="comment">// 开启多线程</span></span><br><span class="line">      parallel: <span class="literal">true</span>,</span><br><span class="line">      extractComments: <span class="literal">false</span></span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="comment">// 优化 css 压缩过程</span></span><br><span class="line">    <span class="keyword">new</span> OptimizeCSSAssetsPlugin(&#123;</span><br><span class="line">      <span class="comment">// 使用 cssnano 压缩，插件自带</span></span><br><span class="line">      cssProcessor: <span class="built_in">require</span>(<span class="string">'cssnano'</span>),</span><br><span class="line">      cssProcessorOptions: &#123;</span><br><span class="line">        safe: <span class="literal">true</span>,</span><br><span class="line">        autoprefixer: <span class="literal">false</span>,</span><br><span class="line">        discardComments: &#123;</span><br><span class="line">          removeAll: <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">// 将压缩过程输出到控制台</span></span><br><span class="line">      canPrint: <span class="literal">true</span></span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>css 文件若是都堆积在一坨也会变的很大，所以需要 <code>mini-css-extract-plugin</code> 来对 css 进行抽离</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">yarn add -D mini-css-extract-plugin</span><br></pre></td></tr></table></figure><p>在 <code>config/pluginsConfig.js</code> 中加上这个插件配置</p><p><img src="./6.png" alt></p><p>然后在 <code>styleRules.js</code> 中加上这个 MiniCssExtractPluginLoader（是的，本身这个插件是包含一个 loader 和一个 plugin 的）</p><p><img src="./7.png" alt></p><p>这里为啥要对 <code>style-loader</code> 做一个替换呢，因为我们知道在 <code>style-loader</code> 是在页面上添加一个 style 节点的，而分离 css 的步骤应该发生在 <code>css-loader</code> 之后，所以需要做一个替换(也就是说 minicss extract 这个插件内部帮我们做了 style-loader 的事情)</p><p>这里需要注意几个 hash 值所表达的意思</p><ol><li>hash: hash 和整个项目的配置有关，只要项目中有代码改变，那么所有打包出来的 hash 值都会变，并且所有文件共用一个 hash 值</li><li>chunkhash: chunkhash 和 hash 不同点在于，它根据入口文件进行依赖文件解析，然后构建对应的 hash 值，也就是每个打包出来的文件 hash 值都是不一样的，每次修改代码时候，他会根据依赖关系自动修改相关模块的 hash 值，但是打包出来对应的 js 和 css 文件的 hash 会相同。</li><li>contenthash: 在打包代码的时候，一般会将 css 文件分离出来，然后我们通常会在组件中引入 css 文件，这时候如果使用的是 chunkhash，在只修改组件 js 代码的情况下因为对应的 css 文件的 hash 值相同，打包出来的 css 文件的 hash 值也会跟着变，这时候就可以使用 contenthash了，他会针对每个文件的内容来计算 hash 值</li></ol><h4 id="将-config-json-拷贝到-dist-目录"><a href="#将-config-json-拷贝到-dist-目录" class="headerlink" title="将 config.json 拷贝到 dist 目录"></a>将 config.json 拷贝到 dist 目录</h4><p>这个很简单，只需要装一个插件 <code>copy-webpack-plugin</code></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yarn add -D copy-webpack-plugin</span><br></pre></td></tr></table></figure><p>然后在 <code>config/pluginsConfig.js</code> 中配置这个插件</p><p><img src="./8.png" alt></p><h4 id="支持在代码中使用环境变量"><a href="#支持在代码中使用环境变量" class="headerlink" title="支持在代码中使用环境变量"></a>支持在代码中使用环境变量</h4><p>可以使用 <code>dotenv-webpack</code> 这个插件</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yarn add -D dotenv-webpack</span><br></pre></td></tr></table></figure><p>然后在 <code>config/pluginsConfig.js</code> 中引入这个插件</p><p><img src="./9.png" alt></p><p><code>path</code> 属性表示引入的是哪个文件</p><h4 id="支持-px-向-vw-的单位转换"><a href="#支持-px-向-vw-的单位转换" class="headerlink" title="支持 px 向 vw 的单位转换"></a>支持 px 向 vw 的单位转换</h4><p>这个配置是直接从 xp 的项目拷贝过来的，即 <code>postcss.config.js</code></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  plugins: &#123;</span><br><span class="line">    autoprefixer: &#123;&#125;,</span><br><span class="line">    <span class="string">'postcss-px-to-viewport'</span>: &#123;</span><br><span class="line">      viewportWidth: <span class="string">'375'</span>, <span class="comment">// 视窗的宽度，对应的是我们设计稿的宽度，一般是750</span></span><br><span class="line">      unitPrecision: <span class="number">3</span>, <span class="comment">// 指定`px`转换为视窗单位值的小数位数（很多时候无法整除）</span></span><br><span class="line">      viewportUnit: <span class="string">'vw'</span>, <span class="comment">// 指定需要转换成的视窗单位，建议使用vw</span></span><br><span class="line">      <span class="comment">// propList: ['*', '!background-image'],</span></span><br><span class="line">      selectorBlackList: [</span><br><span class="line">        <span class="comment">// 指定不转换为视窗单位的类，可以自定义，可以无限添加,建议定义一至两个通用的类名</span></span><br><span class="line">        <span class="string">'ignore'</span>,</span><br><span class="line">      ],</span><br><span class="line">      minPixelValue: <span class="number">1</span>, <span class="comment">// 小于或等于`1px`不转换为视窗单位</span></span><br><span class="line">      mediaQuery: <span class="literal">false</span>, <span class="comment">// 允许在媒体查询中转换`px`</span></span><br><span class="line">      <span class="comment">// exclude: /(\/|\\)(node_modules)(\/|\\)/</span></span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这里需要安装两个东西</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yarn add -D postcss-loader postcss-px-to-viewport</span><br></pre></td></tr></table></figure><p>因为是对 css 做一个预处理，所以应该是在 sass-loader 转换为 css 之后应该执行这个 loader，所以直接在 sass-loader 后添加这个 loader 即可</p><p><img src="./10.png" alt></p><h4 id="提交自动检查-commit"><a href="#提交自动检查-commit" class="headerlink" title="提交自动检查 commit"></a>提交自动检查 commit</h4><p>在 <code>pre-commit</code> 之前要能够自动检查代码以及 commit，首先需要安装 husky</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yarn add -D husky</span><br></pre></td></tr></table></figure><p>然后在 <code>package.json</code> 中做配置</p><p><img src="./11.png" alt></p><p>要规范 commit 提交，就必须安装如下的库</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yarn add -D @commitlint/cli @commitlint/config-conventional</span><br></pre></td></tr></table></figure><p>然后新建一个 <code>commitlint.config.js</code>，自定义 commit 提交规则</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// commitlint.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  extends: [<span class="string">'@commitlint/config-conventional'</span>],</span><br><span class="line">  rules: &#123;</span><br><span class="line">    <span class="string">'type-enum'</span>: [</span><br><span class="line">      <span class="number">2</span>,</span><br><span class="line">      <span class="string">'always'</span>,</span><br><span class="line">      [</span><br><span class="line">        <span class="string">'chore'</span>,</span><br><span class="line">        <span class="string">'feat'</span>,</span><br><span class="line">        <span class="string">'fix'</span>,</span><br><span class="line">        <span class="string">'test'</span>,</span><br><span class="line">        <span class="string">'perf'</span>,</span><br><span class="line">        <span class="string">'style'</span>,</span><br><span class="line">        <span class="string">'merge'</span>,</span><br><span class="line">        <span class="string">'config'</span>,</span><br><span class="line">        <span class="string">'improvement'</span>,</span><br><span class="line">      ],</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样每次提交时都会先检查代码，然后再检查提交，提交的规则可以<a href="https://github.com/conventional-changelog/commitlint" target="_blank" rel="noopener">参考</a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上基本就是搭建模板中踩过的坑以及一系列的搭建步骤了，总的来说，还是手撸一遍项目比较香，不仅比当初的 cra eject 项目简单，而且也更利于后续人员的优化和配置</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;注意：为了方便统一，本文中出现的安装包依赖的方式均使用 &lt;code&gt;yarn&lt;/code&gt; 来安装&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="web前端" scheme="https://strugglebak.github.io/categories/web%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="webpack" scheme="https://strugglebak.github.io/tags/webpack/"/>
    
      <category term="react" scheme="https://strugglebak.github.io/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>从Promise本质开始(三):TDD方式实现基于Promises/A+规范的复杂Promise</title>
    <link href="https://strugglebak.github.io/2020/05/28/%E4%BB%8EPromise%E6%9C%AC%E8%B4%A8%E5%BC%80%E5%A7%8B-%E4%B8%89-TDD%E6%96%B9%E5%BC%8F%E5%AE%9E%E7%8E%B0%E5%9F%BA%E4%BA%8EPromises-A-%E8%A7%84%E8%8C%83%E7%9A%84%E5%A4%8D%E6%9D%82Promise/"/>
    <id>https://strugglebak.github.io/2020/05/28/从Promise本质开始-三-TDD方式实现基于Promises-A-规范的复杂Promise/</id>
    <published>2020-05-28T00:20:30.000Z</published>
    <updated>2022-06-04T08:13:29.222Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>前情提要：之前<a href="https://strugglebak.github.io/2020/03/09/%E4%BB%8EPromise%E6%9C%AC%E8%B4%A8%E5%BC%80%E5%A7%8B-%E4%B8%80-%E5%AE%9E%E7%8E%B0Promise%E5%89%8D%E8%A8%80/">为手动实现 Promise 搭建了环境</a>，然后还<a href="https://strugglebak.github.io/2020/03/20/%E4%BB%8EPromise%E6%9C%AC%E8%B4%A8%E5%BC%80%E5%A7%8B-%E4%BA%8C-TDD%E6%96%B9%E5%BC%8F%E5%AE%9E%E7%8E%B0%E5%9F%BA%E4%BA%8EPromises-A-%E8%A7%84%E8%8C%83%E7%9A%84%E7%AE%80%E6%98%93Promise/">基于 Promises/A+ 规范实现了一个简单的 Promise</a>。这次本文就接着上面的补充，实现一个复杂的 Promise。</p></blockquote><a id="more"></a><p><a href="https://github.com/strugglebak/promise-complex" target="_blank" rel="noopener">项目链接</a></p><h2 id="2-2-7"><a href="#2-2-7" class="headerlink" title="2.2.7"></a>2.2.7</h2><blockquote><p>2.2.7 then must return a promise</p></blockquote><blockquote><p>2.2.7 promise2 = promise1.then(onFulfilled, onRejected);</p></blockquote><p>这里就是 <code>Promise.then</code> 必须返回一个 Promise</p><h3 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">it(<span class="string">'2.2.7 then必须返回一个promise'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    resolve()</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">const</span> promise2 = promise.then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;)</span><br><span class="line">  <span class="comment">// 断言 promise2 是一个 Promise</span></span><br><span class="line">  assert(promise2 <span class="keyword">instanceof</span> <span class="built_in">Promise</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PromiseComplex</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  then(succeed?, fail?) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 将函数 push 进 callbacks 中</span></span><br><span class="line">    <span class="keyword">this</span>.callbacks.push(handle)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> PromiseComplex(<span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> PromiseComplex</span><br></pre></td></tr></table></figure><p>这里需要做的操作就是 <code>then</code> 函数中需要返回一个 <code>Promise</code> 即可，注意这里的 <code>Promise</code> 是自己的写的 <code>PromiseComplex</code></p><h2 id="2-2-7-1"><a href="#2-2-7-1" class="headerlink" title="2.2.7.1"></a>2.2.7.1</h2><blockquote><p>2.2.7.1 If either <code>onFulfilled</code> or <code>onRejected</code> returns a value <code>x</code>, run the Promise Resolution Procedure <code>[[Resolve]](promise2, x)</code></p></blockquote><p>Promises/A+ 规范的 <strong>2.2.7.1</strong> 里面这句话什么意思？就是说，<strong>如果 <code>onFulfilled</code> 或者 <code>onRejected</code> 函数返回了一个 x 的值， 那么就运行 Promise 的 Resolution 步骤，即运行 <code>[[Resolve]](promise2, x)</code></strong></p><p>云里雾里的，其实这句话的意思就是，在 <code>promise</code> 内部执行 <code>resolve</code> 或者 <code>reject</code> 函数时，会调用一个成功或者失败的函数，这个函数会返回一个值叫 <code>x</code>，然后再把这个值 <code>x</code> 跟一个新的 <code>promise</code> 传给一个叫做 <code>Resolve</code> 的函数。这个叫做 <code>Resolve</code> 的函数干了什么事情呢，它会将这个值 <code>x</code> 变成 <code>then</code> 里面传的回调的参数。这么说可能不太直观，接着看下面的测试用例应该会明白一些。</p><h3 id="测试用例-1"><a href="#测试用例-1" class="headerlink" title="测试用例"></a>测试用例</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">it(<span class="string">`2.2.7.1 如果 then(success, fail) 中的 success 返回一个值 x,</span></span><br><span class="line"><span class="string">  运行 Promise Resolution Procedure [[Resolve]](promise2, x)`</span>, done =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    resolve()</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// 注意这里的返回值 x 为 '123'，在 then 的回调传的参数 result 中可以获取到</span></span><br><span class="line">  promise.then(<span class="function"><span class="params">()</span> =&gt;</span> <span class="string">'123'</span>).then(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">    assert.equal(result, <span class="string">'123'</span>)</span><br><span class="line">    done()</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">it(<span class="string">`2.2.7.1.2 x 是一个 promise 实例`</span>, done =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    resolve()</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">const</span> fn = sinon.fake()</span><br><span class="line">  promise</span><br><span class="line">    .then(<span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> resolve()))</span><br><span class="line">    .then(fn)</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    assert.isTrue(fn.called)</span><br><span class="line">    done()</span><br><span class="line">  &#125;, <span class="number">10</span>) <span class="comment">// 这里有个小 bug, 如果将延时时间改为 0 则不通过</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">it(<span class="string">`2.2.7.1.2 x 是一个 promise 实例, 测试第一个 then 的失败回调`</span>, done =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    resolve()</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">const</span> fn = sinon.fake()</span><br><span class="line">  promise</span><br><span class="line">    .then(<span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> reject()))</span><br><span class="line">    .then(<span class="literal">null</span>, fn)</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    assert.isTrue(fn.called)</span><br><span class="line">    done()</span><br><span class="line">  &#125;, <span class="number">0</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">it(<span class="string">`2.2.7.1.2 fail 的返回值是一个 promise 实例`</span>, done =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    reject()</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">const</span> fn = sinon.fake()</span><br><span class="line">  promise</span><br><span class="line">    .then(<span class="literal">null</span>, () =&gt; <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> resolve()))</span><br><span class="line">    .then(fn)</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 这里主要看 promise.then 里的 Promise</span></span><br><span class="line">    <span class="comment">// 如果是成功则调用 succeed 函数</span></span><br><span class="line">    <span class="comment">// 如果是失败则调用 fail 函数</span></span><br><span class="line">    assert(fn.called)</span><br><span class="line">    done()</span><br><span class="line">  &#125;, <span class="number">0</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">it(<span class="string">`2.2.7.1.2 fail 的返回值是一个 promise 实例, 且失败了`</span>, done =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    reject()</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">const</span> fn = sinon.fake()</span><br><span class="line">  promise</span><br><span class="line">    .then(<span class="literal">null</span>, () =&gt; <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> reject()))</span><br><span class="line">    .then(<span class="literal">null</span>, fn)</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    assert(fn.called)</span><br><span class="line">    done()</span><br><span class="line">  &#125;, <span class="number">0</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="源码-1"><a href="#源码-1" class="headerlink" title="源码"></a>源码</h3><p>那么测试用例有了，源码应该怎么考虑呢？答案很简单，跟着规范来写。首先我们这里因为是用类写的，所以我们可以使用 <code>Promise.Resovle(x)</code> 的方式来表达 <strong>2.2.7.1</strong> 规范中出现的调用方式。这里可以将 <code>Resolve</code> 这个函数的名字改动下，我们叫它 <code>resolveWith</code> 吧，然后在源码中定义 <code>resolveWith</code></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PromiseComplex</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  resolveWith(x) &#123;</span><br><span class="line">    <span class="comment">//TODO</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为定义调用 <code>resolveWith</code> 的方式是通过 <code>Promise.resolveWith</code> 的方式调用的，而这个 <code>Promise</code> 根据规范是一个 <code>promise2</code>，也就意味着这是一个新的 <code>Promise</code>，还记得之前源码中的 <code>then</code> 中的 <code>return new PromiseComplex(() =&gt; {})</code> 么，现在我们这么做</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PromiseComplex</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  then(succeed?, fail?) &#123;</span><br><span class="line">    <span class="keyword">const</span> handle = []</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> succeed === <span class="string">'function'</span>) &#123;</span><br><span class="line">      handle[<span class="number">0</span>] = succeed</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> fail === <span class="string">'function'</span>) &#123;</span><br><span class="line">      handle[<span class="number">1</span>] = fail</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将下一个 promise 放入 handle[2] 中</span></span><br><span class="line">    handle[<span class="number">2</span>] = <span class="keyword">new</span> PromiseComplex(<span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;)</span><br><span class="line">    <span class="comment">// 将函数 push 进 callbacks 中</span></span><br><span class="line">    <span class="keyword">this</span>.callbacks.push(handle)</span><br><span class="line">    <span class="keyword">return</span> handle[<span class="number">2</span>]</span><br><span class="line">  &#125;</span><br><span class="line">  resolveWith(x) &#123;</span><br><span class="line">    <span class="comment">//TODO</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里将这个新的 <code>Promise</code> 存在 <code>handle</code> 这个数组的第三个元素中，然后再返回就好。接下来就需要对 <code>resolve</code> 以及 <code>reject</code> 中改写下逻辑了</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PromiseComplex</span> </span>&#123;</span><br><span class="line">  resolve(result) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 遍历 callbacks, 调用所有的 handle</span></span><br><span class="line">    <span class="keyword">this</span>.callbacks.forEach(<span class="function"><span class="params">handle</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> succeed = handle[<span class="number">0</span>]</span><br><span class="line">      <span class="comment">// 注意这里拿到了规范中定义的 promise2</span></span><br><span class="line">      <span class="keyword">const</span> nextPromise = handle[<span class="number">2</span>]</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> succeed === <span class="string">'function'</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> x = succeed.call(<span class="literal">undefined</span>, result)</span><br><span class="line">        <span class="comment">// 2.2.7.1 如果onFulfilled或onRejected返回一个值x,</span></span><br><span class="line">        <span class="comment">// 运行 Promise Resolution Procedure [[Resolve]](promise2, x)</span></span><br><span class="line">        <span class="comment">// promise2 表示第二个 promise</span></span><br><span class="line">        nextPromise.resolveWith(x)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  reject(reason) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 遍历 callbacks, 调用所有的 handle</span></span><br><span class="line">    <span class="keyword">this</span>.callbacks.forEach(<span class="function"><span class="params">handle</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> fail = handle[<span class="number">1</span>]</span><br><span class="line">      <span class="keyword">const</span> nextPromise = handle[<span class="number">2</span>]</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> fail === <span class="string">'function'</span>) &#123;</span><br><span class="line">        <span class="comment">// 这里 reject 的逻辑也是一样的</span></span><br><span class="line">        <span class="keyword">const</span> x = fail.call(<span class="literal">undefined</span>, reason)</span><br><span class="line">        nextPromise.resolveWith(x)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来就是 <strong>重头戏</strong> 了，因为要实现这一条规范，或者说通过上面的测试用例，还需要结合 <strong>规范 2.3.x</strong> 来看，因为 2.3.x 的规范是教你怎么写上面说到的 <code>resolveWith</code> 函数的</p><h3 id="resolveWith"><a href="#resolveWith" class="headerlink" title="resolveWith"></a>resolveWith</h3><p>为了实现 <code>resolveWith</code>,必须遵循以下步骤(规范)</p><h4 id="2-3-1"><a href="#2-3-1" class="headerlink" title="2.3.1"></a>2.3.1</h4><blockquote><p>If promise and x refer to the same object, reject promise with a TypeError as the reason</p></blockquote><p><strong>如果 promise 和值 x 引用的是同一个对象，则用 TypeError 作为 reason 拒绝（reject）promise</strong>，因为之前 <code>resolveWith</code> 函数是通过 <code>nextPromise.resolveWith(x)</code> 这种方式调用的，所以这里规范说的 <strong>promise</strong> 就是指这个代码中的 <code>nextPromise</code>，而在 <code>resolveWith</code> 函数中，<code>nextPromise</code> 就是 <code>this</code>。即为了实现 2.3.1 规范， <code>resolveWith</code> 函数应该这么写</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">resolveWith(x) &#123;</span><br><span class="line">  <span class="keyword">if</span> (x === <span class="keyword">this</span>) &#123;</span><br><span class="line">    <span class="comment">// 2.3.1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.reject(<span class="keyword">new</span> <span class="built_in">TypeError</span>())</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-3-2"><a href="#2-3-2" class="headerlink" title="2.3.2"></a>2.3.2</h4><p>如果 x 是一个 promise，采取它的状态</p><blockquote><p>2.3.2.1 If x is pending, promise must remain pending until x is fulfilled or rejected.<br>2.3.2.2 If/when x is fulfilled, fulfill promise with the same value.<br>2.3.2.3 If/when x is rejected, reject promise with the same reason.</p></blockquote><p>上面的规范，说白了就是，<strong>如果 x 是一个 promise，就采取 promise 的状态</strong>，所以就在 <code>resolveWith</code> 函数中加判断条件</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">resolveWith(x) &#123;</span><br><span class="line">  <span class="keyword">if</span> (x === <span class="keyword">this</span>) &#123;</span><br><span class="line">    <span class="comment">// 2.3.1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.reject(<span class="keyword">new</span> <span class="built_in">TypeError</span>())</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (x <span class="keyword">instanceof</span> PromiseComplex) &#123;</span><br><span class="line">    <span class="comment">// 2.3.2</span></span><br><span class="line">    x.then(</span><br><span class="line">      result =&gt; <span class="keyword">this</span>.resolve(result),</span><br><span class="line">      reason =&gt; <span class="keyword">this</span>.reject(reason)</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-3-3"><a href="#2-3-3" class="headerlink" title="2.3.3"></a>2.3.3</h4><p>否则，如果 x 是一个对象或者函数</p><blockquote><p>2.3.3.1 Let <code>then</code> be <code>x.then</code>.</p></blockquote><p>这句话的意思就是代码，即声明一个 <code>then</code> 变量，将 <code>x.then</code> 赋值给这个变量</p><blockquote><p>2.3.3.2 If retrieving the property <code>x.then</code> results in a thrown exception <code>e</code>, reject <code>promise</code> with <code>e</code> as the reason.</p></blockquote><p>如果 <code>x.then</code> 抛出一个异常，则使用 <code>e</code> 作为 reason 并 reject 这个 promise</p><blockquote><p>2.3.3.3 If <code>then</code> is a function, call it with <code>x</code> as <code>this</code>, first argument <code>resolvePromise</code>, and second argument <code>rejectPromise</code>, where:</p></blockquote><p>如果 <code>then</code> 是一个方法，把 <code>x</code> 当作 <code>this</code> 来调用它， 第一个参数为 <code>resolvePromise</code>，第二个参数为 <code>rejectPromise</code></p><blockquote><p>2.3.3.3.1 If/when <code>resolvePromise</code> is called with a value <code>y</code>, run <code>[[Resolve]](promise, y)</code>.</p></blockquote><p>如果 <code>resolvePromise</code> 调用时传了参数 <code>y</code>，则执行 <code>resolveWith(y)</code></p><blockquote><p>2.3.3.3.2 If/when <code>rejectPromise</code> is called with a reason <code>r</code>, reject <code>promise</code> with <code>r</code></p></blockquote><p>如果 <code>rejectPromise</code> 调用时传了参数 <code>r</code>，则执行 <code>resolveWith(r)</code>(这里也可以直接调用 <code>this.reject(r)</code> 函数，为了程序的统一性，这边改动成了 <code>resolveWith(r)</code>)</p><blockquote><p>2.3.3.3.3 If both <code>resolvePromise</code> and <code>rejectPromise</code> are called, or multiple calls to the same argument are made, the first call takes precedence, and any further calls are ignored</p></blockquote><p>如果 <code>resolvePromise</code> 和 <code>rejectPromise</code> 都被调用了，或者对同一个参数进行多次调用，则以第一次调用为优先级最高，其他未来的调用会被忽略掉。这里解释下这个情况，就是比方说如下的代码，可以说明 2.3.3.3.3 中所说的例子</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> PromiseComplex(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> resolve(&#123;</span><br><span class="line">  then: <span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">'123'</span>)</span><br><span class="line">    reject(<span class="string">'456'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;))</span><br><span class="line"></span><br><span class="line">promise.then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(res)) <span class="comment">// '123'</span></span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> PromiseComplex(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> resolve(&#123;</span><br><span class="line">  then: <span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">'123'</span>)</span><br><span class="line">    resolve(<span class="string">'456'</span>)</span><br><span class="line">    resolve(<span class="string">'789'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;))</span><br><span class="line"></span><br><span class="line">promise.then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(res)) <span class="comment">// '123'</span></span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> PromiseComplex(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  PromiseComplex.resolve(<span class="string">'123'</span>).then(<span class="function"><span class="params">result</span> =&gt;</span> resolve(result))</span><br><span class="line">  PromiseComplex.resolve(<span class="string">'456'</span>).then(<span class="function"><span class="params">result</span> =&gt;</span> resolve(result))</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">promise.then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(res)) <span class="comment">// '123'</span></span><br></pre></td></tr></table></figure><p>上面的代码，多次进行了 <code>resolve</code> 的操作，但是只取第一次的，所以最终打印出来的就是 <code>&#39;123&#39;</code>。由于该功能已经在<a href="https://strugglebak.github.io/2020/03/20/%E4%BB%8EPromise%E6%9C%AC%E8%B4%A8%E5%BC%80%E5%A7%8B-%E4%BA%8C-TDD%E6%96%B9%E5%BC%8F%E5%AE%9E%E7%8E%B0%E5%9F%BA%E4%BA%8EPromises-A-%E8%A7%84%E8%8C%83%E7%9A%84%E7%AE%80%E6%98%93Promise/">上一篇</a>博客文章中解决，所以这里的规则可以自动忽略掉</p><blockquote><p>2.3.3.3.4 if calling <code>then</code> throws an exception <code>e</code><br>2.3.3.3.4.1 If <code>resolvePromise</code> or <code>rejectPromise</code> have been called, ignore it.<br>2.3.3.3.4.2 Otherwise, reject <code>promise</code> with <code>e</code> as the reason.</p></blockquote><p>如果调用 <code>then</code> 的时候抛出异常了</p><ul><li>如果 <code>resolvePromise</code> 和 <code>rejectPromise</code> 的都被调用了，就忽略它</li><li>否则，reject 掉这个 <code>promise</code></li></ul><blockquote><p>2.3.3.4 If <code>then</code> is not a function, fulfill <code>promise</code> with <code>x</code>.</p></blockquote><p>如果 <code>then</code> 不是一个函数，则 resolve 掉这个 <code>promise</code></p><p>根据以上的描述，<code>resolveWith</code> 中的代码可以增加为</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">resolveWith(x) &#123;</span><br><span class="line">  <span class="keyword">if</span> (x === <span class="keyword">this</span>) &#123;</span><br><span class="line">    <span class="comment">// 2.3.1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.reject(<span class="keyword">new</span> <span class="built_in">TypeError</span>())</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (x <span class="keyword">instanceof</span> PromiseComplex) &#123;</span><br><span class="line">    <span class="comment">// 2.3.2</span></span><br><span class="line">    x.then(</span><br><span class="line">      result =&gt; <span class="keyword">this</span>.resolve(result),</span><br><span class="line">      reason =&gt; <span class="keyword">this</span>.reject(reason)</span><br><span class="line">    )</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (x <span class="keyword">instanceof</span> <span class="built_in">Object</span>) &#123;</span><br><span class="line">    <span class="comment">// 2.3.3 另外，如果 x 是个对象或者方法</span></span><br><span class="line">    <span class="keyword">let</span> then</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 2.3.3.1</span></span><br><span class="line">      then = x.then</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      <span class="comment">// 2.3.3.2 如果取回的 x.then 属性的结果为一个异常 e,用 e 作为原因 reject promise</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.reject(e)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2.3.3.3 如果 then 是一个方法，把 x 当作 this 来调用它， 第一个参数为 resolvePromise，第二个参数为 rejectPromise</span></span><br><span class="line">    <span class="keyword">if</span> (then <span class="keyword">instanceof</span> <span class="built_in">Function</span>) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 2.3.3.3.1/2.3.3.3.2/2.3.3.3.3</span></span><br><span class="line">        then.call(x, y =&gt; <span class="keyword">this</span>.resolveWith(y), r =&gt; <span class="keyword">this</span>.resolveWith(r))</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="comment">// 2.3.3.3.4</span></span><br><span class="line">        <span class="keyword">this</span>.reject(e)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 2.3.3.4 如果 then 不是一个函数，用 x 完成 (fulfill) promise</span></span><br><span class="line">      <span class="keyword">this</span>.resolve(x)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-2-7-2"><a href="#2-2-7-2" class="headerlink" title="2.2.7.2"></a>2.2.7.2</h2><blockquote><p>2.2.7.2 If either <code>onFulfilled</code> or <code>onRejected</code> throws an exception <code>e</code>, <code>promise2</code> must be rejected with <code>e</code> as the reason.</p></blockquote><p>如果在调用 <code>resolve</code> 或者 <code>reject</code> 时抛出了异常，则 <code>nextPromise</code> 必须调用 <code>reject</code>，并将这个 <code>e</code> 作为参数传入</p><h3 id="测试用例-2"><a href="#测试用例-2" class="headerlink" title="测试用例"></a>测试用例</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">it(<span class="string">'2.2.7.2 如果 success 或 fail 抛出一个异常 e, promise2 必须被拒绝'</span>, done =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    resolve()</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">const</span> error = <span class="keyword">new</span> <span class="built_in">Error</span>()</span><br><span class="line">  <span class="keyword">const</span> fn = sinon.fake()</span><br><span class="line">  promise</span><br><span class="line">    .then(<span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="keyword">throw</span> error &#125;)</span><br><span class="line">    .then(<span class="literal">null</span>, fn)</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    assert(fn.called)</span><br><span class="line">    assert(fn.calledWith(error))</span><br><span class="line">    done()</span><br><span class="line">  &#125;, <span class="number">0</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="源码-2"><a href="#源码-2" class="headerlink" title="源码"></a>源码</h3><p>由规范的定义可知，这里就需要在 <code>resolve</code> 以及 <code>reject</code> 函数中，在调用成功或者失败函数时，需要加个 <code>try catch</code>，因为在调用这些函数的时候，有可能会失败</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PromiseComplex</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  resolve(result) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> succeed === <span class="string">'function'</span>) &#123;</span><br><span class="line">      <span class="comment">// 这里调用的时候有可能报错</span></span><br><span class="line">      <span class="keyword">let</span> x</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        x = succeed.call(<span class="literal">undefined</span>, result)</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="comment">// 2.2.7.2 如果onFulfilled或onRejected抛出一个异常e</span></span><br><span class="line">        <span class="comment">// promise2 必须被拒绝（rejected）并把e当作原因</span></span><br><span class="line">        <span class="keyword">return</span> nextPromise.reject(e)</span><br><span class="line">      &#125;</span><br><span class="line">      nextPromise.resolveWith(x)</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">  &#125;,</span><br><span class="line">  reject(reason) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> fail === <span class="string">'function'</span>) &#123;</span><br><span class="line">      <span class="keyword">let</span> x</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        x = fail.call(<span class="literal">undefined</span>, reason)</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="keyword">return</span> nextPromise.reject(e)</span><br><span class="line">      &#125;</span><br><span class="line">      nextPromise.resolveWith(x)</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="API-实现"><a href="#API-实现" class="headerlink" title="API 实现"></a>API 实现</h2><p>以上，基本就是实现了一个复杂的符合 Promises/A+ 规范的 Promise 了，接下来就是实现该 Promise 的其他 API 的工作了</p><h3 id="resolve-reject"><a href="#resolve-reject" class="headerlink" title="resolve/reject"></a>resolve/reject</h3><p>真正的 Promise 中是能直接访问到这个方法的，而我们这里实现的 <code>PromiseComplex</code> 是一个类，如果要能访问到这个方法，则必须在方法上加上 <code>static</code> 属性</p><h4 id="测试用例-3"><a href="#测试用例-3" class="headerlink" title="测试用例"></a>测试用例</h4><p>这里另起一个 <code>describe</code>，专门用来测试该 <code>Promise</code> 的 API 用。之后的各种 API 相关的测试用例都在这个里面写</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">describe(<span class="string">'Promise API'</span>, () =&gt; &#123;</span><br><span class="line">  it(<span class="string">'测试 resolve'</span>, done =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> promise = <span class="built_in">Promise</span>.resolve2(<span class="number">123</span>)</span><br><span class="line">    assert(promise <span class="keyword">instanceof</span> <span class="built_in">Promise</span>)</span><br><span class="line">    promise.then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">      assert(result === <span class="number">123</span>)</span><br><span class="line">      done()</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">const</span> promise2 = <span class="built_in">Promise</span>.resolve2(<span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;))</span><br><span class="line">    assert(promise2 <span class="keyword">instanceof</span> <span class="built_in">Promise</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  it(<span class="string">'测试 resolve thenable'</span>, done =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> promise2 = <span class="built_in">Promise</span>.resolve2(&#123;</span><br><span class="line">      then(resolve, reject) &#123; resolve(<span class="string">'233'</span>) &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    assert(promise2 <span class="keyword">instanceof</span> <span class="built_in">Promise</span>)</span><br><span class="line">    promise2.then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">      assert(result === <span class="string">'233'</span>)</span><br><span class="line">      done()</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">  it(<span class="string">'测试 reject'</span>, done =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> promise = <span class="built_in">Promise</span>.reject2(<span class="number">123</span>)</span><br><span class="line">    assert(promise <span class="keyword">instanceof</span> <span class="built_in">Promise</span>)</span><br><span class="line">    promise.then(<span class="literal">null</span>, result =&gt; &#123;</span><br><span class="line">      assert(result === <span class="number">123</span>)</span><br><span class="line">      done()</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// reject thenable</span></span><br><span class="line">    <span class="keyword">const</span> promise2 = <span class="built_in">Promise</span>.reject2(&#123;</span><br><span class="line">      then(resolve, reject) &#123; reject(<span class="string">'233'</span>) &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    assert(promise2 <span class="keyword">instanceof</span> <span class="built_in">Promise</span>)</span><br><span class="line">    promise2.then(<span class="literal">null</span>, result =&gt; &#123;</span><br><span class="line">      assert(result === <span class="string">'233'</span>)</span><br><span class="line">      done()</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="源码-3"><a href="#源码-3" class="headerlink" title="源码"></a>源码</h4><blockquote><p>简便起见，这里直接使用 <code>resolve2</code> 和 <code>reject2</code> 来命名这两个方法</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PromiseComplex</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">static</span> resolve2(result) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> PromiseComplex(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (result &amp;&amp; result.then &amp;&amp; <span class="keyword">typeof</span> result.then === <span class="string">'function'</span>) &#123;</span><br><span class="line">        result.then(resolve, reject)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        resolve(result)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> reject2(reason) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> PromiseComplex(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      reject(reason)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，基本上就是调用了类里面的逻辑，new 一个 Promise，然后调用里面的 <code>resolve</code> 或者 <code>reject</code> 方法。但是对于 <code>resolve</code> 来说，如果 result 中有 then，并且这个 then 是一个函数，则需要继续调用这个 <code>result.then</code></p><h3 id="catch"><a href="#catch" class="headerlink" title="catch"></a>catch</h3><p>用来捕获 Promise reject 的错误用的，这里实现的逻辑也很简单</p><h4 id="测试用例-4"><a href="#测试用例-4" class="headerlink" title="测试用例"></a>测试用例</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">it(<span class="string">'测试 catch'</span>, done =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    resolve()</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">const</span> fn = sinon.fake()</span><br><span class="line">  promise</span><br><span class="line">    .then(<span class="function"><span class="params">result</span> =&gt;</span> &#123; <span class="keyword">throw</span> <span class="string">'233'</span> &#125;)</span><br><span class="line">    .catch(<span class="function">(<span class="params">e</span>) =&gt;</span> &#123; assert(e === <span class="string">'233'</span>) &#125;)</span><br><span class="line">    .then(fn)</span><br><span class="line"></span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    assert(fn.called)</span><br><span class="line">    done()</span><br><span class="line">  &#125;, <span class="number">0</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="源码-4"><a href="#源码-4" class="headerlink" title="源码"></a>源码</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PromiseComplex</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">catch</span>(reject) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.then(<span class="literal">null</span>, reject)</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意这里 <code>catch</code> 的参数 <code>reject</code> 是一个失败函数</p><h3 id="finally"><a href="#finally" class="headerlink" title="finally"></a>finally</h3><p>测试 <code>finally</code> 这个 API 的关键就是看 <code>finally</code> 中传的函数有没有得到执行，所以测试用例可以写成下面这样</p><h4 id="测试用例-5"><a href="#测试用例-5" class="headerlink" title="测试用例"></a>测试用例</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">it(<span class="string">'测试 finally'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    resolve()</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">const</span> callbacks = [sinon.fake(), sinon.fake(), sinon.fake()]</span><br><span class="line">  promise</span><br><span class="line">    .then(<span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="keyword">throw</span> <span class="string">'error'</span> &#125;)</span><br><span class="line">    .catch(callbacks[<span class="number">0</span>])</span><br><span class="line">    .finally(callbacks[<span class="number">1</span>])</span><br><span class="line">    .then(callbacks[<span class="number">2</span>])</span><br><span class="line"></span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    assert(callbacks[<span class="number">0</span>].called)</span><br><span class="line">    assert(callbacks[<span class="number">1</span>].called) <span class="comment">// 测试被调用</span></span><br><span class="line">    assert(callbacks[<span class="number">2</span>].called)</span><br><span class="line">    assert(callbacks[<span class="number">2</span>].calledAfter(callbacks[<span class="number">1</span>]))</span><br><span class="line">  &#125;, <span class="number">0</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="源码-5"><a href="#源码-5" class="headerlink" title="源码"></a>源码</h4><p>因为无论成功或者失败，都会走到 <code>finally</code> 中，所以 <code>finally</code> 都可以继续 <code>then</code></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PromiseComplex</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">finally</span>(callback) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.then(</span><br><span class="line">      (result) =&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> PromiseComplex.resolve2(callback()).then(<span class="function"><span class="params">()</span> =&gt;</span> result)</span><br><span class="line">      &#125;,</span><br><span class="line">      (error) =&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> PromiseComplex.resolve2(callback()).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;<span class="keyword">throw</span> error&#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有个疑问，为何 <code>finally</code> 不能做如下的实现</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">finally</span>(callback) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.then(</span><br><span class="line">    callback,</span><br><span class="line">    callback</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是因为假如我们想要再其调用失败函数的时候报错，比如需要做一个 <code>throw an error</code> 之类的操作，这个时候你只能通过 <code>Promise.resolve</code> 之类的方式去实现它。而为了能够跟失败函数被调用时代码逻辑一致，所以成功函数也写成跟失败函数类似的逻辑。</p><h3 id="all"><a href="#all" class="headerlink" title="all"></a>all</h3><p>all API 的逻辑看起来简单，就是遍历执行，但是内部是做了一些情况的判断的，不过测试用例还是很简单的，如下</p><h4 id="测试用例-6"><a href="#测试用例-6" class="headerlink" title="测试用例"></a>测试用例</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">it(<span class="string">'测试 all, 等待所有都完成(或第一个失败) '</span>, done =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> promise1 = <span class="built_in">Promise</span>.resolve2(<span class="number">3</span>)</span><br><span class="line">  <span class="keyword">const</span> promise2 = <span class="number">1337</span></span><br><span class="line">  <span class="keyword">const</span> promise3 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">'foo'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">let</span> ret</span><br><span class="line">  <span class="built_in">Promise</span>.all([promise1, promise2, promise3]).then(<span class="function"><span class="params">results</span> =&gt;</span> &#123;</span><br><span class="line">    ret = results</span><br><span class="line">  &#125;)</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    assert(ret[<span class="number">0</span>] === <span class="number">3</span>)</span><br><span class="line">    assert(ret[<span class="number">1</span>] === <span class="number">1337</span>)</span><br><span class="line">    assert(ret[<span class="number">2</span>] === <span class="string">'foo'</span>)</span><br><span class="line">    done()</span><br><span class="line">  &#125;, <span class="number">10</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="源码-6"><a href="#源码-6" class="headerlink" title="源码"></a>源码</h4><p>先说下实现 all API 需要注意的几个点</p><ul><li>如果传入的参数是一个空的可迭代对象，那么此 promise 对象回调完成(resolve), 只有此情况是同步执行的，其它都是异步返回</li><li>promises 中所有的 promise 都“完成”时，或参数中(result)不包含 promise 时回调完成。</li><li>如果传入的参数(promises[i])不包含任何 promise，则返回一个异步完成</li><li>如果参数中有一个 promise 失败，那么 Promise.all 返回的 promise 对象失败</li><li>在任何情况下，Promise.all 返回的 promise 的完成状态的结果都是一个数组</li></ul><p>所以实现的逻辑如下</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PromiseComplex</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">static</span> all(promises) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> PromiseComplex(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> index = <span class="number">0</span></span><br><span class="line">      <span class="comment">// 5. 在任何情况下，Promise.all 返回的 promise 的完成状态的结果都是一个数组</span></span><br><span class="line">      <span class="keyword">let</span> resultArray = []</span><br><span class="line">      <span class="comment">// 1. 如果传入的参数是一个空的可迭代对象，</span></span><br><span class="line">      <span class="comment">// 那么此promise对象回调完成(resolve),</span></span><br><span class="line">      <span class="comment">// 只有此情况，是同步执行的，其它都是异步返回</span></span><br><span class="line">      <span class="keyword">if</span> (promises &amp;&amp; promises.length === <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> resolve(resultArray)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">const</span> processResult = <span class="function">(<span class="params">result, i</span>) =&gt;</span> &#123;</span><br><span class="line">        resultArray[i] = result</span><br><span class="line">        <span class="comment">// 2. promises 中所有的promise都“完成”时</span></span><br><span class="line">        <span class="comment">// 或参数中(result)不包含 promise 时回调完成。</span></span><br><span class="line">        <span class="keyword">if</span> (++index === promises.length) resolve(resultArray)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; promises.length; i++) &#123;</span><br><span class="line">        <span class="comment">// 3. 如果传入的参数(promises[i])不包含任何 promise，则返回一个异步完成</span></span><br><span class="line">        PromiseComplex.resolve2(promises[i])</span><br><span class="line">          .then(</span><br><span class="line">            result =&gt; processResult(result, i),</span><br><span class="line">            <span class="comment">// 4. 如果参数中有一个promise失败，那么Promise.all返回的promise对象失败</span></span><br><span class="line">            reason =&gt; reject(reason)</span><br><span class="line">          )</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="allSettled"><a href="#allSettled" class="headerlink" title="allSettled"></a>allSettled</h3><p>allSettled API 在 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/allSettled" target="_blank" rel="noopener">MDN</a> 的解释如下</p><blockquote><p>The <code>Promise.allSettled()</code> method returns a promise that resolves after all of the given promises have either fulfilled or rejected, with an array of objects that each describes the outcome of each promise.</p></blockquote><p>即</p><blockquote><p><code>Promise.allSettled</code> 方法会返回一个 promise，then 中传的函数的参数就是一个对象数组，这个对象数组描述了每个 promise 的输出情况，这个 promise 能够 resolve 所有给到的 promises，无论这些 promises 是被 fulfilled 了还是被 rejected</p></blockquote><p>比如如下的代码</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise1 = <span class="built_in">Promise</span>.resolve(<span class="number">3</span>);</span><br><span class="line"><span class="keyword">const</span> promise2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> setTimeout(reject, <span class="number">100</span>, <span class="string">'foo'</span>));</span><br><span class="line"><span class="keyword">const</span> promises = [promise1, promise2];</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.allSettled(promises).</span><br><span class="line">  then(<span class="function">(<span class="params">results</span>) =&gt;</span> results.forEach(<span class="function">(<span class="params">result</span>) =&gt;</span> <span class="built_in">console</span>.log(result)));</span><br></pre></td></tr></table></figure><p>输出就是如下</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; Object &#123; status: <span class="string">"fulfilled"</span>, value: 3 &#125;</span><br><span class="line">&gt; Object &#123; status: <span class="string">"rejected"</span>, reason: <span class="string">"foo"</span> &#125;</span><br></pre></td></tr></table></figure><h4 id="测试用例-7"><a href="#测试用例-7" class="headerlink" title="测试用例"></a>测试用例</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">it(<span class="string">'测试 allSettled'</span>, done =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> promise1 = <span class="built_in">Promise</span>.resolve2(<span class="number">3</span>)</span><br><span class="line">  <span class="keyword">const</span> promise2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> reject(<span class="string">'foo'</span>))</span><br><span class="line">  <span class="keyword">const</span> promises = [promise1, promise2]</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> ret</span><br><span class="line">  <span class="built_in">Promise</span>.allSettled(promises).then(<span class="function"><span class="params">results</span> =&gt;</span> &#123;</span><br><span class="line">    ret = results</span><br><span class="line">  &#125;)</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    assert(ret[<span class="number">0</span>].state === <span class="string">'fulfilled'</span> &amp;&amp; ret[<span class="number">0</span>].result === <span class="number">3</span>)</span><br><span class="line">    assert(ret[<span class="number">1</span>].state === <span class="string">'rejected'</span> &amp;&amp; ret[<span class="number">1</span>].reason === <span class="string">'foo'</span>)</span><br><span class="line">    done()</span><br><span class="line">  &#125;, <span class="number">10</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="源码-7"><a href="#源码-7" class="headerlink" title="源码"></a>源码</h4><p>源码的逻辑就是在 <code>all</code> API 的基础上做修改，注意这里返回的状态</p><ul><li>如果成功，那么每个 promise 产出的结果应该是 <code>{ state: &#39;fulfilled&#39;, result: 123 }</code></li><li>如果失败，那么每个 promise 产出的结果应该是 <code>{ state: &#39;rejected&#39;, reason: 456 }</code></li></ul><p>所以应该这么写</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PromiseComplex</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">static</span> allSettled(promises) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> PromiseComplex(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> index = <span class="number">0</span></span><br><span class="line">      <span class="keyword">let</span> resultArray = []</span><br><span class="line">      <span class="keyword">if</span> (promises &amp;&amp; promises.length === <span class="number">0</span>) <span class="keyword">return</span> resolve(resultArray)</span><br><span class="line">      <span class="comment">// 这里的逻辑需要对 state 做个判断</span></span><br><span class="line">      <span class="keyword">const</span> processResult = <span class="function">(<span class="params">result, i, state</span>) =&gt;</span> &#123;</span><br><span class="line">        resultArray[i] = status === <span class="string">'fulfilled'</span></span><br><span class="line">          ? &#123;status, result&#125;</span><br><span class="line">          : &#123;status, <span class="attr">reason</span>: result&#125;</span><br><span class="line">        <span class="keyword">if</span> (++index === promises.length) resolve(resultArray)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; promises.length; i++) &#123;</span><br><span class="line">        PromiseComplex.resolve2(promises[i])</span><br><span class="line">          .then(</span><br><span class="line">            result =&gt; processResult(result, i, <span class="string">'fulfilled'</span>),</span><br><span class="line">            <span class="comment">// 无论成功或者失败，都调用 resolve</span></span><br><span class="line">            reason =&gt; processResult(reason, i, <span class="string">'rejected'</span>)</span><br><span class="line">          )</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>但是这里其实还有一种更加优雅的写法，直接调用 <code>Promise.all</code> 的形式来实现</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> allSettled(promises) &#123;</span><br><span class="line">  <span class="keyword">const</span> x = <span class="function">(<span class="params">promises</span>) =&gt;</span> promises.map(</span><br><span class="line">    promise =&gt; promise.then(</span><br><span class="line">      value =&gt; (&#123;<span class="attr">status</span>: <span class="string">'fulfilled'</span>, value&#125;),</span><br><span class="line">      reason =&gt; (&#123;<span class="attr">status</span>: <span class="string">'rejected'</span>, reason&#125;)</span><br><span class="line">    )</span><br><span class="line">  )</span><br><span class="line">  <span class="keyword">return</span> PromiseComplex.all(x(promises))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里将 promises 做了一个 map，然后它返回的是一个数组 <code>x(promises)</code>，代码就变得更加精简和易读了。你可能会迷惑，这里为啥要用到一个 <code>promise.then</code> 对其做一个值的构建呢？因为我们这里，<code>then</code> 是会返回一个 promise 的，通过使用 <code>.then()</code> 这种方式来修改 promise 中的传值参数才是一种符合 promise 的方式。</p><h3 id="race"><a href="#race" class="headerlink" title="race"></a>race</h3><p>race 在 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/race" target="_blank" rel="noopener">MDN</a> 上的解释如下</p><blockquote><p>The <code>Promise.race()</code> method returns a promise that fulfills or rejects as soon as one of the promises in an iterable fulfills or rejects, with the value or reason from that promise.</p></blockquote><p>即</p><blockquote><p><code>Promise.race()</code> 方法返回一个 promise，一旦其中一个 promise 处于一个可迭代的 fulfills 或者 rejects 中时，那这个对应的 promise 就会 fulfill 一个 value 出来或者 reject 一个 reason 出来</p></blockquote><p>简单来说就是 <strong>竞争</strong>，哪个先执行 resolve 或者 reject，哪个就先导出对应的结果</p><h4 id="测试用例-8"><a href="#测试用例-8" class="headerlink" title="测试用例"></a>测试用例</h4><p>上面可能说的不是很清楚，先看下测试用例吧</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">it(<span class="string">'测试 race'</span>, done =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> promise1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(</span><br><span class="line">    (resolve, reject) =&gt; setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> resolve(<span class="number">200</span>), <span class="number">200</span>)</span><br><span class="line">  )</span><br><span class="line">  <span class="keyword">const</span> promise2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(</span><br><span class="line">    (resolve, reject) =&gt; setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> resolve(<span class="number">10</span>), <span class="number">10</span>)</span><br><span class="line">  )</span><br><span class="line">  <span class="keyword">const</span> promise3 = <span class="keyword">new</span> <span class="built_in">Promise</span>(</span><br><span class="line">    (resolve, reject) =&gt; setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> reject(<span class="number">100</span>), <span class="number">100</span>)</span><br><span class="line">  )</span><br><span class="line">  <span class="keyword">let</span> result, reason</span><br><span class="line">  <span class="built_in">Promise</span>.race([promise1, promise2, promise3])</span><br><span class="line">    .then(</span><br><span class="line">      data =&gt; result = data,</span><br><span class="line">      error =&gt; reason = error</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    assert(result === <span class="number">10</span>)</span><br><span class="line">    done()</span><br><span class="line">  &#125;, <span class="number">500</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>以上的测试用例，由于 promise2 持续的时间最短，那么按照道理来说，promise2 的结果就是最终的结果</p><h4 id="源码-8"><a href="#源码-8" class="headerlink" title="源码"></a>源码</h4><p>race API 源码实现思路也是通过遍历来实现，但是这里是通过调用 <code>Promise.resolve(xxx).then</code> 来实现的。只要其中有一个 <code>resolve</code> 或者 <code>reject</code> 了，那么就<strong>自动</strong>走 <code>then</code> 的逻辑，其他的就忽略掉。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> race(promises) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> PromiseComplex(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (promises &amp;&amp; promises.length === <span class="number">0</span>) <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; promises.length; i++) &#123;</span><br><span class="line">      PromiseComplex.resolve2(promises[i])</span><br><span class="line">      .then(</span><br><span class="line">        <span class="comment">// 谁(promises[i]) 先完成谁先 resolve</span></span><br><span class="line">        result =&gt; resolve(result),</span><br><span class="line">        reason =&gt; reject(reason)</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你可能会疑惑了，为啥这里可以自动走 <code>then</code> 的逻辑呢？这又牵扯到 <strong>微任务宏任务</strong> 的知识了。先说结论，<strong>在 eventLoop 中，一旦执行一个阶段里的一个宏任务(setTimeout, setInterval 和 setImmediate)就立刻执行微任务队列(Node 11 及以上或者浏览器环境中)</strong>，而我们代码中的 <code>resolve</code> 方法(不是 <code>resolve2</code> 方法) 是放在微任务队列中的(下文优化代码部分会说到)。所以它会先执行 <code>PromiseComplex.resolve2(promises[i])</code>(宏任务)，在下一个宏任务(<code>promise2</code> 中的 <code>resolve</code>)到来之前，执行微任务(<code>resolve</code> 中的代码逻辑)，发现状态没有变(<code>state === &#39;pending&#39;</code>)就往下执行，将状态改变，并且将 <code>nextTick</code> 中的代码入<strong>微任务队列</strong>。然后时间到，执行宏任务(<code>promise2</code> 中的 <code>resolve</code>)，然后执行<strong>微任务</strong>(<code>resolve</code> 中的代码逻辑)，发现状态变了(<code>state !== &#39;pending&#39;</code>)，后面的逻辑就不执行了。这个时候因为你已经将 <code>then</code> 中的 <code>callback</code> 当作参数传给了 <code>Promise</code> 内部的变量，所以就可以拿着这些 <code>callbacks</code> 去执行。这样看起来就是 <code>then</code> 中的逻辑被 <em>自动执行</em> 了</p><p>你可能又会疑惑了，为啥这里可以忽略掉其他的 <code>promise</code> 呢？还记得规范 2.3.3.3.3 中说的是啥么(手动滑稽)，以及结合规范 2.2.2 和 2.2.3 来看的话，关键的地方在于，<strong>这个 <code>promise</code> 内部的 <code>state</code> 改变了</strong>，一旦这个 <code>state</code> 被改变了，那么无论后面怎么 <code>resolve</code> 或者 <code>reject</code>，那么都会在判断 <code>state</code> 状态时被 return 掉</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">resolve (result) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.state !== <span class="string">'pending'</span>) <span class="keyword">return</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">reject (reason) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.state !== <span class="string">'pending'</span>) <span class="keyword">return</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="重构-resolve-reject-API"><a href="#重构-resolve-reject-API" class="headerlink" title="重构 resolve/reject API"></a>重构 resolve/reject API</h2><p>在之前的这两个 api 的逻辑中，关于异步的部分只是用了 <code>setTimeout</code> 来解决的，但是这里就会存在一个 bug，在测试用例中，要断言 assert 测试代码的结果，也需要用到 <code>setTimeout</code>，但是这里需要延时一小段时间，不然会和源码中的 <code>setTimeout</code> 有冲突(即如果测试用例中 <code>setTimeout</code> 传的时间是 0 ms，那么有可能这个会优先源码中的 <code>setTimeout</code> 执行)，这是一个 bug 隐患。那么解决方式是什么呢？很简单，将 <code>setTimeout</code> 修改成 <code>process.nextTick</code>(微任务，优先级更高) 即可</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">resolve(result) &#123;</span><br><span class="line">  process.nextTick(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">reject(reason) &#123;</span><br><span class="line">  process.nextTick(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这样又会带来新的问题，如果是浏览器环境就不支持 <code>process.nextTick</code>，所以这里就需要想办法做一个兼容的处理。怎么兼容呢，这里可以参考 <a href="https://juejin.im/post/5d519abce51d453b753a1a9d" target="_blank" rel="noopener">Vue 源码中关于 <code>nextTick</code> 是怎么处理的</a>。这里方便起见就直接上代码了</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 兼容 process.nextTick 和 setImmediate 方案</span></span><br><span class="line"><span class="comment">// 其实就是 vue 里面的 nextTick 方案</span></span><br><span class="line"><span class="comment">// 主要是用 mutationObserver 实现的，这个只要改动下 dom 去更新一个函数</span></span><br><span class="line"><span class="comment">// 而在这个函数里面去做操作即可，这个是比 setTimeout 要快的</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">nextTick</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 兼容处理</span></span><br><span class="line">  <span class="keyword">if</span> (process !== <span class="literal">undefined</span> &amp;&amp; <span class="keyword">typeof</span> process.nextTick === <span class="string">'function'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> process.nextTick(fn)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> counter = <span class="number">1</span></span><br><span class="line">  <span class="keyword">var</span> observer = <span class="keyword">new</span> MutationObserver(fn)</span><br><span class="line">  <span class="keyword">var</span> textNode = <span class="built_in">document</span>.createTextNode(<span class="built_in">String</span>(counter))</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 监听节点变化</span></span><br><span class="line">  observer.observe(textNode, &#123; <span class="attr">characterData</span>: <span class="literal">true</span> &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 修改节点</span></span><br><span class="line">  counter = (counter + <span class="number">1</span>) % <span class="number">2</span></span><br><span class="line">  textNode.data = <span class="built_in">String</span>(counter)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里是通过 <a href="https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver" target="_blank" rel="noopener">MutationObserver</a> 这个 API，通过创建一个 textNode 的节点，然后使用 <code>observer.observe</code> 去 <strong>监听这个节点的变化</strong>，节点一旦变化就会去执行传入的 <code>fn</code> 回调，这样就可以做一个兼容的处理了。</p><p>最后只需要将 <code>resolve/reject</code> API 中的 <code>process.nextTick</code> 改写成 <code>nextTick</code> 函数即可</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上就是实现一个复杂的 <code>Promise</code> 的完整步骤了，<a href="https://github.com/strugglebak/promise-complex" target="_blank" rel="noopener">仓库链接可以点击这里</a>，另外我还在这个项目中对部分代码进行了优化，但总体上的逻辑和本文都是一样的，若有看到源码不一样的同学还请不要惊讶</p><p>本质上来说，这里主要就规范中的 2.2.7 以及 2.3 的部分进行了比较细的描述，如果有问题欢迎各位大佬在项目中提 issue</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;前情提要：之前&lt;a href=&quot;https://strugglebak.github.io/2020/03/09/%E4%BB%8EPromise%E6%9C%AC%E8%B4%A8%E5%BC%80%E5%A7%8B-%E4%B8%80-%E5%AE%9E%E7%8E%B0Promise%E5%89%8D%E8%A8%80/&quot;&gt;为手动实现 Promise 搭建了环境&lt;/a&gt;，然后还&lt;a href=&quot;https://strugglebak.github.io/2020/03/20/%E4%BB%8EPromise%E6%9C%AC%E8%B4%A8%E5%BC%80%E5%A7%8B-%E4%BA%8C-TDD%E6%96%B9%E5%BC%8F%E5%AE%9E%E7%8E%B0%E5%9F%BA%E4%BA%8EPromises-A-%E8%A7%84%E8%8C%83%E7%9A%84%E7%AE%80%E6%98%93Promise/&quot;&gt;基于 Promises/A+ 规范实现了一个简单的 Promise&lt;/a&gt;。这次本文就接着上面的补充，实现一个复杂的 Promise。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="手写源码" scheme="https://strugglebak.github.io/categories/%E6%89%8B%E5%86%99%E6%BA%90%E7%A0%81/"/>
    
    
      <category term="Promise" scheme="https://strugglebak.github.io/tags/Promise/"/>
    
  </entry>
  
  <entry>
    <title>从Promise本质开始(二):TDD方式实现基于Promises/A+规范的简易Promise</title>
    <link href="https://strugglebak.github.io/2020/03/20/%E4%BB%8EPromise%E6%9C%AC%E8%B4%A8%E5%BC%80%E5%A7%8B-%E4%BA%8C-TDD%E6%96%B9%E5%BC%8F%E5%AE%9E%E7%8E%B0%E5%9F%BA%E4%BA%8EPromises-A-%E8%A7%84%E8%8C%83%E7%9A%84%E7%AE%80%E6%98%93Promise/"/>
    <id>https://strugglebak.github.io/2020/03/20/从Promise本质开始-二-TDD方式实现基于Promises-A-规范的简易Promise/</id>
    <published>2020-03-19T16:21:02.000Z</published>
    <updated>2022-06-04T08:13:29.234Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>之前我还讲过 <a href="https://strugglebak.github.io/2020/03/09/%E4%BB%8EPromise%E6%9C%AC%E8%B4%A8%E5%BC%80%E5%A7%8B-%E4%B8%80-%E5%AE%9E%E7%8E%B0Promise%E5%89%8D%E8%A8%80/">如何为实现 Promise 搭建 TDD 环境</a>，而本文的目的主要是探讨如何基于 TDD 这样的方式实现一个 Promise，并且描述了部分 Promises/A+ 规范，以此为基础实现的一个 Promise</p></blockquote><a id="more"></a><p><a href="https://github.com/strugglebak/promise-easy" target="_blank" rel="noopener">项目地址</a></p><h2 id="先实现一个最基础版本的-Promise"><a href="#先实现一个最基础版本的-Promise" class="headerlink" title="先实现一个最基础版本的 Promise"></a>先实现一个最基础版本的 Promise</h2><p>有了之前的准备，现在就可以进行 TDD(Test Driven Develop)测试驱动开发了，注意，以下的测试代码都写在测试文件 <code>test/index.ts</code> 中，并且文件大致的代码结构为如下所示</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; assert &#125; <span class="keyword">from</span> <span class="string">'chai'</span></span><br><span class="line"><span class="keyword">import</span> &#123; describe, it &#125; <span class="keyword">from</span> <span class="string">'mocha'</span></span><br><span class="line"><span class="keyword">import</span> <span class="built_in">Promise</span> <span class="keyword">from</span> <span class="string">'../src/promise'</span></span><br><span class="line"></span><br><span class="line">describe(<span class="string">'Promise'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="comment">// TODO</span></span><br><span class="line">  it(<span class="string">'TODO'</span>, () =&gt; &#123;</span><br><span class="line">    <span class="comment">// TODO</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>并且源码文件为 <code>src/promise.ts</code></p><h3 id="Promise-是一个类"><a href="#Promise-是一个类" class="headerlink" title="Promise 是一个类"></a>Promise 是一个类</h3><h4 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h4><p>测试用例是这样写</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">it(<span class="string">'是一个类'</span>, () =&gt; &#123;</span><br><span class="line">  assert.isFunction(<span class="built_in">Promise</span>)</span><br><span class="line">  assert.isObject(<span class="built_in">Promise</span>.prototype)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>即 <code>assert</code> 断言</p><ul><li>Promise 是一个 <code>function</code></li><li>Promise 的原型 <code>prototype</code> 是一个对象</li></ul><p>那么就可以证明 Promise 是一个类了</p><h4 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PromiseEasy</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="comment">// TODO</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很简单吧，其实就是用 <strong>测试的需求</strong> 来推动 <strong>开发</strong></p><h3 id="new-Promise-如果接受的不是函数就报错"><a href="#new-Promise-如果接受的不是函数就报错" class="headerlink" title="new Promise() 如果接受的不是函数就报错"></a>new Promise() 如果接受的不是函数就报错</h3><p>这里的逻辑是 Promise 需要接受一个函数作为参数，所以测试用例应该这么写</p><h4 id="测试用例-1"><a href="#测试用例-1" class="headerlink" title="测试用例"></a>测试用例</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">it(<span class="string">'new Promise() 如果接受的不是函数就报错'</span>, () =&gt; &#123;</span><br><span class="line">  assert.throw(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// @ts-ignore</span></span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>()</span><br><span class="line">  &#125;)</span><br><span class="line">  assert.throw(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// @ts-ignore</span></span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="number">1</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  assert.throw(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// @ts-ignore</span></span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="literal">true</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>这里 <code>// @ts-ignore</code> 的意思就是 <strong>注释会忽略下一行中产生的所有错误</strong>，但是因为这里要是不通过就很麻烦，所以还是加上</p></blockquote><blockquote><p><code>assert.throw</code> 这个 API 的意思就是断言一段会报错的代码</p></blockquote><h4 id="源码-1"><a href="#源码-1" class="headerlink" title="源码"></a>源码</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PromiseEasy</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(fn) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> fn !== <span class="string">'function'</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'这里只接受函数'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>逻辑也很简单，对传入的参数做一个判断即可</p><h3 id="new-Promise-fn-会生成一个对象，该对象会有个-then-方法"><a href="#new-Promise-fn-会生成一个对象，该对象会有个-then-方法" class="headerlink" title="new Promise(fn) 会生成一个对象，该对象会有个 then 方法"></a>new Promise(fn) 会生成一个对象，该对象会有个 then 方法</h3><p>嗯，该往 Promise 里面添加 <code>then</code> 方法了，不过之前还是得写测试用例</p><h4 id="测试用例-2"><a href="#测试用例-2" class="headerlink" title="测试用例"></a>测试用例</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">it(<span class="string">'new Promise(fn) 会生成一个对象，该对象会有个 then 方法'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">()</span>=&gt;</span>&#123;&#125;)</span><br><span class="line">  assert.isFunction(promise.then)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="源码-2"><a href="#源码-2" class="headerlink" title="源码"></a>源码</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PromiseEasy</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(fn) &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">  then() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="new-Promise-fn-中的函数立即执行"><a href="#new-Promise-fn-中的函数立即执行" class="headerlink" title="new Promise(fn) 中的函数立即执行"></a>new Promise(fn) 中的函数立即执行</h3><p>这个的测试代码就很简单了</p><h4 id="测试用例-3"><a href="#测试用例-3" class="headerlink" title="测试用例"></a>测试用例</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">it(<span class="string">'new Promise(fn) 中的函数立即执行'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> called = <span class="literal">false</span></span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    called = <span class="literal">true</span></span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// @ts-ignore</span></span><br><span class="line">  assert(called === <span class="literal">true</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>判断是否被调用就是判断 <code>called</code> 这个变量有没有变化</p><h4 id="源码-3"><a href="#源码-3" class="headerlink" title="源码"></a>源码</h4><p>那就很简单了，直接调用构造函数里面传入的 <code>fn</code> 即可</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PromiseEasy</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(fn) &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    fn()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Promise-then-success-中的-success-会在-resolve-被调用后执行"><a href="#Promise-then-success-中的-success-会在-resolve-被调用后执行" class="headerlink" title="Promise.then(success) 中的 success 会在 resolve 被调用后执行"></a>Promise.then(success) 中的 success 会在 resolve 被调用后执行</h3><p>所以这里的核心就是需要验证 <code>then</code> 之后里面 <code>resolve</code> 的函数有没有被执行过了</p><h4 id="测试用例-4"><a href="#测试用例-4" class="headerlink" title="测试用例"></a>测试用例</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">it(<span class="string">'promise.then(success) 中的 success 会在 resolve 被调用后执行'</span>, done =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> called = <span class="literal">false</span></span><br><span class="line">  <span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    assert(called === <span class="literal">false</span>)</span><br><span class="line">    resolve()</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      assert(called === <span class="literal">true</span>)</span><br><span class="line">      done()</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// @ts-ignore</span></span><br><span class="line">  promise.then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    called = <span class="literal">true</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>注意这里在 <code>Promise</code> 中使用了 <code>setTimeout</code>,这是因为</p><ul><li>这里只有等一会才能断言 <code>called = true</code></li><li>因为顺序是先 then -&gt; 调用 fn -&gt; 调用 succeed</li><li>而 succeed 是放入了 setTimeout 中的</li></ul><p>并且还使用了 <code>done</code>，这是因为</p><ul><li>如果代码里面需要异步的测试，则需要加 <code>done</code></li><li>表示异步测试的完成，告诉 mocha 可以检查其测试结果了</li><li>不然很多个任务都是异步测试的话，mocha 就不知道哪个是先完成的(这里 mocha 对于测试用例是一个一个同步执行的)</li></ul><h4 id="源码-4"><a href="#源码-4" class="headerlink" title="源码"></a>源码</h4><p>首先需要在 <code>Promise</code> 里面声明两个变量 <code>succeed</code> 和 <code>fail</code> 分别保存成功和失败回调</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PromiseEasy</span> </span>&#123;</span><br><span class="line">  succeed = <span class="literal">null</span> <span class="comment">// 保存成功回调</span></span><br><span class="line">  fail = <span class="literal">null</span> <span class="comment">// 保存失败回调</span></span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>then</code> 函数执行时保存回调</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PromiseEasy</span> </span>&#123;</span><br><span class="line">  succeed = <span class="literal">null</span> <span class="comment">// 保存成功回调</span></span><br><span class="line">  fail = <span class="literal">null</span> <span class="comment">// 保存失败回调</span></span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">  then(succeed, fail) &#123;</span><br><span class="line">    <span class="keyword">this</span>.succeed = succeed</span><br><span class="line">    <span class="keyword">this</span>.fail = fail</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么什么时候这个 <code>succeed</code> 函数被调用呢，就是 <code>resolve</code> 的时候。众所周知 Promise 不仅仅有 <code>resolve</code>，还有 <code>reject</code>，并且在 <code>new Promise</code> 中使用 <code>resolve</code> 时并不会立刻调用成功回调，而是在执行 <code>then</code> 之后才调用，所以 <code>resolve</code> 和 <code>reject</code> 函数是异步的，这里仅就用 <code>setTimeout</code> 做一个简单的处理</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PromiseEasy</span> </span>&#123;</span><br><span class="line">  succeed = <span class="literal">null</span> <span class="comment">// 保存成功回调</span></span><br><span class="line">  fail = <span class="literal">null</span> <span class="comment">// 保存失败回调</span></span><br><span class="line"></span><br><span class="line">  resolve() &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.succeed()</span><br><span class="line">    &#125;, <span class="number">0</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  reject() &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.fail()</span><br><span class="line">    &#125;, <span class="number">0</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">  then(succeed, fail) &#123;</span><br><span class="line">    <span class="keyword">this</span>.succeed = succeed</span><br><span class="line">    <span class="keyword">this</span>.fail = fail</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在构造函数中需要将 <code>resolve</code> 和 <code>reject</code> 传给 <code>fn</code> 当参数就可以了，当然这里需要 <code>bind</code> 下 <code>this</code>，不然 <code>resolve</code> 和 <code>reject</code> 函数中的 <code>this</code> 是访问不到的</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PromiseEasy</span> </span>&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="keyword">constructor</span>(fn) &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    fn(<span class="keyword">this</span>.resolve.bind(<span class="keyword">this</span>), <span class="keyword">this</span>.reject.bind(<span class="keyword">this</span>))</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Promise-then-null-fail-中的-fail-会在-reject-被调用后执行"><a href="#Promise-then-null-fail-中的-fail-会在-reject-被调用后执行" class="headerlink" title="Promise.then(null, fail) 中的 fail 会在 reject 被调用后执行"></a>Promise.then(null, fail) 中的 fail 会在 reject 被调用后执行</h3><p>这里的测试代码不用说了，和上面的基本差不多</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">it(<span class="string">'promise.then(null, fail) 中的 fail 会在 reject 被调用后执行'</span>, done =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> fail = sinon.fake()</span><br><span class="line">  <span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    assert.isFalse(fail.called)</span><br><span class="line">    reject()</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      assert.isTrue(fail.called)</span><br><span class="line">      done()</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// @ts-ignore</span></span><br><span class="line">  promise.then(<span class="literal">null</span>, fail)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>至此，一个基本的简单的 Promise 框架就算完成了，剩下就是按照 A+ 规范标准在上面添砖加瓦了</p><h2 id="遵循比较重要的-Promise-A-规范增加功能"><a href="#遵循比较重要的-Promise-A-规范增加功能" class="headerlink" title="遵循比较重要的 Promise/A+ 规范增加功能"></a>遵循比较重要的 Promise/A+ 规范增加功能</h2><h3 id="2-2-1-Both-onFulfilled-and-onRejected-are-optional-arguments"><a href="#2-2-1-Both-onFulfilled-and-onRejected-are-optional-arguments" class="headerlink" title="2.2.1 Both onFulfilled and onRejected are optional arguments"></a>2.2.1 Both onFulfilled and onRejected are optional arguments</h3><p><code>onFulfilled</code> 和 <code>onRejected</code> 都是可选的参数</p><h4 id="测试用例-5"><a href="#测试用例-5" class="headerlink" title="测试用例"></a>测试用例</h4><p>这里的测试用例很简单</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">it(<span class="string">'2.2.1 onFulfilled 和 onRejected 都是可选的参数'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resovle</span> =&gt;</span> &#123;</span><br><span class="line">    resovle()</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  promise.then(<span class="literal">false</span>, <span class="literal">null</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>参数可选什么意思，就是 <code>then</code> 传的俩参数都是可以传或者可以不传，所以这里的测试用例很简单</p><h4 id="源码-5"><a href="#源码-5" class="headerlink" title="源码"></a>源码</h4><p>所以这个时候就需要在 3 个地方对参数做判断了</p><ul><li><code>resolve</code> 函数</li><li><code>reject</code> 函数</li><li><code>then</code> 函数</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PromiseEasy</span> </span>&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  resolve() &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span>.succeed === <span class="string">'function'</span>) &#123; <span class="comment">// 添加判断</span></span><br><span class="line">        <span class="keyword">this</span>.succeed()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, <span class="number">0</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  reject() &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span>.fail === <span class="string">'function'</span>) &#123; <span class="comment">// 添加判断</span></span><br><span class="line">        <span class="keyword">this</span>.fail()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, <span class="number">0</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  then(succeed?, fail?) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> succeed === <span class="string">'function'</span>) &#123; <span class="comment">// 添加判断</span></span><br><span class="line">      <span class="keyword">this</span>.succeed = succeed</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> fail === <span class="string">'function'</span>) &#123; <span class="comment">// 添加判断</span></span><br><span class="line">      <span class="keyword">this</span>.fail = fail</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-2-If-onFulfilled-is-a-function"><a href="#2-2-2-If-onFulfilled-is-a-function" class="headerlink" title="2.2.2 If onFulfilled is a function"></a>2.2.2 If onFulfilled is a function</h3><p>2.2.2 这里有三点</p><ol><li>it must be called after promise is fulfilled, with promise’s value as its first argument</li><li>it must not be called before promise is fulfilled</li><li>it must not be called more than once</li></ol><p>总的来说，大意就是 <strong>此函数必须在 promise 完成(fulfilled) 后被调用,并把 promise 的 result 值作为它的第一个参数</strong></p><p>这里先在测试用例中将以上 3 点都测试一遍，但是为了方便起见就只用一个标题</p><h4 id="测试用例-6"><a href="#测试用例-6" class="headerlink" title="测试用例"></a>测试用例</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">it(<span class="string">'2.2.2.1 此函数必须在 promise 完成(fulfilled) 后被调用,并把 promise 的 result 值作为它的第一个参数'</span>, done =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> success = sinon.fake()</span><br><span class="line">  <span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    assert.isFalse(success.called) <span class="comment">// 测试第 2 点</span></span><br><span class="line">    resolve(<span class="string">'hi'</span>)</span><br><span class="line">    resolve(<span class="string">'hii'</span>) <span class="comment">// 调用两次</span></span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      assert(promise.state === <span class="string">'fulfilled'</span>) <span class="comment">// 测试第 1 点</span></span><br><span class="line">      assert.isTrue(success.calledOnce) <span class="comment">// 测试第 3 点</span></span><br><span class="line">      assert.isTrue(success.calledWith(<span class="string">'hi'</span>)) <span class="comment">// 测试第 1 点</span></span><br><span class="line">      done()</span><br><span class="line">    &#125;, <span class="number">0</span>)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  promise.then(success)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>这里使用了 <code>sinon.fake</code> 作为假函数，然后使用 <code>assert.isTrue/assert.isFalse</code> 判断 <code>sinon.fake.called</code> 是否为 <code>true</code>，为 <code>true</code> 说明其已经被调用了，使用 <code>sinon.fake.calledOnce</code> 判断其是否只被调用一次，使用 <code>sinon.fake.calledWith</code> 判断其是否在调用 <code>resolve</code> 时传了对应的参数</p></blockquote><p>所以要实现这一条规范，我们就需要在 Promise 内部维护一个 <code>state</code> 状态判断当前是否是处于 <code>初始状态</code>/<code>resolve</code>/<code>reject</code>，现在我们定义 <code>state</code> 有 3 种状态</p><ul><li><code>pending</code>: 表示初始状态</li><li><code>fulfilled</code>: 表示用户调用了 <code>resolve</code> 函数</li><li><code>rejected</code>: 表示用户调用了 <code>reject</code> 函数</li></ul><blockquote><p>这里还要说明的是，<code>state</code> 状态只能是单向的变化，即只能是 <code>pending</code> -&gt; <code>fulfilled</code> 或者 <code>pending</code> -&gt; <code>rejected</code>，而不能三者两两互相变化</p></blockquote><h4 id="源码-6"><a href="#源码-6" class="headerlink" title="源码"></a>源码</h4><p>所以源码应该是要对 <code>resolve</code> 以及 <code>reject</code> 做修改，并且还要增加一个 <code>state</code></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PromiseEasy</span> </span>&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  state = <span class="string">'pending'</span></span><br><span class="line">  resolve(result) &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.state !== <span class="string">'pending'</span>) <span class="keyword">return</span></span><br><span class="line">      <span class="keyword">this</span>.state = <span class="string">'fulfilled'</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span>.succeed === <span class="string">'function'</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.succeed(result)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, <span class="number">0</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  reject(reason) &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.state !== <span class="string">'pending'</span>) <span class="keyword">return</span></span><br><span class="line">      <span class="keyword">this</span>.state = <span class="string">'rejected'</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span>.fail === <span class="string">'function'</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.fail(reason)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, <span class="number">0</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在进入 <code>resolve</code>/ <code>reject</code> 之后，先判断其是否是在 <code>pending</code> 状态，否则就 <code>return</code>，即保证上述规范第3点，之后才将状态改变，并且对 <code>succeed</code>/<code>fail</code> 函数做判断，只有其是函数时才能被调用。其中还添加了 <code>resolve</code> 的参数 <code>result</code> 以及 <code>reject</code> 参数 <code>reason</code></p><h3 id="2-2-3-If-onRejected-is-a-function"><a href="#2-2-3-If-onRejected-is-a-function" class="headerlink" title="2.2.3 If onRejected is a function"></a>2.2.3 If onRejected is a function</h3><ul><li>it must be called after promise is rejected, with promise’s reason as its first argument</li><li>it must not be called before promise is rejected</li><li>it must not be called more than once</li></ul><p>这个跟 2.2.2 其实很像的，就是做 <code>reject</code> 之后的逻辑</p><h4 id="测试用例-7"><a href="#测试用例-7" class="headerlink" title="测试用例"></a>测试用例</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">it(<span class="string">'2.2.3.1 此函数必须在 promise 失败(rejected) 后被调用,并把 promise 的值作为它的第一个参数'</span>, done =&gt; &#123;</span><br><span class="line">   <span class="keyword">const</span> fail = sinon.fake()</span><br><span class="line">   <span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">     assert.isFalse(fail.called)</span><br><span class="line">     reject(<span class="string">'hi'</span>)</span><br><span class="line">     reject(<span class="string">'hii'</span>)</span><br><span class="line">     setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">       assert(promise.state === <span class="string">'rejected'</span>)</span><br><span class="line">       assert.isTrue(fail.calledOnce)</span><br><span class="line">       assert.isTrue(fail.calledWith(<span class="string">'hi'</span>))</span><br><span class="line">       done()</span><br><span class="line">     &#125;, <span class="number">0</span>)</span><br><span class="line">   &#125;)</span><br><span class="line"></span><br><span class="line">   promise.then(<span class="literal">null</span>, fail)</span><br><span class="line"> &#125;)</span><br></pre></td></tr></table></figure><h4 id="源码-7"><a href="#源码-7" class="headerlink" title="源码"></a>源码</h4><p><a href="#2.2.2-If-onFulfilled-is-a-function">参考 2.2.2 If onFulfilled is a function</a></p><h3 id="2-2-4-onFulfilled-or-onRejected-must-not-be-called-until-the-execution-context-stack-contains-only-platform-code"><a href="#2-2-4-onFulfilled-or-onRejected-must-not-be-called-until-the-execution-context-stack-contains-only-platform-code" class="headerlink" title="2.2.4 onFulfilled or onRejected must not be called until the execution context stack contains only platform code"></a>2.2.4 onFulfilled or onRejected must not be called until the execution context stack contains only platform code</h3><p>这句话给人很疑惑的感觉，因为官方的翻译就是</p><blockquote><p>在执行上下文堆栈（execution context）仅包含平台代码之前，不得调用 onFulfilled 和 onRejected</p></blockquote><p>再去看对应的解释(<a href="https://promisesaplus.com/#notes" target="_blank" rel="noopener">3.1</a>)</p><blockquote><p>Here “platform code” means engine, environment, and promise implementation code. In practice, this requirement ensures that <code>onFulfilled</code> and <code>onRejected</code> execute asynchronously, after the event loop turn in which <code>then</code> is called, and with a fresh stack. This can be implemented with either a “macro-task” mechanism such as <code>setTimeout</code> or <code>setImmediate</code>, or with a “micro-task” mechanism such as <code>MutationObserver</code> or <code>process.nextTick</code>. Since the promise implementation is considered platform code, it may itself contain a task-scheduling queue or “trampoline” in which the handlers are called.</p></blockquote><p>翻译一下，就是</p><blockquote><p>这里的 “platform code” 表示 (JS 的) 引擎，(JS 的)环境和 promise 执行的代码。实际上，这个(规范)要求能确保，<code>onFulfilled</code> 和 <code>onRejected</code> 在 eventLoop 之后调用 <code>then</code>，  它们可以(得到)异步地执行，然后(继续)使用新的堆栈。这里既可以使用 <code>setTimeout</code>/<code>setImmediate</code> 这样的 “宏任务” 机制实现，也可以使用 <code>MutationObserver</code>/<code>process.nextTick</code> 这样的 “微任务” 机制实现。由于 promise 的实现被看作是 platform code，所以它可能本身就包含一个任务调度队列或者用来处理调用(关系)的 “trampoline”</p></blockquote><p>还是不理解？我举个例子好了，比如有一个函数叫做 <code>XXX</code> 吧，一个 promise 做了如下的操作</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">promise.then(XXX)</span><br></pre></td></tr></table></figure><p>但是此时函数 <code>XXX</code> <strong>还没有执行</strong>哦，因为规范要求，<strong>一定要在调用 <code>then</code></strong> 之后执行。因为这才可以产生一个异步的操作，而这个异步的操作如何来？规范里面也写了，可以利用 <code>setTimeout</code>/<code>setImmediate</code> 这样的宏任务来解决，或者也可以使用 <code>MutationObserver</code>/<code>process.nextTick</code> 这样的微任务来解决。解决的关键点是什么呢？就是在 Promise 内部，其传入的函数里面执行的<strong>优先级</strong>比外面通过 <code>promise.then</code> 方式调用 <code>XXX</code> 的优先级 <strong>要高</strong>。那么怎么做到这种优先级要高呢？ <strong>就是在 <code>resolve</code>/<code>reject</code> 中加上 <code>setTimeout</code></strong>。当然了，这里只是简单的处理，比如我写如下的测试代码你大概就懂了</p><blockquote><p>如果实在不明白宏任务/微任务机制的可以<a href="https://github.com/strugglebak/front-end-daliy/issues/8" target="_blank" rel="noopener">点击参考我之前写的这篇</a></p></blockquote><h4 id="测试用例-8"><a href="#测试用例-8" class="headerlink" title="测试用例"></a>测试用例</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">it(<span class="string">'2.2.4 在我的代码执行完之前，不得调用 then 后面的两个函数'</span>, done =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> success = sinon.fake()</span><br><span class="line">  <span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    resolve()</span><br><span class="line">  &#125;)</span><br><span class="line">  promise.then(success)</span><br><span class="line">  <span class="comment">// 这个时候代码还没有执行完，success 函数还没有被调用</span></span><br><span class="line">  assert.isFalse(success.called)</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 这个时候代码执行完了，success 函数被调用了</span></span><br><span class="line">    assert.isTrue(success.called)</span><br><span class="line">    done()</span><br><span class="line">  &#125;, <span class="number">0</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">it(<span class="string">'2.2.4 失败回调'</span>, done =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> fail = sinon.fake()</span><br><span class="line">  <span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    reject()</span><br><span class="line">  &#125;)</span><br><span class="line">  promise.then(<span class="literal">null</span>, fail)</span><br><span class="line">  assert.isFalse(fail.called)</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    assert.isTrue(fail.called)</span><br><span class="line">    done()</span><br><span class="line">  &#125;, <span class="number">0</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>所以你可以看到，外面的 <code>setTimeout</code> 要 <strong>靠后 </strong> 执行了，为什么，因为 <code>success</code> 函数先进入了 Promise 内部，其内部有个 <code>setTimeout</code> 函数将其包裹了起来，eventLoop 时运行环境会将这个里面的代码放到了一个宏任务队列中，而这个外面调的 <code>setTimeout</code> 也将其紧随其后放到这个队列里面。执行时会优先执行先进去的任务，那么就是 <code>success</code> 先在里面执行了，然后外部的 <code>setTimeout</code> 自然就会觉察到 <code>success</code> 被调用了。</p><h4 id="源码-8"><a href="#源码-8" class="headerlink" title="源码"></a>源码</h4><p>参考最开始写的 <a href="#先实现一个最基础版本的-Promise">先实现一个最基础版本的 Promise</a></p><h3 id="2-2-5-onFulfilled-and-onRejected-must-be-called-as-functions-i-e-with-no-this-value"><a href="#2-2-5-onFulfilled-and-onRejected-must-be-called-as-functions-i-e-with-no-this-value" class="headerlink" title="2.2.5 onFulfilled and onRejected must be called as functions (i.e. with no this value)"></a>2.2.5 onFulfilled and onRejected must be called as functions (i.e. with no this value)</h3><p>这里的意思是 <code>onFulfilled</code> 和 <code>onRejected</code> 必须被当作函数调用(例如: 没有 <code>this</code>)</p><p>又懵逼了，啥玩意儿???还是看看<a href="https://promisesaplus.com/#notes" target="_blank" rel="noopener">说明 3.2</a>吧</p><blockquote><p>That is, in strict mode <code>this</code> will be <code>undefined</code> inside of them; in sloppy mode, it will be the global object</p></blockquote><p>意思就是说</p><blockquote><p>严格模式下，<code>this</code> 在 <code>onFulfilled</code> 以及 <code>onRejected</code> 内部是 <code>undefined</code>; 而在非严格模式下，<code>this</code> 在它们内部就是一个全局对象</p></blockquote><p>所以这里我们就选择严格模式就好了，因为本来就是由类封装起来的对象，在这种情况下，<code>this</code> 在 <code>onFulfilled</code> 以及 <code>onRejected</code> 内部只能是 <code>undefined</code>，那么测试用例应该这么写</p><h4 id="测试用例-9"><a href="#测试用例-9" class="headerlink" title="测试用例"></a>测试用例</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">it(<span class="string">'2.2.5 onFulfilled 和 onRejected 必须被当做函数调用(并且里面没有 this)'</span>, done =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    resolve()</span><br><span class="line">  &#125;)</span><br><span class="line">  promise.then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">    'use strict'</span></span><br><span class="line">    assert(<span class="keyword">this</span> === <span class="literal">undefined</span>) <span class="comment">// 断言这个函数里面的 this 为 undefined</span></span><br><span class="line">    done()</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">it(<span class="string">'2.2.5 失败回调'</span>, done =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    reject()</span><br><span class="line">  &#125;)</span><br><span class="line">  promise.then(<span class="literal">null</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">    'use strict'</span></span><br><span class="line">    assert(<span class="keyword">this</span> === <span class="literal">undefined</span>)</span><br><span class="line">    done()</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="源码-9"><a href="#源码-9" class="headerlink" title="源码"></a>源码</h4><p>源码就好改了，对应的 <code>resolve</code> 以及 <code>reject</code> 函数里面将对应的函数调用 <code>call</code> 一个 <code>undefined</code> 就好，如下</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PromiseEasy</span> </span>&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  resovle(result) &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span>.succeed === <span class="string">'function'</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.succeed.call(<span class="literal">undefined</span>, result)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  reject(reason) &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span>.fail === <span class="string">'function'</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.fail.call(<span class="literal">undefined</span>, reason)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-6-then-may-be-called-multiple-times-on-the-same-promise"><a href="#2-2-6-then-may-be-called-multiple-times-on-the-same-promise" class="headerlink" title="2.2.6 then may be called multiple times on the same promise"></a>2.2.6 then may be called multiple times on the same promise</h3><p><code>then</code> 可以在同一个 Promise 里被多次调用。那么基本上测试代码可以这么写</p><h4 id="测试用例-10"><a href="#测试用例-10" class="headerlink" title="测试用例"></a>测试用例</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">it(<span class="string">'2.2.6 then可以在同一个promise里被多次调用'</span>, done =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    resolve()</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">const</span> callbacks = [sinon.fake(), sinon.fake(), sinon.fake()]</span><br><span class="line">  promise.then(callbacks[<span class="number">0</span>])</span><br><span class="line">  promise.then(callbacks[<span class="number">1</span>])</span><br><span class="line">  promise.then(callbacks[<span class="number">2</span>])</span><br><span class="line"></span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    assert(callbacks[<span class="number">0</span>].called)</span><br><span class="line">    assert(callbacks[<span class="number">1</span>].called)</span><br><span class="line">    assert(callbacks[<span class="number">2</span>].called)</span><br><span class="line">    <span class="comment">// 如果/当 promise 完成执行（fulfilled）,各个相应的onFulfilled回调 必须根据最原始的then 顺序来调用</span></span><br><span class="line">    assert(callbacks[<span class="number">1</span>].calledAfter(callbacks[<span class="number">0</span>]))</span><br><span class="line">    assert(callbacks[<span class="number">2</span>].calledAfter(callbacks[<span class="number">1</span>]))</span><br><span class="line">    done()</span><br><span class="line">  &#125;, <span class="number">0</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">it(<span class="string">'2.2.6 失败回调'</span>, done =&gt; &#123;</span><br><span class="line">   <span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">     reject()</span><br><span class="line">   &#125;)</span><br><span class="line">   <span class="keyword">const</span> callbacks = [sinon.fake(), sinon.fake(), sinon.fake()]</span><br><span class="line">   promise.then(<span class="literal">null</span>, callbacks[<span class="number">0</span>])</span><br><span class="line">   promise.then(<span class="literal">null</span>, callbacks[<span class="number">1</span>])</span><br><span class="line">   promise.then(<span class="literal">null</span>, callbacks[<span class="number">2</span>])</span><br><span class="line"></span><br><span class="line">   setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">     assert(callbacks[<span class="number">0</span>].called)</span><br><span class="line">     assert(callbacks[<span class="number">1</span>].called)</span><br><span class="line">     assert(callbacks[<span class="number">2</span>].called)</span><br><span class="line">     assert(callbacks[<span class="number">1</span>].calledAfter(callbacks[<span class="number">0</span>]))</span><br><span class="line">     assert(callbacks[<span class="number">2</span>].calledAfter(callbacks[<span class="number">1</span>]))</span><br><span class="line">     done()</span><br><span class="line">   &#125;, <span class="number">0</span>)</span><br></pre></td></tr></table></figure><blockquote><p>这里 <code>sinon.fake.calledAfter</code> 表示在某个目标函数之后被调用</p></blockquote><h4 id="源码-10"><a href="#源码-10" class="headerlink" title="源码"></a>源码</h4><p>这里的 <code>promise</code> 要求能够多次调用 <code>then</code>，而我们原来 Promise 的逻辑是 <code>then</code> 只是保存了一次 <code>succeed</code> 和 <code>fail</code>，这样的话多次 <code>then</code> 就只会覆盖掉之前传入的函数。要能通过测试用例中的代码，我们很容易想到，每次 <code>then</code> 时，用<strong>数组来保存 <code>succeed</code> 和 <code>fail</code></strong> 即可。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PromiseEasy</span> </span>&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  callbacks = [] <span class="comment">// 用来保存成功以及失败回调的数组</span></span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  then(succeed?, fail?) &#123;</span><br><span class="line">    <span class="keyword">const</span> handle = []</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> succeed === <span class="string">'function'</span>) &#123;</span><br><span class="line">      handle[<span class="number">0</span>] = succeed</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> fail === <span class="string">'function'</span>) &#123;</span><br><span class="line">      handle[<span class="number">1</span>] = fail</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.callbacks.push(handle)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么在调用的时候怎么办呢？只需要在 <code>resolve</code> 和 <code>reject</code> 中 <strong>遍历调用</strong> 即可</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PromiseEasy</span> </span>&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  resolve(result) &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">//...</span></span><br><span class="line">      <span class="keyword">this</span>.callbacks.forEach(<span class="function"><span class="params">handle</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> succeed = handle[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> succeed === <span class="string">'function'</span>) &#123;</span><br><span class="line">          succeed.call(<span class="literal">undefined</span>, result)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;, <span class="number">0</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  reject(reason) &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">//...</span></span><br><span class="line">      <span class="keyword">this</span>.callbacks.forEach(<span class="function"><span class="params">handle</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> fail = handle[<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> fail === <span class="string">'function'</span>) &#123;</span><br><span class="line">          fail.call(<span class="literal">undefined</span>, reason)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;, <span class="number">0</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，本质就是两步</p><ul><li>添加一个<strong>二维数组</strong>，<code>then</code> 时保存 <code>succeed</code> 和 <code>fail</code> 的数组</li><li>在 <code>resolve</code>/<code>reject</code> 时<strong>遍历</strong>，取出对应的 <code>succeed</code>/<code>fail</code>，并执行</li></ul><h2 id="与-Promises-A-规范的区别"><a href="#与-Promises-A-规范的区别" class="headerlink" title="与 Promises/A 规范的区别"></a>与 Promises/A 规范的区别</h2><p>至此，我们已经完成一个 Promise 的基本功能，这个功能包括了 Promise 的核心 API，即 <code>new Promise</code> 以及 <code>then</code> 和里面的成功以及失败回调，下面就来讲(fan)讲(yi) Promises/A+ 规范和 Promises/A 规范的几个<strong>比较重要</strong>的区别</p><h3 id="Omissions"><a href="#Omissions" class="headerlink" title="Omissions"></a>Omissions</h3><p>下面的几点都是 Promises/A 规范所遗漏的:</p><ol><li>进度处理: 实际上，它并未被指定，并且当前在实现 promise 的社区中没有形成一致的意见</li><li>可交互的 promises: 这被认为超出了可互操作保证所必需的最小 API 的范围</li><li>对于 <code>var promise2 = promise1.then(onFulfilled, onRejected)</code> 这样的代码，<code>promise1 !== promise2</code> 并不是必要的</li></ol><h3 id="Clarifications"><a href="#Clarifications" class="headerlink" title="Clarifications"></a>Clarifications</h3><p>Promises/A+ 规范与 Promises/A 规范使用不同的术语，这体现在 Promise 的实现过程中，它们已经成为事实(标准)意义上的词汇。 特别是如下:</p><ol><li>给定的 promise 的状态是 “pending”、”fulfilled”、”rejected”</li><li>当 promises 被 fulfilled 时，它们会有 “value”; 当 promises 被 rejected 时，它们会有 “reason”</li><li>它引入了与 “promises” 不同的术语叫 “thenable”，以便更准确地讨论实现互操作所必需的 duck 测试</li></ol><h3 id="Additions"><a href="#Additions" class="headerlink" title="Additions"></a>Additions</h3><p>Promises/A+ 规范另外指定:</p><ol><li>当 <code>onFulfilled</code> 或 <code>onRejected</code> 返回一个 <code>thenable</code> 的行为时，应包括解析过程的详细信息</li><li>传给 <code>onRejected</code> 的 <code>reason</code> 在处理 <code>throws</code> 必须要抛异常</li><li><code>onFulfilled</code> 和 <code>onRejected</code> 必须是被异步调用的</li><li><code>onFulfilled</code> 和 <code>onRejected</code> 必须是当作函数来调用</li><li>对 <code>onFulfilled</code> 和 <code>onRejected</code> 的调用的严格排序，以便在同一个 promise 上调用 <code>then</code></li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>一个基础的 Promises/A+ 规范的 Promise 的实现需要注意以下几点</p><ol><li>构造函数需要传一个函数，并在构造函数内部调用这个函数，而这个函数传了两个参数作为参数: <code>resolve</code> 和 <code>reject</code>，这两个函数都是 Promise 内部实现的函数</li><li>每次 <code>then</code> 时都将传入的 <code>succeed</code> 和 <code>fail</code> 函数 push 进一个数组当中，而这个数组是一个二维数组，用来维护这一堆 <code>succeed</code> 和 <code>fail</code> 函数</li><li>Promise 内部的 <code>resolve</code> 函数和 <code>reject</code> 函数中都做了如下的操作<ul><li>判断 <code>state</code> 是否为 <code>pending</code> 状态，不是就 return</li><li>修改状态为 <code>fulfilled</code>/ <code>rejected</code></li><li>遍历上述的二维数组，找到 <code>succeed</code>/<code>fail</code> 函数并调用(<code>.call(undefined, result/reason)</code>)</li></ul></li><li><code>resolve</code>/<code>reject</code> 函数里面使用 <code>setTimeout</code> 做异步执行</li></ol><blockquote><p>另外，对应的<a href="https://github.com/strugglebak/promise-easy" target="_blank" rel="noopener">项目链接在这里</a></p></blockquote><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://promisesaplus.com/" target="_blank" rel="noopener">Promises/A+</a></p><p><a href="https://promisesaplus.com/differences-from-promises-a" target="_blank" rel="noopener">Differences from Promises/A</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;之前我还讲过 &lt;a href=&quot;https://strugglebak.github.io/2020/03/09/%E4%BB%8EPromise%E6%9C%AC%E8%B4%A8%E5%BC%80%E5%A7%8B-%E4%B8%80-%E5%AE%9E%E7%8E%B0Promise%E5%89%8D%E8%A8%80/&quot;&gt;如何为实现 Promise 搭建 TDD 环境&lt;/a&gt;，而本文的目的主要是探讨如何基于 TDD 这样的方式实现一个 Promise，并且描述了部分 Promises/A+ 规范，以此为基础实现的一个 Promise&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="手写源码" scheme="https://strugglebak.github.io/categories/%E6%89%8B%E5%86%99%E6%BA%90%E7%A0%81/"/>
    
    
      <category term="Promise" scheme="https://strugglebak.github.io/tags/Promise/"/>
    
  </entry>
  
  <entry>
    <title>watermelon-clock:基于TypeScript+React的西瓜闹钟项目的实践总结</title>
    <link href="https://strugglebak.github.io/2020/03/17/watermelon-clock-%E5%9F%BA%E4%BA%8ETypeScript-React%E7%9A%84%E8%A5%BF%E7%93%9C%E9%97%B9%E9%92%9F%E9%A1%B9%E7%9B%AE%E7%9A%84%E5%AE%9E%E8%B7%B5%E6%80%BB%E7%BB%93/"/>
    <id>https://strugglebak.github.io/2020/03/17/watermelon-clock-基于TypeScript-React的西瓜闹钟项目的实践总结/</id>
    <published>2020-03-16T16:05:52.000Z</published>
    <updated>2022-06-04T08:13:29.095Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>注意，本项目是基于 <code>create-react-app</code> 搭建，但是使用了 <code>--typescript</code> 选项，所以是基于 <code>TypeScript</code> 写的。另外，<a href="https://github.com/strugglebak/watermelon-clock" target="_blank" rel="noopener">项目地址在这里，求各位大佬看到了如果喜欢还请点个小星星(拜托啦这真的对我很重要 QAQ)</a></p></blockquote><a id="more"></a><h2 id="项目实现-Feature"><a href="#项目实现-Feature" class="headerlink" title="项目实现 Feature"></a>项目实现 Feature</h2><ul><li><p>小巧的用户验证</p><p>  这一部分主要是用来注册/登陆的验证用的，注册/登陆后会自动跳转至首页，所以这边也做了一个简单的路由鉴权功能</p></li><li><p>西瓜闹钟</p><p>  点击开始闹钟时，会显示 25 分钟的倒计时，计时结束后若没有打断则会生成一个西瓜</p></li><li><p>待办 todo 任务</p><p>  新建待办任务和完成待办任务后都会出现任务的列表，而且是不同的列表展示</p></li><li><p>数据统计</p><p>  主要有 3 个</p><ul><li>月度统计：统计每个月任务总量的累计/增长率/平均值</li><li>西瓜历史统计：主要是一个长达 25 分钟的西瓜量，表示自己长时间的执行完某个任务的量化显示，可编辑/删除/恢复，同时也可以手动增加西瓜记录</li><li>待办 todo 历史统计：表示自己短时间内执行完的小任务的量化表示，可编辑/删除/恢复，同时可以查看已经删除的任务</li></ul></li></ul><h2 id="项目主要技术栈"><a href="#项目主要技术栈" class="headerlink" title="项目主要技术栈"></a>项目主要技术栈</h2><ul><li>React 16.12</li><li>Antd 4.0.1</li><li>Axios 库</li><li>React-Router-DOM 5.1.2</li><li>React-Redux 7.1.3</li><li>Redux 4.0.5</li><li>TypeScript 3.8.3</li><li>History 4.10.1</li><li>Lodash 4.14</li><li>Stylus</li></ul><p>这里需要说明的是目前的 antd 用的是比较新的版本，但是由于组件目前并不涉及到非常复杂的结构，所以可以使用其升级工具进行无痛升级</p><p>在配置 <code>stylus</code> 时应该在项目对应的 <code>config-overrides.js</code> 目录做如下的配置</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">const</span> stylus = <span class="function"><span class="params">()</span> =&gt;</span> <span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> stylusLoader = &#123;</span><br><span class="line">    test: <span class="regexp">/\.styl$/</span>,</span><br><span class="line">    use: [</span><br><span class="line">      &#123;</span><br><span class="line">        loader: <span class="string">'style-loader'</span></span><br><span class="line">      &#125;, &#123;</span><br><span class="line">        loader: <span class="string">'css-loader'</span>,</span><br><span class="line">      &#125;, &#123;</span><br><span class="line">        loader: <span class="string">'stylus-loader'</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> oneOf = config.module.rules.find(<span class="function"><span class="params">rule</span> =&gt;</span> rule.oneOf).oneOf</span><br><span class="line">  oneOf.unshift(stylusLoader)</span><br><span class="line">  <span class="keyword">return</span> config</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = override(</span><br><span class="line">  ...</span><br><span class="line">  stylus()</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>这里的作用相当于找出原有配置中的 <code>oneOf</code> 然后将 <code>stylus</code> 的配置加入其中，很好理解(因为我目前使用的时 cra 所以在某些配置方面能省则省了，目的是体验并上手 React 结合 TypeScript 的开发)</p><h2 id="项目实现技术细节"><a href="#项目实现技术细节" class="headerlink" title="项目实现技术细节"></a>项目实现技术细节</h2><h3 id="部分组件使用-hooks"><a href="#部分组件使用-hooks" class="headerlink" title="部分组件使用 hooks"></a>部分组件使用 hooks</h3><p>主要是倒计时组件这里使用了 <code>useEffect</code> 以及 <code>useState</code> 这两个 hooks</p><p>原来的倒计时组件用类组件来写的话就比较繁琐</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/components/waterMelon/countDown.tsx</span></span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">countDown</span> <span class="keyword">extends</span> <span class="title">Component</span>&lt;<span class="title">ICountDownProps</span>, <span class="title">ICountDownState</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span>(props: ICountDownProps) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props)</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      countDown: <span class="keyword">this</span>.props.time,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">get</span> countDown() &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">get</span> progressWidth() &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentWillUnmount() &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (...)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本质上就是使用了一个生命周期的形式来实现效果，代码分散在多处不好做统一管理，但是使用了 hooks 之后代码量减少很多，减小了很多心智负担</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> CountDown:FunctionComponent&lt;ICountDownProps&gt; = <span class="function">(<span class="params">props: ICountDownProps</span>) =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> [countDown, setCountDown] = useState(props.time)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 时间换算显示</span></span><br><span class="line">  <span class="keyword">const</span> min = <span class="built_in">Math</span>.floor(countDown/<span class="number">1000</span>/<span class="number">60</span>)</span><br><span class="line">  <span class="keyword">const</span> sec = <span class="built_in">Math</span>.floor(countDown/<span class="number">1000</span>%<span class="number">60</span>)</span><br><span class="line">  <span class="keyword">const</span> time = <span class="string">`<span class="subst">$&#123;min &lt; <span class="number">10</span> ? <span class="string">`0<span class="subst">$&#123;min&#125;</span>`</span> : min&#125;</span>:<span class="subst">$&#123;sec &lt; <span class="number">10</span> ? <span class="string">`0<span class="subst">$&#123;sec&#125;</span>`</span> : sec&#125;</span>`</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// progress bar 进度条长度计算显示</span></span><br><span class="line">  <span class="keyword">const</span> &#123; duration &#125; = props</span><br><span class="line">  <span class="keyword">const</span> progressWidth = (<span class="number">100</span> - (countDown - <span class="number">1000</span>) * <span class="number">100</span> / duration).toFixed(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span>=&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">document</span>.title = <span class="string">`<span class="subst">$&#123;time&#125;</span> - 西瓜闹钟 App`</span></span><br><span class="line">    timerId = setInterval(<span class="function"><span class="params">()</span>=&gt;</span> &#123;</span><br><span class="line">      setCountDown(countDown - <span class="number">1000</span>)</span><br><span class="line">      <span class="keyword">if</span> (countDown &lt; <span class="number">1000</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(countDown)</span><br><span class="line">        props.onEnd()</span><br><span class="line">        <span class="built_in">window</span>.clearInterval(timerId)</span><br><span class="line">        <span class="built_in">document</span>.title = <span class="string">'西瓜闹钟 App'</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 组件销毁时</span></span><br><span class="line">      <span class="built_in">window</span>.clearInterval(timerId)</span><br><span class="line">      <span class="built_in">document</span>.title = <span class="string">'西瓜闹钟 App'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (...)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 <code>useEffect</code> 可以统一处理副作用以及组件销毁时的逻辑，而使用 <code>useState</code> 就可以统一状态的管理，这样就可以最大程度的减小代码量，可以将一些比较重要的逻辑统一起来管理，使得组件代码更加明了</p><h3 id="axios-配置"><a href="#axios-配置" class="headerlink" title="axios 配置"></a>axios 配置</h3><p>这里的配置比较简单，主要是通过使用 axios 的拦截器去拦截验证从后端发过来的 token 有没有，配置主要有以下两点</p><ul><li><p>发送请求前需要在请求头中加 token 方便后端验证</p>  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/config/http.ts</span></span><br><span class="line">instance.interceptors.request.use(</span><br><span class="line">  config =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> xToken = localStorage.getItem(<span class="string">'x-token'</span>)</span><br><span class="line">    <span class="keyword">if</span> (xToken) config.headers[<span class="string">'Authorization'</span>] = <span class="string">`Bearer <span class="subst">$&#123;xToken&#125;</span>`</span></span><br><span class="line">    <span class="keyword">return</span> config</span><br><span class="line">  &#125;,</span><br><span class="line">  e =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'request error: '</span>, e)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(e)</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li><li><p>接受响应之前设置下 token</p>  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">instance.interceptors.response.use(</span><br><span class="line">  res =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (res.headers[<span class="string">'x-token'</span>]) localStorage.setItem(<span class="string">'x-token'</span>, res.headers[<span class="string">'x-token'</span>])</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">  &#125;,</span><br><span class="line">  e =&gt; &#123;</span><br><span class="line">    <span class="comment">// eslint-disable-next-line</span></span><br><span class="line">    <span class="keyword">if</span> (e.response &amp;&amp; e.response.status === <span class="number">401</span> || e.response.status &gt;= <span class="number">500</span>) &#123;</span><br><span class="line">      <span class="comment">// 一般是如果鉴权失败，需要做重定向跳转到登录页</span></span><br><span class="line">      <span class="built_in">console</span>.log(history.location.pathname)</span><br><span class="line">      <span class="keyword">if</span> (history.location.pathname === <span class="string">'/'</span>) history.push(<span class="string">'/login'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(e)</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li></ul><p>这里做了一个简单的路由鉴权，不过更加详细的鉴权我写在了 redux 的 <code>userActions</code> 中，不过留着下面来说</p><h3 id="redux-以及-redux-thunk-这个中间件"><a href="#redux-以及-redux-thunk-这个中间件" class="headerlink" title="redux 以及 redux-thunk 这个中间件"></a>redux 以及 redux-thunk 这个中间件</h3><ul><li><p>模块划分<br>  说到模块划分，基本是如下的结构</p>  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">redux/</span><br><span class="line">├── actionTypes.ts</span><br><span class="line">├── actions</span><br><span class="line">│   ├── todosActions.ts</span><br><span class="line">│   ├── userActions.ts</span><br><span class="line">│   └── waterMelonActions.ts</span><br><span class="line">├── reducers</span><br><span class="line">│   ├── indexReducer.ts</span><br><span class="line">│   ├── todosReducer.ts</span><br><span class="line">│   ├── userReducer.ts</span><br><span class="line">│   └── waterMelonReducer.ts</span><br><span class="line">└── store.ts</span><br></pre></td></tr></table></figure><p>  因为这里的各种 <code>type</code> 都比较简单，所以这里就没有分各个模块文件了，只是就大概的 <code>actions</code> 以及 <code>reducers</code> 分了一下，<code>store.ts</code> 模块主要就是 <code>creatStore</code> 以及 <code>applyMiddleware</code> 中间件。这里还用了一个 <code>redux-devtools-extension</code> redux 的调试工具，在 debug 环境调试用的。</p></li><li><p>用户登陆/注册的鉴权</p><p>  其实在用户登陆和注册之前可以先调用下 <code>getUserInfo</code> 获取下用户的信息，先判断是否会得到错误，如果没错那么本来没有在 <code>/</code> 路由的就跳转到 <code>/</code>，如果出错了那么在判断其是否在 <code>/</code> 路由，在的话就强制跳转至 <code>/login</code> 路由页面</p><p>  登陆和注册的逻辑基本就是如下</p>  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">await</span> http.post(url, params)</span><br><span class="line">  <span class="keyword">const</span> response = <span class="keyword">await</span> http.get(<span class="string">'/me'</span>)</span><br><span class="line">  <span class="keyword">const</span> userInfo = response.data</span><br><span class="line">  dispatch(&#123;</span><br><span class="line">    type: VERIFY_USER_SUCCESS,</span><br><span class="line">    payload: userInfo</span><br><span class="line">  &#125;)</span><br><span class="line">  history.push(<span class="string">'/'</span>)</span><br><span class="line">&#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e.response)</span><br><span class="line">  <span class="keyword">let</span> errorInfo</span><br><span class="line">  <span class="keyword">if</span>(!e.response)&#123;</span><br><span class="line">    errorInfo = <span class="string">'请检查网络是否正常'</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; errors &#125; = e.response.data</span><br><span class="line">    errorInfo = errors.account</span><br><span class="line">    ? errors.account</span><br><span class="line">    : errors</span><br><span class="line">  &#125;</span><br><span class="line">  dispatch(&#123;</span><br><span class="line">    type: VERIFY_USER_FAILURE,</span><br><span class="line">    error: errorInfo</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>为什么使用 <code>redux-thunk</code> 来 <code>dispatch</code> 数据</p><p>  因为用到了异步，而我们这里的异步比较简单，实际上用 <code>redux-thunk</code> 这个中间件就能解决问题了。那么这里的 <code>actions</code> 的写法也比较简单，只是需要返回一个 <code>async</code> 的带有 <code>dispatch</code> 函数参数的一个函数即可，<code>redux-thunk</code> 会自己帮你 enhance 这个 <code>dispatch</code></p>  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> xxx = <span class="keyword">async</span> (dispatch: any) =&gt; &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  dispatch(&#123;</span><br><span class="line">    type: <span class="string">'YYY'</span>,</span><br><span class="line">    payload: &#123;...&#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>react-redux</code> 中的 <code>connect</code> 组件</p><p>  首先我不认同只有父级组件用 <code>connect</code> 而其他组件就被动传 <code>props</code> 的这种用法。因为尽管是比较简单的一个项目，但是在某个功能模块上依然存在层级嵌套比较深的情况。有一般而言传个三级就觉得很麻烦了，这个时候子组件使用 <code>connect</code> 是很有必要的(虽然可能写起来依然麻烦了点，但是的确能省点心思思考我的父级组件到底给我传了个啥)</p></li></ul><h3 id="封装的-history-配置"><a href="#封装的-history-配置" class="headerlink" title="封装的 history 配置"></a>封装的 <code>history</code> 配置</h3><p>这部分的代码也并不是特别复杂，如下所示</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createBrowserHistory &#125; <span class="keyword">from</span> <span class="string">'history'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ENV = process.env.NODE_ENV</span><br><span class="line"><span class="keyword">let</span> publicUrl: string = <span class="string">''</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ENV === <span class="string">'development'</span>) &#123;</span><br><span class="line">  publicUrl = <span class="string">'/'</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (ENV === <span class="string">'production'</span>) &#123;</span><br><span class="line">  publicUrl = <span class="string">'/watermelon-clock'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> history = createBrowserHistory(&#123;</span><br><span class="line">  basename: publicUrl</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> history</span><br></pre></td></tr></table></figure><p>虽然在 <code>App.tsx</code> 中使用过 <code>BrowserRouter</code>，但是不如自己封装来的快，因为这块很多地方都要用到，比如如上所述的鉴权的位置，用于登陆验证过后的跳转</p><h2 id="数据统计图"><a href="#数据统计图" class="headerlink" title="数据统计图"></a>数据统计图</h2><p>这次的数据统计图没有使用诸如 <code>echart.js</code> 和 <code>highchart.js</code> 的原因部分是因为觉得没有多大必要，觉得自己使用 <code>svg</code> 来实现或许会更加好一点，有点造轮子的意思，不过还是挺有趣的。当然这次也没有选中 <code>canvas</code> 的原因是 <code>svg</code> 有个好处就是不依赖 <strong>分辨率</strong>，因为它生成的图像是基于<strong>矢量位图</strong> 的，你放大缩小都不会失真。</p><h3 id="折线图"><a href="#折线图" class="headerlink" title="折线图"></a>折线图</h3><p>折线图就是下图这玩意儿</p><p><img src="./1.png" alt></p><p>我这边是先实现的折线图，所以先说一下大概是怎么实现的，代码如下所示</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">// src/components/statistics/polyline.tsx</span><br><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">className</span>=<span class="string">"polyline peity"</span> <span class="attr">width</span>=<span class="string">"100%"</span> <span class="attr">height</span>=<span class="string">"60"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">polygon</span></span></span><br><span class="line"><span class="tag">    <span class="attr">fill</span>=<span class="string">"rgba(215,78,78,0.1)"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">points</span>=<span class="string">&#123;this.points()&#125;</span></span></span><br><span class="line"><span class="tag">  /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">polygon</span></span></span><br><span class="line"><span class="tag">    <span class="attr">fill</span>=<span class="string">"none"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">stroke</span>=<span class="string">"rgba(215,78,78,0.5)"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">strokeWidth</span>=<span class="string">"1"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">strokeLinecap</span>=<span class="string">"square"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">points</span>=<span class="string">&#123;this.points()&#125;</span></span></span><br><span class="line"><span class="tag">  /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这里有几个属性，说明一下</p><ul><li><code>fill</code>: 表示填充进 <code>svg</code> 框住的那部分，取值是颜色</li><li><code>points</code>: 就是描线，线的坐标</li><li><code>stroke</code>: 表示 <code>fill</code> 外层的那条线，取值也是颜色</li><li><code>strokeWidth</code>: 表示线宽</li><li><code>strokeLinecap</code>: 表示从起点到终点的线它两边的形状，可以是 <code>butt | round | square | inherit</code></li></ul><p>这里的逻辑很好理解，就是 <code>svg</code> 包 <code>polygon</code> 画线并填充颜色，然后是坐标点的计算</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">points = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> &#123; data, finishedCount, width &#125; = <span class="keyword">this</span>.props</span><br><span class="line">  <span class="comment">// 首先传入的 data 是一个类似 &#123;'时间1': &#123;...&#125;, '时间2': &#123;...&#125;&#125; 这样的对象</span></span><br><span class="line">  <span class="comment">// 这里首先要做的就是根据时间大小排序</span></span><br><span class="line">  <span class="comment">// 得到一个 ['时间1', '时间2', ...] 的数组</span></span><br><span class="line">  <span class="keyword">const</span> datesKeys = <span class="built_in">Object</span>.keys(data).sort(</span><br><span class="line">    (a, b) =&gt; &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Date</span>.parse(a) - <span class="built_in">Date</span>.parse(b)</span><br><span class="line">    &#125;</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 计算起始点和终止点的坐标</span></span><br><span class="line">  <span class="keyword">const</span> firstDay = datesKeys[<span class="number">0</span>]</span><br><span class="line">  <span class="keyword">const</span> startPoints = <span class="string">'0,60'</span></span><br><span class="line">  <span class="keyword">const</span> lastPoints = <span class="string">`<span class="subst">$&#123;width&#125;</span>,60`</span></span><br><span class="line">  <span class="keyword">if</span> (!firstDay) <span class="keyword">return</span> [<span class="string">`<span class="subst">$&#123;startPoints&#125;</span>`</span>, <span class="string">`<span class="subst">$&#123;lastPoints&#125;</span>`</span>].join(<span class="string">' '</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> lastDay = datesKeys[datesKeys.length - <span class="number">1</span>]</span><br><span class="line">  <span class="comment">// 若是同一天有很多任务，并且只有这一天的情况下，dayRange 有可能是 0</span></span><br><span class="line">  <span class="keyword">const</span> dayRange = <span class="built_in">Date</span>.parse(lastDay) - <span class="built_in">Date</span>.parse(firstDay) || <span class="number">1</span></span><br><span class="line">  <span class="keyword">let</span> count = <span class="number">0</span></span><br><span class="line">  <span class="keyword">let</span> lastY</span><br><span class="line">  <span class="comment">// 画折线图需要 x y 坐标</span></span><br><span class="line">  <span class="comment">// 有断点的折线图每个 x y 都是有范围的</span></span><br><span class="line">  <span class="comment">// 所以这里需要除一个 range</span></span><br><span class="line">  <span class="keyword">const</span> pointsArray = datesKeys.map(<span class="function">(<span class="params">datesKey: any</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> x = (<span class="built_in">Date</span>.parse(datesKey) - <span class="built_in">Date</span>.parse(firstDay)) / dayRange * (width || <span class="number">320</span>)</span><br><span class="line">    count += <span class="keyword">this</span>.props.data[datesKey].length</span><br><span class="line">    <span class="keyword">const</span> y = (<span class="number">1</span> -  (count / finishedCount)) * <span class="number">60</span></span><br><span class="line">    lastY = y</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;x&#125;</span>,<span class="subst">$&#123;y&#125;</span>`</span></span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> [<span class="string">`<span class="subst">$&#123;startPoints&#125;</span>`</span>, ...pointsArray, <span class="string">`<span class="subst">$&#123;width&#125;</span>,<span class="subst">$&#123;lastY&#125;</span>`</span>, <span class="string">`<span class="subst">$&#123;lastPoints&#125;</span>`</span>].join(<span class="string">' '</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里本质上就是求出一个多边形每个点 x 和 y 的坐标，然后求出 range 范围有个对应的关系，基本上就能搞定了</p><h3 id="条形柱状图"><a href="#条形柱状图" class="headerlink" title="条形柱状图"></a>条形柱状图</h3><p>条形柱状图就是下面这玩意儿</p><p><img src="./2.png" alt></p><p>这个逻辑就是在 <code>svg</code> 中渲染 <code>rect</code></p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">className</span>=<span class="string">"bar-chart"</span> <span class="attr">width</span>=<span class="string">'100%'</span> <span class="attr">height</span>=<span class="string">&#123;height&#125;</span>&gt;</span></span><br><span class="line">&#123;</span><br><span class="line">  this.points().map((point, index) =&gt; (</span><br><span class="line">    <span class="tag">&lt;<span class="name">rect</span> <span class="attr">key</span>=<span class="string">&#123;index&#125;</span> <span class="attr">fill</span>=<span class="string">"rgba(215,78,78,0.5)"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">x</span>=<span class="string">&#123;point[0]&#125;</span> <span class="attr">y</span>=<span class="string">&#123;point[1]&#125;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">width</span>=<span class="string">&#123;16&#125;</span> <span class="attr">height</span>=<span class="string">&#123;height</span> <span class="attr">-</span> <span class="attr">point</span>[<span class="attr">1</span>] || <span class="attr">0</span>&#125;</span></span><br><span class="line"><span class="tag">    /&gt;</span></span><br><span class="line">  ))</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>width</code>: 柱子的宽度</li><li><code>height</code>: 柱子的高度</li><li><code>fill</code>: 颜色填充，之前说过</li><li><code>x</code>: <code>x</code> 坐标值</li><li><code>y</code>: <code>y</code> 坐标值</li><li><code>key</code>: 就是 <code>key</code>，一个 key 值，因为要渲染多个，所以需要这个指明每个 <code>rect</code> 元素的 id</li></ul><p>坐标点计算逻辑如下</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/components/statistics/barChart.tsx</span></span><br><span class="line">points = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; data, finishedCount &#125; = <span class="keyword">this</span>.props</span><br><span class="line">  <span class="keyword">const</span> xRange = <span class="number">10</span></span><br><span class="line">  <span class="comment">// 利用 reduce 找出数据中7天中完成西瓜数最多的数</span></span><br><span class="line">  <span class="comment">// data 传进来就是周一到周日的数据</span></span><br><span class="line">  <span class="comment">// &#123;0: [...], 1: [...], ...&#125;</span></span><br><span class="line">  <span class="keyword">const</span> yRange = data.reduce(</span><br><span class="line">    (acc, cur) =&gt; &#123;</span><br><span class="line">      <span class="keyword">return</span> acc &gt; cur.length ? acc : cur.length</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="number">0</span></span><br><span class="line">  )</span><br><span class="line">  <span class="comment">// 这里用的就是计数法，哪个上面 length 大说明这个柱子 y 坐标越大</span></span><br><span class="line">  <span class="keyword">return</span> data.map(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> x = (index + gap) / xRange * finishedCount - <span class="number">8</span></span><br><span class="line">    <span class="keyword">let</span> y = (<span class="number">1</span> - item.length / (yRange || <span class="number">1</span>)) * height</span><br><span class="line">    y &gt;= height &amp;&amp; (y = height - <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> [x, y]</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="点线图"><a href="#点线图" class="headerlink" title="点线图"></a>点线图</h3><p>点线图就是下面这玩意儿</p><p><img src="./3.png" alt></p><p>分析下，首先是背景的那个灰色的矩形框，就用 <code>rect</code> 绘制，然后使用 <code>path</code> 画线，用 <code>circle</code> 画圆圈，用 <code>text</code> 表示下面的点</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">width</span>=<span class="string">'100%'</span> <span class="attr">height</span>=<span class="string">'200'</span>&gt;</span></span><br><span class="line">  // 灰色背景图</span><br><span class="line">  <span class="tag">&lt;<span class="name">rect</span> <span class="attr">x</span>=<span class="string">&#123;0&#125;</span> <span class="attr">y</span>=<span class="string">&#123;0&#125;</span> <span class="attr">width</span>=<span class="string">'100%'</span> <span class="attr">height</span>=<span class="string">&#123;170&#125;/</span>&gt;</span></span><br><span class="line">  // 描线</span><br><span class="line">  <span class="tag">&lt;<span class="name">path</span></span></span><br><span class="line"><span class="tag">    <span class="attr">d</span>=<span class="string">&#123;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">this.points</span>()<span class="attr">.reduce</span>(</span></span><br><span class="line"><span class="tag">        // <span class="attr">M</span>,<span class="attr">x</span>,<span class="attr">y</span>,<span class="attr">x1</span>,<span class="attr">y1</span> 的形式画直线</span></span><br><span class="line"><span class="tag">        (<span class="attr">acc</span>, <span class="attr">cur</span>) =&gt;</span> acc.concat(`$&#123;cur.slice(0,2).join(',')&#125;,`),</span><br><span class="line">        'M'</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">   /&gt;</span><br><span class="line">  &#123;</span><br><span class="line">    // x 坐标轴上的值显示 1 2 3 4...</span><br><span class="line">    this.points().map(</span><br><span class="line">      // 隔一个显示一个</span><br><span class="line">      (point, index) =&gt; (</span><br><span class="line">        index % 2 === 0</span><br><span class="line">        ? <span class="tag">&lt;<span class="name">text</span> <span class="attr">key</span>=<span class="string">&#123;index&#125;</span> <span class="attr">x</span>=<span class="string">&#123;point[0]</span> <span class="attr">-</span> <span class="attr">5</span>&#125; <span class="attr">y</span>=<span class="string">"200"</span>&gt;</span></span><br><span class="line">            &#123;index + 1&#125;</span><br><span class="line">          <span class="tag">&lt;/<span class="name">text</span>&gt;</span></span><br><span class="line">        : null</span><br><span class="line">    ))</span><br><span class="line">  &#125;</span><br><span class="line">  &#123;</span><br><span class="line">    this.points().map((point, index) =&gt; (</span><br><span class="line">      <span class="tag">&lt;<span class="name">Tooltip</span></span></span><br><span class="line"><span class="tag">        <span class="attr">key</span>=<span class="string">&#123;index&#125;</span> <span class="attr">placement</span>=<span class="string">"top"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">title</span>=<span class="string">&#123;</span>`$&#123;<span class="attr">point</span>[<span class="attr">2</span>]&#125;`&#125; <span class="attr">overlayClassName</span>=<span class="string">'daily_tips'</span>&gt;</span></span><br><span class="line">        &#123;/* 坐标点对应的⚪ */&#125;</span><br><span class="line">        <span class="tag">&lt;<span class="name">circle</span> <span class="attr">r</span>=<span class="string">&#123;this.circleRadius&#125;</span> <span class="attr">cx</span>=<span class="string">&#123;point[0]&#125;</span> <span class="attr">cy</span>=<span class="string">&#123;point[1]&#125;</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">Tooltip</span>&gt;</span></span><br><span class="line">    ))</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注意这里使用了 <code>Tooltip</code> 组件， 表示鼠标悬浮上去之后会有一个提示冒出来</p><p>点坐标的计算就是如下</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">points = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; data, xRange, width &#125; = <span class="keyword">this</span>.props</span><br><span class="line">  <span class="comment">// data 同样是一个类似 &#123;0: [...], 1: [...]&#125; 的对象</span></span><br><span class="line">  <span class="comment">// 这里用 reduce 找出 y 的最大范围值，好用来定高度</span></span><br><span class="line">  <span class="keyword">let</span> yRange = <span class="built_in">Object</span>.keys(data).reduce(</span><br><span class="line">    (acc, cur) =&gt; &#123;</span><br><span class="line">      <span class="keyword">return</span> acc &gt; data[cur].length ? acc : data[cur].length</span><br><span class="line">    &#125;</span><br><span class="line">  , <span class="number">0</span>)</span><br><span class="line">  yRange === <span class="number">0</span> &amp;&amp; (yRange = <span class="number">5</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Object</span>.keys(data).map(</span><br><span class="line">    date =&gt; &#123;</span><br><span class="line">      <span class="keyword">const</span> x = (<span class="keyword">new</span> <span class="built_in">Date</span>(date).getDate() - <span class="number">0.5</span>) / xRange * (width - xBias)</span><br><span class="line">      <span class="keyword">const</span> y = (<span class="number">1</span> - data[date].length / yRange) * <span class="number">160</span> + yBias</span><br><span class="line">      <span class="comment">// 这里需要返回一个 [x, y, 一个数] 是为了 Tooltip 做兼容用的</span></span><br><span class="line">      <span class="keyword">return</span> [x, y, data[date].length]</span><br><span class="line">    &#125;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="项目难点"><a href="#项目难点" class="headerlink" title="项目难点"></a>项目难点</h2><p>项目难点有 2</p><h3 id="使用-svg-矢量图的大小缩放的问题"><a href="#使用-svg-矢量图的大小缩放的问题" class="headerlink" title="使用 svg 矢量图的大小缩放的问题"></a>使用 svg 矢量图的大小缩放的问题</h3><p><img src="./4.png" alt></p><p>因为在项目中还稍微用媒体查询做了下小屏幕的适配，但是在小屏幕适配下图形就显得不是很好看了，为了兼容这个小屏幕，花了点心思，首先使用 <code>css</code> 这种自适应适配的方式是不行的，不管是 <code>flex</code> 还是 <code>100%</code> 这种方式都不能使其适应小屏幕的宽度，所以最后采用 js 来解决，怎么解决的呢，一般来说分为以下几步</p><ul><li>获取到其中一个 <code>li</code> 的宽度<br>  因为其实三个宽度都一样，只要获取到其中一个就可以了</li><li>将其加入点坐标的计算</li><li>完</li></ul><p>加入点坐标计算上面已经说过了，现在说下宽度是怎么搞的</p><p>首先在 <code>statistics</code> 组件中引入两个变量</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/components/statistics/statistics.tsx</span></span><br><span class="line"><span class="keyword">this</span>.state = &#123;</span><br><span class="line">  liWidth: <span class="keyword">this</span>.liRef.current?.offsetWidth || <span class="number">0</span>,</span><br><span class="line">  ulWidth: <span class="keyword">this</span>.ulRef.current?.offsetWidth || <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应的 <code>liRef</code> 和 <code>ulRef</code> 为</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">ulRef = React.createRef&lt;HTMLUListElement&gt;()</span><br><span class="line">liRef = React.createRef&lt;HTMLLIElement&gt;()</span><br></pre></td></tr></table></figure><p>然后需要设定一个 <code>updateSize</code> 函数，就是当其宽度变时就要调用的</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">updateSize = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> liWidth = <span class="keyword">this</span>.liRef.current?.offsetWidth || <span class="number">0</span></span><br><span class="line">  <span class="keyword">let</span> ulWidth = <span class="keyword">this</span>.ulRef.current?.offsetWidth || <span class="number">0</span></span><br><span class="line">  ulWidth &lt; <span class="number">0</span> &amp;&amp; (ulWidth = <span class="number">0</span>)</span><br><span class="line">  <span class="keyword">this</span>.state.liWidth !== liWidth &amp;&amp; (</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; liWidth &#125;)</span><br><span class="line">  )</span><br><span class="line">  <span class="keyword">this</span>.state.ulWidth !== ulWidth &amp;&amp; (</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; ulWidth &#125;)</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到其实这里就是初始化的操作，利用 dom 的 <code>current.offsetWidth</code> 的属性确定宽度</p><p>然后在组件挂载时需要监听 <code>resize</code> 事件</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">componentDidMount() &#123;</span><br><span class="line">  <span class="keyword">this</span>.updateSize()</span><br><span class="line">  <span class="built_in">window</span>.addEventListener(<span class="string">'resize'</span>, <span class="keyword">this</span>.updateSize)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在组件销毁时需要取消监听 <code>resize</code> 事件避免内存泄露</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">componentWillUnmount() &#123;</span><br><span class="line">  <span class="built_in">window</span>.removeEventListener(<span class="string">'resize'</span>, <span class="keyword">this</span>.updateSize)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在把这两个 <code>ref</code> 定位到对应的 dom 上即可</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">className</span>=<span class="string">"statistics"</span> <span class="attr">ref</span>=<span class="string">&#123;this.ulRef&#125;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">className</span>=<span class="string">&#123;monthlyTitleClasses&#125;</span> <span class="attr">ref</span>=<span class="string">&#123;this.liRef&#125;</span> /&gt;</span></span><br><span class="line">  ...</span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure><p>这样通过 <code>resize</code> 就拿到了该组件的 <code>width</code>，在下面计算图形的宽度时就可以代入加参数计算了，一般来说这里就是计算一个 range 即可。</p><h3 id="有关一个组件通信的功能"><a href="#有关一个组件通信的功能" class="headerlink" title="有关一个组件通信的功能"></a>有关一个组件通信的功能</h3><p>就是西瓜闹钟在运行时，本来是想让 <code>waterMelon</code> 组件和 <code>todos</code> 组件有个通信的过程的，比如将正在计时中的 <code>waterMelon</code> 和 <code>todos</code> 关联起来，如果此时有完成的 <code>todos</code> 任务，那么在计时后，完成的 <code>todos</code> 几个任务的 “合体” <code>description</code> 就是西瓜闹钟的 <code>description</code>，比如我完成了 <code>todo1</code> 和 <code>todo2</code> 和 <code>todo3</code>，那么在 <code>watermelon</code> 结束计时后其 <code>description</code> 就是 <code>todo1 + todo2 + todo3</code> 这种形式做自动填充。不过这个地方有些难度，主要在于代码实现比较难看所以我没继续添加了。我想了下有几种方案</p><ol><li>每次完成一个 <code>todos</code>，都向后端发送一个请求记录当前的 <code>todos</code> 到 <code>waterMelon</code> 中</li><li>将 <code>todos</code> 的数据用 <code>props</code> 传给 <code>waterMelon</code> 组件，只要 <code>todos</code> 有变化就改变 <code>waterMelon</code> 中的 <code>state.description</code></li><li>将 <code>description</code> 提升到 <code>redux</code> 中，每次完成一个 <code>todos</code>，发送一个 <code>actionType</code>，<code>waterMelon</code> 接受这个并不属于它的 <code>actionType</code>，将 <code>todo</code> 的 <code>description</code> 合并到 <code>waterMelon</code> 中</li><li>搞一个 window 全局变量存 <code>description</code>…</li></ol><p>首先我想要说明的是，这里我尽量想做到 <strong>高内聚低耦合</strong>，然而这里的尴尬之处在于要实现这样的功能，这两个组件在这点上居然是强耦合的，以致于说以上的方案虽然可行一点点，但是在代码上就非常的不整洁，因为</p><ol><li>每次发请求处理相当的麻烦，而且也不是一种优化，要知道请求一多也容易降低 app 的性能</li><li>这样做只能是在 <code>componentDidUpdate</code> 这个生命周期里面来 <code>setState</code>，处理一不小心就无限循环了，这还能行???</li><li>这样也不好，耦合了，而且这个功能并不是一开始就想出来的，而是后面加的，如果要该则需要改动代码的范围大，只能是重构有时间的情况下弄弄。代码一旦庞大就不好出手了，这也是很重要的一点。</li><li>这个想都不要想，全局变量污染的问题不应该再犯了…</li></ol><p>综上，由于这个功能十分的的蛋疼(因为点击完成一个 todo 既要更新 <code>todos</code> 的数据又要更新 <code>waterMelon</code> 的数据简单使用 <code>actionType</code> 来做区分是不现实的)，而且目前也没有找到一个更加优雅的解决方案，故先搁置(或许如果各位感兴趣了我可以重构的((<em>^_^</em>)), 先别慌老铁)</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总之 TypeScript 是真香，少了自由度但是多了类型检查，能够不太费力的解决编程中因为静态视力导致的一些超级低级的 bug，以及 react 也真香，函数即UI这种思想很棒，而且天然支持 TypeScript，社区活跃并且轮子很多，也不乏优秀的插件，也许这就是是我转向 react 的原因之一吧哈哈。</p><h2 id="文档参考"><a href="#文档参考" class="headerlink" title="文档参考"></a>文档参考</h2><p><a href="https://ant.design/docs/react/use-in-typescript-cn" target="_blank" rel="noopener">在 TypeScript 中使用</a><br><a href="https://ant.design/docs/react/migration-v4-cn" target="_blank" rel="noopener">从 V3 到 V4</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;注意，本项目是基于 &lt;code&gt;create-react-app&lt;/code&gt; 搭建，但是使用了 &lt;code&gt;--typescript&lt;/code&gt; 选项，所以是基于 &lt;code&gt;TypeScript&lt;/code&gt; 写的。另外，&lt;a href=&quot;https://github.com/strugglebak/watermelon-clock&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;项目地址在这里，求各位大佬看到了如果喜欢还请点个小星星(拜托啦这真的对我很重要 QAQ)&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="TypeScript" scheme="https://strugglebak.github.io/categories/TypeScript/"/>
    
      <category term="React" scheme="https://strugglebak.github.io/categories/TypeScript/React/"/>
    
    
      <category term="TypeScript" scheme="https://strugglebak.github.io/tags/TypeScript/"/>
    
      <category term="React" scheme="https://strugglebak.github.io/tags/React/"/>
    
      <category term="WaterMelon-clock" scheme="https://strugglebak.github.io/tags/WaterMelon-clock/"/>
    
  </entry>
  
  <entry>
    <title>txios-基于TypeScript的http库的实践总结</title>
    <link href="https://strugglebak.github.io/2020/03/14/txios-%E5%9F%BA%E4%BA%8ETypeScript%E7%9A%84http%E5%BA%93%E7%9A%84%E5%AE%9E%E8%B7%B5%E6%80%BB%E7%BB%93/"/>
    <id>https://strugglebak.github.io/2020/03/14/txios-基于TypeScript的http库的实践总结/</id>
    <published>2020-03-13T16:06:28.000Z</published>
    <updated>2022-06-04T08:13:29.071Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本次项目是对自己用 TypeScript 造的一个轮子的总结，麻雀虽小，但已经尽量五脏俱全，希望各位能多多 star(摩多摩多~)，<a href="https://github.com/strugglebak/txios" target="_blank" rel="noopener">毕竟项目地址都在这儿了各位 QAQ</a></p></blockquote><a id="more"></a><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><h3 id="使用的工具库"><a href="#使用的工具库" class="headerlink" title="使用的工具库"></a>使用的工具库</h3><p>这里罗列下使用到的一些工具库吧</p><ul><li><p>rollupjs</p><p>  这是一个帮助 txios 项目打包的库，打包方面没有选择 Webpack 的原因是因为这个比较好配置, <strong>API 简单</strong>。并且由于其<strong>基于 ES2015 模块</strong>，比 Webpack 使用的 CommonJS 模块机制更加高效，同时也更加容易执行 <strong><code>tree-shaking</code></strong></p></li><li><p>prettier/tslint</p><p>  这两个是比较重要的代码风格检查工具库了，在写一些工具库的时候尤其需要注意配合使用的</p></li><li><p>typeDoc</p><p>  文档生成工具，毕竟写一个库需要自动生成文档给开发者看，并且这个库也能帮忙部署到 Github page 上</p></li><li><p>commitizen</p><p>  主要用来规范 commit 提交信息，这个是很有好处的，清晰和规范的提交可以看出你对修改过的文件做了什么，这个是很重要的</p></li><li><p>Semantic-release</p><p>  这个库主要用来处理自动化版本管理和包发布用的。</p></li><li><p>husky</p><p>  使用这个工具，可以在每次的 git commit 之前执行已经定义好的 hook 脚本，可以用来自动化的检查代码质量</p></li><li><p>conventional-changelog</p><p>  当写完一个工具库，你做了啥修改，使用这个配合 Commitizen ，在生成 release 包时会自动将你所修改的 changeLog 发布出来</p></li><li><p>jest</p><p>  著名的测试工具库，主要是用于一些工具库或者 UI 组件库的测试。一般而言是配合 <code>chai</code>、<code>sion</code> 使用</p></li></ul><blockquote><p>⚠: 1.如果搭建环境过程中碰到了 <code>permission denied</code> 之类的字样，请<strong>关闭 vscode 试试</strong></p></blockquote><blockquote><p>⚠: 2.如果在项目中执行 <code>semantic-release</code> 时遇到了类似这样的错误 <code>SemanticReleaseError: No GitHub token specified</code>，请首先去你的 github 账号的 settings 那里的 Developer settings 里新建一个 Personal access tokens ( <a href="https://strugglebak.github.io/2020/03/11/%E9%85%8D%E7%BD%AE%E4%BB%A3%E7%A0%81%E8%A6%86%E7%9B%96%E7%8E%87%E5%BE%BD%E6%A0%87%E7%9A%84%E9%97%AE%E9%A2%98/">具体可参考我写的一篇博客</a> )，然后再到<strong>本地</strong>执行 <code>export GITHUB_TOKEN=&quot;你的 token&quot;</code>，最后再执行 <code>semantic-release</code> 即可。我想了下这可能是由于 <code>semantic-release</code> 是读取系统当前用户的环境变量所导致的，本地的 travis 并没有将其设置进环境变量中，而只是设置到项目的 <code>.travis.yml</code> 配置文件中了</p></blockquote><h3 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h3><p>一般来说，这里是先建立 <code>src</code> 以及 <code>test</code> 文件夹，<code>src</code> 就存放源码部分，<code>test</code> 就存放测试代码部分, <code>examples</code> 就存放代码的用例，当然这个用例跟测试用例是不一样的，这个只是方便写出了功能做调试用。你可以理解为 <code>examples</code> 就是这个库的一个应用了，可以在 <code>examples</code> 目录下新建一个 <code>webpack.config.js</code>，里面利用 webpack 的 <code>HotModuleReplacementPlugin</code> 插件建立模块热替换，当更改了模块之后就可以进行局部更新了。</p><p>这里还要强调的部分是对 <code>entry</code> 做了处理，因为 <code>examples</code> 下面有多个 demo 目录，而每个 demo 目录下都有 <code>app.ts</code> 文件作为这个 webpack 的入口文件, 因此 <code>entries</code> 需要收集 <code>examples</code> 下的这些个 <code>app.ts</code>，因为每个入口又引入了一个用于热更新的文件，所以看到的 <code>entry</code> 的配置基本如下</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"></span><br><span class="line">entry: fs.readdirSync(__dirname).reduce(<span class="function">(<span class="params">entries, dir</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> fullDir = path.join(__dirname, dir);</span><br><span class="line">  <span class="keyword">const</span> entryFile = path.join(fullDir, <span class="string">'app.ts'</span>);</span><br><span class="line">  <span class="keyword">if</span> (fs.statSync(fullDir).isDirectory() &amp;&amp; fs.existsSync(entryFile)) &#123;</span><br><span class="line">    entries[dir] = [<span class="string">'webpack-hot-middleware/client'</span>, entryFile];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> entries;</span><br><span class="line">&#125;, &#123;&#125;),</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>而基本上可以看到这里就是典型的多入口配置，代码的逻辑其实很简单</p><ul><li>读取当前目录下的各个 demo 目录的 <code>app.ts</code></li><li>构建诸如 <code>{&#39;demo&#39;: [&#39;webpack-hot-middleware/client&#39;, &#39;./demo/app.ts&#39;]}</code> 这样的 <code>entries</code> 对象</li><li>返回这个 <code>entries</code> 对象</li></ul><p>那么为何要加上这个 <code>webpack-hot-middleware/client</code> 呢？先别急，我们先在 <code>examples</code> 目录下构建这样一个 <code>server.js</code> 文件，然后引入 <code>webpack</code> 以及 <code>webpack.config.js</code></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>);</span><br><span class="line"><span class="keyword">const</span> middleware = <span class="built_in">require</span>(<span class="string">'webpack-dev-middleware'</span>);</span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>);</span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"><span class="keyword">const</span> complier = webpack(webpackConfig);</span><br><span class="line"></span><br><span class="line">app.use(</span><br><span class="line">  middleware(compiler, &#123;</span><br><span class="line">    <span class="comment">// webpack-dev-middleware options</span></span><br><span class="line">  &#125;)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>, () =&gt; <span class="built_in">console</span>.log(<span class="string">'Example app listening on port 3000!'</span>));</span><br></pre></td></tr></table></figure><p>这里我们是通过 <code>node server.js</code> 来启动这个应用，然后引入 <code>webpack</code> 以及 <code>webpack.config.js</code> 来打包这个应用，然而这里我们还要引入一个包叫 <code>webpack-hot-middleware</code>，如果需要做热更新的话，需要在每个入口文件处引入 <code>hot middleware client</code>，具体的做法就是上面说的，在入口文件处添加 <code>webpack-hot-middleware/client</code> 就好</p><p>添加完后，在 <code>server.js</code> 中添加</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> webpackHotMiddleware = <span class="built_in">require</span>(<span class="string">'webpack-hot-middleware'</span>);</span><br><span class="line">...</span><br><span class="line">app.use(webpackHotMiddleware(complier));</span><br></pre></td></tr></table></figure><p><code>examples</code> 目录下应用 <code>demo</code> 的目录基本是这样的形式，<code>demo</code> 有两个文件</p><ul><li><code>app.ts</code></li><li><code>index.html</code></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// demo/app.ts</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> txios <span class="keyword">from</span> <span class="string">'../../src/index'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行 txios 相关的操作</span></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">// demo/index.html</span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Demo example<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  // 注意这里引入了生成好的 demo.js，也就是被编译好的当前目录下的 app.ts !!!</span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"/__build__/demo.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="其他工具的配置"><a href="#其他工具的配置" class="headerlink" title="其他工具的配置"></a>其他工具的配置</h3><p>说几个比较重要的</p><h4 id="非工作流工具配置"><a href="#非工作流工具配置" class="headerlink" title="非工作流工具配置"></a>非工作流工具配置</h4><ul><li><p>编辑器的配置，用于规范团队代码、文档在 vscode 上的统一编辑以及显示的 <code>.editorconfig</code></p>  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// .editorconfig</span><br><span class="line"><span class="comment">#root = true</span></span><br><span class="line">[*] <span class="comment"># 表示匹配所有文件</span></span><br><span class="line">end_of_line = lf <span class="comment">#  当一行文字被回车时，对应的回车字符为 lf</span></span><br><span class="line">charset = utf-8 <span class="comment"># 使用 utf-8 编码</span></span><br><span class="line">trim_trailing_whitespace = <span class="literal">false</span> <span class="comment"># 不从行尾删除空白</span></span><br><span class="line">insert_final_newline = <span class="literal">true</span> <span class="comment"># 文件以换行结束</span></span><br><span class="line">indent_style = space <span class="comment"># 以空格作为 tab</span></span><br><span class="line">indent_size = 2 <span class="comment"># tab 间距为 2 个 space 宽度</span></span><br><span class="line"></span><br><span class="line">[&#123;*.yml,*.json&#125;] <span class="comment"># 匹配 .yml .json 文件</span></span><br><span class="line">indent_style = space <span class="comment"># 以空格作为 tab</span></span><br><span class="line">indent_size = 2 <span class="comment"># tab 间距为 2 个 space 宽度</span></span><br></pre></td></tr></table></figure></li><li><p>检查正在编辑的代码的语法的 <code>.eslintrc</code></p>  <figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">// .eslintrc</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"parserOptions"</span>: &#123; <span class="comment">// 解析选项</span></span><br><span class="line">    <span class="attr">"ecmaVersion"</span>: <span class="number">2017</span> <span class="comment">// 使用 es2017</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"env"</span>: &#123;</span><br><span class="line">    <span class="attr">"es6"</span>: <span class="literal">true</span> <span class="comment">// 支持 es6 以及新的 es6 全局变量</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>用于检查编写的 js 代码中的可疑部分的 <code>.jshintrc</code></p>  <figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">// .jshitrc</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"esversion"</span>: <span class="number">6</span> <span class="comment">// 指定代码必须遵循 es6 版本</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>用于指定 TypeScript 编译选项的 <code>tsconfig.json</code></p>  <figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">// tsconfig.json</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"compilerOptions"</span>: &#123; <span class="comment">// 编译选项配置</span></span><br><span class="line">    <span class="attr">"moduleResolution"</span>: <span class="string">"node"</span>, <span class="comment">// 以 Nodejs 方式 resolve 模块</span></span><br><span class="line">    <span class="attr">"target"</span>: <span class="string">"es5"</span>, <span class="comment">// 指定 es 的目标版本，其默认是 es3</span></span><br><span class="line">    <span class="attr">"module"</span>:<span class="string">"es2015"</span>, <span class="comment">// 指定模块代码以 es2015 的方式生成</span></span><br><span class="line">    <span class="attr">"lib"</span>: [<span class="string">"es2015"</span>, <span class="string">"es2016"</span>, <span class="string">"es2017"</span>, <span class="string">"dom"</span>], <span class="comment">// 指定要包含在编译中的库文件列表(编译时要包含进 es5/6/7 以及 DOM 的一些 API)</span></span><br><span class="line">    <span class="attr">"strict"</span>: <span class="literal">true</span>, <span class="comment">// 启用所有的严格类型检查选项</span></span><br><span class="line">    <span class="attr">"sourceMap"</span>: <span class="literal">true</span>, <span class="comment">// 编译后要生成 .map 源码映射文件</span></span><br><span class="line">    <span class="attr">"declaration"</span>: <span class="literal">true</span>, <span class="comment">// 编译后要生成 .d.ts 声明文件</span></span><br><span class="line">    <span class="attr">"allowSyntheticDefaultImports"</span>: <span class="literal">true</span>, <span class="comment">// 默认允许 import 那些没有进行 default export 的模块(这不影响代码的 export，只是会影响到类型检查)</span></span><br><span class="line">    <span class="attr">"experimentalDecorators"</span>: <span class="literal">true</span>, <span class="comment">// 启用对 es 装饰器语法的支持</span></span><br><span class="line">    <span class="attr">"emitDecoratorMetadata"</span>: <span class="literal">true</span>, <span class="comment">// 启用对 reflect-metadata 库的支持</span></span><br><span class="line">    <span class="attr">"declarationDir"</span>: <span class="string">"dist/types"</span>, <span class="comment">// 定义编译后生成的声明文件的输出目录为 dist/types</span></span><br><span class="line">    <span class="attr">"outDir"</span>: <span class="string">"dist/lib"</span>, <span class="comment">// 定义编译后代码文件的输出目录为 dist/lib</span></span><br><span class="line">    <span class="attr">"typeRoots"</span>: [ <span class="comment">// 编译过程中只考虑编译 node_modules/@types 下的包</span></span><br><span class="line">      <span class="string">"node_modules/@types"</span></span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"include"</span>: [ <span class="comment">// 只编译 src 下的源码文件</span></span><br><span class="line">    <span class="string">"src"</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>用于检查编写的 ts 代码中可读性、可维护性和功能错误的 <code>tslint.json</code></p>  <figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">// tslint.json</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"extends"</span>: [ <span class="comment">// 指定使用 tslint-config-standard 和 tslint-config-prettier 来检查</span></span><br><span class="line">    <span class="string">"tslint-config-standard"</span>,</span><br><span class="line">    <span class="string">"tslint-config-prettier"</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>用于测试代码的 <code>jest.config.js</code></p>  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// jest.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="string">"verbose"</span>: <span class="literal">true</span>, <span class="comment">// 指定在运行期间需要报告测试结果</span></span><br><span class="line">  <span class="string">"transform"</span>: &#123; <span class="comment">// 转换器</span></span><br><span class="line">    <span class="string">".(ts|tsx)"</span>: <span class="string">"ts-jest"</span> <span class="comment">// 使用 ts-jest 对 .ts/.tsx 文件代码进行测试</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"testEnvironment"</span>: <span class="string">"jsdom"</span>, <span class="comment">// 使用 jsdom 来作为测试环境</span></span><br><span class="line">  <span class="string">"testRegex"</span>: <span class="string">"(/__tests__/.*|\\.(test|spec))\\.(ts|tsx|js)$"</span>, <span class="comment">// 测试 __test__ 目录下所有的以 .test/.spec 作为中间名的、以 .ts/.tsx/.js 结尾的文件</span></span><br><span class="line">  <span class="string">"moduleFileExtensions"</span>: [ <span class="comment">// 模块文件拓展，测试文件中引入的模块支持 .ts/.tsx/.js 模块</span></span><br><span class="line">    <span class="string">"ts"</span>,</span><br><span class="line">    <span class="string">"tsx"</span>,</span><br><span class="line">    <span class="string">"js"</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="string">"coveragePathIgnorePatterns"</span>: [ <span class="comment">// 执行测试时需要过滤掉的一些目录 node_modules 和 test</span></span><br><span class="line">    <span class="string">"/node_modules/"</span>,</span><br><span class="line">    <span class="string">"/test/"</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="string">"coverageThreshold"</span>: &#123; <span class="comment">// 代码测试覆盖率设定</span></span><br><span class="line">    <span class="string">"global"</span>: &#123; <span class="comment">// 指定一个全局的设定</span></span><br><span class="line">      <span class="string">"branches"</span>: <span class="number">90</span>, <span class="comment">// 测试能覆盖到 90% 的代码分支</span></span><br><span class="line">      <span class="string">"functions"</span>: <span class="number">95</span>, <span class="comment">// 测试能覆盖到 95% 的函数</span></span><br><span class="line">      <span class="string">"lines"</span>: <span class="number">95</span>, <span class="comment">// 测试能覆盖到 95% 的代码行数</span></span><br><span class="line">      <span class="string">"statements"</span>: <span class="number">95</span> <span class="comment">// 测试能覆盖到 95% 的声明</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"collectCoverageFrom"</span>: [ <span class="comment">// 从以下文件中收集测试代码覆盖率的信息</span></span><br><span class="line">    <span class="string">"src/*.&#123;js,ts&#125;"</span>, <span class="comment">// src 下的当前目录的 .js 或者 .ts 文件</span></span><br><span class="line">    <span class="string">"src/**/*.&#123;js,ts&#125;"</span> <span class="comment">// src 下的子目录的 .js 或者 .ts 文件</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="string">"setupFilesAfterEnv"</span>: [ <span class="comment">// 在测试之前需要运行的一些启动或者配置文件</span></span><br><span class="line">    <span class="string">"&lt;rootDir&gt;/test/boot.ts"</span> <span class="comment">// 项目根目录下的 test/boot.ts</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  在 <code>boot.ts</code> 中写了什么呢</p>  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// test/boot.ts</span></span><br><span class="line"><span class="keyword">const</span> JasmineCore = <span class="built_in">require</span>(<span class="string">'jasmine-core'</span>)</span><br><span class="line"><span class="comment">// @ts-ignore</span></span><br><span class="line">global.getJasmineRequireObj = <span class="function"><span class="params">()</span> =&gt;</span> JasmineCore</span><br><span class="line"><span class="built_in">require</span>(<span class="string">'jasmine-ajax'</span>)</span><br></pre></td></tr></table></figure><p>  因为这里需要测试 ajax，所以这里用到了 <code>jasmine-ajax</code>，而这个库依赖于 <code>jasmine-core</code>。而为了能让 <code>jasmine-ajax</code> 这个插件运行成功，需要手动添加全局的 <code>getJasmineRequireObj</code> 方法，这样每次在启动测试的时候都会去加载这个插件，那么在测试时就可以使用 <code>jasmine-ajax</code> 了</p></li><li><p>用于整理和打包库的 <code>rollup.config.js</code></p>  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// rollup.config.js</span></span><br><span class="line"><span class="keyword">import</span> resolve <span class="keyword">from</span> <span class="string">'rollup-plugin-node-resolve'</span></span><br><span class="line"><span class="keyword">import</span> commonjs <span class="keyword">from</span> <span class="string">'rollup-plugin-commonjs'</span></span><br><span class="line"><span class="keyword">import</span> sourceMaps <span class="keyword">from</span> <span class="string">'rollup-plugin-sourcemaps'</span></span><br><span class="line"><span class="keyword">import</span> camelCase <span class="keyword">from</span> <span class="string">'lodash.camelcase'</span></span><br><span class="line"><span class="keyword">import</span> typescript <span class="keyword">from</span> <span class="string">'rollup-plugin-typescript2'</span></span><br><span class="line"><span class="keyword">import</span> json <span class="keyword">from</span> <span class="string">'rollup-plugin-json'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> pkg = <span class="built_in">require</span>(<span class="string">'./package.json'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> libraryName = <span class="string">'txios'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  input: <span class="string">`src/index.ts`</span>, <span class="comment">// 入口文件</span></span><br><span class="line">  output: [ <span class="comment">// 出口文件</span></span><br><span class="line">    <span class="comment">// 一个用来打包成 umd</span></span><br><span class="line">    &#123; <span class="attr">file</span>: pkg.ain, <span class="attr">name</span>: camelCase(libraryName), <span class="attr">format</span>: <span class="string">'umd'</span>, <span class="attr">sourcemap</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">    <span class="comment">// 一个用来打包成 es5</span></span><br><span class="line">    &#123; <span class="attr">file</span>: pkg.module, <span class="attr">format</span>: <span class="string">'es'</span>, <span class="attr">sourcemap</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">  ],</span><br><span class="line">  <span class="comment">// 指定不会被打包的源码目录</span></span><br><span class="line">  external: [],</span><br><span class="line">  watch: &#123; <span class="comment">// 如果 include 配置下的 src/ 目录下的某个模块源码变更，则自动进行打包</span></span><br><span class="line">    include: <span class="string">'src/**'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [ <span class="comment">// rollup 插件</span></span><br><span class="line">    <span class="comment">// 允许 resolve json 文件</span></span><br><span class="line">    json(),</span><br><span class="line">    <span class="comment">// 编译 TypeScript 文件</span></span><br><span class="line">    <span class="comment">// 并且编译的声明文件将在 tsconfig 中指定的目录中发出</span></span><br><span class="line">    typescript(&#123; <span class="attr">useTsconfigDeclarationDir</span>: <span class="literal">true</span> &#125;),</span><br><span class="line">    <span class="comment">// 允许打包 commonjs 模块</span></span><br><span class="line">    commonjs(),</span><br><span class="line">    <span class="comment">// 允许 resolve node_modules 下的文件，可以使用 'external' 属性去控制</span></span><br><span class="line">    <span class="comment">// 哪个 external 模块是被包含进打包后的文件中的</span></span><br><span class="line">    <span class="comment">// https://github.com/rollup/rollup-plugin-node-resolve#usage</span></span><br><span class="line">    resolve(),</span><br><span class="line"></span><br><span class="line">    <span class="comment">// resolve 对应源码的源码映射文件</span></span><br><span class="line">    sourceMaps(),</span><br><span class="line">  ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="工作流工具配置"><a href="#工作流工具配置" class="headerlink" title="工作流工具配置"></a>工作流工具配置</h4><p>最后再讲讲这个 git commit 以及自动发布 release 如何形成一个 flow 流的。首先我们前面提到了几个工具</p><ul><li>husky</li><li>commitizen</li><li>jest</li><li>conventional-changelog</li><li>semantic-release</li></ul><p>然后看看 <code>package.json</code> 里面是怎么写的，几个相关的配置如下</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">// package.json</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="attr">"scripts"</span>: &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="attr">"test"</span>: <span class="string">"jest --coverage --config ./jest.config.js"</span>,</span><br><span class="line">    <span class="attr">"test:watch"</span>: <span class="string">"jest --coverage --watch --config ./jest.config.js"</span>,</span><br><span class="line">    <span class="attr">"test:prod"</span>: <span class="string">"npm run lint &amp;&amp; npm run test -- --no-cache"</span>,</span><br><span class="line">    <span class="attr">"commit"</span>: <span class="string">"git-cz"</span>,</span><br><span class="line">    <span class="attr">"sr"</span>: <span class="string">"semantic-release"</span>,</span><br><span class="line">    <span class="attr">"srp"</span>: <span class="string">"ts-node tools/semantic-release-prepare"</span>,</span><br><span class="line">    <span class="attr">"pre-commit"</span>: <span class="string">"lint-staged"</span>,</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"lint-staged"</span>: &#123;</span><br><span class="line">    <span class="attr">"&#123;src,test&#125;/**/*.ts"</span>: [</span><br><span class="line">      <span class="string">"prettier --write"</span>,</span><br><span class="line">      <span class="string">"git add"</span></span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"husky"</span>: &#123;</span><br><span class="line">    <span class="attr">"hooks"</span>: &#123;</span><br><span class="line">      <span class="attr">"commit-msg"</span>: <span class="string">"commitlint -E HUSKY_GIT_PARAMS"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"config"</span>: &#123;</span><br><span class="line">    <span class="attr">"commitizen"</span>: &#123;</span><br><span class="line">      <span class="attr">"path"</span>: <span class="string">"node_modules/cz-conventional-changelog"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"prettier"</span>: &#123;</span><br><span class="line">    <span class="attr">"semi"</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">"singleQuote"</span>: <span class="literal">true</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"commitlint"</span>: &#123;</span><br><span class="line">    <span class="attr">"extends"</span>: [</span><br><span class="line">      <span class="string">"@commitlint/config-conventional"</span></span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当 <code>src</code> 下或者 <code>test</code> 目录下的代码文件产生变动后，执行 <code>yarn commit</code>时 ，会先触发 <code>lint-staged</code><br>，<code>lint-staged</code> 里面会先执行 <code>prettier</code> 将代码进行格式化，然后执行 <code>git add</code>。这个执行完之后，就可以执行 <code>git-cz</code> 了，<code>git-cz</code> 是 <code>commitizen</code> 包里面的一个工具，它就会找到 <code>cz-cli</code> 以及 <code>cz-conventional-changelog</code> 这两个工具并执行，执行后会生成如下的命令行界面</p><p><img src="./1.png" alt></p><p>格式都做好了，其他的就是自己选择自己根据提示来 commit message 就好</p><p>在输入的信息完成之后，就会交给 <code>husky</code> 去拦截 git 的 hooks，它一旦发现有 <code>commit msg</code> 要提交了就去拦截，然后执行操作 <code>commitlint -E HUSKY_GIT_PARAMS</code>，<code>commitlint</code> 是一个检查 <code>commit msg</code> 是否符合要求的一个库，这句话的意思是通过 <code>commitlint</code> 这个工具与它自己定义的 <code>HUSKY_GIT_PARAMS</code> 变量结合起来，若 commit 不符合要求，则此次 commit 算作失败</p><p>一般而言，符合 <code>commitlint</code> 要求的 commit 是像下面这样的</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">chore: run tests on travis ci</span><br><span class="line">fix(server): send cors headers</span><br><span class="line">feat(blog): add comment section</span><br></pre></td></tr></table></figure><p>其实这些都是根据 <a href="https://www.conventionalcommits.org/en/v1.0.0/" target="_blank" rel="noopener">传统提交格式</a> 来的。</p><p>总结一下这个工作流，简单而言就是如下</p><ol start="0"><li>代码变更了，我要提交代码，执行 <code>yarn commit</code></li><li><code>lint-staged</code> –&gt; <code>prettier</code> –&gt; <code>git add</code>(格式化代码)</li><li><code>git-cz</code> –&gt; <code>cz-cli</code> –&gt; <code>cz-conventional-changelog</code>(生成选择 commit 格式的界面并记录 changelog)</li><li><code>husky</code>(提供 commit 钩子并触发 <code>commitlint</code>)</li><li><code>commitlint</code>(检查 commit 是否满足要求)</li></ol><p>对于发布一个 release 包而言，其实逻辑都差不多。在执行 <code>yarn sr</code> 时，会执行 <code>semantic-release</code>，这里不做配置会直接校验 npm 的 token 和 github 的 token，校验过后它就会分析你的 commit 然后生成一个 changelog 并上传至 github 。如果想在这条命令之前执行代码测试直接在前面加上 <code>yarn test</code> 即可</p><h2 id="Feature-实现"><a href="#Feature-实现" class="headerlink" title="Feature 实现"></a>Feature 实现</h2><p>这里就大体实现的有一些功能做个总结吧。在 <a href="https://github.com/strugglebak/txios/blob/master/README.md" target="_blank" rel="noopener">txios 的文档</a> 上也有说明</p><ul><li>支持使用 XMLHttpRequest 对象通信</li><li>支持 Promise API</li><li>支持请求/响应拦截以及其过程中的数据转换</li><li>支持取消请求</li><li>支持自动转换 JSON 数据</li><li>客户端支持 XSRF 防御</li></ul><h3 id="支持使用-XMLHttpRequest-对象通信"><a href="#支持使用-XMLHttpRequest-对象通信" class="headerlink" title="支持使用 XMLHttpRequest 对象通信"></a>支持使用 XMLHttpRequest 对象通信</h3><p>其实这里面就是对 <code>XMLHttpRequest</code> 对象的封装。这里整体封装的逻辑是，先写一个大体的逻辑，就是封装一个函数，然后再在其他地方引入这个函数做测试。这个大体的框架是什么呢，就是如下的代码</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">xhr</span>(<span class="params">config: TxiosRequestConfig</span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; data = <span class="literal">null</span>, url, method = <span class="string">'get'</span> &#125; = config</span><br><span class="line">  <span class="keyword">const</span> request = <span class="keyword">new</span> XMLHttpRequest()</span><br><span class="line">  request.open(method.toUpperCase(), url, <span class="literal">true</span>)</span><br><span class="line">  request.send(data)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最开始其只有一个 <code>open</code> 跟 <code>send</code>，功能极为简陋，所以需要在上面添砖加瓦。<br>一般来说需要处理的东西包括</p><ul><li>请求的 url 数据</li><li>请求的 body 数据</li><li>请求的 header 数据</li><li>响应的数据</li><li>响应的 header 数据</li></ul><p>所以在这里面，除了要对请求的数据做处理之外，还需要对响应的数据做处理。这一部分主要的操作就是需要定义 <code>TxiosRequestConfig</code> 的类型，因为请求配置的参数很重要，所以在这里可以看到一堆的类型声明。这里有一个比较特别的声明叫做 <strong>字符串索引</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/types/index.ts</span></span><br><span class="line"><span class="keyword">export</span> interface TxiosRequestConfig &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  [propName: string]: any</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种就是字符串索引签名了，一般会在 <code>xxx[key]</code> 这种方式去访问一个对象内部 <code>key</code> 对应的 <code>value</code> 时用上。</p><p>这里需要注意的一下就是，在对处理请求的 body 数据时(因为要转换成 JSON 字符串发送出去)，会用到一个判断其是不是”普通”的对象的函数，如下所式</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">isNormalObject</span> (<span class="params">val: any</span>): <span class="title">val</span> <span class="title">is</span> <span class="title">Object</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> toString.call(val) === <span class="string">'[object Object]'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于 <code>val !== null &amp;&amp; typeof val === &#39;object&#39;</code> 这种方式虽然也能判断一个数是否为对象，但是其已经包括了 <code>FormData</code> 或者 <code>ArrayBuffer</code> 这样的类型了。而这些类型在 body 中是不需要处理成 JSON 字符串的(<code>JSON.stringify</code>)，如果是 <code>FormData</code> 类似这种类型的直接返回 data 就好不需要做处理</p><p>在处理 url 参数上需要注意的情况比较多，一般而言有如下几种</p><ul><li>参数值为数组的</li><li>参数值为对象的</li><li>参数值为 Date 类型的</li><li>还有一些特殊字符的</li><li>一些空值如 null 或者 undefined</li><li>有 hash 参数的比如 # 后面的</li><li>已经有参数的</li></ul><p>需要对这些参数遍历之后重新建立新的 url，对这些条件判断后拼接字符串</p><p>在对异常处理的方面，有两个要注意的点</p><ul><li>使用 TypeScript 继承一个内置对象时，需要使用在你继承的类中使用 <code>Object.setPrototypeOf(this, 你的类.prototype)</code> 才能做到正确的继承</li><li>为了使得代码更加简化，可以为类对外暴露一个 <strong>工厂方法</strong></li></ul><p>什么是工厂方法？工厂方法指的是<strong>一个函数</strong>接受参数并返回一个 <code>new</code> 过的对象，这样在下次使用时就不必频繁的 <code>new</code> 了，直接调用这个方法即可</p><h3 id="支持-Promise-API"><a href="#支持-Promise-API" class="headerlink" title="支持 Promise API"></a>支持 Promise API</h3><p>首先需要构建一个 <code>TxiosPromise</code> 的接口，这个接口继承自 Promise</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/types/index.ts</span></span><br><span class="line"><span class="keyword">export</span> interface TxiosPromise extends <span class="built_in">Promise</span>&lt;TxiosResponse&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意这里的 <code>Promise</code> 在返回后其 <code>resolve</code> 或者 <code>reject</code> 中的 <code>data</code> 就是 <code>TxiosResponse</code> 类型的</p><p>然后需要在 <code>Txios</code> 这个接口中的每个扩展方法的后面都要加上 <code>TxiosPromise</code> 作为返回值的声明</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/types/index.ts</span></span><br><span class="line"><span class="keyword">export</span> interface Txios &#123;</span><br><span class="line">  <span class="keyword">get</span>&lt;T = any&gt;(url: string, config?: TxiosRequestConfig): TxiosPromise</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在封装 <code>XMLHttpRequest</code> 那块的代码上也需要加上 <code>TxiosPromise</code> 的声明并返回一个 <code>new Promise</code></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/core/xhr.ts</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">xhr</span>(<span class="params">config: TxiosRequestConfig</span>): <span class="title">TxiosPromise</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么这里还有个问题，即如何让响应的数据支持泛型呢？首先需要对 <code>TxiosResponse</code> 做改造</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/types/index.ts</span></span><br><span class="line"><span class="keyword">export</span> interface TxiosResponse&lt;T = any&gt; &#123;</span><br><span class="line">  data: T</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样 <code>data</code> 就是泛型的数据了，接下来还要对上文中出现的 <code>TxiosPromise</code> 做一个改造，使其也变成一个泛型的接口</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/types/index.ts</span></span><br><span class="line"><span class="keyword">export</span> interface TxiosPromise&lt;T = any&gt; extends <span class="built_in">Promise</span>&lt;TxiosResponse&lt;T&gt;&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样在 <code>Promise</code> 中 <code>resolve</code> 或者 <code>reject</code> 的 <code>data</code> 就是 <code>TxiosResponse&lt;T&gt;</code> 类型的了，需要注意的是这个 <code>data</code> 中还有个 <code>data</code>(这个是在 <code>TxiosResponse</code> 中定义过的) 是 <code>T</code> 类型。<code>TxiosPromise&lt;T = any&gt;</code> 这个表示 <code>resolve</code> 或 <code>reject</code> 的 <code>data</code> 可以是 <code>T</code> 类型的数据</p><h3 id="支持请求-响应拦截以及其过程中的数据转换"><a href="#支持请求-响应拦截以及其过程中的数据转换" class="headerlink" title="支持请求/响应拦截以及其过程中的数据转换"></a>支持请求/响应拦截以及其过程中的数据转换</h3><p>首先拦截器的工作原理可以用一张图来描述</p><p><img src="./2.png" alt></p><p>一般我们使用 <code>txios.interceptors.request.use</code> 来添加请求拦截器，使用 <code>txios.interceptors.response.use</code> 来添加响应拦截器。由上图可以知道，拦截器的执行顺序是 <strong>链式调用的</strong>，并且每个拦截器都支持 <strong>同步和异步</strong>的处理。所以这里最终还是采用 <code>Promise</code> 链式调用去实现这个功能。</p><p>实现的逻辑大概是这样的</p><ul><li><p>首先定义个拦截器的总体的管理类，它里面有两个方法: <code>use</code>(添加拦截器) 和 <code>eject</code>(删除拦截器)。</p>  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/types/index.ts</span></span><br><span class="line"><span class="keyword">export</span> interface TxiosInterceptorManager&lt;T&gt; &#123;</span><br><span class="line">  use(resolved: ResolvedFn&lt;T&gt;, rejected?: RejectedFn): number</span><br><span class="line">  eject(id: number): <span class="keyword">void</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>use</code> 方法里面有 <code>resolve</code> 和 <code>reject</code> 方法，所以这俩也是要定义的</p>  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/types/index.ts</span></span><br><span class="line"><span class="keyword">export</span> interface ResolvedFn&lt;T = any&gt; &#123;</span><br><span class="line">  (value: T): T | <span class="built_in">Promise</span>&lt;T&gt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> interface RejectedFn &#123;</span><br><span class="line">  (error: any): any</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>接下来去实现这个管理类的时候，基本上就是去实现 <code>use</code> 和 <code>eject</code>。注意这个类里面维护了一个私有的 <code>interceptors</code> 数组</p>  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/core/interceptor.ts</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">InterceptorManager</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// use 就是将 resolve 和 reject push 进这个数组中并返回一个位置 id</span></span><br><span class="line">  use(resolved: ResolvedFn&lt;T&gt;, rejected?: RejectedFn): number &#123;</span><br><span class="line">    <span class="keyword">this</span>.interceptors.push(&#123; resolved, rejected &#125;)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.interceptors.length - <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// eject 就是拿到位置 id 然后删除拦截器</span></span><br><span class="line">  eject(id: number): <span class="keyword">void</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.interceptors[id]) <span class="keyword">this</span>.interceptors[id] = <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这里还写了个 forEach 函数用来遍历拦截器并执行它传入的拦截器</span></span><br><span class="line">  forEach(fn: <span class="function">(<span class="params">interceptor: Interceptor&lt;T&gt;</span>) =&gt;</span> <span class="keyword">void</span>): <span class="keyword">void</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.interceptors.forEach(<span class="function"><span class="params">interceptor</span> =&gt;</span> &#123;</span><br><span class="line">      interceptor &amp;&amp; fn(interceptor)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li><li><p>需要在发送请求的逻辑中构建 <code>Promise</code> 链，这个链的接口定义是这样的</p>  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/core/txios-core.ts</span></span><br><span class="line">interface PromiseChain &#123;</span><br><span class="line">  resolved: ResolvedFn | <span class="function">(<span class="params">(config: TxiosRequestConfig</span>) =&gt;</span> TxiosPromise)</span><br><span class="line">  rejected?: RejectedFn</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在 <code>TxiosCore</code> 这个方法中构造 <code>interceptors</code></p>  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/core/txios-core.ts</span></span><br><span class="line"><span class="keyword">constructor</span>(initConfig: TxiosRequestConfig) &#123;</span><br><span class="line">  <span class="keyword">this</span>.interceptors = &#123;</span><br><span class="line">    request: <span class="keyword">new</span> InterceptorManager&lt;TxiosRequestConfig&gt;(),</span><br><span class="line">    response: <span class="keyword">new</span> InterceptorManager&lt;TxiosResponse&gt;()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>然后在 <code>request</code> 这个请求方法中开始构建这个 <code>Promise Chain</code></p>  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/core/txios-core.ts</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">TxiosCore</span> </span>&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  request(url: any, config?: any): TxiosPromise &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">const</span> chain: PromiseChain[] = [</span><br><span class="line">      &#123;</span><br><span class="line">        resolved: dispatchRequest,</span><br><span class="line">        rejected: <span class="literal">undefined</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关键代码!!!</span></span><br><span class="line">    <span class="keyword">this</span>.interceptors.request.forEach(<span class="function"><span class="params">interceptor</span> =&gt;</span> &#123;</span><br><span class="line">      chain.unshift(interceptor) <span class="comment">// 插入到 chain 前面</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">this</span>.interceptors.response.forEach(<span class="function"><span class="params">interceptor</span> =&gt;</span> &#123;</span><br><span class="line">      chain.push(interceptor) <span class="comment">// 插入到 chain 后面</span></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> promise = <span class="built_in">Promise</span>.resolve(config)</span><br><span class="line">    <span class="comment">// 循环这个 chain 拿到每个拦截器对象</span></span><br><span class="line">    <span class="comment">// 将其 resolved 以及 rejected 函数添加到 promise.then 的参数中</span></span><br><span class="line">    <span class="comment">// 通过 Promise 链式调用方式，可实现拦截器一层一层链式调用效果</span></span><br><span class="line">    <span class="keyword">while</span> (chain.length) &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123; resolved, rejected &#125; = chain.shift()!</span><br><span class="line">      promise = promise.then(resolved, rejected)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> promise</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  这里链式调用的直接效果，就是其执行完了拦截器之后的代码逻辑之后再发送请求。但是这里需要注意，<strong>拦截响应的逻辑同时也执行了</strong>，也就是说如果你在拦截响应的逻辑中对其 response 的 data 做了什么赋值操作的话，那么最终返回结果就是你拦截之后的结果。其实很好理解，要实现拦截器的真正效果，其核心就是 <strong>优先执行拦截器中的代码逻辑</strong></p></li></ul><h3 id="支持取消请求"><a href="#支持取消请求" class="headerlink" title="支持取消请求"></a>支持取消请求</h3><p>这个功能的适用场景是这样的，一般而言在搜索框输入的时候，如果第一次输入发出请求了，紧接着第二次输入也发出请求了，但是万一第二次输入的请求服务端反应比较快，一下子就返回了，而第一次请求服务端的反应比较慢，等很久之后才返回。这样就会出现一种情况，<strong>前面请求结果把后面的请求结果给覆盖了</strong>，这是用户极为不愿意看到的。所以如果在这种情况下，如果前面的请求响应很慢或者已经没办法响应了，就直接取消掉它就能解决这个问题了</p><p>实现的思路是这样的</p><ul><li>要取消请求，需要为该请求配置一个 <code>CancelToken</code> 来表示取消这次请求的操作，然后在外部调用一个 <code>cancel</code> 方法来取消</li><li><code>cancel</code> 方法本质上是通过执行 <code>XMLHttpRequest</code> 的 <code>abort</code> 方法来取消请求的</li><li>但是由于请求是异步的，而且取消请求操作是用户设置的，并且用户是访问不到这个 <code>XMLHttpRequest</code> 对象的。那么用什么方法才能做到，我外部调用一个 <code>cancel</code> 方法，就能通知到其内部的 <code>XMLHttpRequest</code> 对象，自动执行 <code>abort</code> 终止请求操作呢？</li><li>有个办法是这样的，在 <code>CancelToken</code> 内部维护一个 <code>Promise</code> 的对象，最开始设定这个 <code>Promise</code> 对象内部的 <code>state</code> 为 <code>pending</code> 状态。当我们外部调用了 <code>cancel</code> 方法后，会将这个 <code>CancelToken</code> 内部的 <code>Promise</code> 对象的 <code>state</code> 转变成 <code>fulfilled</code> 状态，这样的话如果之前就写了 <code>CancelToken.promise.then</code>，那么它就会<strong>自动执行</strong> <code>then</code> 里面的逻辑，在 <code>then</code> 里面直接调用 <code>abort</code> 就可以了</li></ul><p>调用是这么调用的</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 该请求通过 cancel() 方式取消</span></span><br><span class="line"><span class="keyword">let</span> cancel: Canceler;</span><br><span class="line">txios.get(<span class="string">'/cancel/get'</span>, &#123;</span><br><span class="line">  cancelToken: <span class="keyword">new</span> CancelToken(<span class="function"><span class="params">c</span> =&gt;</span> &#123; cancel = c &#125;)</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (txios.isCancel(e)) <span class="built_in">console</span>.log(<span class="string">'Request canceled'</span>);</span><br><span class="line">&#125;);</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123; cancel() &#125;, <span class="number">200</span>);</span><br></pre></td></tr></table></figure><p>然后基于 <code>XMLHttpRequest</code> 对象封装下的 <code>xhr</code> 的内部是这样子判断的</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/core/xhr.ts</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// 设置取消请求</span></span><br><span class="line"><span class="keyword">if</span> (cancelToken) &#123;</span><br><span class="line">  cancelToken.promise</span><br><span class="line">    .then(<span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">      request.abort()</span><br><span class="line">      reject(reason)</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// TODO</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了使用例子和以上的说明，核心代码就很好理解了</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/cancel/cancelToken.ts</span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">CancelToken</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">constructor</span>(executor: CancelExecutor) &#123; <span class="comment">// executor 是一个 callback !!!</span></span><br><span class="line">    <span class="keyword">let</span> resolvePromise: ResolvePromise <span class="comment">// resolvePromise 是一个函数 !!!</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// this.promise 用来表示一个 pending 状态的 Promise 对象</span></span><br><span class="line">    <span class="keyword">this</span>.promise = <span class="keyword">new</span> <span class="built_in">Promise</span>&lt;Cancel&gt;(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">      resolvePromise = resolve <span class="comment">// 注意这里将这个 resolve 函数保存起来了 !!!</span></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行传入的 executor 函数, 传的参数是一个 cancel 函数</span></span><br><span class="line">    <span class="comment">// 此时 executor === (c) =&gt; &#123; cancel = c &#125;</span></span><br><span class="line">    <span class="comment">// c 是 executor 的参数</span></span><br><span class="line">    <span class="comment">// 此时 c === (message) =&gt; &#123;...&#125;</span></span><br><span class="line">    <span class="comment">// 因为此时参数是一个函数</span></span><br><span class="line">    executor(<span class="function"><span class="params">message</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">      <span class="comment">// 此时 this.promise 会从 pending 状态变为 resolved 状态</span></span><br><span class="line">      <span class="comment">// 便于外部可以做 xxx.promise.then 的调用</span></span><br><span class="line">      resolvePromise(<span class="keyword">this</span>.reason)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意此时 <code>c === (message) =&gt; {...}</code>，而外部变量 <code>cancel === c</code>，所以当外部变量 <code>cancel()</code> 调用时，就会调用 <code>(message) =&gt; {...}</code> 这个函数，调用 <code>resolvePromise</code>，这会把 <code>CancelToken</code> 里面的 <code>this.promise</code> 的 <code>state</code> 从 <code>pending</code> 变为 <code>fulfilled</code> 状态。在程序的外部如果之前<strong>已经写好了 then</strong> ，那么它就会 <strong>自动执行 then</strong>，调用 <code>abort</code> 取消请求，从而达到异步分离的目的</p><blockquote><p>如果上面的函数调用的逻辑看不懂， <a href="https://jsbin.com/yacezusohu/edit?html,js,output" target="_blank" rel="noopener">请点击这个链接</a>相信可以帮助理解</p></blockquote><h3 id="支持自动转换-JSON-数据"><a href="#支持自动转换-JSON-数据" class="headerlink" title="支持自动转换 JSON 数据"></a>支持自动转换 JSON 数据</h3><p>这个逻辑实现就很简单了，在 <code>src/helper/data-helper.ts</code> 文件中，有如下的两个专门用于数据处理的函数</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">transformRequest</span>(<span class="params">data: any</span>): <span class="title">any</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (isNormalObject(data)) <span class="keyword">return</span> <span class="built_in">JSON</span>.stringify(data)</span><br><span class="line">  <span class="keyword">return</span> data</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">transformResponse</span>(<span class="params">data: any</span>): <span class="title">any</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> data === <span class="string">'string'</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      data = data &amp;&amp; <span class="built_in">JSON</span>.parse(data)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">      <span class="comment">// TODO</span></span><br><span class="line">      <span class="comment">// console.log(error)</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> data</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在请求数据之前先把数据做一个处理，将数据转换成 JSON 字符串(transformRequest)；在处理响应数据之前先把数据转成 JSON 对象处理(transformResponse)，分别就是调用如上的两个帮助函数实现</p><h3 id="客户端支持-XSRF-防御"><a href="#客户端支持-XSRF-防御" class="headerlink" title="客户端支持 XSRF 防御"></a>客户端支持 XSRF 防御</h3><p>XSRF 又叫 Cross-site request forgery，跨站请求伪造，一种前端老生长谈的攻击方式了，简单点来说你通过一个陌生的链接打开一个恶意的网站，这个网站利用你之前登陆其他网站的登陆状态发起一个跨站点的网络请求，从而伪造身份来攻击</p><p>所以解决这种攻击的一种方式，就是服务端生成一个 token，客户端收到后存为 cookie，每次访问时就带上这个 token，而这个 token 在客户端每次访问站点时都生成，算是一个服务端的验证，这样有了唯一性验证这种攻击方式就弱小了很多。</p><p>所以实现这种功能就是每次发送请求时，自动从 cookie 中读取 token，然后添加进请求头中，一般来说是这么调用</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> instance = txios.create(&#123;</span><br><span class="line">  xsrfCookieName: <span class="string">'XSRF-TOKEN-D'</span>,</span><br><span class="line">  xsrfHeaderName: <span class="string">'X-XSRF-TOKEN-D'</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">instance.get(<span class="string">'/more/get'</span>)</span><br><span class="line">  .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p>核心代码如下</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/core/xhr.ts</span></span><br><span class="line"><span class="comment">// 设置 cookie</span></span><br><span class="line"><span class="keyword">if</span> ((withCredentials || isUrlSameOrigin(url!)) &amp;&amp; xsrfCookieName) &#123;</span><br><span class="line">  <span class="keyword">const</span> token = cookie.getToken(xsrfCookieName)</span><br><span class="line">  <span class="keyword">if</span> (token) headers[xsrfHeaderName!] = token</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>逻辑是这样的</p><ol><li>若 withCredentials = true | <strong>同源</strong>请求，在 headers 中添加 xsrf 相关字段</li><li>判断成功,则从 cookie 中读取 xsrf 的 token</li><li>若能读到，则将其添加到请求 headers 的 xsrf 相关字段中</li></ol><blockquote><p>注意跨域请求中若要请求域中携带 cookie 则需要设置 <code>XMLHttpRequest</code> 对象的 <code>withCredentials</code> 为 true</p></blockquote><p>那么 <code>getToken</code> 干了什么事情呢</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//src/helpers/cookie-helper.ts</span></span><br><span class="line">getToken(name: string): string | <span class="literal">null</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> match = <span class="built_in">document</span>.cookie.match(</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">'(^|;\\s*)('</span> + name + <span class="string">')=([^;]*)'</span>)</span><br><span class="line">  )</span><br><span class="line">  <span class="keyword">return</span> match ? <span class="built_in">decodeURIComponent</span>(match[<span class="number">3</span>]) : <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里就是利用正则表达式解析到 <code>name</code> 对应的值，如果有的话就取 <code>match[3]</code> 也就是 token 的值了，这里再稍微解释下过程，比如你的 <code>document.cookie</code> 值为 <code>XSRF-TOKEN-D=1234abc</code>，本质上是需要将 <code>1234abc</code> 拿出来，那么实际上你的正则就是 <code>(^|;\s*)(XSRF-TOKEN-D)=([^;]*)</code></p><ul><li><code>(^|;\s*)</code> 表示匹配字符串开头的 <code>;</code> 或者是 <code>;空格</code> 的字符串或者是其他字符串(<code>;</code> 可有可无)</li><li><code>(XSRF-TOKEN-D)</code> 表示匹配 <code>XSRF-TOKEN-D</code> 这样的字符串</li><li><code>=</code> 表示匹配 <code>=</code> 这样的字符</li><li><code>([^;]*)</code> 表示匹配除了 <code>;</code> 这样的字符的其他字符串</li></ul><p>那么连起来就很明了了，就是匹配 <code>XSRF-TOKEN-D=</code> 这样的字符串，匹配到了后 <code>match</code> 伪数组结果长这样</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="number">0</span>: <span class="string">"XSRF-TOKEN-D=1234abc"</span></span><br><span class="line">  <span class="number">1</span>: <span class="string">""</span></span><br><span class="line">  <span class="number">2</span>: <span class="string">"XSRF-TOKEN-D"</span></span><br><span class="line">  <span class="number">3</span>: <span class="string">"1234abc"</span></span><br><span class="line">  index: <span class="number">0</span></span><br><span class="line">  input: <span class="string">"XSRF-TOKEN-D=1234abc"</span></span><br><span class="line">  groups: <span class="literal">undefined</span></span><br><span class="line">  length: <span class="number">4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>于是 <code>match[3]</code> 就是结果，直接取它就行</p><blockquote><p>若这里不懂也可以点击这个 <a href="https://github.com/ziishaned/learn-regex/blob/master/translations/README-cn.md" target="_blank" rel="noopener">正则参考链接</a></p></blockquote><h2 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h2><p>单元测试其实是个比较蛋疼的话题，说实话要做到一个比较高的代码覆盖率，需要自己写很多的代码取做验证，其核心的逻辑就是验证输入跟输出的对比，使用 jest 这个测试框架的 expert 断言去写，利用 <code>jasmine</code> 去做 <code>ajax</code> 异步的请求 mock，基本上就是这么个套路了。</p><p>而如果要做到很高的代码测试覆盖率，需要自己深入到函数里面，理清楚它的每个判断，然后对相应的代码走向编写测试代码就行。这是比较累的地方，但却是最能保证代码质量的地方。</p><h2 id="比较难实现的地方"><a href="#比较难实现的地方" class="headerlink" title="比较难实现的地方"></a>比较难实现的地方</h2><p>除了上面提及到的<a href="#支持-Promise-API">支持 Promise API</a> 以及<a href="#支持取消请求">支持取消请求</a>比较难实现外，还有一个就是合并配置功能的实现。<br>在合并配置时需要注意默认配置和用户在调用 <code>txios</code> 时的自定义配置，优先级比较高的是用户自定义的配置，这部分的配置包括 <code>headers</code> 以及一些 <code>config</code>。但是合并不是简单的合并覆盖属性就完了，对于不同的字段的合并，需要不同的策略</p><p>这里的合并策略主要有3个</p><ul><li><p>默认合并策略</p><p>  如果自定义配置中有某个属性，就采用自定义的，反之采用默认</p>  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defaultPolicy</span>(<span class="params">defaultValue: any, customValue: any</span>): <span class="title">any</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> customValue !== <span class="string">'undefined'</span> ? customValue : defaultValue</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>只接受自定义的配置策略</p><p>  这是对于 url params data 的合并策略</p>  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onlyCustomPolicy</span>(<span class="params">defaultValue: any, customValue: any</span>): <span class="title">any</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> customValue !== <span class="string">'undefined'</span>) <span class="keyword">return</span> customValue</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>复杂对象合并策略</p>  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepMergePolicy</span>(<span class="params">defaultValue: any, customValue: any</span>): <span class="title">any</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 优先检测自定义配置</span></span><br><span class="line">  <span class="keyword">if</span> (isNormalObject(customValue)) &#123;</span><br><span class="line">    <span class="comment">// 自定义配置 value 是普通对象</span></span><br><span class="line">    <span class="keyword">return</span> deepMerge(defaultValue, customValue)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> customValue !== <span class="string">'undefined'</span>) &#123; <span class="comment">// 这里判断踩了个坑</span></span><br><span class="line">    <span class="comment">// 自定义配置 value 是其他对象</span></span><br><span class="line">    <span class="keyword">return</span> customValue</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isNormalObject(defaultValue)) &#123;</span><br><span class="line">    <span class="comment">// 默认配置是普通对象</span></span><br><span class="line">    <span class="keyword">return</span> deepMerge(defaultValue)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 默认配置是其他对象</span></span><br><span class="line">    <span class="keyword">return</span> defaultValue</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>之前在复杂策略判断这里踩了个坑，原来的判断是少个 <code>typeof</code> 的，也就是说那条语句变成了 <code>else if (customValue !== &#39;undefined&#39;)</code>，然后单元测试老是过不去，弄了很久，逐行打印分析还以为是 <code>deepMerge</code> 函数那里写错了，后面定位问题才逐渐定位到这里，删除了代码又添加代码之后才发现的。看来使用 TypesSript 也有眼瞎的时候，虽然它已经能够帮你解决 80% 的低端 bug 了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这次的项目算是使用 TypeScript 对 axios 库功能的一次仿写，由代码测试来看，部分功能还算是比较成功的。同时也了解到了 TypeScript 这一门语言的强大之处，比起 js 来说，用的人都应该感觉算蛮香的。虽然类型定义有些奇怪，但用习惯之后觉得还好。另外，若大家有兴趣，还请 <a href="https://github.com/strugglebak/txios" target="_blank" rel="noopener">star 下我的 txios 库</a> ，各位有问题也可以直接 <a href="https://github.com/strugglebak/txios/pulls" target="_blank" rel="noopener">PR</a>，我通通合并(开玩笑哈哈)</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本次项目是对自己用 TypeScript 造的一个轮子的总结，麻雀虽小，但已经尽量五脏俱全，希望各位能多多 star(摩多摩多~)，&lt;a href=&quot;https://github.com/strugglebak/txios&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;毕竟项目地址都在这儿了各位 QAQ&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="TypeScript" scheme="https://strugglebak.github.io/categories/TypeScript/"/>
    
      <category term="Axios" scheme="https://strugglebak.github.io/categories/TypeScript/Axios/"/>
    
    
      <category term="Txios" scheme="https://strugglebak.github.io/tags/Txios/"/>
    
      <category term="Promise" scheme="https://strugglebak.github.io/tags/Promise/"/>
    
      <category term="TypeScript-Http" scheme="https://strugglebak.github.io/tags/TypeScript-Http/"/>
    
  </entry>
  
  <entry>
    <title>配置代码覆盖率徽标的问题</title>
    <link href="https://strugglebak.github.io/2020/03/11/%E9%85%8D%E7%BD%AE%E4%BB%A3%E7%A0%81%E8%A6%86%E7%9B%96%E7%8E%87%E5%BE%BD%E6%A0%87%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>https://strugglebak.github.io/2020/03/11/配置代码覆盖率徽标的问题/</id>
    <published>2020-03-10T16:21:44.000Z</published>
    <updated>2022-06-04T08:13:29.652Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>配置代码覆盖率的这个徽标也是一个很麻烦的问题，由于采用的是 travis 这个 ci 工具，所以坑还是有点多的，这里也记录了如何生成一个 github 的 token，也算做个记录</p></blockquote><a id="more"></a><h2 id="找库"><a href="#找库" class="headerlink" title="找库"></a>找库</h2><p>首先是看到 <a href="http://https://github.com/axios/axios" target="_blank" rel="noopener">axios 这个库</a> 里面有个 <code>coverage</code><br><img src="./1.png" alt></p><p>然后查人家的 <code>package.json</code> 发现是用 <code>coveralls</code> 这个工具的，并且命令为<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="string">"coveralls"</span>: <span class="string">"cat coverage/lcov.info | ./node_modules/coveralls/bin/coveralls.js"</span></span><br></pre></td></tr></table></figure></p><p>原理就是用 <code>coveralls</code> 这个工具计算好代码覆盖率之后，会在项目根目录下生成 <code>coveralls</code> 文件夹，里面就有相关的文件以及最关键的 – <code>lcov.info</code>， 这个文件就是我想要的那个徽标</p><h2 id="网站配置"><a href="#网站配置" class="headerlink" title="网站配置"></a>网站配置</h2><p>首先我项目都是基于 TravisCI 进行持续集成的，最开始的 <code>.travis.yml</code> 如下<br><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">language:</span> <span class="string">node_js</span></span><br><span class="line"><span class="attr">cache:</span></span><br><span class="line">  <span class="attr">directories:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">"~/.npm"</span></span><br><span class="line"><span class="attr">notifications:</span></span><br><span class="line">  <span class="attr">email:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">node_js:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">'10'</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">'11'</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">'8'</span></span><br><span class="line"><span class="attr">script:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">npm</span> <span class="string">run</span> <span class="string">test:prod</span> <span class="string">&amp;&amp;</span> <span class="string">npm</span> <span class="string">run</span> <span class="string">build</span></span><br><span class="line"><span class="attr">after_success:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">npm</span> <span class="string">run</span> <span class="string">travis-deploy-once</span> <span class="string">"npm run report-coverage"</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">if</span> <span class="string">[</span> <span class="string">"$TRAVIS_BRANCH"</span> <span class="string">=</span> <span class="string">"master"</span> <span class="string">-a</span> <span class="string">"$TRAVIS_PULL_REQUEST"</span> <span class="string">=</span> <span class="string">"false"</span> <span class="string">];</span> <span class="string">then</span> <span class="string">npm</span></span><br><span class="line">  <span class="string">run</span> <span class="string">travis-deploy-once</span> <span class="string">"npm run deploy-docs"</span><span class="string">;</span> <span class="string">fi</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">if</span> <span class="string">[</span> <span class="string">"$TRAVIS_BRANCH"</span> <span class="string">=</span> <span class="string">"master"</span> <span class="string">-a</span> <span class="string">"$TRAVIS_PULL_REQUEST"</span> <span class="string">=</span> <span class="string">"false"</span> <span class="string">];</span> <span class="string">then</span> <span class="string">npm</span></span><br><span class="line">  <span class="string">run</span> <span class="string">travis-deploy-once</span> <span class="string">"npm run sr"</span><span class="string">;</span> <span class="string">fi</span></span><br><span class="line"><span class="attr">branches:</span></span><br><span class="line">  <span class="attr">except:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">"/^v\\d+\\.\\d+\\.\\d+$/"</span></span><br></pre></td></tr></table></figure></p><p>按照道理来说，配置好后提交，然后 travis 那边只需要关联上你对应的项目就好，但是会出一个 bug 报错<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Error: GitHub authentication missing</span><br><span class="line">    at validate (/home/travis/build/strugglebak/txios/node_modules/travis-deploy-once/lib/validate.js:12:27)</span><br><span class="line">    at module.exports (/home/travis/build/strugglebak/txios/node_modules/travis-deploy-once/lib/travis-deploy-once.js:25:3)</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><p>看了下是执行<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm run travis-deploy-once <span class="string">"npm run report-coverage"</span></span><br></pre></td></tr></table></figure></p><p>这句话报错的，刚好是要执行代码覆盖率相关操作的语句。 先放在这里不管，继续找徽标</p><h2 id="shields-io"><a href="#shields-io" class="headerlink" title="shields.io"></a>shields.io</h2><p>google 搜 <code>github 徽标</code>，出来第一个结果就是 <code>shields.io</code> 相关的，然后找 <code>Code Coverage</code>，匹配到 <code>coveralls</code> 相关的<br><img src="./2.png" alt><br>再一搜原来需要登陆 <code>Coveralls</code> 的官方网站搞，于是用 github 账号登陆<a href="https://coveralls.io/" target="_blank" rel="noopener">coveralls 官网</a>，看了下应该也是需要关联仓库的，点击左边的 <code>Add Repos</code><br><img src="./3.png" alt></p><p>添加完之后点击 <code>REPOS</code> 然后再点击刚刚添加项目会发现如下说明<br><img src="./4.png" alt></p><p>wtf。。。我才知道原来 travis 还有 pro 版本，赶紧一搜，原来是 travis-ci.org 和 travis-ci.com 的区别，估计是重构了服务什么的吧，这个就先没管了，于是搜 [coveralls 使用]，条件是过去一年内, 看到了<a href="https://zhuanlan.zhihu.com/p/54958391" target="_blank" rel="noopener">知乎的一篇文章</a>,浏览量下也就很普通的解决方案，但是用的是 travis-ci.com 也就是所谓的 pro 版本，于是登陆 pro 版，也是 github 账号登陆，选择管理项目的时候选择了[自己的 github 的所有 repo] 而不是 [指定的项目]，但是在搜索框搜项目的时候居然不存在。。。</p><p><img src="./5.png" alt></p><p>于是乱点了下，点击那个 <code>Migrate</code> tab 后终于出现了</p><p><img src="./6.png" alt></p><p>现在我懂了，如果你是从 travis-ci.org 那边过来的，那边如果有项目在的话，要在这个 travis-ci.com 用，必须要[迁移]过来。</p><p>现在照着知乎那篇帖子配置了下， git push 后看结果，傻眼了，还是报那个错，而且刷新 Coveralls 的相关项目页的时候还是没有出现所谓的[代码覆盖率的报告]，但是如果<strong>不生成这个报告的话，你就拿不到代码覆盖率的徽标了</strong>，继续搜索尝试解决问题</p><h2 id="bug-报错的提示"><a href="#bug-报错的提示" class="headerlink" title="bug 报错的提示"></a>bug 报错的提示</h2><p>前面说了那个 bug 的提示就是<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Error: GitHub authentication missing</span><br></pre></td></tr></table></figure></p><p>貌似就是跟 github 项目相关的 token 验证有关系，于是搜<br>[travis github token set]，<a href="https://docs.travis-ci.com/user/deployment/pages/" target="_blank" rel="noopener">第一个</a>无脑点进去看</p><p>还是官方文档</p><p><img src="./7.png" alt></p><p>看懂了，是这样的一个过程。<br><strong>一般是你要在 travis 帮你在 github page 上部署你的静态文件时会用到 personal access token 这个玩意儿，然后这个 token 是很敏感的私密字符串(因为你可以用这个 token 代替密码来进行仓库的一些操作)， 所以你需要对其进行加密处理</strong></p><p><img src="./8.png" alt></p><p>点击人家推荐的链接<a href="https://help.github.com/en/github/authenticating-to-github/creating-a-personal-access-token-for-the-command-line" target="_blank" rel="noopener">repository settings 里面看</a><br>最终得到类似这么个玩意儿</p><p><img src="./9.png" alt></p><p>然后点击人家推荐的链接<a href="https://docs.travis-ci.com/user/environment-variables#defining-encrypted-variables-in-travisyml" target="_blank" rel="noopener">encrypted variables</a></p><p><img src="./10.png" alt></p><p>然后再点击 <a href="https://docs.travis-ci.com/user/encryption-keys#usage" target="_blank" rel="noopener">Encryption keys – Usage</a></p><p><img src="./11.png" alt></p><p>返回去看了下</p><p><img src="./12.png" alt></p><p>看了下，大致意思就是，你可以使用下面这条命令<br><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">travis encrypt --pro SOMEVAR=<span class="string">"secretvalue"</span> --<span class="keyword">add</span></span><br></pre></td></tr></table></figure></p><p>去加密一个变量，然后这个就会以加密后的一串字符串追加到 <code>.travis.yml</code> 文件后<br><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">env:</span></span><br><span class="line">  <span class="attr">global:</span></span><br><span class="line">    <span class="attr">secure:</span> <span class="string">WPuJZvLNAyAfwu2gM89Y3t520/rnO5GK25Bf1WViJff5q...</span></span><br></pre></td></tr></table></figure></p><p>这就表示把你定义的变量加入到 travis 这个环境变量里面去了，然后你在 travis 上编译测试成功后，会在你项目你自己已经定义好的变量中去找，因为这是一个 key 和 value，找到你对应的 key 再解密然后比对 value，就达到了权限验证的目的了。</p><blockquote><p>这里我执行的命令是 <code>travis encrypt --pro GITHUB_TOKEN=&quot;yourgithubtokenvalue&quot; --add</code></p></blockquote><p>比如我的就是设置的变量名就是 <code>GITHUB_TOKEN</code>，就在 travis 项目中的 <code>setting</code> 页面中的那个 <code>Environment Variables</code> 里填，<code>Value</code> 项就是你在 github 上设置成功的 token 值，然后点击 <code>Add</code> 添加</p><p><img src="./xxx.png" alt></p><p><img src="./13.png" alt></p><p>最后就是项目的修改和提交了，主要就是更改了 <code>.travis.yml</code> 配置文件，提交了之后等待 travis 测试通过，再刷新 <code>Coveralls</code> 官网对应的项目，看到下图表示代码覆盖率报告已经生成，也就是说可以在 <code>shields.io</code> 上拿到 <code>coverage</code> 的徽标了!</p><p><img src="./14.png" alt></p><h2 id="travis-相关文件配置"><a href="#travis-相关文件配置" class="headerlink" title="travis 相关文件配置"></a>travis 相关文件配置</h2><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">provider:</span> <span class="string">pages</span></span><br><span class="line">  <span class="attr">skip_cleanup:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">github_token:</span> <span class="string">$GITHUB_TOKEN</span></span><br><span class="line">  <span class="attr">keep_history:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">on:</span></span><br><span class="line">    <span class="attr">branch:</span> <span class="string">master</span></span><br><span class="line"><span class="attr">language:</span> <span class="string">node_js</span></span><br><span class="line"><span class="attr">cache:</span></span><br><span class="line">  <span class="attr">directories:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">"~/.npm"</span></span><br><span class="line"><span class="attr">notifications:</span></span><br><span class="line">  <span class="attr">email:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">node_js:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">'10'</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">'11'</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">'8'</span></span><br><span class="line"><span class="attr">script:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">npm</span> <span class="string">run</span> <span class="string">test:prod</span> <span class="string">&amp;&amp;</span> <span class="string">npm</span> <span class="string">run</span> <span class="string">build</span></span><br><span class="line"><span class="attr">after_success:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">npm</span> <span class="string">run</span> <span class="string">travis-deploy-once</span> <span class="string">"npm run report-coverage"</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">if</span> <span class="string">[</span> <span class="string">"$TRAVIS_BRANCH"</span> <span class="string">=</span> <span class="string">"master"</span> <span class="string">-a</span> <span class="string">"$TRAVIS_PULL_REQUEST"</span> <span class="string">=</span> <span class="string">"false"</span> <span class="string">];</span> <span class="string">then</span> <span class="string">npm</span></span><br><span class="line">  <span class="string">run</span> <span class="string">travis-deploy-once</span> <span class="string">"npm run deploy-docs"</span><span class="string">;</span> <span class="string">fi</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">if</span> <span class="string">[</span> <span class="string">"$TRAVIS_BRANCH"</span> <span class="string">=</span> <span class="string">"master"</span> <span class="string">-a</span> <span class="string">"$TRAVIS_PULL_REQUEST"</span> <span class="string">=</span> <span class="string">"false"</span> <span class="string">];</span> <span class="string">then</span> <span class="string">npm</span></span><br><span class="line">  <span class="string">run</span> <span class="string">travis-deploy-once</span> <span class="string">"npm run sr"</span><span class="string">;</span> <span class="string">fi</span></span><br><span class="line"><span class="attr">branches:</span></span><br><span class="line">  <span class="attr">except:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">"/^v\\d+\\.\\d+\\.\\d+$/"</span></span><br><span class="line"><span class="attr">env:</span></span><br><span class="line">  <span class="attr">global:</span></span><br><span class="line">    <span class="attr">secure:</span> <span class="string">WPuJZvLNAyAfwu2gM89Y3t520/rnO5GK25Bf1WViJff5q893Z...</span></span><br></pre></td></tr></table></figure><p>注意我写的 <code>$GITHUB_NAME</code> 这里就是获取到你在 travis 上配置的环境变量名。</p><p>最后的最后需要注意的，可能是一个坑，但是我还是加上了，就是有看到  github 上有 issue 讨论这个问题<a href="https://github.com/semantic-release/travis-deploy-once/issues/52" target="_blank" rel="noopener">GH_TOKEN has not authenticated Travis CI yet</a><br>然后他是通过在 <code>package.json</code> 中的 <code>travis-deploy-once</code> 后加 <code>--pro</code> 解决的</p><p><img src="./15.png" alt></p><p>为了以防万一，我也在项目中加了, 我的项目地址为<a href="https://github.com/strugglebak/txios.git" target="_blank" rel="noopener">txios - 基于 TypeScript 的轻量级 http 库</a></p><p>虽然没试过，但是加了没有问题，就这样问题解决了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这个坑之前搞 travis ci 的时候没碰到过，算是给自己一个记录，以后谁踩坑了可以参考我这篇博客哈哈。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;配置代码覆盖率的这个徽标也是一个很麻烦的问题，由于采用的是 travis 这个 ci 工具，所以坑还是有点多的，这里也记录了如何生成一个 github 的 token，也算做个记录&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="bug" scheme="https://strugglebak.github.io/categories/bug/"/>
    
    
      <category term="bug" scheme="https://strugglebak.github.io/tags/bug/"/>
    
  </entry>
  
  <entry>
    <title>有关react hooks这一堆东西的详细解释(万字长文)</title>
    <link href="https://strugglebak.github.io/2020/03/09/%E6%9C%89%E5%85%B3react-hooks%E8%BF%99%E4%B8%80%E5%A0%86%E4%B8%9C%E8%A5%BF%E7%9A%84%E8%AF%A6%E7%BB%86%E8%A7%A3%E9%87%8A-%E4%B8%87%E5%AD%97%E9%95%BF%E6%96%87/"/>
    <id>https://strugglebak.github.io/2020/03/09/有关react-hooks这一堆东西的详细解释-万字长文/</id>
    <published>2020-03-09T10:08:29.000Z</published>
    <updated>2022-06-04T08:13:29.500Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文主要会就 React hooks 中用的比较多的 <code>useState</code> 做一个详细讲解，其他的 hooks 会涉及到原理和使用但不会涉及到源码仿写，望周知</p></blockquote><a id="more"></a><h2 id="实现-useState"><a href="#实现-useState" class="headerlink" title="实现 useState"></a>实现 useState</h2><h3 id="useState-是怎么用的"><a href="#useState-是怎么用的" class="headerlink" title="useState 是怎么用的"></a>useState 是怎么用的</h3><p>在实现一个 <code>useState</code> 之前，先来看看 <code>useState</code> 大致是怎么用的</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123;useState&#125; <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [n, setN] = useState(<span class="number">0</span>)</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">"App"</span>&gt;</span><br><span class="line">      &lt;p&gt;&#123;n&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">      &lt;p&gt;</span></span><br><span class="line"><span class="regexp">        &lt;button onClick=&#123;() =&gt; setN(n+1)&#125;&gt;+1&lt;/</span>button&gt;</span><br><span class="line">      &lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里是一个简单的 <a href="https://codesandbox.io/s/inspiring-tree-3yrpr" target="_blank" rel="noopener">加法器的应用</a>，所以这里的效果就是点击一下 button, n 就会加 1。那么这里面的过程是怎么样的呢，这里分 2 部走</p><ul><li>首次渲染<br>  首次渲染时，会调用 <code>App()</code> 函数，得到一个 <strong>虚拟 DOM</strong>，然后再创建<strong>真实 DOM</strong></li><li>用户点击 button 时<br>  会先调用 <code>setN(n+1)</code> 函数，然后<strong>再次 render 渲染</strong>，渲染就调用 <code>App()</code> 函数，然后再次得到一个<strong>新的虚拟 DOM</strong>，这个虚拟 DOM 会和之前的虚拟 DOM 做一个 <strong>Diff</strong> 的操作，然后再更新对应的真实 DOM</li></ul><blockquote><p>这里注意，每次调用 <code>App()</code> 函数时，都会调用 <code>useState(0)</code></p></blockquote><p>所以这里我们可以看到两个问题</p><ul><li><strong>在执行 <code>setN</code></strong>时，<strong>n 不会变</strong>，但是 <code>App()</code> 函数会重新执行</li><li><code>App()</code> 函数在执行后，在 <code>useState(0)</code> 时，<strong>每次的 n 的值都是不同的</strong></li></ul><h3 id="分析-useState"><a href="#分析-useState" class="headerlink" title="分析 useState"></a>分析 useState</h3><p>对于数据 <code>X</code> 来说，使用 <code>useState</code> 会有如下的规律</p><ul><li><p><code>setN</code></p><ol><li><code>setN</code> 一定会修改数据 <code>X</code>, 将 <code>n+1</code> 存入 <code>X</code></li><li><code>setN</code> 一定会触发 <code>&lt;App/&gt;</code> 并重新渲染(执行 <code>App()</code> 函数)</li></ol></li><li><p><code>useState</code><br>  <code>useState</code> 肯定会从 <code>X</code> <strong>读取</strong> <code>n</code> 的最新值</p></li><li><p><code>X</code><br>  每个组件都有自己的数据 <code>X</code>，其实就是所谓的 <code>state</code></p></li></ul><h3 id="实现-useState-初级版本"><a href="#实现-useState-初级版本" class="headerlink" title="实现 useState 初级版本"></a>实现 useState 初级版本</h3><p>有了以上的分析，可以写一个简单的 <code>useState</code> 了</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> _state; <span class="comment">// 全局变量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> useState = <span class="function"><span class="params">initValue</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// _state 用来保存一个全局的状态</span></span><br><span class="line">  _state = _state === <span class="literal">undefined</span> ? initValue : _state;</span><br><span class="line">  <span class="comment">// setState 是一个 callback, 只要 setState 被调用，就会重新 render 一遍</span></span><br><span class="line">  <span class="comment">// 同时 _state 也会得到更新</span></span><br><span class="line">  <span class="keyword">const</span> setState = <span class="function"><span class="params">newValue</span> =&gt;</span> &#123;</span><br><span class="line">    _state = newValue;</span><br><span class="line">    render();</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> [_state, setState];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// render 函数</span></span><br><span class="line"><span class="keyword">const</span> render = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> rootElement = <span class="built_in">document</span>.getElementById(<span class="string">"root"</span>);</span><br><span class="line">  ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span></span>, rootElement);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里为了方便起见，其 <code>render</code> 函数就直接调用了 <code>ReactDom.render</code>。比较关键的是这个全局的 <code>_state</code>，这个 <code>_state</code> 是一个全局的变量，为了下次渲染时不被初始化而设立的，<code>setState</code> 实际上就是一个回调，作用就是 <strong>保存 state 并开启渲染</strong>，所以这里可以知道为何在调用 <code>setN</code> 时，<code>n</code> 不会变了。因为此的 <code>n</code> 只是被存放在 <code>_state</code> 中，最后返回的 <code>_state</code> 中才是变化的 <code>n</code>，而只有再次渲染才能得到这个变化的 <code>n</code></p><h3 id="实现-useState-升级版本"><a href="#实现-useState-升级版本" class="headerlink" title="实现 useState 升级版本"></a>实现 useState 升级版本</h3><p>但是目前还有一个问题，就是万一同一个组件，调用用了 <strong>2 次以上的 useState</strong> 怎么办。以上的初始版本的代码会带来什么问题呢？就是因为 <code>_state</code> 是全局的，导致组件的数据之间会相互冲突</p><h4 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h4><p>解决的思路有两个</p><ul><li>将 <code>_state</code> 变成对象的形式，比如变成 <code>_state: {n: 0, m: 0}</code><br>  实际上这样做是不可取的，因为 <code>useState</code> 中参数就是传一个初始值(initValue)，这种情况下我们怎么知道是 <code>n</code> 是 0, 还是 <code>m</code> 是 0 呢</li><li>将 <code>_state</code> 变成<strong>数组</strong>的形式，比如 <code>_state: [0, 0]</code><br>  这种是可以的，因为可以通过<strong>下标</strong>区分每个 <code>useState</code> 的数据</li></ul><h4 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> _state = []; <span class="comment">// 全局变量</span></span><br><span class="line"><span class="keyword">let</span> index = <span class="number">0</span>; <span class="comment">// 解决 state 冲突的问题,因为有可能使用多个 useState</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> useState = <span class="function"><span class="params">initValue</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 保存当前的 index</span></span><br><span class="line">  <span class="keyword">let</span> currentIndex = index;</span><br><span class="line">  <span class="comment">// _state 用来保存一个全局的状态</span></span><br><span class="line">  _state[currentIndex] =</span><br><span class="line">    _state[currentIndex] === <span class="literal">undefined</span> ? initValue : _state[currentIndex];</span><br><span class="line">  <span class="comment">// setState 是一个 callback, 只要 setState 被调用，就会重新 render 一遍</span></span><br><span class="line">  <span class="comment">// 同时 _state 也会得到更新</span></span><br><span class="line">  <span class="keyword">const</span> setState = <span class="function"><span class="params">newValue</span> =&gt;</span> &#123;</span><br><span class="line">    _state[currentIndex] = newValue;</span><br><span class="line">    render();</span><br><span class="line">  &#125;;</span><br><span class="line">  index += <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> [_state[currentIndex], setState];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> render = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  index = <span class="number">0</span>; <span class="comment">// 注意这里要 index 置零</span></span><br><span class="line">  <span class="keyword">const</span> rootElement = <span class="built_in">document</span>.getElementById(<span class="string">"root"</span>);</span><br><span class="line">  ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span></span>, rootElement);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>既然要采取上面的数组的方案做，那么 <code>_state</code> 自然初始值就是一个数组。其他的逻辑并没有变化，主要是增加了一个全局的变量 <code>index</code> 以及一个 <code>useState</code> 中的临时变量 <code>currentIndex</code>。每次当 <code>useState</code> 执行时，<code>index</code> 就自增 1 与其他的 <code>state</code> 做区分。<code>currentIndex</code> 的作用是能让 <code>_state[0]</code> 有个初始值而不至于是 <code>undefined</code>。同时在每次 <code>render</code> 时需要将 <code>index</code> 置为零。这样一来每次执行 <code>useState</code> 得到的就是不同的 <code>n</code> 以及 <code>setN</code> 了</p><p><a href="https://codesandbox.io/s/winter-surf-9nqr2" target="_blank" rel="noopener">测试代码链接点击这里</a></p><h4 id="数组方案的主要缺点"><a href="#数组方案的主要缺点" class="headerlink" title="数组方案的主要缺点"></a>数组方案的主要缺点</h4><p>数组的一个很明显的缺点就是它的 <strong>调用顺序</strong>。因为数组非常强调顺序，所以在 React 中不允许出现类似如下的代码</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;useState&#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">...</span><br><span class="line">  <span class="keyword">const</span> [n, setN] = useState(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">let</span> m, setM;</span><br><span class="line">  <span class="keyword">if</span> (n % <span class="number">2</span> === <span class="number">0</span>) &#123;</span><br><span class="line">    [m, setM] = useState(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>React 就会报如下的错误</p><blockquote><p>❌ :React Hook “React.useState” is called conditionally. React Hooks must be called in the exact same order in every component render</p></blockquote><p>意思是说，React 不能依照条件调用 <code>useState</code>，在每个组件渲染时应该依照一样的顺序调用 hooks</p><p>所以在使用 React 相关的 hook 时，上面的代码是不被 React 允许的</p><h4 id="数组方案的其他缺点以及解决方案"><a href="#数组方案的其他缺点以及解决方案" class="headerlink" title="数组方案的其他缺点以及解决方案"></a>数组方案的其他缺点以及解决方案</h4><ul><li><code>App</code> 组件使用了全局的 <code>_state</code> 和 <code>index</code>，那么其他组件怎么用？不还是冲突了么？<br>  只需要在每个组件内部维护一个 <code>_state</code> 和 <code>index</code> 即可</li><li>对于类组件来说，不存在全局作用域重名的问题，对于函数组件来说就有，这个时候怎么办？<br>  只需要将 <code>_state</code> 和 <code>index</code> 放在组件对应的虚拟 DOM 对象上即可</li></ul><p>原理是这样的</p><p><img src="./1.png" alt></p><p>在函数组件调用了 <code>useState</code> 时，就会更新绑定在虚拟 DOM 对象上的 <code>_state</code> 和 <code>index</code>，当下次数据有变化触发 render 时，会再次调用 <code>useState</code> 并生成一个新的虚拟 DOM 对象，这个对象会跟之前的旧对象进行一个 Diff 的操作，对比出要更改的节点后会出一个 Patch，然后再根据这个 Patch 更新虚拟 DOM 上的数据，这里面包括了 <code>_state</code> 和 <code>index</code>，最后再修改生成一个真实 DOM 节点。</p><h3 id="useState-注意点"><a href="#useState-注意点" class="headerlink" title="useState 注意点"></a>useState 注意点</h3><ul><li><p>对于其使用状态</p>  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> [n, setN] = React.useState(<span class="number">0</span>) <span class="comment">// 这里 n 的初始值就是 0</span></span><br><span class="line"><span class="keyword">const</span> [m, setM] = React.useState(&#123;<span class="attr">name</span>: <span class="string">'xxx'</span>&#125;) <span class="comment">// 这里 m 的初始值就是 &#123;name: 'xxx'&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>不可以局部更新<br>  <a href="https://codesandbox.io/s/laughing-dawn-v2d5t" target="_blank" rel="noopener">代码链接</a></p>  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> [user, setUser] = useState(&#123; <span class="attr">name</span>: <span class="string">"xxx"</span>, <span class="attr">age</span>: <span class="number">18</span> &#125;);</span><br><span class="line"><span class="keyword">const</span> onClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  setUser(&#123;</span><br><span class="line">    name: <span class="string">"Jack"</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line">  &lt;div className=<span class="string">"App"</span>&gt;</span><br><span class="line">    &lt;h1&gt;&#123;user.name&#125;&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">    &lt;h2&gt;&#123;user.age&#125;&lt;/</span>h2&gt;</span><br><span class="line">    &lt;button onClick=&#123;onClick&#125;&gt;Click&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>div&gt;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>  从贴出的代码链接可以看出，点击 button 后，<code>user.age</code> 并没有显示出来。这是因为 <strong>setState 并不会帮你合并属性，要合并的话需要自己额外操作，比如利用拓展运算符 <code>...</code></strong></p></li><li><p><code>setState(obj)</code> 中的地址要变<br>  <a href="https://codesandbox.io/s/runtime-feather-2wi3n" target="_blank" rel="noopener">代码链接</a></p>  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> [user, setUser] = useState(&#123; <span class="attr">name</span>: <span class="string">"xxx"</span>, <span class="attr">age</span>: <span class="number">18</span> &#125;);</span><br><span class="line"><span class="keyword">const</span> obj = user <span class="comment">// 注意这里 !!!</span></span><br><span class="line"><span class="keyword">const</span> onClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  obj.name = <span class="string">'Jack'</span> <span class="comment">// 注意这里 !!!</span></span><br><span class="line">  setUser(obj); <span class="comment">// 在这种情况下页面数据是不会更新的 !!!</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line">  &lt;div className=<span class="string">"App"</span>&gt;</span><br><span class="line">    &lt;h1&gt;&#123;user.name&#125;&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">    &lt;h2&gt;&#123;user.age&#125;&lt;/</span>h2&gt;</span><br><span class="line">    &lt;button onClick=&#123;onClick&#125;&gt;Click&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>div&gt;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>  只要 <code>obj</code> 的地址没变，React 就认为其数据没有变化，因此就不会触发更新</p></li><li><p><code>useState</code> 可以接受一个函数</p>  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> [state, setState] = useState(<span class="function"><span class="params">()</span> =&gt;</span> initialState) <span class="comment">// 该函数返回初始值 state，且只执行一次</span></span><br></pre></td></tr></table></figure></li><li><p><code>setState</code> 可以接受一个函数</p><p>  <a href="https://codesandbox.io/s/runtime-feather-2wi3n" target="_blank" rel="noopener">代码链接</a></p>  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> [n, setN] = useState(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">const</span> onClick = <span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">  setN(n+<span class="number">1</span>)</span><br><span class="line">  setN(n+<span class="number">1</span>) <span class="comment">// 你会发现 n 不能加 2</span></span><br><span class="line">  <span class="comment">// setN(i=&gt;i+1)</span></span><br><span class="line">  <span class="comment">// setN(i=&gt;i+1) // 但是使用了函数之后就可以加 2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line">  &lt;div className=<span class="string">"App"</span>&gt;</span><br><span class="line">    &lt;h1&gt;n: &#123;n&#125;&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">    &lt;button onClick=&#123;onClick&#125;&gt;+2&lt;/</span>button&gt;</span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">);</span></span><br></pre></td></tr></table></figure><p>  所以为了避免 bug，应该优先使用这种在 <code>setState</code> 中传函数更新 <code>state</code> 的方式</p></li></ul><h3 id="useState-总结"><a href="#useState-总结" class="headerlink" title="useState 总结"></a>useState 总结</h3><ul><li>每个函数组件对应着一个 React 节点(FiberNode)</li><li>每个节点保存着 <code>_state</code> 和 <code>index</code></li><li>useState 会读取 <code>_state[index]</code></li><li><code>index</code> 由 useState 出现的顺序决定</li><li><code>setState</code> 会修改 <code>_state</code>，并且之后会触发更新</li></ul><blockquote><p>⚠ 注意：这里只是一个对 <code>useState</code> 的思路型源码，并非是 React hook 中的源码。另这里的 <code>_state</code> 对应源码中的 <code>memorizedState</code>，而 <code>index</code> 在源码中是利用链表来实现的。这里只是抛砖引玉一下。</p></blockquote><h2 id="useReducer"><a href="#useReducer" class="headerlink" title="useReducer"></a>useReducer</h2><p><code>useReducer</code> 本质就是用来践行 <code>Flux/Redux</code> 的思想的这么一个 hook，例子的<a href="https://codesandbox.io/s/practical-lederberg-f1hp6" target="_blank" rel="noopener">代码链接</a>在这里</p><h3 id="使用-useReducer"><a href="#使用-useReducer" class="headerlink" title="使用 useReducer"></a>使用 useReducer</h3><p>首先是声明一个 <code>initial</code> 初始变量</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> initial = &#123;</span><br><span class="line">  n: <span class="number">0</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后声明 <code>reducer</code></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> reducer = <span class="function">(<span class="params">state, action</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (action.type === <span class="string">"add"</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">n</span>: state.n + action.number &#125;;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (action.type === <span class="string">"multi"</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">n</span>: state.n * <span class="number">2</span> &#125;;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"unknown type"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后在 <code>App()</code> 函数组件中使用将这个 <code>reducer</code> 以及 <code>initial</code> 值当作参数传入 <code>useReducer</code> 中，返回的就是一个 <code>state</code> 和 <code>dispatch</code></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注意这里参数的传入顺序</span></span><br><span class="line"><span class="keyword">const</span> [state, dispatch] = useReducer(reducer, initial);</span><br><span class="line"><span class="keyword">const</span> &#123; n &#125; = state;</span><br><span class="line"><span class="keyword">const</span> onClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  dispatch(&#123; <span class="attr">type</span>: <span class="string">"add"</span>, <span class="attr">number</span>: <span class="number">1</span> &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> onClick2 = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  dispatch(&#123; <span class="attr">type</span>: <span class="string">"add"</span>, <span class="attr">number</span>: <span class="number">2</span> &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line">  &lt;div className=<span class="string">"App"</span>&gt;</span><br><span class="line">    &lt;h1&gt;n: &#123;n&#125;&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">    &lt;button onClick=&#123;onClick&#125;&gt;+1&lt;/</span>button&gt;</span><br><span class="line">    &lt;button onClick=&#123;onClick2&#125;&gt;+<span class="number">2</span>&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>div&gt;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>可以看出，以上的代码是分几步走的</p><ol><li>创建初始值 <code>initial</code></li><li>创建 <code>reducer</code> 这个操作的集合，它接受一个 <code>state</code> 和一个 <code>action</code></li><li>将 <code>reducer</code> 和 <code>initial</code> 传给 <code>useReducer</code>，并得到一个读(<code>state</code>)和写(<code>dispatch</code>)的 API</li><li>调用写(<code>dispatch</code>) API 传入 <code>{type: &#39;操作类型&#39;}</code> 去对 <code>state</code> 做相应的更新</li></ol><p>从以上描述我们不难看出，这个 <code>useReducer</code> 可以用来代替 <code>redux</code></p><h3 id="使用-useReducer-代替-redux"><a href="#使用-useReducer-代替-redux" class="headerlink" title="使用 useReducer 代替 redux"></a>使用 useReducer 代替 redux</h3><p><a href="https://codesandbox.io/s/interesting-volhard-lfxpm" target="_blank" rel="noopener">代码链接</a></p><blockquote><p>由于代码太长了所以这里就不放代码了，详情可以点击链接中的代码去查看</p></blockquote><p>由以上的代码我们可以知道一个基本的使用 <code>useReducer</code> 代替 redux 的步骤为</p><ol><li>声明一个 <code>store</code> 对象，对象中存放着该组件使用的数据</li><li>声明一个 <code>reducer</code> ，所有的相关的 crud 之类的操作都往这个里面放</li><li>使用 <code>createContext</code> 创建一个 <code>Context</code>，为组件间传递数据做准备</li><li>在 <code>App</code> 组件中使用 <code>useReducer</code> 创建读写 API，在其子组件中使用 <code>useContext</code> 创建读写 API(读: state 访问数据, 写: dispatch 对数据进行操作)</li><li>将第 4 步的返回内容放入到第 3 步的 <code>Context.Provider</code> 组件的 <code>value</code> 中</li><li>使用 <code>Context.Provider</code> 将 <code>Context</code> 提供给所有组件</li><li>然后各个子组件使用 <code>useContext(Context)</code> 获取到读写 API</li></ol><p>当然了，如果涉及到模块化的问题，将代码分开就可以了。比如</p><p><code>Context.js</code> 中可以放入</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Context.js</span></span><br><span class="line">mport React <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Context = React.createContext(<span class="literal">null</span>);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Context;</span><br></pre></td></tr></table></figure><p><code>reducers</code> 可以单独建立一个文件夹，里面放入的都是对应数据的一些操作，比如对 book 的操作可以这么写</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// reducers/books_reducer.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  setBooks: <span class="function">(<span class="params">state, action</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; ...state, <span class="attr">books</span>: action.books &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  deleteBook: <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后 <code>App</code> 子组件就放入 <code>components</code> 文件夹中，里面就是组件的一些东西了，这里不再赘述</p><p>最后的最后，在从 <code>src/index.js</code> 中引入这些文件即可，然后再做相应的代码优化。实际上模块化的本质就是分类整理代码，这样做了之后基本就能起到替代 <code>redux</code> 的作用了</p><h3 id="useReducer-注意点"><a href="#useReducer-注意点" class="headerlink" title="useReducer 注意点"></a>useReducer 注意点</h3><p>需要注意的是，<code>useReducer</code> 本身也不会帮你合并属性，所以同 <code>useState</code> 一样，要合并属性时需要自己动手操作</p><h3 id="useReducer-总结"><a href="#useReducer-总结" class="headerlink" title="useReducer 总结"></a>useReducer 总结</h3><p>总的来说，<code>useReducer</code> 这个 hook 其实本质上借鉴了 Flux/Redux 的一些思想，我们可以通过一些 hooks 来创建一个类似 <code>redux</code> 的写法，只要将其模块化后就可以替代 redux</p><h2 id="useRef"><a href="#useRef" class="headerlink" title="useRef"></a>useRef</h2><p>在理解 <code>uesRef</code> 之前，先看一个<a href="https://codesandbox.io/s/boring-booth-n6igq" target="_blank" rel="noopener">例子</a></p><h3 id="useState-的-bug"><a href="#useState-的-bug" class="headerlink" title="useState 的 bug"></a>useState 的 bug</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState &#125; <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [n, setN] = useState(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> log = <span class="function"><span class="params">()</span> =&gt;</span> setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">"n ="</span>, n), <span class="number">3000</span>);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">"App"</span>&gt;</span><br><span class="line">      &lt;p&gt;&#123;n&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">      &lt;p&gt;</span></span><br><span class="line"><span class="regexp">        &lt;button</span></span><br><span class="line"><span class="regexp">          onClick=&#123;() =&gt; &#123;</span></span><br><span class="line"><span class="regexp">            setN(n + 1);</span></span><br><span class="line"><span class="regexp">          &#125;&#125;</span></span><br><span class="line"><span class="regexp">        &gt;</span></span><br><span class="line"><span class="regexp">          +1</span></span><br><span class="line"><span class="regexp">        &lt;/</span>button&gt;</span><br><span class="line">      &lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">      &lt;p&gt;</span></span><br><span class="line"><span class="regexp">        &lt;button onClick=&#123;log&#125;&gt;log&lt;/</span>button&gt;</span><br><span class="line">      &lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在有个问题，在点击完 +1 button 然后点击 log，打印出来的 n 是正常的。但是如果是先 log 然后立即执行 +1，那么我们可以发现一个 bug，就是 <strong>n 居然没有变化!!!居然还是之前的旧数据!!!</strong></p><p>wtf, 这是什么情况???</p><p>先来看一张图</p><p><img src="./2.png" alt></p><ul><li>如果先点 +1 再点 log<br>  <code>setN</code> 会先执行，然后触发 <code>render</code>，3 秒过后，<code>log</code> 里面读到的 <code>n</code> 就是 <strong>已经从 <code>useState</code></strong> 里面读出来的 <code>n</code>，所以 <code>n = 1</code></li><li>如果先点 log 再点 +1<br>  <code>log</code> 会先执行，但是注意，此时 <code>log</code> 里的 <code>n</code> 还是初始状态下读到的 <strong>旧的 <code>n</code></strong>，随后 <code>setN</code> 执行后会产生一个<strong>新的 <code>n</code></strong>。然而此时其触发的 <code>render</code> 早就更新页面上的 <code>n</code> 了。所以会出现这种 “滞后” 的 bug</li></ul><h3 id="useState-bug-的解决方案"><a href="#useState-bug-的解决方案" class="headerlink" title="useState bug 的解决方案"></a>useState bug 的解决方案</h3><ul><li><p>将 <code>n</code> 和 <code>setN</code> 挂在全局变量 <code>window</code> 上<br>  这种解决方案太傻了，不考虑变量之间相互污染的问题么?</p></li><li><p>使用 <code>useRef</code></p>  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useRef &#125; <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> n = useRef(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> log = <span class="function"><span class="params">()</span> =&gt;</span> setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">"n ="</span>, n.current), <span class="number">3000</span>);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">"App"</span>&gt;</span><br><span class="line">      &lt;p&gt;&#123;n.current&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">      &lt;p&gt;</span></span><br><span class="line"><span class="regexp">        &lt;button</span></span><br><span class="line"><span class="regexp">          onClick=&#123;() =&gt; &#123;</span></span><br><span class="line"><span class="regexp">            n.current += 1;</span></span><br><span class="line"><span class="regexp">          &#125;&#125;</span></span><br><span class="line"><span class="regexp">        &gt;</span></span><br><span class="line"><span class="regexp">          +1</span></span><br><span class="line"><span class="regexp">        &lt;/</span>button&gt;</span><br><span class="line">      &lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">      &lt;p&gt;</span></span><br><span class="line"><span class="regexp">        &lt;button onClick=&#123;log&#125;&gt;log&lt;/</span>button&gt;</span><br><span class="line">      &lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  但你会发现这种<a href="https://codesandbox.io/s/boring-booth-n6igq" target="_blank" rel="noopener">方案</a>，页面上的元素不更新了，于是你可以这么改<a href="https://codesandbox.io/s/exciting-mirzakhani-4i06k" target="_blank" rel="noopener">代码</a></p>  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useRef, useState &#125; <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> n = useRef(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> update = useState(<span class="number">0</span>)[<span class="number">1</span>]; <span class="comment">// 注意这里!!!</span></span><br><span class="line">  <span class="keyword">const</span> log = <span class="function"><span class="params">()</span> =&gt;</span> setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">"n ="</span>, n.current), <span class="number">3000</span>);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">"App"</span>&gt;</span><br><span class="line">      &lt;p&gt;&#123;n.current&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">      &lt;p&gt;</span></span><br><span class="line"><span class="regexp">        &lt;button</span></span><br><span class="line"><span class="regexp">          onClick=&#123;() =&gt; &#123;</span></span><br><span class="line"><span class="regexp">            n.current += 1;</span></span><br><span class="line"><span class="regexp">            update(n.current); /</span><span class="regexp">/ 注意这里!!!</span></span><br><span class="line"><span class="regexp">          &#125;&#125;</span></span><br><span class="line"><span class="regexp">        &gt;</span></span><br><span class="line"><span class="regexp">          +1</span></span><br><span class="line"><span class="regexp">        &lt;/</span>button&gt;</span><br><span class="line">      &lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">      &lt;p&gt;</span></span><br><span class="line"><span class="regexp">        &lt;button onClick=&#123;log&#125;&gt;log&lt;/</span>button&gt;</span><br><span class="line">      &lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  这里做了一个小 trick，就是使用 <code>useState</code> 返回的第二个函数强制更新。。。当然这种方式太过 hack 肯定是不推荐的。不过由此我们可以知道 <code>useRef</code> 可以作为一种 <strong>贯穿始终的状态</strong> 来解决 <code>useState</code> 使用上的 bug</p></li></ul><h3 id="与-forwardRef-的关系"><a href="#与-forwardRef-的关系" class="headerlink" title="与 forwardRef 的关系"></a>与 forwardRef 的关系</h3><p>使用 <code>useRef</code> 时，<code>props</code> 是不能直接传递 <code>ref</code> 属性的，比如下面的代码</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> buttonRef = useRef(<span class="literal">null</span>);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">"App"</span>&gt;</span><br><span class="line">      &lt;Button2 ref=&#123;buttonRef&#125;&gt;按钮&lt;<span class="regexp">/Button2&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Button2 = <span class="function"><span class="params">props</span> =&gt;</span> &#123; <span class="comment">// 这里的 props 中的 ref 传不进来</span></span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">className</span>=<span class="string">"red"</span> &#123;<span class="attr">...props</span>&#125; /&gt;</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>浏览器会报错</p><blockquote><p>Warning: Function components cannot be given refs. Attempts to access this ref will fail. Did you mean to use React.forwardRef()?</p></blockquote><p>React 这个时候提醒你使用 <code>React.forwardRef()</code> 来传 <code>props</code> 中的 <code>ref</code> 属性，于是你可以这么改</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> buttonRef = useRef(<span class="literal">null</span>);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">"App"</span>&gt;</span><br><span class="line">      &lt;Button3 ref=&#123;buttonRef&#125;&gt;按钮&lt;<span class="regexp">/Button3&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意这里使用 React.forwardRef 多包裹了一层</span></span><br><span class="line"><span class="keyword">const</span> Button3 = React.forwardRef(<span class="function">(<span class="params">props, ref</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">className</span>=<span class="string">"red"</span> <span class="attr">ref</span>=<span class="string">&#123;ref&#125;</span> &#123;<span class="attr">...props</span>&#125; /&gt;</span></span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>当然你也可以通过两次传递 <code>ref</code> 来得到 button 的引用，这里就不细讲，有兴趣的童鞋可以参考<a href="https://codesandbox.io/s/amazing-snow-9f5g3" target="_blank" rel="noopener">这个链接</a><br>这个例子本质上也是参考上面代码的例子，只是这里我们需要理解的是 <code>ref</code> 属性是可以传一个引用的</p><p>所以由上面的例子我们知道了，其实 <code>useRef</code> <strong>既能引用 DOM 对象也能引用普通对象</strong>，但是在传 <code>ref</code> 时需要用到 <code>forwardRef</code></p><p>而对于 <code>forwardRef</code> 来说，由于 <code>props</code> 不包含 <code>ref</code>(主要是大部分时候也不需要 <code>props</code> 去传一个 <code>ref</code>)，这个时候才需要 <code>forwardRef</code>。</p><p>而 <code>forwardRef</code> 本身就是通过 <code>ref</code> 的透传来实现对于指定的 DOM 的定位的，这一点和 Vue 的 refs 是一样的</p><h3 id="useRef-总结"><a href="#useRef-总结" class="headerlink" title="useRef 总结"></a>useRef 总结</h3><p>由于每次的渲染，组件函数中对应的 <code>state</code> 都会不一样，比如上述代码中的 <code>n</code>。如果希望拿到同一个 <code>n</code>，那么可以考虑使用 <code>useRef</code> 这个 hook，那么这个时候你就需要访问的是 <code>n.current</code> 而不是 <code>n</code> 了。</p><p><code>useRef</code> <strong>不能做到变化时自动更新 render</strong>，前面说过解决方案，就是通过监听 <code>n</code>，当 <code>n.current</code> 变化时调用 <code>update</code> 解决，这里需要配合 <code>useState</code> 这个 hook 来使用。也就是说这个功能需要你自己加</p><h2 id="useContext"><a href="#useContext" class="headerlink" title="useContext"></a>useContext</h2><p>其实想想，<code>Context</code> 的译文就是 “上下文”。那么什么是上下文呢？</p><ul><li><strong>全局变量</strong> 是全局的 <strong>上下文</strong></li><li><strong>上下文</strong> 是局部的 <strong>全局变量</strong></li></ul><p>实际上 <code>useContext</code> 的用法跟 <code>useRef</code> 差不多，不过 <code>useContext</code> 不仅能<strong>贯穿始终</strong>，还能<strong>贯穿不同组件</strong></p><h3 id="使用-useContext"><a href="#使用-useContext" class="headerlink" title="使用 useContext"></a>使用 useContext</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useContext, useState &#125; <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> themeContext = React.createContext(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [theme, setTheme] = useState(<span class="string">"red"</span>);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="comment">// 这里 value 传入读写 API</span></span><br><span class="line">    &lt;themeContext.Provider value=&#123;&#123; theme, setTheme &#125;&#125;&gt;</span><br><span class="line">      &lt;div className=&#123;<span class="string">`App <span class="subst">$&#123;theme&#125;</span>`</span>&#125;&gt;</span><br><span class="line">        &lt;p&gt;&#123;theme&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">        &lt;div&gt;</span></span><br><span class="line"><span class="regexp">          &lt;ChildA /</span>&gt;</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;div&gt;</span></span><br><span class="line"><span class="regexp">          &lt;ChildB /</span>&gt;</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    &lt;<span class="regexp">/themeContext.Provider&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">function ChildA() &#123;</span></span><br><span class="line"><span class="regexp">  const &#123; theme, setTheme &#125; = useContext(themeContext); /</span><span class="regexp">/ 子组件中可以用 setTheme 函数</span></span><br><span class="line"><span class="regexp">  console.log(theme); /</span><span class="regexp">/ 子组件中可以拿到 theme 状态</span></span><br><span class="line"><span class="regexp">  return (</span></span><br><span class="line"><span class="regexp">    &lt;div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;button onClick=&#123;() =&gt; setTheme("red")&#125;&gt;red&lt;/</span>button&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">function ChildB() &#123;</span></span><br><span class="line"><span class="regexp">  const &#123; setTheme &#125; = useContext(themeContext); /</span><span class="regexp">/ 子组件中可以用 setTheme 函数</span></span><br><span class="line"><span class="regexp">  return (</span></span><br><span class="line"><span class="regexp">    &lt;div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;button onClick=&#123;() =&gt; setTheme("blue")&#125;&gt;blue&lt;/</span>button&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p><a href="https://codesandbox.io/s/exciting-mirzakhani-4i06k" target="_blank" rel="noopener">代码链接在这里</a></p><p>所以我们从中可以看到使用 <code>useContext</code> 的步骤了</p><ol><li>使用 <code>C = CreateContext(initial)</code> 创建上下文</li><li>使用 <code>C.Provider</code> 来限定要传的值的作用域在这个范围内</li><li>然后在 <code>C.Provider</code> 的作用域内使用 <strong><code>useContext(C)</code></strong> 来使用上下文(也就是 <code>C.Provider</code> 组件里面的 <code>value</code>)</li></ol><h3 id="useContext-注意点"><a href="#useContext-注意点" class="headerlink" title="useContext 注意点"></a>useContext 注意点</h3><p><code>useContext</code> 这个 hook 并不是响应式的，在一个组件中将 <code>C</code> 里面的值改变了(比如上述代码中的 <code>theme</code> 改变了)，另一个组件并不会知道这个变化。<strong>所以如果需要能够响应式，最好是配合 <code>useState</code> 来使用</strong></p><h3 id="useContext-总结"><a href="#useContext-总结" class="headerlink" title="useContext 总结"></a>useContext 总结</h3><p>如果希望拿到同一个 <code>n</code>，那么可以考虑使用 <code>useContext</code> 这个 hook，只需要将 <code>useRef</code> 的地方改成 <code>useContext</code> 就行</p><h2 id="useEffect"><a href="#useEffect" class="headerlink" title="useEffect"></a>useEffect</h2><p>这个就是 “副作用” 了，什么意思呢？</p><ul><li>在 js 中，我们把对环境的改变就叫 <strong>副作用</strong>，一个很典型的例子就是 <strong>修改 <code>document.title</code></strong></li><li>一定非得要把一些副作用的操作放到 <code>useEffect</code> 中执行么？<strong>不一定</strong></li><li>你可以把它理解为 <code>afterRender</code> ，因为这个<strong>总在 <code>render</code> 后执行</strong></li></ul><p>React 渲染的大致流程如下</p><figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">App()          <span class="comment">--&gt;  执行          --&gt; 生成虚拟 DOM --</span></span><br><span class="line">                                                    |</span><br><span class="line">             render 完毕                            |</span><br><span class="line">                ↓                                   |</span><br><span class="line">执行 useEffect &lt;<span class="comment">--  改变外观     &lt;-- 生成真实 DOM &lt;--</span></span><br><span class="line">      ↑                ↑</span><br><span class="line">&lt;<span class="keyword">div</span>&gt;<span class="number">1000</span>&lt;/<span class="keyword">div</span>&gt;     &lt;<span class="keyword">div</span>&gt;<span class="number">0</span>&lt;/<span class="keyword">div</span>&gt;</span><br></pre></td></tr></table></figure><p>如上面所示，在改变外观这里，render 完毕之后，就会执行 <code>useEffect</code>。</p><h3 id="使用-useEffect"><a href="#使用-useEffect" class="headerlink" title="使用 useEffect"></a>使用 useEffect</h3><ul><li><code>useEffect(() =&gt; {}, [])</code><br>  由于第二个参数传的是一个空数组，所以第一个参数函数只有在<strong>第一次渲染时执行</strong></li><li><code>useEffect(() =&gt; {}, [n])</code><br>  由于第二个参数传的是一个 <code>[n]</code>，这里表示<strong>只要 <code>n</code> 有变化</strong>，那么第一个参数函数就会执行</li><li><code>useEffect(() =&gt; {})</code><br>  由于没有传第二个参数，这里就表示 <strong>任何一个 state 变化时都不会执行</strong></li></ul><p><code>useEffect</code> 还有个用法，就是当组件处于 <code>componentWillUnmount</code> 时，即组件快要挂掉时使用，比如</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> id = setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;, <span class="number">1000</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="comment">// 这里 return 一个函数，当组件挂掉时调用这个，清理掉定时器，避免内存泄露</span></span><br><span class="line">    clearInterval(id)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, [])</span><br></pre></td></tr></table></figure><p><code>useEffect</code> 还有一个特点跟 <code>useState</code> 一样的，就是<strong>如果同时存在多个 <code>useEffect</code>， 会按照其出现的次序执行</strong></p><h3 id="useEffect-总结"><a href="#useEffect-总结" class="headerlink" title="useEffect 总结"></a>useEffect 总结</h3><ul><li>在对环境有些副作用操作的时候用 <code>useEffect</code></li><li>前面说的 <code>useEffect</code> 的几种用法中，可以都同时存在</li><li>可以将 <code>useEffect</code> 理解成 “afterRender”，因为它就是在 render 之后执行的</li></ul><h2 id="useLayoutEffect"><a href="#useLayoutEffect" class="headerlink" title="useLayoutEffect"></a>useLayoutEffect</h2><p>如果说 <code>useEffect</code> 在浏览器渲染完成后执行，那么 <code>useLayoutEffect</code> 就是在<strong>浏览器渲染完成前执行</strong>，它的位置在如下所示的位置</p><figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">App()          <span class="comment">--&gt;  执行          --&gt; 生成虚拟 DOM --</span></span><br><span class="line">                                                     |</span><br><span class="line">             render 完毕       useLayoutEffect       |</span><br><span class="line">                ↓                 ↓                  |</span><br><span class="line">执行 useEffect &lt;<span class="comment">--  改变外观     &lt;-- 生成真实 DOM &lt;--</span></span><br><span class="line">      ↑                ↑</span><br><span class="line">&lt;<span class="keyword">div</span>&gt;<span class="number">1000</span>&lt;/<span class="keyword">div</span>&gt;     &lt;<span class="keyword">div</span>&gt;<span class="number">0</span>&lt;/<span class="keyword">div</span>&gt;</span><br></pre></td></tr></table></figure><h3 id="useLayoutEffect-特点"><a href="#useLayoutEffect-特点" class="headerlink" title="useLayoutEffect 特点"></a>useLayoutEffect 特点</h3><ul><li>由图可知，<code>useLayoutEffect</code> 总是比 <code>useEffect</code> 先执行</li><li><code>useLayoutEffect</code> 里的操作最好是影响了 layout，虽然它性能更高，但是如果在这个里面的操作很多，它会影响用户看到画面变化的时间。从用户的角度来说，这是很影响用户体验的</li></ul><h3 id="useLayoutEffect-总结"><a href="#useLayoutEffect-总结" class="headerlink" title="useLayoutEffect 总结"></a>useLayoutEffect 总结</h3><ul><li>是跟 <code>useEffect</code> 差不多的玩意儿，不同之处在于其执行的优先级，它的优先级比 <code>useEffect</code> 高</li><li>为了用户体验，在能使用 <code>useEffect</code> 解决问题的前提下，尽量不要使用这个 <code>useLayoutEffect</code></li></ul><h2 id="useMemo"><a href="#useMemo" class="headerlink" title="useMemo"></a>useMemo</h2><p>这里 <code>Memo</code> 的全称应该是 <code>Memorize</code> 也就是 “记忆”，这个钩子的作用就是记忆代码，如果有多余的代码就不执行，怎么理解呢，在理解这个之前，需要先看看 <code>React.memo</code></p><h3 id="理解-React-memo"><a href="#理解-React-memo" class="headerlink" title="理解 React.memo"></a>理解 React.memo</h3><p>假设有如下的代码</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [n, setN] = React.useState(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> [m, setM] = React.useState(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> onClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    setN(n + <span class="number">1</span>);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">"App"</span>&gt;</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;button onClick=&#123;onClick&#125;&gt;update n &#123;n&#125;&lt;<span class="regexp">/button&gt; /</span>*点击 button 只让 n + <span class="number">1</span>*<span class="regexp">/</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">      &lt;Child data=&#123;m&#125; /&gt; <span class="comment">/* 这里的 m 没有变化，按照理由来说 child 不应该重新渲染才对*/</span></span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">function Child(props) &#123;</span></span><br><span class="line"><span class="regexp">  console.log("child 执行了");</span></span><br><span class="line"><span class="regexp">  console.log("假设这里有大量代码"); /</span><span class="regexp">/ 但是这里却执行了!!!</span></span><br><span class="line"><span class="regexp">  return &lt;div&gt;child: &#123;props.data&#125;&lt;/</span>div&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>传入的 <code>props.data</code> 根本没有变化，即 <code>m</code> 没有变，变的只是 <code>n</code>，但是这里 <code>Child()</code> 每次都执行了，要是 <code>Child()</code> 函数里面有很多的代码，势必会造成页面的卡顿现象，于是这个时候，<code>React.memo</code> 就排上用场了</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [n, setN] = React.useState(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> [m, setM] = React.useState(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> onClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    setN(n + <span class="number">1</span>);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">"App"</span>&gt;</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;button onClick=&#123;onClick&#125;&gt;update n &#123;n&#125;&lt;<span class="regexp">/button&gt; /</span>*点击 button 只让 n + <span class="number">1</span>*<span class="regexp">/</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">      &lt;Child2 data=&#123;m&#125; /&gt; <span class="comment">/* 这里的 m 没有变化，按照理由来说 child 不应该重新渲染才对*/</span></span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">function Child(props) &#123;</span></span><br><span class="line"><span class="regexp">  console.log("child 执行了");</span></span><br><span class="line"><span class="regexp">  console.log("假设这里有大量代码"); /</span><span class="regexp">/ 使用了 React.memo 后，这里就没有执行了!!!</span></span><br><span class="line"><span class="regexp">  return &lt;div&gt;child: &#123;props.data&#125;&lt;/</span>div&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Child2 = React.memo(Child)</span><br></pre></td></tr></table></figure><p>如果 <code>props</code> 没变，就没有必要再次执行一个函数组件，这个 <code>React.memo</code> 是属于 React 优化的一部分。原理就是跟缓存的道理一样的。在 React 中，其默认有多余的 render。为了解决这个问题后面才出来 memo</p><h3 id="React-memo-的-bug"><a href="#React-memo-的-bug" class="headerlink" title="React.memo 的 bug"></a>React.memo 的 bug</h3><p>请看如下的代码</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [n, setN] = React.useState(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> [m, setM] = React.useState(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> onClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    setN(n + <span class="number">1</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">const</span> onClickChild = <span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="comment">// 这里只是添加了一个 click 的回调而已。。。</span></span><br><span class="line">    <span class="built_in">console</span>.log(m);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">"App"</span>&gt;</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;button onClick=&#123;onClick&#125;&gt;update n &#123;n&#125;&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">      &lt;Child2 data=&#123;m&#125; onClick=&#123;onClickChild&#125; /&gt;</span><br><span class="line">      &#123;<span class="comment">/* Child2 居然又执行了 */</span>&#125;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">function Child(props) &#123;</span></span><br><span class="line"><span class="regexp">  console.log("child 执行了");</span></span><br><span class="line"><span class="regexp">  console.log("假设这里有大量代码"); /</span><span class="regexp">/ 这里的代码因为仅仅只是添加了回调的原因，居然又执行了!!!</span></span><br><span class="line"><span class="regexp">  return &lt;div onClick=&#123;props.onClick&#125;&gt;child: &#123;props.data&#125;&lt;/</span>div&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Child2 = React.memo(Child); <span class="comment">// memo 在这里就没用了!!!</span></span><br></pre></td></tr></table></figure><p>为什么在这种情况下 <code>React.memo</code> 的优化作用失效了呢？因为在点击 button 更新 <code>n</code> 的数据时会再次渲染页面，就会再次执行 <code>App()</code>，就会再次声明 <code>onClickChild</code> 这个函数，<strong>而这个函数的地址已经变了!!!!</strong>。因为这个函数地址变的原因，<strong>React 就判断其 <code>props</code> 产生了变化</strong>，于是就认为 <code>Child</code> 组件已经变化了，需要重新渲染它!!，于是乎 <code>Child()</code> 就会再次执行!!!</p><p>那么还有什么解决办法呢？有的，就是使用 <code>useMemo</code>，使用这个 hook 就不会有这个问题</p><h3 id="使用-useMemo"><a href="#使用-useMemo" class="headerlink" title="使用 useMemo"></a>使用 useMemo</h3><p>使用 <code>useMemo</code> 去解决上面的 bug 的话，只需要将 <code>onClickChild</code> 函数修改成如下</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> onClickChild = useMemo(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> fn = <span class="function"><span class="params">div</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"on click child, m: "</span> + m);</span><br><span class="line">    <span class="built_in">console</span>.log(div);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> fn;</span><br><span class="line">&#125;, [m]); <span class="comment">// 这里只要 m 变化才能说明 `onClickChild` 变化了，当然这里的 m 要是改为 n 会打印出旧的 n 的数据</span></span><br></pre></td></tr></table></figure><ul><li><code>useMemo</code> 第一个参数是一个工厂函数 <code>() =&gt; value</code>, 第二个参数是依赖<code>[n, m]</code>，只有当依赖变化时，才会计算出新的 <code>value</code></li><li>如果依赖没有变化，则服用之前的 <code>value</code></li></ul><h3 id="useMemo-注意点"><a href="#useMemo-注意点" class="headerlink" title="useMemo 注意点"></a>useMemo 注意点</h3><ul><li><p>如果本身 <code>value</code> 是一个函数，你就必须要这么写</p>  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">useMemo(<span class="function"><span class="params">()</span> =&gt;</span> <span class="function"><span class="params">x</span> =&gt;</span> <span class="built_in">console</span>.log(x), [m]) <span class="comment">// 注意这里是一个返回函数的函数</span></span><br></pre></td></tr></table></figure></li><li><p>如果觉得这很不优雅，推荐使用 <code>useCallback</code></p></li></ul><h3 id="useMemo-总结"><a href="#useMemo-总结" class="headerlink" title="useMemo 总结"></a>useMemo 总结</h3><p>从本质上看 <code>useMemo</code> 有点像 Vue 中的 Computed，其计算属性本来就依赖一个会变化的数据，数据变化时 vue 会帮你做相应的更新操作</p><p><code>useMemo</code> 一般是结合 <code>React.memo</code> 做一些代码层面的优化工作</p><h2 id="useCallback"><a href="#useCallback" class="headerlink" title="useCallback"></a>useCallback</h2><p><code>useCallback</code> 就是为了解决上述 <code>useMemo</code> 中 <code>value</code> 是一个函数时的传参写法问题的，它的用法如下</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">useCallback(<span class="function"><span class="params">x</span> =&gt;</span> <span class="built_in">console</span>.log(x), [m])</span><br></pre></td></tr></table></figure><p>其等价于<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">useMemo(<span class="function"><span class="params">()</span> =&gt;</span> <span class="function"><span class="params">x</span> =&gt;</span> <span class="built_in">console</span>.log(x), [m])</span><br></pre></td></tr></table></figure></p><h3 id="useCallback-总结"><a href="#useCallback-总结" class="headerlink" title="useCallback 总结"></a>useCallback 总结</h3><p>这个是跟 <code>useMemo</code> 功能相近的 hook，主要为了补充 <code>useMemo</code> 传参的写法用的</p><h2 id="useImperativeHandle"><a href="#useImperativeHandle" class="headerlink" title="useImperativeHandle"></a>useImperativeHandle</h2><p>你可以将其理解为 <code>setRef</code>，其作用就是 <strong>自定义 ref 的属性</strong>，<a href="https://codesandbox.io/s/elegant-poitras-mxoym" target="_blank" rel="noopener">代码链接在这里</a></p><p>关键的代码在这一句</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">setRef(ref, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    x: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      realButton.current.remove();</span><br><span class="line">    &#125;,</span><br><span class="line">    realButton: realButton</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>其实就是给 <code>ref</code> 增添了属性，让其对应的 <code>ref</code> 能够访问到 <code>realButton</code> 这个属性以及能够调用 <code>x</code> 这个方法</p><h2 id="hooks-其他内容-dlc"><a href="#hooks-其他内容-dlc" class="headerlink" title="hooks 其他内容(dlc)"></a>hooks 其他内容(dlc)</h2><h3 id="如何自定义-hook"><a href="#如何自定义-hook" class="headerlink" title="如何自定义 hook"></a>如何自定义 hook</h3><p>拿 <code>useState</code> 举例，可以将自己定义的 hook 作为一个模块封装起来然后 <code>export</code> 出去，具体来说就像如下代码所做的</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useState, useEffect &#125; <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> useList = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [list, setList] = useState(<span class="literal">null</span>);</span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    ajax(<span class="string">"/list"</span>).then(<span class="function"><span class="params">list</span> =&gt;</span> &#123;</span><br><span class="line">      setList(list); <span class="comment">// 异步请求</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;, []); <span class="comment">// [] 确保只在第一次运行</span></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    list: list,</span><br><span class="line">    setList: setList,</span><br><span class="line">    addItem: <span class="function"><span class="params">name</span> =&gt;</span> &#123;</span><br><span class="line">      setList([...list, &#123; <span class="attr">id</span>: <span class="built_in">Math</span>.random(), <span class="attr">name</span>: name &#125;]);</span><br><span class="line">    &#125;,</span><br><span class="line">    deleteIndex: <span class="function"><span class="params">index</span> =&gt;</span> &#123;</span><br><span class="line">      setList(list.slice(<span class="number">0</span>, index).concat(list.slice(index + <span class="number">1</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> useList;</span><br></pre></td></tr></table></figure><p>所以我们可以看到，这里本质上就是对 <code>useState</code> 这个 hook 做了一层封装，然后返回的依然是 <code>state</code> 以及 <code>setState</code> 这个方法，即返回的是一个<strong>读(查)写(增删改) API</strong></p><h3 id="自定义-hook-注意点"><a href="#自定义-hook-注意点" class="headerlink" title="自定义 hook 注意点"></a>自定义 hook 注意点</h3><ul><li>也可以在自定义 hook 里面使用 <code>Context</code> API</li><li><code>useState</code> 可以在函数里使用，关键是这个函数是在组件里面运行的就可以</li></ul><h3 id="Stale-Closure"><a href="#Stale-Closure" class="headerlink" title="Stale Closure"></a>Stale Closure</h3><p>这个主要是被尤大吐槽过的，说他在读一些使用 hooks 写的库时就十分的脑壳疼，评价其为过时的闭包(stale closure)</p><p>那么过时闭包是怎么一回事呢，来看如下的代码</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createIncrement</span>(<span class="params">i</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> value = <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">increment</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    value += i;</span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">    <span class="keyword">const</span> message = <span class="string">`Current value is <span class="subst">$&#123;value&#125;</span>`</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">logValue</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(message);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> increment;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> inc = createIncrement(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">const</span> log = inc(); <span class="comment">// logs 1</span></span><br><span class="line">inc();             <span class="comment">// logs 2</span></span><br><span class="line">inc();             <span class="comment">// logs 3</span></span><br><span class="line"><span class="comment">// Does not work!</span></span><br><span class="line">log();             <span class="comment">// logs "Current value is 1"</span></span><br></pre></td></tr></table></figure><p>最后 <code>log</code> 居然还是之前第一次的 <code>value</code>, 这不科学！！！但是这是正常的，毕竟你保存的是第一个函数执行的地址，而其他函数执行地址跟这个不一样，所以才有这个问题</p><p>于是解决办法也有，其实只要每次得到最新的 <code>value</code> 就可以了</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createIncrementFixed</span>(<span class="params">i</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> value = <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">increment</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    value += i;</span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">logValue</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">const</span> message = <span class="string">`Current value is <span class="subst">$&#123;value&#125;</span>`</span>; <span class="comment">// 注意这里将这句移动到 logValue 里面来了 !!!</span></span><br><span class="line">      <span class="built_in">console</span>.log(message);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> increment;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> inc = createIncrementFixed(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">const</span> log = inc(); <span class="comment">// logs 1</span></span><br><span class="line">inc();             <span class="comment">// logs 2</span></span><br><span class="line">inc();             <span class="comment">// logs 3</span></span><br><span class="line"><span class="comment">// Works!</span></span><br><span class="line">log();             <span class="comment">// logs "Current value is 3"</span></span><br></pre></td></tr></table></figure><p>所以说 hooks 中也有解决这些过时闭包的 bug 出现的措施，就是依赖更新。<br>比如 <code>useEffect</code> 中要传的第二个参数，比如 <code>useState</code> 中 <code>setState</code> 传一个函数更新的形式，都是为了解决这个 bug 而出现的举措。<br>这里就不详细说明了，有兴趣的童鞋可以去参考我列出的链接</p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://dmitripavlutin.com/react-hooks-stale-closures/" target="_blank" rel="noopener">Be Aware of Stale Closures when Using React Hooks</a></li><li><a href="https://zh-hans.reactjs.org/docs/hooks-intro.html" target="_blank" rel="noopener">hooks 简介</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文主要会就 React hooks 中用的比较多的 &lt;code&gt;useState&lt;/code&gt; 做一个详细讲解，其他的 hooks 会涉及到原理和使用但不会涉及到源码仿写，望周知&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="React" scheme="https://strugglebak.github.io/categories/React/"/>
    
    
      <category term="react-hooks" scheme="https://strugglebak.github.io/tags/react-hooks/"/>
    
  </entry>
  
  <entry>
    <title>从Promise本质开始(一):实现Promise前言</title>
    <link href="https://strugglebak.github.io/2020/03/09/%E4%BB%8EPromise%E6%9C%AC%E8%B4%A8%E5%BC%80%E5%A7%8B-%E4%B8%80-%E5%AE%9E%E7%8E%B0Promise%E5%89%8D%E8%A8%80/"/>
    <id>https://strugglebak.github.io/2020/03/09/从Promise本质开始-一-实现Promise前言/</id>
    <published>2020-03-09T10:02:39.000Z</published>
    <updated>2022-06-04T08:13:29.212Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>注意，由于本文讨论的是使用 TDD 方式实现一个 Promise，所以本文着重描述的是搭建 TDD 环境</p></blockquote><a id="more"></a><h2 id="Promise-能解决什么问题"><a href="#Promise-能解决什么问题" class="headerlink" title="Promise 能解决什么问题"></a>Promise 能解决什么问题</h2><p>先来看一段代码</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">fs.readdir(source, <span class="function"><span class="keyword">function</span> (<span class="params">err, files</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'Error finding files: '</span> + err)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        files.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">filename, fileIndex</span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(filename)</span><br><span class="line">            gm(source + filename).size(<span class="function"><span class="keyword">function</span> (<span class="params">err, values</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (err) &#123;</span><br><span class="line">                    <span class="built_in">console</span>.log(<span class="string">'Error identifying file size: '</span> + err)</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="built_in">console</span>.log(filename + <span class="string">' : '</span> + values)</span><br><span class="line">                    aspect = (values.width / values.height)</span><br><span class="line">                    widths.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">width, widthIndex</span>) </span>&#123;</span><br><span class="line">                        height = <span class="built_in">Math</span>.round(width / aspect)</span><br><span class="line">                        <span class="built_in">console</span>.log(<span class="string">'resizing '</span> + filename + <span class="string">'to '</span> + height + <span class="string">'x'</span> + height)</span><br><span class="line">                        <span class="keyword">this</span>.resize(width, height).write(dest + <span class="string">'w'</span> + width + <span class="string">'_'</span> + filename, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">                            <span class="keyword">if</span> (err) <span class="built_in">console</span>.log(<span class="string">'Error writing file: '</span> + err)</span><br><span class="line">                        &#125;)</span><br><span class="line">                    &#125;.bind(<span class="keyword">this</span>))</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>可以看到着里面产生了几个回调，也就是那个著名的 <code>callback hell</code>(回调地狱)</p><p>所以这有可能真的是回调地狱的问题么?来看看改善之后的代码吧</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">fs.readdir(source, (err, files) =&gt; &#123;</span><br><span class="line">  travalFiles = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">console</span>.log(<span class="string">'Error: 找不到目录'</span> + err)</span><br><span class="line">    &#125;</span><br><span class="line">    files.forEach(gmFile)</span><br><span class="line">  &#125;</span><br><span class="line">  gmFile = <span class="function">(<span class="params">filename</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(filename)</span><br><span class="line">    gm(source + filename).size(afterGetSize)</span><br><span class="line">  &#125;</span><br><span class="line">  afterGetSize = <span class="function">(<span class="params">err, values</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">return</span> <span class="built_in">console</span>.log(<span class="string">'无法读取文件尺寸: '</span> + err)</span><br><span class="line">    <span class="built_in">console</span>.log(filename + <span class="string">' : '</span> + values)</span><br><span class="line">    aspect = (values.width / values.height)</span><br><span class="line">    widths.forEach(<span class="function">(<span class="params">width, widthIndex</span>) =&gt;</span> resize(width, aspect))</span><br><span class="line">  &#125;</span><br><span class="line">  resize = <span class="function">(<span class="params">width, aspect</span>) =&gt;</span> &#123;</span><br><span class="line">    height = <span class="built_in">Math</span>.round(width / aspect)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'将'</span> + filename + <span class="string">'的尺寸变为'</span> + width + <span class="string">'x'</span> + height)</span><br><span class="line">    <span class="keyword">this</span>.resize(width, height).write(</span><br><span class="line">      dest + <span class="string">'w'</span> + width + <span class="string">'_'</span> + filename,</span><br><span class="line">      (err) =&gt; err &amp;&amp; <span class="built_in">console</span>.log(<span class="string">'Error writing file: '</span> + err)</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  travalFiles(err, files)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>上面的代码没有回调么？当然有，那么为什么看起来清晰了呢？是因为这里将 <strong>函数当作参数传给要调用的函数了</strong>，所以其实对于 <code>Promise</code> 而言也是一样的</p><h2 id="Promise-的优点"><a href="#Promise-的优点" class="headerlink" title="Promise 的优点"></a>Promise 的优点</h2><p>优点有俩</p><h3 id="减少缩进-在整体代码的意义上"><a href="#减少缩进-在整体代码的意义上" class="headerlink" title="减少缩进(在整体代码的意义上)"></a>减少缩进(在整体代码的意义上)</h3><p>将 <strong>函数套函数</strong> 的形式转变成 <strong>链式调用</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">f1(xxx, <span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">    f3(yyy, <span class="function"><span class="keyword">function</span> <span class="title">f4</span>(<span class="params">b</span>) </span>&#123;</span><br><span class="line">        f5(a+b, <span class="function"><span class="keyword">function</span> <span class="title">f6</span>(<span class="params"></span>) </span>&#123;&#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>转变成</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">f1(xxx)</span><br><span class="line">    .then(f2) <span class="comment">// f2 调用 f3，并同时将参数作为结果输出</span></span><br><span class="line">    .then(f4) <span class="comment">// f4 调用 f5，并同时接受到 f2 的结果(就是参数)，f5 就得到了 f2 以及 f4 的参数</span></span><br><span class="line">    .then(f6)</span><br></pre></td></tr></table></figure><h3 id="消灭-if-err-形式的代码"><a href="#消灭-if-err-形式的代码" class="headerlink" title="消灭 if(err) 形式的代码"></a>消灭 if(err) 形式的代码</h3><ul><li>关于错误的处理可以单独放到一个函数里面</li><li>如果不处理，则一直等到向后抛</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">f1(xxx)</span><br><span class="line">    .then(f2, error1)</span><br><span class="line">    .then(f4, error2)</span><br><span class="line">    .then(f6, error3)</span><br><span class="line">    .then(<span class="literal">null</span>, errorAll)</span><br><span class="line"><span class="comment">// 这里最后一句可以改成 catch, 意味着它可以处理所有的 error</span></span><br></pre></td></tr></table></figure><h2 id="如何使用-Promise"><a href="#如何使用-Promise" class="headerlink" title="如何使用 Promise"></a>如何使用 Promise</h2><p>对于一个异步的代码，以前是这么写</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        fn(<span class="string">'1 秒后调用'</span>) <span class="comment">// 这里相当于 fn.call(null, '1 秒后调用')</span></span><br><span class="line">    &#125; , <span class="number">1000</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test(<span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">'传入 fn'</span>) &#125;)</span><br></pre></td></tr></table></figure><p>如果使用 <code>Promise</code></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// new Promise 接受一个参数，返回一个 Promise 实例</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            resolve(<span class="string">'1 秒后调用'</span>)</span><br><span class="line">        &#125; , <span class="number">1000</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test(<span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">'传入 fn'</span>) &#125;)</span><br></pre></td></tr></table></figure><h2 id="Promise-有哪些-API"><a href="#Promise-有哪些-API" class="headerlink" title="Promise 有哪些 API"></a>Promise 有哪些 API</h2><ul><li><strong>Promise 是一个类</strong>(相当于一个特殊的函数)</li><li>类属性: <code>length</code></li><li>类方法: <code>all</code>, <code>allSettled</code>, <code>race</code>, <code>reject</code>, <code>resolve</code></li><li>对象属性: <strong><code>then</code></strong> , <code>finally</code>, <code>catch</code></li><li>对象内部属性: <strong><code>state</code></strong>(pending, fullfilled, rejected)</li></ul><p>这里注意，<code>state</code> 的 <code>pending</code> 状态的转变是单向的，即只有</p><ul><li>pending -&gt; fullfilled(成功)</li><li>pending -&gt; rejected(失败)</li></ul><p><strong>并且 fullfilled 以及 rejected 状态不能互相转变，也不能转化成 pending</strong></p><h2 id="Promise-API-怎么写"><a href="#Promise-API-怎么写" class="headerlink" title="Promise API 怎么写"></a>Promise API 怎么写</h2><ul><li>参考 <a href="https://promisesaplus.com/" target="_blank" rel="noopener">promise/A+ 规范</a> 或者其 <a href="https://juejin.im/post/5b6161e6f265da0f8145fb72" target="_blank" rel="noopener">翻译版文档</a></li><li>在写代码时根据文档<strong>写测试用例</strong>，规则都通过了说明 <code>Promise</code> 相关的逻辑也就完成了</li></ul><h2 id="使用测试工具"><a href="#使用测试工具" class="headerlink" title="使用测试工具"></a>使用测试工具</h2><h3 id="使用-chai"><a href="#使用-chai" class="headerlink" title="使用 chai"></a>使用 chai</h3><p>先全局安装两个包</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yarn add -g ts-node mocha</span><br></pre></td></tr></table></figure><p>然后创建项目 <code>promise-easy</code>，再执行</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> promise-easy</span><br><span class="line">yarn init -y</span><br></pre></td></tr></table></figure><p>最后再次给项目安装包</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yarn add -D ts-node mocha chai @types/chai @types/mocha typescript</span><br></pre></td></tr></table></figure><p>然后创建 <code>test/index.ts</code></p><figure class="highlight irpf90"><table><tr><td class="code"><pre><span class="line"><span class="keyword">touch</span> test/<span class="built_in">index</span>.ts</span><br></pre></td></tr></table></figure><p>最后增加 <code>package.json</code> 的 <code>scripts</code></p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">"scripts": &#123;</span><br><span class="line">    "test": "mocha -r ts-node/register test/**/*.ts" // mocha 使用 ts-node/register 模块来对 test 下的 ts 文件进行测试</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后执行</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yarn <span class="built_in">test</span></span><br></pre></td></tr></table></figure><p>出现如下打印输出则算配置成功</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yarn run v1.21.1</span><br><span class="line">$ mocha -r ts-node/register <span class="built_in">test</span>/**/*.ts</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  0 passing (5ms)</span><br><span class="line"></span><br><span class="line">Done <span class="keyword">in</span> 3.18s.</span><br></pre></td></tr></table></figure><p>然后说下这几个包的作用</p><ul><li><code>chai</code>: chai 是一个 BDD/TDD 的断言库，我们经常使用其 <code>assert</code> api 来做测试种断言的操作</li><li><code>mocha</code>: mocha 是一个多功能的测试框架，我们经常使用其 <code>describe</code> 以及 <code>it</code> api 来做相关的测试</li><li><code>ts-node</code>, <code>typescript</code>: ts-node 是用来编译 node 中的 typescript 用的，使用 typescript 时需要安装 typescript</li><li><code>@types/chai</code>, <code>@types/mocha</code>: chai 和 mocha 的 typescript 版本，方便在 ts 文件中引入</li></ul><p>现在就可以在 <code>test/index.ts</code> 中写代码了</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; assert &#125; <span class="keyword">from</span> <span class="string">'chai'</span></span><br><span class="line"><span class="keyword">import</span> &#123; describe, it &#125; <span class="keyword">from</span> <span class="string">'mocha'</span></span><br><span class="line"></span><br><span class="line">describe(<span class="string">'测试 Chai 的使用'</span>, () =&gt; &#123;</span><br><span class="line"> it(<span class="string">'可以测试相等'</span>, () =&gt; &#123;</span><br><span class="line">    assert(<span class="number">1</span> === <span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>其中 <code>describe</code> 表示描述测试的场景，而 <code>it</code> 表示在该测试场景下的对象</p><blockquote><p>注意，若在断言的那段代码的上面加 <code>//@ts-ignore</code> 即可屏蔽掉 typescript 对这段代码的检查，那么代码在编译运行时就不会报错</p></blockquote><p>对于 <code>assert</code> 这个 api 来说，它里面有很多的函数比如经常使用到的有如下几个</p><ul><li><code>isXXX</code>: 判断对象或变量的类型用的，比如 <code>isFunction</code>，<code>isObject</code></li><li><code>throw</code>: 这个一般用于你想让其传入的回调函数中的代码报错</li></ul><h3 id="使用-sinon"><a href="#使用-sinon" class="headerlink" title="使用 sinon"></a>使用 sinon</h3><p>安装 <code>sinon</code></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yarn add -D sinon sinon-chai @types/sinon @types/sinon-chai</span><br></pre></td></tr></table></figure><p>然后说下这几个包都是啥</p><ul><li><code>sinon</code>: 适用于任何单元测试框架的测试库</li><li><code>sinon-chai</code>: 为 <code>sinon</code> 提供了一系列自自定义的断言 api，相当于 chai 的拓展</li><li><code>@types/sinon</code>, <code>@types/sinon-chai</code>: sinon 和 sinon-chai 的 typescript 版本</li></ul><p>在这里主要是使用 <code>sinon.fake()</code> 提供一个假函数，然后通过判断这个假函数的 <code>called</code> 属性来判断函数是否被调用</p><p>你需要这样引入</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> chai <span class="keyword">from</span> <span class="string">'chai'</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> sinon <span class="keyword">from</span> <span class="string">'sinon'</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> sinonChai <span class="keyword">from</span> <span class="string">'sinon-chai</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">chai.use(sinonChai)</span></span><br></pre></td></tr></table></figure><p>然后像这样使用</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">it(<span class="string">'new Promise(fn) 中的函数立即执行'</span>, () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> fn = sinon.fake()</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(fn)</span><br><span class="line">    assert(fn.called)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文主要介绍了如何搭建测试环境，以及如何使用测试框架来进行开发(TDD)。其中比较重要的还设计到了 <code>Promise</code> 的几个要点，即</p><ul><li>Promise 要解决什么问题 - why</li><li>Promise 是怎么解决它的 - how</li><li>Promise (对比其他技术)有什么有点 - pros</li><li>Promise有什么缺点 - cons</li><li>如何解决这些缺点</li></ul><p>框架和环境已经搭建完毕，接下来就是遵循 Promise/A+ 规范实现一个简易 Promise</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;注意，由于本文讨论的是使用 TDD 方式实现一个 Promise，所以本文着重描述的是搭建 TDD 环境&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="手写源码" scheme="https://strugglebak.github.io/categories/%E6%89%8B%E5%86%99%E6%BA%90%E7%A0%81/"/>
    
    
      <category term="Promise" scheme="https://strugglebak.github.io/tags/Promise/"/>
    
  </entry>
  
</feed>

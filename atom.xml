<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Stay Hungry</title>
  
  <subtitle>对，跑快一些，再快一些</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://strugglebak.github.io/"/>
  <updated>2022-06-05T13:44:02.314Z</updated>
  <id>https://strugglebak.github.io/</id>
  
  <author>
    <name>strugglebak</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>CMU-15-445-645-笔记-04-数据库存储-part2</title>
    <link href="https://strugglebak.github.io/2022/06/05/CMU-15-445-645-%E7%AC%94%E8%AE%B0-04-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%98%E5%82%A8-part2/"/>
    <id>https://strugglebak.github.io/2022/06/05/CMU-15-445-645-笔记-04-数据库存储-part2/</id>
    <published>2022-06-05T13:35:59.000Z</published>
    <updated>2022-06-05T13:44:02.314Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>注: 本文首发我的 b 站专栏文章<a href="https://www.bilibili.com/read/cv14558880" target="_blank" rel="noopener">CMU 15-445/645-笔记-04-数据库存储-part2</a></p></blockquote><a id="more"></a><p><img src="./Cover.png" alt></p><blockquote><p>注意：这节课是 3-1 的延续</p></blockquote><ul><li><p>课程目标</p><p>  <img src="./1.png" alt></p></li><li><p>日志结构（Log-Structured）的文件组织</p><p>  <img src="./2.png" alt></p><p>  主要是存储如何创建 tuple 以及修改 tuple 的相关信息，比如增删改查的操作</p><p>  <img src="./3.png" alt></p><p>  这些记录会以文本文件的形式保存，读起来就像是日志记录一样</p><p>  为什么要这么做？</p><p>  循序写入/读取/访问的速度要远比随机访问快得多。如果使用 Slotted Pages 的方式，假设要更新 10 个在不同 page 上的 tuple，那就必须在这 10 个 page 上来写入并更新这些 tuple。但如果使用的是 Log-Structured 文件组织这种形式，把这要更新的 10 个 tuple 的语句写在单个 page 上，就一次性能搞定全部了。</p><p>  Log-Structured 文件组织这种想法也并不新颖，它是在 1980 年代末，1990 年代初出现的。虽然出现的晚，但最近十年这种技术开始起飞。比如在 HDFS 或者 S3 中，这些分布式文件系统就只支持这种追加的方式，即没办法进行随机更新，能做的就是追加记录</p><p>  但这种方式有明显缺陷，是什么呢？</p><p>  是 读取</p><p>  如果现在要去读取某个 tuple，那么就需要回头去在日志中查找这个 tuple</p><p>  <img src="./4.png" alt></p><p>  有几种方式可以加快访问的速度</p><ol><li><p>建立索引，可以通过索引跳到日志中特定的 offset 处，就能找到对应的数据</p><p> <img src="./5.png" alt></p></li><li><p>定期压缩 log</p><p> 重新遍历一遍 log，对里面的内容进行筛选压缩，而对于每个 tuple，只需要一条记录即可</p><p> 把这种</p><p> <img src="./6.png" alt></p><p> 变成这种</p><p> <img src="./7.png" alt></p><p> 有以下几个数据库用这种方式</p><p> <img src="./8.png" alt></p><ul><li>HBase</li><li>Cassandra</li><li>LevelDB</li><li><p>RocksDB</p><p>有许多分布式数据库系统使用了这种技术，并且是用 Go 写的。比如 CockroachDB 使用了 RocksDB 存储管理器作为底层，它的分布式执行层都是用 Go 来写，但在它内部使用的 RocksDB 用的是 C++。而 RocksDB 是 Meta 的，但它是基于 LevelDB 改进后的产物，而 LevelDB 是 G 家的。Meta 把 LevelDB 拿过来，首先做的事情就是干掉 mmap，然后才有的 RocksDB。</p><p>LevelDB 至今还活着，但很多人用的还是 RocksDB</p></li></ul></li></ol></li><li><p>Tuple 存储</p><p>  <img src="./9.png" alt></p><p>  例如 Integer 和 Float 这些固定长度的东西，在大部分数据库系统中其表达方式和 C/C++ 使用的方式是一样的</p><p>  <img src="./10.png" alt></p><p>  因为这通常是由 IEEE-754（二进制浮点数算数标准） 标准所定义的</p><p>  IEEE-754 是一种行业标准，用来表示数字和 CPU 的规范，比如 Integer 和 Float 应该是多少个字节，是大端对齐还是小端对齐之类的</p><p>  对于那些可变长度的类型，例如 VARCHAR/VARBINARY/TEXT/BLOB 来说，通常情况下它们里面会有一个 header，这个 header 会有 保存的 blob 的长度，如果是一个很大的值，那后面还会跟一个 checksum。紧接着跟着的就是字节序列了。</p><p>  对于时间类型来讲，大多数数据库系统通常会去保存从 1970 年 1 月 1 日起的秒数/毫秒数/微秒数来处理时间。本质上这些数据库系统保存的依然是完整的时间戳。</p><p>  对于定点数字（Fixed Point Value）来说，非常依赖于 C++ 或者底层硬件所提供给我们的数字</p><p>  <img src="./11.png" alt></p><p>  Float, Real/Double 或者可变精度的数字，这些都是 CPU 或者 C++ 给的不精确的数字</p><p>  而对可变精度数字执行操作的速度要比任意精度数字快得多，因为 CPU 拥有能高效执行这些操作的指令。比如，CPU 通过 1 条指令就能对俩浮点数进行加减运算，但处理定点数字时就需要一大堆指令来处理了</p><p>  虽然处理可变精度数字相对快，但这里也存在舍入误差，因为在 IEEE-754 标准中，并没有任何办法能够将十进制数 准确 地存入硬件，也只能使用一个大概的数字</p><p>  一个浮点数精度的例子，假如我想要的时小数点后 20 位的数，那么用 GCC 编译出来是啥结果呢？</p><p>  <img src="./12.png" alt></p><p>  因为硬件只能近似逼近或者说模拟 0.3 这个浮点数，没有办法真正精确地去表示这个数</p><p>  所以为了解决这个舍入误差的问题，就需要固定精度的数字了</p><p>  <img src="./13.png" alt></p><p>  可以把值作为 VARCHAR 类型（不是 string）来储存，然后通过一些元数据来表示，这里是小数点，那里是精度范围，接着另一边是舍入信息，这些东西都放在 tuple 里面，同时也是该 tuple 字节数组的一部分</p><p>  Postgres 一段源码</p><p>  <img src="./14.png" alt></p><p>  当声明一个 Fixed point DECIMAL 时，Postgres 就像上图中那个方式来存这个 struct，这里面包含了关于 DECIMAL 的一些额外的元数据</p><p>  <img src="./15.png" alt></p><p>  用红色标注出来的部分，其实是一个用来表示 REAL 类型值的字符串</p><p>  那么为什么操作 DECIMAL 会慢呢？下面是一段做加法的源码</p><p>  <img src="./16.png" alt></p><p>  可以看到，这并不是用一条指令就能完成的，它需要一系列的 switch 条件才能完成，比如说要判断它的正负、是不是 0，或者两个数字是否相等。但是如果是 REAL 或者是一个浮点数做加法时，CPU 只需要一条指令就能完成。</p><p>  所以如果不想因为精度问题丢失数据，那就用 Fixed Point DECIMAL</p></li><li><p>大数值</p><p>  <img src="./17.png" alt></p><p>  如果想要保存的东西因为体积太大而无法放在一个单一 page 上，该怎么办？<br>  有两种方式</p><ol><li><p>用 overflow page 来解决<br> 在这个例子中，如果这个 tuple 中的 c 对应的 data 太大了，那么就通过一个指针来指向保存 c 对应的 data 的那个 overflow page</p><p> <img src="./18.png" alt></p><p> 如果 overflow page 也放不下这个数据，那么同样可以通过 overflow 指针来指向某些其他 page 来解决这个问题</p><p> 正常情况下，overflow page 是无法通过常规手段进行操作的，所以要尽量避免</p><p> 在 Postgres 中，大部分时候，这些 overflow page 是 只读，或者几乎都用来读，很少往上面去写东西。所以大部分对 overflow page 的优化，都受到和常规 data page 或者 tuple page 一样的保护</p></li><li><p>用 外部存储 来解决</p><p> <img src="./19.png" alt><br> <img src="./20.png" alt></p><p> 基本思路是，不会把该属性的数据保存在 tuple 内部，而是往这个里面保存一个指针或者是一个文件路径，它们指向存放该数据的本地磁盘/网络存储/外部存储设备的位置</p><p> 有些系统对此进行了支持，例如 Oracle，DB2，以及巨硬</p><p> 对于 DBMS 来讲，它无法对外部存储文件中的内容做修改</p><ol><li>没有持久化保护</li><li><p>没有事务保护</p><p>有一篇 10 前年的论文，由很多在微软工作的数据库专家撰写的，叫 《TO BLOB or Not TO BLOB: Large Object Storage in a Database or a Filesystem?》</p><p>BLOB 的意思是二进制大对象，是可变长度的二进制数据</p><p>在 2000 年代，任何小于 256KB 的东西，我们都倾向于将它保存在一个 overflow page 上，任何大于 256KB 的，我们都倾向于将他保存在外部存储文件中</p><p>之前有个做 SQLite 相关工作的来 CMU 搞了一场讲座，他表示对许多手机应用来讲，最好将图像的缩略图存储在数据库系统中，尽管某些图片的大小甚至有 1MB，因为从数据库中读取这些记录会更快，因为它们已经将文件打开，就不用去根据指针在文件系统中查找文件，然后使用 f.open 来打开文件获取数据了</p><p>但是，如果将一大堆视频文件保存在高端的企业磁盘上，那就真的是浪费钱了。所以解决办法是把这些文件弄成块 （chuck），保存在 HDFS 或者使用更便宜的网络存储服务– AWS 的 S3 上面，那么数据库系统就不会因为为了维护这堆文件而负担过重了。</p></li></ol></li></ol></li><li><p>系统 Catalogs</p><p>  <img src="./21.png" alt></p><p>  系统 catalogs 是关于数据库相关信息的元数据，它里面存放了表名，索引等等</p><p>  很多数据库系统都会将它们的 catalog 用另一张表来保存</p><p>  <img src="./22.png" alt></p><p>  大部分数据库系统会通过 STANDARD INFORMATION_SCHEMA 这个 API 把 catalog 暴露出来，因为 1980 年代每个这种 API 每个数据库给的都不一样，所以后面出了 ANSI 标准使得每个数据库系统都必须支持这个 API</p><ul><li><p>访问表 Schema<br>  访问当前数据库的所有表</p><p>  <img src="./23.png" alt></p><p>  访问当前数据库某张表的 schema</p><p>  <img src="./24.png" alt></p><p>  schema，当在数据库中做查询以及构建索引时，就会用到它</p></li></ul></li></ul><ul><li><p>Wikipedia 简化版本表例子</p><p>  <img src="./25.png" alt></p></li><li><p>workload<br>  在数据库系统中，我们所关心的 workload 主要有两类</p><ol><li><p>OLTP</p><p> <img src="./26.png" alt></p><p> On-line Transaction Processing，即联机事务处理</p><p> 思路是，从外部世界拿到新数据之后，将它们放入到数据库系统中，而在查询/更新时，数据库只会去读取/更新一小部分数据，然后不断地重复类似的操作</p><p> 比如 Amazon 的 storefront，当你在网站上买东西的时候，就可以当作是对应用程序的 OLTP。购物网站会大量地进行添加商品、结账、更新账户信息等操作，但是对于顾客个人来说，只需要查询/更新他自己的那一部分数据。</p></li><li><p>OLAP</p><p> <img src="./27.png" alt></p><p> On-line Analytical Processing，即联机分析处理</p><p> 当数据库已经从 OLTP 应用程序中收集到一大堆数据时，现在要分析这堆数据，并从中推断出新的信息（数据科学？？）。同时 aka 商务智能（business intelligence）/决策支持（dicision support）/大数据（big data）</p><p> 在 OLAP 的情况下，数据库不会去更新数据，但是会读取大量的数据，要做大量的 join 操作</p><p>一张 workload characterization 图</p><p><img src="./28.png" alt></p><p>从图中可以看出</p></li></ol><ul><li>OLTP 擅长简单的查询，但是会做大量的写操作</li><li>OLAP 会做大量的读操作，但它们会更复杂</li><li><p>HTAP（Hybrid Transaction Analytical Processing）混合事务分析处理，综合 OLTP 和 OLAP 的产物</p><p>对于传统的 NoSQL 系统，mongoDB、Cassandra 以及 Redis 来讲，它们应该属于靠近 OLTP 那块，即主要往数据库里面塞入新数据</p><p>在某些分析方面，mongoDB 对此做了部分支持</p><p>而 MySQL 和 PostgreSQL 支持一些属于 OLAP 类型的查询</p><p>但这些比起列存储数据库来讲，就没那么高效了</p><p>NoSQL 是在 2000 年末出现的，有很多公司做这个，比如 G 家就为此投入了大量的资金，它们推出了 HBase、 BigTable 以及 Hadoop。它们不会去执行 SQL，也不会进行事务处理，更不会进行 join 操作，但是这就是它们能拓展的原因。</p><p>最终这帮人构建出了 NoSQL 数据库系统，比如 mongoDB 和 Cassandra，它们都试着遵循某种设计模式，以此来支持现代的软件 2.0 或 web 2.0 应用。</p><p>Hadoop 具备 OLAP 能力，而像 BigTable，Cassandra，mongoDB 具备的则是 OLTP 能力</p><p>后来人们也想在 NoSQL 系统上执行 SQL，进行事务处理，进行 join 操作，NewSQL 因此应运而生</p><p>Wiki 上 NewSQL 相关信息的第一个系统 H-Store 就是老师开发的，因为这个页面是老师写的（笑</p><p>搞 SQL 那帮人一开始表示它们不会去使用 SQL，认为 SQL 太垃圾了，除了 mongoDB 支持某些 SQL 的变体，其他的系统都不支持 SQL，但后面他们又改口说 NoSQL 的意思是 Not only SQL。。。（草，这算是技术圈的风水轮流转吗）</p><p>人们在 1970/80 以及 2000 年代都觉得 SQL 是一种糟糕的东西，但它一直都没有退出历史舞台。</p></li></ul></li><li><p>数据存储模型</p><p>  那么什么样的存储模型才能更有效地支持这些 workload 呢？</p><p>  <img src="./29.png" alt></p><ul><li><p>n-ary 存储模型（N-Ary Storage Model NSM）</p><p>  <img src="./30.png" alt></p><p>  以行（Row）的形式展示的 tuple，这被称为 n-ary 存储模型</p><p>  基本思路是，将单个 tuple 中的所有属性取出，并将它们连续地存储在 page 中</p><p>  一个 OLTP 的想法，因为要去访问的数据量在粒度上要足够的小，即一次取一行数据，而这一行数据会按照定义连续存储，这样就能访问到单个实体，拿到对应的信息。如果它是一行数据，就会非常高效，因为只需要跳到那个 page，找到那个数据就完事了。<br>  <img src="./31.png" alt><br>  <img src="./32.png" alt></p><p>  让一个 tuple 的所有数据连续地放在一起是读取数据时最有效的方式，因为用索引 index 就可以直接查了，而对于插入操作也是如此</p><p>  但为什么行储存是一个糟糕的想法呢？比如如下的一个查询例子</p><p>  <img src="./33.png" alt></p><p>  在上图的查询中，不得不去读取整个 page，而在非易失性存储设备中，它是一个基于阻塞的 API（EXTRACT ？？？），没办法直接得到这些数据，需要拿到整个 page 之后才行。现在为了执行这条查询，就有了这些我们根本不会去访问的列，但为了得到实际需要的两列（hostname 和 lastLogin），不得不从磁盘中拿到它们（整个 page）并将它们放到内存里（这里的意思应该指内存里面多了 Useless Data）。这是个 bad idea，因为它浪费了硬件的性能。</p><p>  <img src="./34.png" alt></p><ol><li>优势<ul><li>访问整个 tuple 时，插入/更新/删除数据都很快</li><li>利于查询整个 tuple 的属性</li></ul></li><li>劣势<ul><li>但如果要进行一些分析型的查询以及做些 OLAP 的工作，并且要去扫描整张表大部分的内容时，it will suck。因为这需要往内存塞一大堆不需要的数据</li></ul></li></ol></li><li><p>列存储模型（Decomposition Storage Model DSM）</p><p>  <img src="./35.png" alt></p><p>  在列存储模型中，并不会将单个 tuple 的全部属性放在单个 page 中，而是将横跨所有的 tuple 中单个属性的所有的值保存在单个 page 中。即把单个列的所有的值连续的保存在一起。</p><p>  那么要做 OLAP 的话，只需要读取给定表中部分属性的集合就好了</p><p>  <img src="./36.png" alt><br>  <img src="./37.png" alt></p><p>  把 tuple 属性拆开来，一个 page 就放一种 tuple 属性</p><p>  <img src="./38.png" alt></p><p>  对于前面的查找的情况，现在就只需要扫描两个 pages 即可，而不是扫描整个 pages</p><blockquote><p>注意: 这里图的颜色配反了，下面的图应该要黑蓝换一下</p></blockquote><p>  顺便列存储也有利于数据的压缩（如果有重复的值存在），因为每个 page 下的属性的类型都是一致的，那么说明它所占空间每一块对于 page 存储的数据来说都是均匀的，大小一致，而行存储则可能往往相反</p><p>  那么应该怎样从一个 page 中找到一个匹配项呢</p><p>  有 2 种方案，但通常会选择第一种</p><p>  <img src="./39.png" alt></p><ol><li>使用固定长度的 offset（推荐）<br> offset * 每个属性的 size 就能找到位置，比如前面说过的 row ID，page ID 和 slot number 就是这么做的</li><li><p>对于列中的每个值都保存一个主键或者时标识符（不推荐）<br> 通过 (key + value) * offset 的形式去查找，但是本身存储开销很大，因为得为每个值用额外的 32/64 bit 的空间来保存它们的 id，非常浪费</p><p><img src="./40.png" alt></p></li><li><p>优势</p><ul><li>进行 OLAP 查询时，可降低垃圾 I/O 的数量</li><li>利于压缩数据，这样在查询上性能就会更好</li></ul></li><li><p>劣势<br> 读取单个 tuple 时候就会很慢，因为需要把不同列的数据拼在一起，这样才能得到一个完整的 tuple，然而对于行储存直接拿就行，同样的对 tuple 进行更新/删除，代价也更高</p><p>同样的，列存储也不是什么新想法</p><p><img src="./41.png" alt></p></li><li><p>瑞士军方当时构建了一个叫做 Cantor 的系统，在 1970 年代，因为他们使用了别的语言来写的，所以这玩意儿没被叫做数据库，但它实际上就是个列存储数据库。</p></li><li>1980 年代，有篇 paper 提到了列存储模型，同时也提到了更多细节，比如短格式（short format）、存储模型的意义</li><li>Sybase IQ 是 Sybase 公司推出的专门为数据仓库设计的关系型数据库，IQ 的架构与大多数关系型数据库不同，有用于支持大量并发用户的即时查询的特殊设计。可能是最著名的第一个实现列存储的商用数据库。这是一个内存型列存储数据库，Sybase 把它作为普通的行存储数据库系统的加速器发布，这样他们就可以进行 HTAP 处理并具备同步的能力，但它并没有被广泛采用，因为它被当作行存储数据库的插件而不是作为一个独立的产品来卖</li><li>到了 2000 年代，列存储数据库才真正起飞，Vertica 由 Michael Stonebraker 创立，他之前参与过 PostgreSQL 和 Ingres 这些数据库的开发。之后他的公司被 HP 收购，VectorWise 是 MonetDB （MonetDB 是一个开源的面向列的数据库管理系统，它被设计用来为较大规模数据，比如几百万行和数百列级别的数据库表，提供高性能查询的支持） 的内存版。MonetDB 以前是欧洲的一个学术项目，但现在到处都在用它，它是 2000<br>年代出现的第一个列存储数据库系统</li><li>之后列存储很快就出名了，因为人们发现这是构建用于数据分析型数据库系统的正确方式</li></ol></li></ul></li></ul><p>那么有没有结合行存储和列存储方式的数据库系统呢？有的，比如 MySQL，在创建表时，可以告诉它用行存储，在创建另一张表时可以告诉它用列存储，所以本质上来说 MySQL 有俩独立的存储管理器，以及俩独立的执行引擎来处理，所以这种就被成为混合数据库系统。虽然有些数据库对于 OLTP 和 OLAP 都支持，但真正牛逼飞起的还没几个。。。</p><p>基本上，人们在前端 OLTP 系统中所运行的是 MySQL、mongoDB 或者其他数据库系统，然后你把数据传输给后端数据仓库（back-end data warehouse），然后基本上，当这堆数据不再需要的时候，就可以把 OLTP 这块老的数据给修剪掉了。这可以通过 MySQL + Vertica 这俩独立数据库做到。或者就使用单个混合型数据库，Splice machine 可以做，MySQL 也能做</p><ul><li><p>结论</p><p>  <img src="./42.png" alt></p><p>  简单规则，make life easier and better。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;注: 本文首发我的 b 站专栏文章&lt;a href=&quot;https://www.bilibili.com/read/cv14558880&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;CMU 15-445/645-笔记-04-数据库存储-part2&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Database" scheme="https://strugglebak.github.io/categories/Database/"/>
    
    
      <category term="Database" scheme="https://strugglebak.github.io/tags/Database/"/>
    
  </entry>
  
  <entry>
    <title>CMU-15-445-645-笔记-03-数据库存储-part1</title>
    <link href="https://strugglebak.github.io/2022/06/05/CMU-15-445-645-%E7%AC%94%E8%AE%B0-03-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%98%E5%82%A8-part1/"/>
    <id>https://strugglebak.github.io/2022/06/05/CMU-15-445-645-笔记-03-数据库存储-part1/</id>
    <published>2022-06-05T13:29:29.000Z</published>
    <updated>2022-06-05T13:34:51.221Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>注: 本文首发我的 b 站专栏文章<a href="https://www.bilibili.com/read/cv14558199" target="_blank" rel="noopener">CMU 15-445/645-笔记-03-数据库存储-part1</a></p></blockquote><a id="more"></a><p><img src="./Cover.png" alt></p><ul><li><p>课程目标</p><p>  <img src="./1.png" alt></p><ol><li>DBMS 是怎么用磁盘上的文件来表示数据库的（主要是这个）</li><li>DBMS 是怎么管理内存的，是怎么在磁盘间来回移动数据的</li></ol></li><li><p>课程大纲</p><p>  <img src="./2.png" alt></p><p>  上述展示的就是一个数据库中应该包含的东西，一个数据库就是建立在这些层面之上</p></li><li><p>面向磁盘的数据库架构</p><p>  <img src="./3.png" alt></p><p>  由于这门课是面向磁盘（Disk-Oriented）的数据库管理系统，即数据库的主要存储位置都是放在磁盘上的，意味着每次执行查询时，所要访问的数据都不在内存（Memory）中。所以在设计这个数据库管理软件时，要基于一些假设来设计一系列的组件，来保护这个数据库系统，使其免于数据丢失、保存无效或错误的数据等情况。</p><p>  此外还需要区分</p><ol><li>易失性存储</li><li><p>非易失性存储</p><p>简单来讲就是，我们所要的 数据系统 管理了数据从非易失性存储到易失性存储的移动</p><p>计算机的存储结构如图所示</p><p><img src="./4.png" alt></p></li><li><p>越上面的容量越小，速度越快，也越贵</p></li><li><p>越下面的容量越大，速度越慢，也越便宜</p><p><img src="./5.png" alt></p><p>注意这里在 DRAM 和 SSD 有条分界线，这里就是易失性和非易失性存储的分界</p><p>需要稳定的能量（电能）维持它所存储的东西的存储设备，叫做易失性存储，那么反之就是非易失性存储</p></li><li><p>如果数据是保存在易失性存储设备中，那么它就支持 快速随机访问，即无论在什么位置访问数据，访问数据的顺序是怎么样的，访问的速度都大体一致</p></li><li>如果数据是保存在非易失性存储设备中，由于它们具备的是 块寻址（非字节寻址） 能力，无法准确地得到数据的 位大小的数据（32bit, 64bit），所能得到的是包含要访问的数据的 块（Block） 或者 页（Page）</li><li><p>但是在非易失性存储设备中，比起随机读取不同位置上的内容，它能更有效率地去读取一段连续的 块 中的内容。所以对于非易失性存储来讲，是希望按顺序读取的数据量越大越好</p><p>Memory 和 Disk 的区分</p><p><img src="./6.png" alt></p><p>现在已经没人用磁带机来存数据了，但是可用来做容灾</p><p>Network Storage 现在指类似于 Amazon 的 EBS 或者 S3 之类的东西</p><p>实际上在分割线处还有新的一类存储设备，它被称之为非易失性内存（Non-Volatile Memory）</p><p><img src="./7.png" alt></p><p>比如 Intel 的 傲腾（Optane）内存，牙膏厂虽然是第一个发布这种内存的厂商，但这类技术的研究已经有 15-20 年左右的历史了</p><p>它可以像 DRAM 一样，可以插在 DIMM 槽内，却具备 字节寻址 能力，也可以像 SSD 那样，断电也能持久保存数据。</p><p>但残念的是，目前这种既能又能的存储设备并没有被广泛应用</p><p>顺便老师在课上写的这本书有卖吗？</p><p><img src="./8.png" alt></p><p>一张关于各种存储设备的访问耗时表</p><p><img src="./9.png" alt></p></li></ol></li><li><p>系统设计目标</p><p>  <img src="./10.png" alt></p><p>  目标就是，给应用程序提供一种错觉，即这个系统能提供足够的内存，能把整个数据库导入到内存中。并且最小化每次从磁盘读取/查询内容所带来的影响</p><p>  比如这种最小化的方式可以通过以下几种方式达到</p><ol><li>允许在同一时间运行不同的线程/查询</li><li>缓存</li><li><p>提前计算某些数据</p><p>一个访问磁盘数据的示意图</p><p><img src="./11.png" alt></p><p>可以看到有几个关键的地方，Directory、Buffer、Page</p><p>那么这个有点像什么呢？– 虚拟内存</p><p>那么操作系统能做这件事，为什么还这样设计而不直接使用操作系统来做呢？</p><p><img src="./12.png" alt><br><img src="./13.png" alt></p><blockquote><p>注意 mmap 指的是 maps files or devices into memory</p></blockquote><p>虽然操作系统可以利用虚拟内存通过 mmap 来映射到文件，但是这只适用于 只读 的访问，对于有多个 writer 的情况就复杂很多了</p><p><img src="./14.png" alt></p><p>因为操作系统并不知道某些 pages 必须要先于其他 pages ，从内存刷到磁盘，这里有一个竞争的关系</p><p>那么有没有解决方案呢？有的</p><p><img src="./15.png" alt></p></li><li><p>使用 madvise 告诉 OS 怎么去访问某些页面（顺序/随机读取）</p></li><li>使用 mlock 阻止 pages 被 OS 回收（尽管可以被锁定但并不能阻止它被写出到磁盘）</li><li><p>使用 msync 告诉 OS 要把数据刷到磁盘中</p><p>使用 mmap 和 部分使用 mmap 的 Database</p><p><img src="./16.png" alt></p></li><li><p>实际上 MemSQL 已经完全摆脱了 mmap</p></li><li>SQLite 有一个特殊的引擎，在嵌入式设备上 mmap 是可选的，默认情况下用不到</li><li>InfluxDB 只有在只读缓存上才使用 mmap</li><li><p>mongoDB 第一次被开发出来时，它的默认存储引擎用的就是 mmap，但为了让这个引擎能正常工作，开发人员也做了很多无用功，因为这里面存在着巨大的瓶颈，然后等他们筹到很多钱之后，就把 mmap 干掉了，再然后他们买了一个叫做 WiredTiger 的非 mmap 的存储引擎</p><p>注意这张图里面少了很多主流的 Database，比如 MySQL，Oracle，DB2 以及 SQL server，这些数据库都没有使用 mmap，因为 mmap 是一个糟糕的想法，因为缺少人为写代码去控制这种行为。</p><p>所以如果 mmap 是一个好的想法，那么这群土豪（指 mongoDB）手下的顶级工程师肯定能证明这的确是，然后并没有（哈哈哈哈好好笑）</p><p>老师痛恨 mmap</p><p><img src="./17.png" alt></p><p>毕竟操作系统啥也不懂，它只看到了一些读写和调用（</p></li></ol></li><li><p>文件存储</p><p>  <img src="./18.png" alt></p><p>  数据库其实就是磁盘上的一堆文件，SQLite 把数据库存储为一个文件，而其他大部分数据库比如 PostgreSQL 则会把这些分为多个文件来存储，因为数据库可能非常大，甚至可能有 PB 级别的数据量，你不会想要对这么大的一个文件做错误修复</p><p>  现在的一些”企业级”的数据库系统还支持自定义的专属文件系统，但近些年的一些数据库系统已经不支持了，因为非常不值得，要管理这种文件系统是一个很大的坑，同时也大大降低了可移植性。</p></li><li><p>存储管理器</p><p>  <img src="./19.png" alt></p><p>  存储管理器也叫存储引擎，它负责维护磁盘上的数据库文件。</p><p>  某些高端数据库系统在文件系统之上还有一个 shim 层，它允许数据库去做一些磁盘的调度，这就像是可以通过一堆线程来对彼此邻近的区块进行写入，也可以将这些区块合并后做一次写入请求。</p></li><li><p>Database Pages</p><p>  <img src="./20.png" alt></p><p>  一个 page 的集合，就是这一堆文件的一个组织形式。本质上来讲，一个 page 就是一个固定大小的数据块</p><p>  self-contained 的意思是，page 的内容必须存储在 page 本身内。比如 Orcale 就需要将描述该 page 中内容的所有元数据，和这些内容数据一起保存在该 page 中，避免数据库故障的时候你找不到，这样即便丢了一个 page，也不会影响其他的 page</p><p>  indirection 层允许将一个 page ID 映射到某个集合中一个文件的某个位置。相当于记录一个相对位置，方便文件整体移动后，只要知道整体文件的初始位置，依然可以通过该相对位置即 page ID 找到某个文件某个位置的数据所对应的 page。因为一个 page 的大小是固定的，page ID * page Size 即为 offset</p><p>  一些 page 的概念</p><p>  <img src="./21.png" alt></p><p>  Database Page 大小各有不同</p><p>  <img src="./22.png" alt></p><p>  但我们更需要关注的是 Hardware Page 的大小，因为它是原子的，即一次只能写入这么大的 page 数据，如果超过了，那么剩下的数据就会丢失写不进去，写入失败也不会回滚，数据就会损坏</p><p>  高级数据库可以设定它们自己 page 的大小</p><p>  那么为什么有些数据库系统使用的是空间更大的 page 呢？</p><p>  这里是有一些权衡的，比如在数据库系统的内部，通过内存中的 Page 目录将 page 映射到内存或者磁盘上的某个位置，如果现在用一个 page ID 来表示一个更大量的数据，那么一个表所占用的大小就会变小。因为固定容量下，一个 ID 表示的数据量越大，那么它所需要的 ID 数也越小。比如 CPU 中 TLB（页表缓存），如果尝试去匹配所有的 page，那么 page 表将会变得非常的大，然后就会出现 cache misses 的现象。因为 page ID 表示的数据范围太小，在高速缓存中无法全部命中。所以这里可以通过更少的 page ID 来表示更多的数据</p></li><li><p>Page 存储架构</p><p>  <img src="./23.png" alt></p><p>  比较重要的就是 Heap File Organization</p><ul><li><p>Database Heap</p><p>  <img src="./24.png" alt></p><p>  数据库中的 heap 文件是一个无序的 page 集合，即可以以随机的顺序把 tuple 数据存储在里面</p><p>  链表来实现一个 page 是很 low 的，更好的方案是使用 Page 目录</p></li><li><p>Heap File: 链表</p><p>  <img src="./25.png" alt></p><p>  这里的例子中，如果要支持反向查找，那还得是一个双向链表</p><p>  如果需要在 page 中 insert 一些东西，那么还是需要对这个链表做遍历，直到找到 free page 为止，在这个位置 insert。为什么需要遍历，因为有些 page 的剩余空间可大可小，所以需要遍历到那个足以容纳下要 insert 的数据的一个剩余空间里面去</p><p>  写数据时需要注意的问题，即数据写一半，写满一个出了问题，后一半还没来得及写，数据就会损坏，所以要保证写数据的原子性和完整性，需要做很多工作</p><p>  写入数据崩溃，如何查找原因？使用 checksum，类似于 CRC 或者 md5</p></li><li><p>Heap File: Page 目录</p><p>  <img src="./26.png" alt><br>  <img src="./27.png" alt></p><p>  Page 目录是一个通常的做法，好处是假如想要插入一些数据时，没必要像链表那样对整个链表做一次遍历，只需要在 Page 目录中做查找就可以。例子中的每个小格中不仅有对应 page 所在位置，也包含了 page 剩余空间的信息</p></li><li><p>Page 头</p><p>  <img src="./28.png" alt></p></li><li><p>Page 层</p><p>  <img src="./29.png" alt></p><ol><li><p>面向 tuple 的组织方式</p><p> <img src="./30.png" alt></p><p> 这种组织方式是一个 bad idea，为什么呢？</p><ul><li>如果 tuple 都是固定长度的，那么要增删 tuple 的话，通过将其移到一个新的空间来取代这个老的空间就可以了不是么（联想到了 V8 的新生代老生代的 GC 算法了）</li><li>如果 tuple 不是固定长度的，那么你插入 tuple<br>的那个位置可能就没有足够的空间</li><li><p>每次要增删 tuple 时，都需要维护顶部的元数据，也就是 Num Tuples，告诉你哪个位置能插数据，或者遍历整个 page 看看哪里能插</p><p>但更好的方式是使用 slotted pages</p><p><img src="./31.png" alt><br><img src="./32.png" alt></p><p>在顶部有一个称之为 slot 数组 的东西，在底部则用来保存想要保存的数据</p><p>本质上来讲，slot 数组是将一个特定的 slot 映射到 page 上的某个 offset 上，根据这个 offset，就能找到想找的哪个 tuple</p><p>注意 slot 存的是 offset</p><p><img src="./33.png" alt></p><p>而填充 page 的方式是</p></li><li>从前往后对 slot 数组进行填充</li><li><p>从后往前对数据进行填充</p><p>什么是 page 已满，指的是数据占用了该 page 的一半以上的大小，再也无法存入任何信息了</p><p>当然也可以用一种 Postgres 中的 vaccum 的操作来整理数据库，或者使用压缩，也可以对数据库进行扫描并整理碎片</p><p>对于这种例子来讲，肯定是不能把视频存在数据库里面的，因为单个 page 根本放不下它。</p><p>一般来讲，要存 tuple 不应该分散地存在多个 page 上，因为维护元数据很麻烦。最好是当我们想要去访问这个 tuple 的时候，它就在这个 page 上。</p><p>为什么需要这么组织结构呢？</p><p>因为不管是将数据库文件中的 page 移动到磁盘还是网络上，系统的其他部分都不会关心这个 page 实际移动到了哪里，因为有 page ID 的存在，就可以通过 Page 目录来找到它实际所保存的位置，而这些 indirection 层避免了这些位置的更新会传播到系统的其他上层部分。比如某些 GC 算法，只需要保证对象间的引用关系就好，对象存在内存的哪个位置会随着 GC 的进行而变化，page ID 有有点像是在维护这个引用关系</p></li></ul></li><li><p>日志结构的组织方式<br> // Todo:<br> 主要这里 3-1 没有讲到</p></li></ol></li></ul></li><li><p>Tuple 层</p><blockquote><p>注: 课程时间不够，这里是简略版本</p></blockquote><p>  <img src="./34.png" alt></p><p>  一个 tuple 基本上就是一串字节，数据库的工作就是再次解释这些字节的实际含义</p><ul><li><p>Tuple 头</p><p>  <img src="./35.png" alt></p><p>  通常没必要将该 tuple 的元数据保存在这个 tuple 里面，因为更高级的元数据信息保存在这个 tuple 对应的 page 中，但可以可以放在 catalog page 里</p></li><li><p>Tuple Data</p><p>  <img src="./36.png" alt></p><p>  通常大部分数据库系统会按照它们创建时的顺寻进行存储，我们知道在关系模型中没必要这么做，但是大部分系统都做了</p></li><li><p>Denormalized Tuple Data</p><p>  <img src="./37.png" alt></p><p>  如果来自不同表的数据保存在同一个 page 中，会发生什么问题？<br>  注意这里大部分数据库系统都不会这么做，因为如果想让 page 变得独立，那么也就不应该去保存一大堆关于不同表的额外的元数据。当对表进行反范式化设计或者对表进行 prejoin 时，就会出现上述图中的情况，也就是数据冗余，一个 page 中存在多个表数据，更新、删除、或者压缩都要对多个表进行处理</p><p>  而数据库规范基本上就是讲如何讲数据库拆分到不同的表中（使用外键时就自然拆分了）</p><p>  下面是一个反范式化的处理例子，将 bar 的 tuple 直接内嵌在 foo 的 tuple 中</p><p>  因为每个 bar 表中的 tuple 复制了 a 属性，如果将它打包进 foo 表的 tuple 中，就没必要重复记录这些数据了，foo 表所拥有的这些列对其他表来说是独一无二的，就像是 prejoin 一样，将 tuple 彼此包装在一起。这样，应用程序依然觉得，这个 db 里面有两张单独的表，但在 db 内部，page 实际上会将它们合并在一起</p><p>  <img src="./38.png" alt><br>  <img src="./39.png" alt><br>  <img src="./40.png" alt></p><p>  但这并不是什么新鲜东西，早在 1970 年代，IBM 在发明它们第一个关系型数据库 System R 的时候，就引入了这个概念</p><p>  然而当 IBM 做出了 DB2 之后，这个方式就被废弃掉了，因为维护它很操蛋</p><p>  System R 是 IBM 发布的第一个关系型数据库，但 IBM 并没有将它商业化，也没有卖掉，10 多年之后，IBM 抽取了 System R 中的部分代码，做出了 DB2</p><p>  实际上在更现代的数据库系统中也出现了这种反范式化的设计</p><p>  <img src="./41.png" alt></p><ol><li>G 家的 Cloud Spanner，如果你定义了一个 Protobuf API，那么你就可以将两张不同表的数据合并在同一个 tuple 中</li><li>10 年前有一个叫 Akiban 的初创公司，他们把他们的存储引擎卖给了 MySQL，MySQL 就可以做到这种反范式化的操作。然后他们被 Foundation DB 收购，之后 Foundation DB 又被苹果收购</li><li>一些文档型数据库或者 JSON 数据库也能做到。比如你在定义你的 JSON document 时，就可以预先对相关属性进行 join 操作</li></ol></li></ul></li><li><p>记录 ID</p><p>  <img src="./42.png" alt></p><p>  保存元数据的大小</p><ul><li>PostgreSQL CTID（4 bytes）</li><li>SQLite ROWID（8 bytes）</li><li>Oracle ROWID（10 bytes）</li></ul></li><li><p>结论</p><p>  <img src="./43.png" alt></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;注: 本文首发我的 b 站专栏文章&lt;a href=&quot;https://www.bilibili.com/read/cv14558199&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;CMU 15-445/645-笔记-03-数据库存储-part1&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Database" scheme="https://strugglebak.github.io/categories/Database/"/>
    
    
      <category term="Database" scheme="https://strugglebak.github.io/tags/Database/"/>
    
  </entry>
  
  <entry>
    <title>CMU-15-445-645-笔记-02-高级SQL</title>
    <link href="https://strugglebak.github.io/2022/06/05/CMU-15-445-645-%E7%AC%94%E8%AE%B0-02-%E9%AB%98%E7%BA%A7SQL/"/>
    <id>https://strugglebak.github.io/2022/06/05/CMU-15-445-645-笔记-02-高级SQL/</id>
    <published>2022-06-05T13:00:10.000Z</published>
    <updated>2022-06-05T13:22:48.483Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>注: 本文首发我的 b 站专栏文章<a href="https://www.bilibili.com/read/cv14530555" target="_blank" rel="noopener">CMU 15-445/645-笔记-02-高级SQL</a></p></blockquote><a id="more"></a><p><img src="./Cover.png" alt></p><ul><li><p>课程目标</p><p>  <img src="./1.png" alt></p></li><li><p>Relational Languages<br>  <img src="./2.png" alt></p></li><li><p>SQL 的历史<br>  <img src="./3.png" alt></p><ul><li>除了 IBM 推出的 SQL 之外，还有另一个主流是由伯克利推出的 Ingres</li><li>而 PostgreSQL 是由开发 Ingres 那帮人开发的，所以才被称之为 “Post” “gre” “SQL”，与 “In” “gres” 对应，因为是在 Ingres 之后才出现的</li><li>开发 Ingres 那帮人有自己的语言，叫 Quel</li><li>英国有个人为他的编程语言也取名叫 SQL，IBM 因此与这个人产生版权以及商标纠纷</li><li>当 IBM 推出了 DB2 和 SQL 时，Oracle 也在同时支持 SQL</li><li>SQL 一直在发展，推出很多新特性<br>  <img src="./4.png" alt></li><li>现在只有非常少的数据库系统通过 SQL:2016 标准</li></ul></li><li><p>SQL 并不是一门单一的语言，它是一些东西的集合</p><p>  <img src="./5.png" alt></p><ul><li>DML: 类似 insert/update/delete/select 命令</li><li>DDL: 跟 schema 有关，通过定义 schema 创建表来存数据</li><li>DCL: 跟安全性授权相关</li><li>lists，也就是列表，可以有重复元素，是有序的</li><li>sets, 也就是集合，没有重复元素，是无序的</li><li>bags, 允许元素重复，无序</li></ul></li><li><p>Example Database</p><p>  <img src="./6.png" alt></p></li><li><p>Aggregates 聚合函数</p><p>  <img src="./7.png" alt></p><p>  <img src="./8.png" alt></p><p>  用 “<em>“ 代替 login<br>  “</em>“ 是 SQL 中的特殊关键字，代表该 tuple 中所有属性</p><p>  <img src="./9.png" alt></p><p>  更进一步，用 “1” 代替 “*”，每数一个 tuple，tuple 的数量就 +1</p><p>  <img src="./10.png" alt></p><p>  一般来讲建议使用 “COUNT(1)”</p><ul><li><p>可以在单个查询中放入多个聚合函数</p><p>  <img src="./11.png" alt></p></li><li><p>DISTINCT<br>  得到去重数据时使用</p><p>  <img src="./12.png" alt></p></li><li><p>一个错误的例子，在聚合函数之外输出其他 columns 会 undefined</p><p>  <img src="./13.png" alt></p></li><li><p>如何解决上面的错误例子？使用 GROUP BY</p><p>  <img src="./14.png" alt></p><p>  基于某个属性把想要的 tuple 放到一起<br>  物以类聚的结果</p><p>  <img src="./15.png" alt></p><p>  新增一个 s.name</p><p>  <img src="./16.png" alt></p></li><li><p>数据过滤，使用 HAVING</p><p>  <img src="./17.png" alt></p></li><li><p>所谓查询优化，可以用 GROUP BY 来做，统计小于某个值的一些集合的数量，或者通过 HAVING 做一些过滤操作，那么要查找的数据集就小了，自然也就快了</p></li></ul></li><li><p>字符串操作<br>  不同数据库对字符串的处理</p><p>  <img src="./18.png" alt></p><ul><li><p>SQL 标准规范有说，所有的字符串，例如 varchar、char、和 text field，它们必须区分大小写，并且使用 单引号 来进行声明</p></li><li><p>‘%’ 和 ‘_’</p><p>  <img src="./19.png" alt></p><ul><li>‘%’: 匹配一个或者多个字符</li><li>‘_’: 匹配一个字符</li></ul></li><li><p>对于字符串函数、数学函数和日期函数来讲，它们可以出现在查询中的任意位置</p><p>  <img src="./20.png" alt></p><p>  你可以把它放在 SELECT/HAVING/或者其他条件语句中等</p></li><li><p>‘||’<br>  SQL 标准下可以使用 ‘||’ 把字符串连起来</p><p>  <img src="./21.png" alt></p></li><li><p>Postgres 和 Oracle 大概是所有数据库系统中遵循 SQL 标准做的最好的</p><ul><li>Postgres ~= Oracle &gt; SQL server &gt; DB2</li><li>SQLite 还行</li><li>MySQL 最差</li></ul></li></ul></li><li><p>DATE/TIME 操作</p><p>  <img src="./22.png" alt></p><p>  注意这里记录用的是 时间戳，但是当你对时间进行操作，提取其中的信息时，结果会变得不可靠</p><p>  比如对日期进行加减处理，三个数据库 SQL 的不同写法</p><ol><li>PostgreSQL</li><li>MySQL</li><li><p>SQLite</p><p><img src="./23.png" alt></p><p>SQLite 居然是最流行的。。。最初由 Richard Hipp 和其他两人开发，手机安卓应用很多前端数据库就用的是 SQLite，很多桌面应用比如 Photoshop 和 ILLustrator，内部也运行 SQLite</p><p>顺便互联网在美国兴起的时间居然是 2000 年代早期。。。</p><p>MySQL 是 Oracle 的，所以 Oracle 有 MySQL 的版权，但 SQLite 没有</p></li></ol></li><li><p>输出重定向</p><p>  <img src="./24.png" alt></p><p>  即你输出的结果可以保存到另一张表中</p><ul><li>可以用 INTO</li><li>或者用 CREATE TABLE</li><li><p>或者用 INSERT INTO</p><p>  <img src="./25.png" alt></p></li></ul></li><li><p>输出控制</p><p>  <img src="./26.png" alt></p><p>  如果想要输出结果变得有序，使用 ORDER BY，因为 SQL 是基于 bag<br>  代数，它是无序的，所以需要使用这个</p><p>  想要在输出列表中加属性，可以接 DESC/ASC</p><p>  <img src="./27.png" alt></p><p>  限制输出可以用 LIMIT</p><p>  <img src="./28.png" alt></p><p>  可以在 LIMIT 后面加 OFFSET</p><p>  <img src="./29.png" alt></p><p>  OFFSET 的意思是，在限制返回 tuple 的数量之前，需要先跳过多少个 tuple，当跳过这么多你设置的 tuple 之后，再开始返回数据</p></li><li><p>嵌套查询（难的优化的东西来了！）<br>  即在查询的内部再嵌套一个查询</p><p>  <img src="./30.png" alt></p><p>  一个嵌套查询例子，SELECT 嵌 SELECT（实际上这也可以用 JOIN 来实现）</p><p>  <img src="./31.png" alt></p><p>  为什么这种方式很慢，实际上这里可以理解为有俩 for 循环查询，因为要对这个表里面每个 tuple 遍历一遍，然后对于每个 tuple 也要遍历一遍，用 JOIN 可以优化</p><p>  用 IN 来优化</p><p>  <img src="./32.png" alt></p><p>  其他查询优化操作符</p><p>  <img src="./33.png" alt></p><p>  使用 ANY 来优化</p><p>  <img src="./34.png" alt></p><p>  SELECT 嵌套也可以不用写在 WHERE 中</p><p>  <img src="./35.png" alt></p><p>  一个查询没有学生注册的所有课程的例子，注意这个例子中使用了 NOT EXIST，逻辑相当于取了个反</p><p>  <img src="./36.png" alt></p><p>  内部查询可以引用外部查询的东西，但是反过来不行</p></li><li><p>window 函数<br>  window 函数会对一个 tuple 子集进行函数计算，并将它们聚合成一个结果。输出每一行数据，并在其后面追加一个聚合字段所表示的数据</p><p>  <img src="./37.png" alt></p><p>  这里的 OVER 有点像 GROUP BY 的意思</p><p>  一个例子<br>  <img src="./38.png" alt></p><p>  输出结果如下</p><p>  <img src="./39.png" alt></p><p>  可以看到后面增加了一个 row_num 的字段</p><ul><li>OVER 关键字的作用是当计算 window 函数时，指定一种组合 tuple 的方式</li><li><p>使用 PARTITION BY 指定 group</p><p>  <img src="./40.png" alt></p><p>  输出如下</p><p>  <img src="./41.png" alt></p><p>  根据 cid 对它们进行分组，每一组内按 row_num 的顺序排列</p></li><li><p>在 window grouping 中也可以使用 ORDER BY</p><p>  <img src="./42.png" alt></p></li><li><p>一个例子，查询每门课中最高分的学生</p><p>  <img src="./43.png" alt></p><p>  在这个内部查询（红色部分表示的）中，遍历整个 enrolled 表，对于每个 tuple，基于 cid 来对它们进行分组</p><p>  RANK() 这个聚合函数会对每一个组进行 rank 排序</p><p>  注意此处的 ‘ranking.rank’ 实际上并不存在于数据库中，它只存在于这个查询之中（感觉像是一个临时变量</p><p>  最终的结果如下，PostgreSQL 支持这个语句</p><p>  <img src="./44.png" alt></p><p>  RANK() 函数会根据排序后每个 tuple 在输出列表中出现的现后顺序来进行计算</p><p>  如果是 SQL 为 <code>SELECT *, RANK() OVER() AS rank FROM enrolled;</code>，那么就是如下的结果</p><p>  <img src="./45.png" alt></p><p>  rank 处的值都是 1，因为这里面并没有排序，所以所有记录中的 rank 都是 1</p><p>  这里的例子中，如果没有 ORDER BY，就没有 rank</p></li></ul></li><li><p>CTE（Common Table Expressions）公用表表达式<br>  这个感觉有点像是可以把一些公用的东西抽出来，然后给其他 SQL 引用的感觉</p><p>  <img src="./46.png" alt></p><p>  它和嵌套查询非常类似，可以将一个查询的输出结果作为另一个查询的输入，但某些 功能 CTE 能做，嵌套查询做不到</p><ul><li><p>一个更复杂的例子</p><p>  <img src="./47.png" alt></p><p>  将输出的 col1 和 col2 与 cteName 中的查询语句中的 name 进行绑定，然后在下面的 SELECT 语句中就可以直接引用 col1 和 col2</p></li><li><p>例子，在 enrolled 表中找到最大的学生 id</p><p>  <img src="./48.png" alt></p><p>那么问题来了，这个跟嵌套查询有啥区别呢？<br>在 CTE 中可以递归，但是嵌套查询不能（所以感觉像是声明了一个函数类似<br>  东西？）<br>比如打印 1 到 10，注意: 不带 ALL 的 UNION 操作会将重复结果移除</p><p><img src="./49.png" alt></p><p>主要逻辑就是调用之前的 CTE 中的 tuple 作为输出结果。<br>在这个例子中，会生成只有一个属性的表（counter），调用一个 SELECT 来获取这个 tuple，然后对它进行 +1，这样就生成了一个新的 tuple。接着继续上述操作，直到 WHERE 条件无法匹配为止</p></li></ul></li></ul><ul><li><p>总结</p><p>  <img src="./50.png" alt></p><p>  在理想情况下，可以无需将数据存放到本地，或者来回移动，就能对整个查询进行计算</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;注: 本文首发我的 b 站专栏文章&lt;a href=&quot;https://www.bilibili.com/read/cv14530555&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;CMU 15-445/645-笔记-02-高级SQL&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Database" scheme="https://strugglebak.github.io/categories/Database/"/>
    
    
      <category term="Database" scheme="https://strugglebak.github.io/tags/Database/"/>
    
  </entry>
  
  <entry>
    <title>CMU-15-445-645-笔记-01-课程简介与关系模型</title>
    <link href="https://strugglebak.github.io/2022/06/04/CMU-15-445-645-%E7%AC%94%E8%AE%B0-01-%E8%AF%BE%E7%A8%8B%E7%AE%80%E4%BB%8B%E4%B8%8E%E5%85%B3%E7%B3%BB%E6%A8%A1%E5%9E%8B/"/>
    <id>https://strugglebak.github.io/2022/06/04/CMU-15-445-645-笔记-01-课程简介与关系模型/</id>
    <published>2022-06-04T08:37:28.000Z</published>
    <updated>2022-06-05T12:53:10.772Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>注: 本文首发我的 b 站专栏文章<a href="https://www.bilibili.com/read/cv14530070" target="_blank" rel="noopener">CMU 15-445/645-笔记-01-课程简介与关系模型</a></p></blockquote><a id="more"></a><p><img src="./Cover.png" alt></p><ul><li>课程目标</li></ul><p><img src="./1.png" alt></p><ul><li>参考书推荐用 《Database System Concepts》</li><li>该课程主要是手写 Database Storage Manager 而不是 Database System（因为项目不支持 SQL 解析）</li><li><p>数据库拓展研究</p><p>  <img src="./2.png" alt></p></li><li><p>用 CSV（Comma-Seperated Value）文件存 database</p></li><li><p>怎么用呢，举个例子</p><p>  <img src="./3.png" alt></p></li><li><p>但这种方式是有问题的</p><ul><li>每个专辑的 entry 中的 artist 都是一样的么？</li><li>Ice Cube 没有拼写错误？</li><li>如果别人在文件里重写了一个无效的 string 怎么办呢？</li><li>如果一张专辑里面有多个 artist，那么怎么存储这些数据呢？</li><li>如何查询数据？</li><li>多线程同一时间写同一个文件怎么办？</li><li>如何保证数据安全（在写数据的时候机器故障咋办？）</li><li><p>Database Management System 的作用</p><p>  <img src="./4.png" alt></p></li></ul></li><li><p>1970 年 Ted Codd 提出的关系型模型（Relational Model）是为了解决之前数据库不断重构数据结构，以及数据结构转存之后不断销毁数据的问题</p></li><li>关系模型三板斧如下<ul><li>用简单数据结构存数据</li><li>用高级语言访问数据</li><li>大型数据库的物理存储策略基于 Database Management System 的实现</li></ul></li><li>这种思想把 逻辑层 和 物理层 完全解耦</li><li><p>关系型数据模型并不是唯一的数据模型</p><p>  <img src="./5.png" alt></p><p>  比如如下</p><p>  <img src="./6.png" alt></p><ul><li>Relational（MySQL, PostgreSQL，Oracle，DB2，SQL server，SQLite）</li><li>Key/Value，Graph，Document， Column-family（NoSQL）</li><li>Array/Matrix（Mathine Learning）</li><li>Hierarchical，Network （Obsolete / Rare）旧时代的余晖。。。</li></ul></li><li><p>关系型模型可以对任何东西进行建模</p></li><li><p>关系型模型主要关注三个方面</p><p>  <img src="./7.png" alt></p></li></ul><ul><li><p>一个 关系（relation） 是一个无序的集合，这个集合包含代表 entities 的属性的关系（relationship），比如</p><p>  <img src="./8.png" alt></p></li><li><p>tuple 在 关系 中就是一个 属性值 的集合</p></li><li><p>原始关系模型中，所有的值必须保证原子性或者它必须是一个单个属性值（比如只能是一个 String，一个 int，或者一个 float等，不能是数组或者嵌套的对象等）</p></li><li>NULL 这个属性值代表未知，SQL 查询会遇到麻烦</li><li>主键 Primary Key，唯一标识记录的 id</li><li>外键 Foreign Key，用于指定一张表中的属性必须存在于另一张表中</li><li>注意 relation 和 table 语义一样</li><li><p>一个外键的例子</p><p>  <img src="./9.png" alt></p></li><li><p>如何从 Database 中取数据？<br>  通过 DML （Data Manipulation Languages）</p><p>  <img src="./10.png" alt></p></li></ul><ul><li>Relational Algebra 关系代数</li><li><p>Ted Codd 提出了在 Relational Algebra 中的其中基本运算符</p><p>  <img src="./11.png" alt></p><ul><li><p>SELECT</p><p>  <img src="./12.png" alt></p></li><li><p>PROJECTION<br>  即 SELECT b_id-100, a_id FROM R WHERE a_id=’2’</p><p>  <img src="./13.png" alt></p></li><li><p>UNION<br>  <img src="./14.png" alt></p></li><li><p>INTERSECTION<br>  <img src="./15.png" alt></p></li><li><p>DIFFERENCE<br>  <img src="./16.png" alt></p></li><li><p>PRODUCT<br>  <img src="./17.png" alt></p></li><li><p>JOIN<br>  即 SELECT * FROM R NATURAL JOIN S;</p><p>  <img src="./18.png" alt></p></li></ul></li></ul><ul><li><p>一些后续研究的额外的操作符</p><p>  <img src="./19.png" alt></p></li><li><p>一些优化策略</p><p>  <img src="./20.png" alt></p></li><li><p>关系型模型与任何查询语言的实现无关，实际上当 Ted Codd 在他写关系型模型论文时并没有提出 SQL，他提出了 关系代数，并推出了自己的语言叫 Alpha，与（1970）同年推出的 SQL、Ingres （伯克利）、Quel 都是竞争对手。</p></li><li><p>SQL 只是一个标准</p></li><li><p>结论</p><p>  <img src="./21.png" alt></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;注: 本文首发我的 b 站专栏文章&lt;a href=&quot;https://www.bilibili.com/read/cv14530070&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;CMU 15-445/645-笔记-01-课程简介与关系模型&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Database" scheme="https://strugglebak.github.io/categories/Database/"/>
    
    
      <category term="Database" scheme="https://strugglebak.github.io/tags/Database/"/>
    
  </entry>
  
  <entry>
    <title>Fast-Properties-in-V8-(翻译)</title>
    <link href="https://strugglebak.github.io/2021/11/23/Fast-Properties-in-V8-%E7%BF%BB%E8%AF%91/"/>
    <id>https://strugglebak.github.io/2021/11/23/Fast-Properties-in-V8-翻译/</id>
    <published>2021-11-23T06:21:51.000Z</published>
    <updated>2022-06-04T08:13:28.728Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>注：该文章翻译自 <a href="https://v8.dev/blog/fast-properties" target="_blank" rel="noopener">Fast properties in V8</a> V8 的关于对象属性内存分配策略的官方文章，文章有翻译的不是很清楚的地方，欢迎各位指正</p></blockquote><a id="more"></a><p>在这篇博客文章中，我们将解释 V8 在内部是怎么处理 JavaScript properties 的。从 JavaScript 的角度来看，properties 只有几个必要的区别。JavaScript 对象与字典类似，使用 string 作为 key 和任意 object 作为 value。但是<a href="https://tc39.es/ecma262/#sec-ordinaryownpropertykeys" target="_blank" rel="noopener">在对象的迭代过程中</a>，规范对于以整数作为 index 的 properties 和其他 properties 的迭代方式是不同的。除此(迭代方式)之外，不同 properties 的表现基本相同，与它们是否以整数作为 index 无关。</p><p>但出于性能和内存的考虑，V8 底层确实依赖 properties 的几种不同表现。在这篇博客中，我们将解释为了能快速访问动态添加的 properties ，V8 是怎么做的。了解 properties 的工作方式对于解释 V8 中的<a href="https://mrale.ph/blog/2012/06/03/explaining-js-vms-in-js-inline-caches.html" target="_blank" rel="noopener">内联缓存(inline caches)</a>之类的优化工作至关重要。</p><p>这篇文章解释了 V8 对以整数作为 index 的 properties 和具名 properties 做处理的区别。然后我们展示了 V8 在添加具名 properties 时如何去维护隐藏类(HiddenClasses)，通过维护隐藏类可以快速识别一个对象的特征。接着我们将继续深入介绍如何根据用法优化具名 properties 来快速访问或修改。在最后一节中，我们将详细谈谈 V8 是怎么处理以整数作为 index 的 properties 或数组 index 的。</p><h2 id="具名-properties-和-elements"><a href="#具名-properties-和-elements" class="headerlink" title="具名 properties 和 elements"></a>具名 properties 和 elements</h2><p>让我们开始分析一个非常简单的对象，例如 <code>{ a：&#39;foo&#39;, b：&#39;bar&#39; }</code>。该对象具有两个具名 properties，<code>&#39;a&#39;</code> 和 <code>&#39;b&#39;</code>。对于 properties 名字来说它没有任何的数组 index。数组 index 这种 properties(通常称为 elements)是数组上最为突出的特点。例如数组 <code>[&#39;foo&#39;，&#39;bar&#39;]</code> 有两个数组 index properties：<code>0</code>，其对应 value 为 <code>&#39;foo&#39;</code>；<code>1</code>，其对应 value 为 <code>&#39;bar&#39;</code>。V8 主要用这个对 properties 做第一层的区分。</p><p>下图显示了一个基本的 JavaScript 对象在内存中的样子。</p><p><img src="./1.png" alt></p><p><strong>elements</strong>和<strong>properties</strong>存在两个单独的数据结构中，这样在不同使用模式下添加/访问 properties 和 elements 会更加有效。</p><p><strong>elements</strong>主要用于各种 <a href="https://tc39.es/ecma262/#sec-properties-of-the-array-prototype-object" target="_blank" rel="noopener">Array.prototype 方法</a>，例如 <code>pop</code> 或 <code>slice</code>。鉴于这些函数是在连续范围内去访问 properties 的，在大多数情况下 V8 内部会把它们看作简单数组。在本文的稍后部分会说明，为了节省内存我们是怎么将这些简单数组转变成稀疏字典(sparse dictionary)的形式的。</p><p>具名 properties 以类似的方式存在单独的数组中。但与 elements 不同，我们不能简单地用 key 来推断它们在 properties 数组中的位置，我们需要一些其他元数据。在 V8 中，每个 JavaScript 对象都会关联一个隐藏类。隐藏类 存放了有关对象特征的信息，除此之外，还存放了 properties 名字 对应 properties 数组 index 的 map。为了使事情复杂化，有时我们使用字典而不是简单数组来表示 properties。我们将在专用部分中对此进行详细说明。</p><p>本节内容：</p><ul><li><strong>以整数作为 index 的数组的 properties</strong> 存在单独的 <strong>elements store</strong>中。</li><li><strong>具名 properties</strong>存在<strong>properties store</strong>中。</li><li><strong>Elements</strong>和<strong>properties</strong>可以是数组或字典。</li><li>每个 JavaScript 对象都有一个关联的隐藏类，用于保存对象特征的信息。</li></ul><h2 id="隐藏类-HiddenClasses-和描述符数组-DescriptorArrays"><a href="#隐藏类-HiddenClasses-和描述符数组-DescriptorArrays" class="headerlink" title="隐藏类(HiddenClasses)和描述符数组(DescriptorArrays)"></a>隐藏类(HiddenClasses)和描述符数组(DescriptorArrays)</h2><p>在解释了 elements 和 具名 properties 的常规区别之后，我们需要看一下隐藏类在 V8 中的工作方式。此隐藏类存了一个对象的元信息，包括对象上的属性数量以及对对象原型的引用。隐藏类在概念上类似于典型的面向对象编程语言中的类。但在基于原型的语言（例如 JavaScript）中，通常不可能预先知道这个类。因此在这种情况下，V8 会即时创建隐藏类，并随着对象的变化而动态更新。隐藏类用于标识对象特征，也对 V8 编译器的优化和内联缓存起到非常重要的作用。例如，如果优化编译器可以通过隐藏类确保兼容的对象结构，那么它就可以直接访问到对象的内联属性。</p><p>让我们来看看隐藏类的重要部分。</p><p><img src="./2.png" alt></p><p>在 V8 中，JavaScript 对象的第一个字段指向隐藏类。(实际上，在 V8 堆上并由垃圾回收器管理的任何对象都是这种情况。)就 properties 而言，最重要的信息是位于 隐藏类的第三个 bit 的字段，这个字段用来存放 properties 的数量和能访问到描述符数组的指针。描述符数组中包含有关具名 properties 的信息，像这个 properties 的名字和 value 的存储位置之类的。注意，这里我们不跟踪整数 index properties，因此描述符数组中没有条目。</p><p>隐藏类的基本设定是对象具有相同的结构，例如在相同顺序下的相同具名 properties 会共享相同的隐藏类。为此，当对象添加了一个属性时，我们使用不同的隐藏类。在下面的示例中，我们创建一个空对象，并添加三个具名 properties。</p><p><img src="./3.png" alt></p><p>每次添加新属性时，对象的隐藏类都会更改。V8 在后台创建一个将隐藏类连接在一起的转换树。当将属性 <code>&#39;a&#39;</code> 添加到空对象时，V8 知道要采用哪个隐藏类。如果以相同的顺序添加相同的属性，此转换树可确保在最后得到的隐藏类是相同的。以下示例表明，即使在两者之间添加简单的 index properties(也就是整数下标)，转换树也是一样没有变化。</p><p><img src="./4.png" alt></p><p>但是，如果我们创建一个添加了其他属性的新对象，在本例中为属性 <code>&#39;d&#39;</code>，V8 将为新的隐藏类创建一个单独的分支。</p><p><img src="./5.png" alt></p><p>本节内容：</p><ul><li>具有相同结构(相同顺序的相同 properties)的对象具有相同的隐藏类。</li><li>默认情况下，每个添加的新具名属性都会导致创建新的隐藏类。</li><li>添加数组 index 的这种 properties 不会创建新的隐藏类。</li></ul><h2 id="三种不同的具名-properties"><a href="#三种不同的具名-properties" class="headerlink" title="三种不同的具名 properties"></a>三种不同的具名 properties</h2><p>在概述了 V8 如何使用隐藏类记录对象的特征之后，让我们深入研究这些 properties 的实际存储方式。如上面引言中所述，properties 有两种基本类型：<code>named</code> 和 <code>indexed</code>。以下部分介绍具名 properties。</p><p>在 V8 中，像 <code>{a: 1, b: 2}</code> 这样的简单对象可以有不同的内部展示。虽然 JavaScript 对象表现得或多或少像外部的简单字典，但 V8 试图避免字典，因为它们妨碍某些优化，如<a href="https://en.wikipedia.org/wiki/Inline_caching" target="_blank" rel="noopener">内联缓存</a>，我们将在单独的一篇文章中解释。</p><p><strong>对象内 properties</strong>与<strong>普通 properties</strong>：V8 支持所谓的对象内 properties，这些属性直接存储在对象上。这些是 V8 中最快的属性，因为它们无需任何间接访问即可使用。对象内 properties 的个数由对象的初始大小确定。如果添加的 properties 所需要的空间比对象能存储的空间多，它们就会把这些 properties 存到 properties store 中。properties store 里的属性是能被间接访问到的，并且这个 properties store 可以自己增加 property。</p><p><img src="./6.png" alt></p><p><strong>快 properties</strong>与<strong>慢 properties</strong>：下一个重要区别是快 properties 与慢 properties 之间的区别。通常将线性 properties store 中存放的 properties 定义为 “快”。快 properties 仅通过 properties store 中的 index 访问。要得到在 properties store 中的具名 properties 的实际位置，我们必须参考隐藏类上的描述符数组，如前所述。</p><p><img src="./7.png" alt></p><p>但如果一个对象添加和删除了许多属性，它可能会花费大量时间和内存开销来维护描述符数组和隐藏类。因此，V8 还支持所谓的慢 properties。具有慢 properties 的对象，它的 properties store 就是一个独立的字典。所有 properties 元信息不再存储在隐藏类的描述符数组中，而是直接存储在 properties 字典 中。因此不更新隐藏类也可以添加和删除属性。由于内联缓存不适用于字典属性，因此后者通常比快 properties 慢。</p><p>本节内容：</p><ul><li><p>有三种不同的具名 properties 类型：对象内 properties、快 properties、慢 properties/字典 properties。</p><ol><li>对象内 properties 直接存储在对象上，并提供最快的访问。</li><li>快 properties 位于 properties store 中，所有元信息都存储在隐藏类的描述符数组中。</li><li>慢 properties 位于独立的 properties 字典中，不再通过隐藏类共享元信息。</li></ol></li><li><p>慢 properties 允许高效地删除和添加属性，但访问速度比其他两种类型慢。</p></li></ul><h2 id="elements-或数组-index-properties"><a href="#elements-或数组-index-properties" class="headerlink" title="elements 或数组 index properties"></a>elements 或数组 index properties</h2><p>到目前为止，我们已经研究了具名 properties，而没讲数组常用的整数 index properties。整数 index properties 的处理与具名 properties 一样复杂。即使所有 index properties 总是单独存储在 elements store 中，那也有 <a href="https://cs.chromium.org/chromium/src/v8/src/elements-kind.h?q=elements-kind.h&amp;sq=package:chromium&amp;dr&amp;l=14" target="_blank" rel="noopener">20</a> 种不同的 elements 类型!</p><p><strong>Packed or Holey Elements</strong>：V8 作出的第一个主要区别是 elements backing store 里的 item 是 packed 的还是有 hole 的。如果删除一个能用 index 访问到的元素或未定义元素，则会在 backing store 中出现 hole。一个简单的例子是<code>[1,,3]</code>，其中第二项就是一个 hole。以下示例说明了此问题：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> o = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>];</span><br><span class="line"><span class="built_in">console</span>.log(o[<span class="number">1</span>]);          <span class="comment">// 打印 'b'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> o[<span class="number">1</span>];                <span class="comment">// 在 elements store 中引入一个 hole</span></span><br><span class="line"><span class="built_in">console</span>.log(o[<span class="number">1</span>]);          <span class="comment">// 打印 'undefined'; 属性 1 不存在</span></span><br><span class="line">o.__proto__ = &#123;<span class="number">1</span>: <span class="string">'B'</span>&#125;;     <span class="comment">// 在 prototype 上定义属性 1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(o[<span class="number">0</span>]);          <span class="comment">// 打印 'a'</span></span><br><span class="line"><span class="built_in">console</span>.log(o[<span class="number">1</span>]);          <span class="comment">// 打印 'B'</span></span><br><span class="line"><span class="built_in">console</span>.log(o[<span class="number">2</span>]);          <span class="comment">// 打印 'c'</span></span><br><span class="line"><span class="built_in">console</span>.log(o[<span class="number">3</span>]);          <span class="comment">// 打印 undefined</span></span><br></pre></td></tr></table></figure><p><img src="./8.png" alt></p><p>总之，如果这个被操作的数组/对象上没有属性，那就必须要在原型链上继续找。考虑到 elements 是独立的，我们不会在隐藏类上存放当前数组的 index properties 的信息，我们需要一个名为 the_hole 的特殊值来标记不存在的属性。这对于数组方法的性能来说至关重要。如果我们知道没有 hole，即 elements store 已经是 packed 状态，我们就可以执行本地操作而没必要在原型链上去做耗费性能的查找。</p><p><strong>快 elements 或字典 elements</strong>：对 elements 来说，第二个主要区别是它们是快模式还是字典模式。快 elements 是简单的 VM 内部数组，它的属性 index 与 elements store 中的 index 有一个 map 的关系。但这种简单的形式对于非常大的 稀疏/holey 数组是非常浪费的，因为这些数组只有非常少的子项。在这种情况下，我们使用基于字典的形式来节省内存，但代价是访问速度稍慢：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> sparseArray = [];</span><br><span class="line">sparseArray[<span class="number">9999</span>] = <span class="string">'foo'</span>; <span class="comment">// 用字典元素创建一个数组</span></span><br></pre></td></tr></table></figure><p>在此示例中，(从内存中)分配具有 10k 个子项的完整数组将非常浪费。取而代之的是，V8 创建了一个字典，在其中存储 key-value-descriptor 这样的三元组。在这种情况下，key 为 <code>&#39;9999&#39;</code>，value 为 <code>&#39;foo&#39;</code>，descriptor 就使用默认的描述符。鉴于我们没有办法在隐藏类上存储描述符详细信息，每当使用自定义描述符定义 index properties 时，V8 都会使用慢 elements：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> array = [];</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(array, <span class="number">0</span>, &#123;<span class="attr">value</span>: <span class="string">'fixed'</span> configurable: <span class="literal">false</span>&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(array[<span class="number">0</span>]);      <span class="comment">// 打印 'fixed'.</span></span><br><span class="line">array[<span class="number">0</span>] = <span class="string">'other value'</span>;   <span class="comment">// 不能覆盖 index 0.</span></span><br><span class="line"><span class="built_in">console</span>.log(array[<span class="number">0</span>]);      <span class="comment">// 仍然打印 'fixed'.</span></span><br></pre></td></tr></table></figure><p>在此示例中，我们在数组上添加了一个不可配置的属性。此信息存储在慢 elements 字典三元组的描述符部分中。重要的是要注意，数组方法在具有慢 elements 的对象上执行时速度要慢得多。</p><p><strong>Smi</strong> 和 <strong>Double Elements</strong>：在 V8 中快 elements 还有另一个重要的区别。例如，如果仅将整数存储在一个常用的数组中，则 GC 不必查看该数组，因为整数直接编码为所谓的小整数（Small integers – Smis）。另一个特殊情况是仅包含双精度的数组。与 Smis 不同，浮点数通常表示为占用几个字长的完整对象。但对于纯双精度数组来说 V8 存的是原始双精度值，以避免内存和性能开销。以下示例列出了 Smi 和 double 元素的 4 个示例：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a1 = [<span class="number">1</span>,   <span class="number">2</span>, <span class="number">3</span>];  <span class="comment">// Smi Packed</span></span><br><span class="line"><span class="keyword">const</span> a2 = [<span class="number">1</span>,    , <span class="number">3</span>];  <span class="comment">// Smi Holey, a2[1] 在 prototype 上找</span></span><br><span class="line"><span class="keyword">const</span> b1 = [<span class="number">1.1</span>, <span class="number">2</span>, <span class="number">3</span>];  <span class="comment">// Double Packed</span></span><br><span class="line"><span class="keyword">const</span> b2 = [<span class="number">1.1</span>,  , <span class="number">3</span>];  <span class="comment">// Double Holey, b2[1] 在 prototype 上找</span></span><br></pre></td></tr></table></figure><p><strong>特殊 elements</strong>：到目前为止，我们提供的信息涵盖了 20 种不同 elements 类型中的 7 种。为简单起见，我们去掉了定型数组(TypedArrays)中的 9 个 elements 类型，也去掉了多个 String wrapper 中的 elements 类型以及 arguments 对象中的多个特殊 elements 类型。</p><p><strong>ElementsAccessor</strong>：如你所想我们并不想用 C++ 写数组方法 20 遍，为每个<a href="https://v8.dev/blog/elements-kinds" target="_blank" rel="noopener">element 类型</a>写一遍。这里就到了体现 C++ 神奇的地方了。我们构建了 <code>ElementsAccessor</code>，而不是一遍又一遍地实现数组方法，在这里我们只需要实现简单的函数即可访问 backing store 中的元素。<code>ElementsAccessor</code> 需要 <a href="https://en.wikipedia.org/wiki/Curiously_recurring_template_pattern" target="_blank" rel="noopener">CRTP</a> 去对每个数组方法创建指定的版本。因此，如果在数组上调用诸如 <code>slice</code> 之类的方法，V8 内部则会调用用 C++ 编写的内置函数，并通过 <code>ElementsAccessor</code> 将其分派到该函数的指定版本：</p><p><img src="./9.png" alt></p><p>本节内容：</p><ul><li>有快模式和字典模式的 index properties 和 elements。</li><li>快 properties 可以被 packed，它们也可以有 holes，这些 holes 说明一些 index properties 被删掉了。</li><li>elements 的 content 专门用于加快数组方法的执行并减少 GC 开销。</li></ul><p>了解 properties 的工作方式是理解 V8 中许多优化的关键。对于 JavaScript 开发人员来说，有许多内部决策是无法直接看到的，但是它们解释了为什么某些代码模式比其他模式更快。更改 properties 或 elements 类型通常会使 V8 创建不同的隐藏类，这可能导致类型污染，从而 <a href="http://mrale.ph/blog/2015/01/11/whats-up-with-monomorphism.html" target="_blank" rel="noopener">阻止 V8 生成最佳代码</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;注：该文章翻译自 &lt;a href=&quot;https://v8.dev/blog/fast-properties&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Fast properties in V8&lt;/a&gt; V8 的关于对象属性内存分配策略的官方文章，文章有翻译的不是很清楚的地方，欢迎各位指正&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="翻译" scheme="https://strugglebak.github.io/categories/%E7%BF%BB%E8%AF%91/"/>
    
    
      <category term="V8" scheme="https://strugglebak.github.io/tags/V8/"/>
    
  </entry>
  
  <entry>
    <title>Elements-kinds-in-V8-(翻译)</title>
    <link href="https://strugglebak.github.io/2021/11/23/Elements-kinds-in-V8-%E7%BF%BB%E8%AF%91/"/>
    <id>https://strugglebak.github.io/2021/11/23/Elements-kinds-in-V8-翻译/</id>
    <published>2021-11-23T06:17:20.000Z</published>
    <updated>2022-06-04T08:13:28.714Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>注：该文章翻译自<a href="https://v8.dev/blog/elements-kinds" target="_blank" rel="noopener">https://v8.dev/blog/elements-kinds</a> V8 的官方博客，这是关于解释在 V8 中「elements」的类型都有哪些的一篇文章，文章有翻译的不是很清楚的地方，欢迎各位指正</p></blockquote><a id="more"></a><p>JavaScript 对象可以和任何属性有关联。对象属性的名称可以包含任何字符。有趣的是 JavaScript 引擎可以选择名称为纯数字的属性来进行优化，而这个属性其实就是<a href="https://tc39.es/ecma262/#array-index" target="_blank" rel="noopener">数组 index</a>。</p><p>在 V8 中，会特殊处理整数名称的属性（最常见的形式是由 Array 构造函数生成的对象）。尽管很多情况下这些数字索引属性的表现和其他属性一样，但为了优化，V8 将它们和非数字属性分开存储。在内部，V8 甚至给这些属性一个特殊的名称：<em>elements</em>。对象通过<a href="https://v8.dev/blog/fast-properties" target="_blank" rel="noopener">properties</a>可以 map 到一些 value ，而数组通过 index 可以 map 到一些子元素。</p><p>尽管这些内部细节从来没有直接向 JavaScript 开发人员公开，但它们解释了为什么某些代码模式比其他模式更快。</p><h2 id="常见的-elements-类型"><a href="#常见的-elements-类型" class="headerlink" title="常见的 elements 类型"></a>常见的 elements 类型</h2><p>在运行 JavaScript 代码时，V8 会追踪每个数组的 elements 的类型。V8 可以根据这些信息，在对拥有这种 elements 类型的数组进行操作时，进行针对性的优化。例如，当在数组上调用 <code>reduce</code>，<code>map</code> 或 <code>forEach</code> 时，V8 可以根据数组的 elements 类型来优化这些操作。</p><p>以这个数组为例:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br></pre></td></tr></table></figure><p>这个数组的 elements 类型是什么呢？如果用 <code>typeof</code> 来回答，结果就是这个数组含有 <code>number</code> 类型的数。在语言层面，这就是我们能看到的：JavaScript 不会区分整数(integers)，浮点数(floats)和双精度数(doubles)，它们都只是数字。但在引擎层面，我们可以做更精确地区分。该数组的 elements 类型为 <code>PACKED_SMI_ELEMENTS</code>。在 V8 中，术语 <code>Smi</code> 是指用于存储小整数(small integers)的一种特定格式。</p><p>然后，向同一个数组中添加浮点数会把这个数组转为更通用的 elements 类型</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="comment">// elements 类型: PACKED_SMI_ELEMENTS</span></span><br><span class="line">array.push(<span class="number">4.56</span>);</span><br><span class="line"><span class="comment">// elements 类型: PACKED_DOUBLE_ELEMENTS</span></span><br></pre></td></tr></table></figure><p>向数组中添加字符串将再次改变数组 elements 类型</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="comment">// elements 类型: PACKED_SMI_ELEMENTS</span></span><br><span class="line">array.push(<span class="number">4.56</span>);</span><br><span class="line"><span class="comment">// elements 类型: PACKED_DOUBLE_ELEMENTS</span></span><br><span class="line">array.push(<span class="string">'x'</span>);</span><br><span class="line"><span class="comment">// elements 类型: PACKED_ELEMENTS</span></span><br></pre></td></tr></table></figure><p>到目前为止，我们已经看到了 3 种不同的 elements 类型，以下是基本类型</p><ul><li><strong>Sm</strong> all  <strong>i</strong> ntegers，也就是 Smi</li><li>Doubles，用于不能用 Smi 表示的浮点数(floating-point)和整数(integers)</li><li>常规 elements，用于不能表示为 Smi 或双精度值(doubles)的值</li></ul><p>注意，doubles 是 Smi 的一种更通用的变体，常规 elements 是 doubles 之上的另一种泛化。用 Smi 表示的数字集 是 用 double 表示的数字集的子集。</p><p>重点是 elements 类型只向一个方向转化，从特殊的(比如: <code>PACKED_SMI_ELEMENTS</code>) 转向更常规的(比如: <code>PACKED_ELEMENTS</code>)，比如一旦一个数组被标记为是 <code>PACKED_ELEMENTS</code>，它就不能再转化成 <code>PACKED_DOUBLE_ELEMENTS</code> 类型的了。</p><p>目前，我们已经了解到</p><ul><li>V8 会对每个数组赋予一个 elements 类型</li><li>数组的 elements 类型并不是一成不变的 —— 它可以在运行时改变。之前的例子中有从 <code>PACKED_SMI_ELEMENTS</code> 转向 <code>PACKED_ELEMENTS</code> 的</li><li>elements 类型只能从特定类型转向常规类型</li></ul><h2 id="PACKED-和-HOLEY-类型"><a href="#PACKED-和-HOLEY-类型" class="headerlink" title="PACKED 和 HOLEY 类型"></a><code>PACKED</code> 和 <code>HOLEY</code> 类型</h2><p>目前我们只谈到了 packed 类型的数组。在数组中创建 holes (使数组变稀疏)会将其 elements 类型降级成它的 “holey” 版本</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4.56</span>, <span class="string">'x'</span>];</span><br><span class="line"><span class="comment">// elements 类型: PACKED_ELEMENTS</span></span><br><span class="line">array.length; <span class="comment">// 5</span></span><br><span class="line">array[<span class="number">9</span>] = <span class="number">1</span>; <span class="comment">// array[5] 到 array[8] 现在都是 holes</span></span><br><span class="line"><span class="comment">// elements 类型: HOLEY_ELEMENTS</span></span><br></pre></td></tr></table></figure><p>V8 之所以有这种区别，它在优化 packed 类型数组的操作上比 holey 类型数组更积极。在 packed 类型数组上大多数操作都可以有效率地执行。相比之下，在 holey 类型数组上，这些操作就需要在原型链上进行额外的检测，并耗费性能高昂的查询。</p><p>到目前为止，我们已经看到每种基本 elements 类型(即 Smis，double 和常规 elements 类型)都有两种: packed 版本和 holey 版本。它们不仅可以从 <code>PACKED_SMI_ELEMENTS</code> 转变成 <code>PACKED_DOUBLE_ELEMENTS</code>，而且还可以从任何 <code>PACKED</code> 类型转变成其 <code>HOLEY</code> 对应类型。<br>总结一下:</p><ul><li>最常见的 elements 类型有 <code>PACKED</code> 类型和 <code>HOLEY</code> 类型</li><li>在 packed 类型数组上的操作比 holey 类型数组更有效率</li><li>elements 类型可以从 <code>PACKED</code> 类型转变成 <code>HOLEY</code> 类型</li></ul><h2 id="elements-类型-格"><a href="#elements-类型-格" class="headerlink" title="elements 类型 格"></a>elements 类型 格</h2><p>这套标记转换系统被 V8 弄成了一个 <a href="https://zh.wikipedia.org/wiki/%E6%A0%BC_(%E6%95%B0%E5%AD%A6" target="_blank" rel="noopener">格</a>)。下面是只有几个 elements 类型的简化示意图:</p><p><img src="./1.png" alt></p><p>它只能通过格来向下转变。一旦一个 Smis 数组添加了单个浮点数(single floating-point)，即便之后使用 Smi 覆盖该浮点数，它都会被标记为 DOUBLE。同样的，一旦一个数组中出现了 hole，即便之后将这个 hole 补上了，它都会被标记为 holey。</p><p>V8 目前区分了 <a href="https://source.chromium.org/chromium/v8/v8.git/+/ec37390b2ba2b4051f46f153a8cc179ed4656f5d:src/elements-kind.h;l=14" target="_blank" rel="noopener">21 种不同的 elements 类型</a>，每一种都可能有一堆优化</p><p>通常，更特定的 elements 类型支持更细粒度的优化。格中 elements 类型越往下，其对象的操作就会越慢。为了获取最佳性能，避免不太特定的类型的这种不必要的转换，应坚持使用最适合情况的特定 elements 类型。</p><h2 id="性能建议"><a href="#性能建议" class="headerlink" title="性能建议"></a>性能建议</h2><p>大多数情况下，elements 类型的追踪工作是在底层运行的，没必要考虑得那么细。但为了从系统中获取最大收益，以下几件事情是可以做的。</p><h3 id="避免读取超出数组长度的内容"><a href="#避免读取超出数组长度的内容" class="headerlink" title="避免读取超出数组长度的内容"></a>避免读取超出数组长度的内容</h3><p>有点出乎意料(鉴于这篇文章的标题)的是，我们的第 1 个性能建议与 elements 类型追踪没有直接联系(尽管背后发生的事情有点像)。读取超过数组长度的数据会对性能产生惊人的影响，例如当 <code>array.length === 5</code> 时去读 <code>array[42]</code> 的数据。这个例子中数组下标 <code>42</code> 已经越界，数组本身就没这属性，JS 引擎就会耗费昂贵的性能去原型链上找。一旦加载遇到这种情况，V8 会记住 “这个加载需要处理特殊情况”，而且它的速度再也不会像读取到越界之前那么快了。</p><p>不要把循环写成这样:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不要这么写!</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, item; (item = items[i]) != <span class="literal">null</span>; i++) &#123;</span><br><span class="line">  doSomething(item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码读取数组中的所有元素，然后再读取一个元素。直到它发现 <code>undefined</code> 的或 <code>null</code> 元素时才结束。(jQuery 在一些地方就这么干的。)</p><p>相反，用老方式写循环，并不断迭代，直到到达最后一个元素。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> index = <span class="number">0</span>; index &lt; items.length; index++) &#123;</span><br><span class="line">  <span class="keyword">const</span> item = items[index];</span><br><span class="line">  doSomething(item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果循环的对象是可迭代的(比如数组和 <code>NodeLists</code>)就更好了，直接用 <code>for-of</code></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> item <span class="keyword">of</span> items) &#123;</span><br><span class="line">  doSomething(item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于特定数组，也可以用内置 <code>forEach</code></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">items.forEach(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">  doSomething(item);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>现在 <code>for-of</code> 和 <code>forEach</code> 的性能都和老式的 for 循环差不多了。</p><p>避免读取超出数组长度的内容！在这种情况下，V8 的边界检查会失败，检查该属性是否存在也就会失败，然后 V8 就要从原型链上找了。如果之后在计算中不小心使用到了这个值(也就是超出数组长度的值)，影响会更糟，例如:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Maximum</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> max = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt;= array.length; i++) &#123; <span class="comment">// 糟糕的比较</span></span><br><span class="line">    <span class="keyword">if</span> (array[i] &gt; max) max = array[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里，最后一次迭代超出了数组长度，返回结果为 <code>undefined</code>，这既影响了加载，又影响了比较：不再只比较数字，它要处理特殊情况。把终止条件改为正确的 <code>i &lt; array.length</code> 可使本示例的性能提高 6 倍(在有 10,000 个元素的数组上进行测试，迭代次数只减少了 0.01%)。</p><h3 id="避免-elements-类型的变化"><a href="#避免-elements-类型的变化" class="headerlink" title="避免 elements 类型的变化"></a>避免 elements 类型的变化</h3><p>通常，如果需要在一个数组上执行很多操作，试着只用一种元素类型，尽可能是特定类型，这样 V8 可以尽可能对这些操作进行优化。</p><p>这比看上去要难。比如仅向一个 Smi 数组中添加 <code>-0</code> 就能把它变成 <code>PACKED_DOUBLE_ELEMENTS</code>。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> array = [<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, +<span class="number">0</span>];</span><br><span class="line"><span class="comment">// PACKED_SMI_ELEMENTS</span></span><br><span class="line">array.push(<span class="number">-0</span>);</span><br><span class="line"><span class="comment">// PACKED_DOUBLE_ELEMENTS</span></span><br></pre></td></tr></table></figure><p>结果就是，之后对该数组的任何操作的优化都与对 Smi 的优化不一样。</p><p>避免使用 <code>-0</code>，除非明确需要在代码中区分 <code>-0</code> 和 <code>+0</code>。(最好不要这么做)</p><p>对于 <code>NaN</code> 和 <code>Infinity</code> 而言都是一样的。它们都被看作是浮点数(doubles)，所以在一个 <code>SMI_ELEMENTS</code> 数组中添加一个 <code>NaN</code> 或者是 <code>Infinity</code>，这个数组就会变成 <code>DOUBLE_ELEMENTS</code></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> array = [<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>];</span><br><span class="line"><span class="comment">// PACKED_SMI_ELEMENTS</span></span><br><span class="line">array.push(<span class="literal">NaN</span>, <span class="literal">Infinity</span>);</span><br><span class="line"><span class="comment">// PACKED_DOUBLE_ELEMENTS</span></span><br></pre></td></tr></table></figure><p>要对一个整数数组进行大量的操作了，在它初始化时就应考虑下把 <code>-0</code> 变成 <code>0</code>，<code>NaN</code> 和 <code>Infinity</code> 之类的值就应该过滤掉。这样一来，这个数组才会维持在 <code>PACKED_SMI_ELEMENTS</code> 状态。这种一次性标准化后的开销对于后续优化都是值得的。</p><p>实际上，如果要对数字(numbers)数组进行数学操作，可以考虑下 TypedArray。这也有对应的特定的 elements 类型。</p><h3 id="优先使用-array-而不是-array-like-的对象"><a href="#优先使用-array-而不是-array-like-的对象" class="headerlink" title="优先使用 array 而不是 array-like 的对象"></a>优先使用 array 而不是 array-like 的对象</h3><p>有些 JS 里的对象，特别是 DOM，看起来像是数组但其实它们并不是真正意义上的数组。创建的 array-like 的数组就像下面这样</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arrayLike = &#123;&#125;;</span><br><span class="line">arrayLike[<span class="number">0</span>] = <span class="string">'a'</span>;</span><br><span class="line">arrayLike[<span class="number">1</span>] = <span class="string">'b'</span>;</span><br><span class="line">arrayLike[<span class="number">2</span>] = <span class="string">'c'</span>;</span><br><span class="line">arrayLike.length = <span class="number">3</span>;</span><br></pre></td></tr></table></figure><p>这个对象有 <code>length</code> ，也可以通过下标索引访问子元素(就像数组一样!)，但它在其原型链上缺少数组方法，比如 <code>forEach</code>。不过仍可以通过下面的方式在这个对象上调用数组的方法</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.forEach.call(arrayLike, (value, index) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123; index &#125;</span>: <span class="subst">$&#123; value &#125;</span>`</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 先打印 '0: a', 然后打印 '1: b', 最后打印 '2: c'.</span></span><br></pre></td></tr></table></figure><p>这段代码调用 array-like 对象上内置的 <code>Array.prototype.forEach</code> 方法，结果符合预期。但这比在真数组上调用 <code>forEach</code> 慢，而后者在 V8 中已被高度优化。要多次在此对象上使用内置的数组方法的话，就应先把它转成真数组再用：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> actualArray = <span class="built_in">Array</span>.prototype.slice.call(arrayLike, <span class="number">0</span>);</span><br><span class="line">actualArray.forEach(<span class="function">(<span class="params">value, index</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123; index &#125;</span>: <span class="subst">$&#123; value &#125;</span>`</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 先打印 '0: a', 然后打印 '1: b', 最后打印 '2: c'.</span></span><br></pre></td></tr></table></figure><p>这种一次性转换的开销对于后续的优化来讲都是值得的，特别是当对数组执行大量操作时。</p><p><code>arguments</code> 对象是一个 array-like 对象，可以在其上调用数组内置函数，但这种操作不会像对真数组那样做全方位的优化。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> logArgs = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">Array</span>.prototype.forEach.call(<span class="built_in">arguments</span>, (value, index) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123; index &#125;</span>: <span class="subst">$&#123; value &#125;</span>`</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line">logArgs(<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>);</span><br><span class="line"><span class="comment">// 先打印 '0: a', 然后打印 '1: b', 最后打印 '2: c'.</span></span><br></pre></td></tr></table></figure><p>ES2015 rest 参数可以在这里帮个忙。它们可以用真数组，而不是优雅地用 array-like 的 <code>arguments</code> 对象。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> logArgs = <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">  args.forEach(<span class="function">(<span class="params">value, index</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123; index &#125;</span>: <span class="subst">$&#123; value &#125;</span>`</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line">logArgs(<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>);</span><br><span class="line"><span class="comment">// 先打印 '0: a', 然后打印 '1: b', 最后打印 '2: c'.</span></span><br></pre></td></tr></table></figure><p>现在你还有啥借口用 <code>arguments</code> 对象。</p><p>所以一般来讲，尽可能避免使用 array-like 的对象，应尽可能使用真数组。</p><h3 id="避免多态"><a href="#避免多态" class="headerlink" title="避免多态"></a>避免多态</h3><p>如果代码中要处理很多不同的 elements 类型的数组，它可能会导致多态操作，这比只用处理单个 elements 类型的代码要慢。</p><p>看如下示例，里面调用了各种 elements 类型的库函数。(注意下这不是原来的 <code>Array.prototype.forEach</code> 方法，除了本文讨论的对特定 elements 类型的优化，这个示例自己也有一套优化。)</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> each = <span class="function">(<span class="params">array, callback</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> index = <span class="number">0</span>; index &lt; array.length; ++index) &#123;</span><br><span class="line">    <span class="keyword">const</span> item = array[index];</span><br><span class="line">    callback(item);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> doSomething = <span class="function">(<span class="params">item</span>) =&gt;</span> <span class="built_in">console</span>.log(item);</span><br><span class="line"></span><br><span class="line">each([], () =&gt; &#123;&#125;);</span><br><span class="line"></span><br><span class="line">each([<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>], doSomething);</span><br><span class="line"><span class="comment">// `PACKED_ELEMENTS` 调用了 `each` 方法。V8 使用了内联缓存</span></span><br><span class="line"><span class="comment">// (或者说叫 "IC") 记住了这个 `each` 方法是被这个 elements 类型调用的。</span></span><br><span class="line"><span class="comment">// 若不出意外，V8 会乐观地假定在 `each` 方法里访问 `array.length` 和 `array[index]` 时</span></span><br><span class="line"><span class="comment">// 是单一的(比如只接受一种 elements 类型)，之后每次调用 `each` 方法，V8 就会去检查这个类型</span></span><br><span class="line"><span class="comment">// 是不是 `PACKED_ELEMENTS`，如果是，V8 会重用之前生成的代码；</span></span><br><span class="line"><span class="comment">// 如果不是，就需要做更多事情了</span></span><br><span class="line"></span><br><span class="line">each([<span class="number">1.1</span>, <span class="number">2.2</span>, <span class="number">3.3</span>], doSomething);</span><br><span class="line"><span class="comment">// `PACKED_DOUBLE_ELEMENTS` 调用了 `each` 方法。 V8 此时看到，在它的内联缓存里面，</span></span><br><span class="line"><span class="comment">// 给 `each` 方法传的是不同的 elements 类型的数组了，那么在 `each` 方法里访问 `array.length` 和 `array[index]` 时就被打上了多态的标记。</span></span><br><span class="line"><span class="comment">// 现在每次在调用 `each` 方法时 V8 都要去做下额外的检查:</span></span><br><span class="line"><span class="comment">// 1. 这个是不是 `PACKED_ELEMENTS`(就像上面说过的)</span></span><br><span class="line"><span class="comment">// 2. 这个是不是 `PACKED_DOUBLE_ELEMENTS`</span></span><br><span class="line"><span class="comment">// 3. 这个还是不是其他的 elements 类型</span></span><br><span class="line"><span class="comment">// 这就会引起性能上的损耗</span></span><br><span class="line"></span><br><span class="line">each([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], doSomething);</span><br><span class="line"><span class="comment">// `PACKED_SMI_ELEMENTS` 调用了 `each` 方法。这就触发了另一个种程度的多态性。现在在内联缓存中，对于 `each` 方法来说有 3 种不同的 elements 类型。从现在开始每次调用 `each` 方法，就需要另外检查 elements 类型，才能将生成的代码重新用于 `PACKED_SMI_ELEMENTS` 数组，而这都需要以消耗性能为代价才能做的。</span></span><br></pre></td></tr></table></figure><p>内置方法(如 <code>Array.prototype.forEach</code>)可以更有效地处理这种多态性，因此如果对性能敏感，请考虑使用这些内置方法而不是用户手写的库函数</p><p>V8 中关于单态与多态的另一个例子就跟对象的 shape 相关，也就是对象的隐藏类。要了解更多请参考 <a href="https://mrale.ph/blog/2015/01/11/whats-up-with-monomorphism.html" target="_blank" rel="noopener">这篇文章</a></p><h3 id="避免创建-holes"><a href="#避免创建-holes" class="headerlink" title="避免创建 holes"></a>避免创建 holes</h3><p>在真正的代码看来，访问 holey 数组和 packed 数组之间的性能差异通常太小，甚至无法测量。如果性能测试表明在优化的代码中保留每一条机器指令是值得的，那么可以尝试把数组维持在 packed 模式。比如说，我们要创建一个数组</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> array = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">3</span>);</span><br><span class="line"><span class="comment">// 此时这个数组是稀疏的，所以它被标记为 `HOLEY_SMI_ELEMENTS`</span></span><br><span class="line"><span class="comment">// 根据当前的信息这就是最可能的结果</span></span><br><span class="line"></span><br><span class="line">array[<span class="number">0</span>] = <span class="string">'a'</span>;</span><br><span class="line"><span class="comment">// 等等，这是一个字符而不是一个 Smi，所以 elements 类型转成 `HOLEY_ELEMENTS`</span></span><br><span class="line"></span><br><span class="line">array[<span class="number">1</span>] = <span class="string">'b'</span>;</span><br><span class="line">array[<span class="number">2</span>] = <span class="string">'c'</span>;</span><br><span class="line"><span class="comment">// 此时，数组的 3 个位置都被填满了。所以数组是 packed 了(不再是稀疏的了)。</span></span><br><span class="line"><span class="comment">// 然而现在已经不能把这个数组再转成一个特定类型比如 `PACKED_ELEMENTS` 了。</span></span><br><span class="line"><span class="comment">// elements 类型仍然为 `HOLEY_ELEMENTS`</span></span><br></pre></td></tr></table></figure><p>一旦数组被标记为 holey，它将永远保持在 holey 状态，即便之后数组里面有元素了</p><p>创建数组的更好方法是使用如下方式</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> array = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>];</span><br><span class="line"><span class="comment">// elements 类型: PACKED_ELEMENTS</span></span><br></pre></td></tr></table></figure><p>如果事先不知道所有的值，可以创建一个空数组，然后将值 <code>push</code> 进去</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> array = [];</span><br><span class="line"><span class="comment">// …</span></span><br><span class="line">array.push(someValue);</span><br><span class="line"><span class="comment">// …</span></span><br><span class="line">array.push(someOtherValue);</span><br></pre></td></tr></table></figure><p>这种方法确保了数组永远不会转换为 holey elements 类型。因此，V8 可能会为这个数组的某些操作生成更快的优化代码。</p><h2 id="调试-elements-类型"><a href="#调试-elements-类型" class="headerlink" title="调试 elements 类型"></a>调试 elements 类型</h2><p>为了弄明白啥是对象的 elements 类型，可用 d8 的调试版本运行(通过在 debug 模式下<a href="https://v8.dev/docs/build" target="_blank" rel="noopener">从源码进行构建</a>，或使用 <a href="https://github.com/GoogleChromeLabs/jsvu" target="_blank" rel="noopener">jsvu</a> 弄到预编译的二进制文件)</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">out/x64.debug/d8 --allow-natives-syntax</span><br></pre></td></tr></table></figure><p>这将打开一个 d8 REPL，其中可用 <code>%DebugPrint(object)</code> 等<a href="https://cs.chromium.org/chromium/src/v8/src/runtime/runtime.h?l=20&amp;rcl=05720af2b09a18be5c41bbf224a58f3f0618f6be" target="_blank" rel="noopener">特殊函数</a>。输出的 <code>elements</code> 字段显示了传递给 这个 debug 函数的对象的 elements 类型。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">d8&gt; const array = [1, 2, 3]; %DebugPrint(array);</span><br><span class="line">DebugPrint: 0x1fbbad30fd71: [JSArray]</span><br><span class="line"> - map = 0x10a6f8a038b1 [FastProperties]</span><br><span class="line"> - prototype = 0x1212bb687ec1</span><br><span class="line"> - elements = 0x1fbbad30fd19 &lt;FixedArray[3]&gt; [PACKED_SMI_ELEMENTS (COW)]</span><br><span class="line"> - length = 3</span><br><span class="line"> - properties = 0x219eb0702241 &lt;FixedArray[0]&gt; &#123;</span><br><span class="line">    <span class="comment">#length: 0x219eb0764ac9 &lt;AccessorInfo&gt; (const accessor descriptor)</span></span><br><span class="line"> &#125;</span><br><span class="line"> - elements= 0x1fbbad30fd19 &lt;FixedArray[3]&gt; &#123;</span><br><span class="line">           0: 1</span><br><span class="line">           1: 2</span><br><span class="line">           2: 3</span><br><span class="line"> &#125;</span><br><span class="line">[…]</span><br></pre></td></tr></table></figure><p>注意，COW 表示<a href="https://zh.wikipedia.org/wiki/%E5%AF%AB%E5%85%A5%E6%99%82%E8%A4%87%E8%A3%BD" target="_blank" rel="noopener">copy-on-write</a>，这是另一个内部优化。</p><p>在调试构建中可用的另一个有用的 flag 是 <code>--trace-elements-transitions</code>。用上它能让 V8 提示你 elements 类型转换是在啥时发生的。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ cat my-script.js</span><br><span class="line">const array = [1, 2, 3];</span><br><span class="line">array[3] = 4.56;</span><br><span class="line"></span><br><span class="line">$ out/x64.debug/d8 --trace-elements-transitions my-script.js</span><br><span class="line">elements transition [PACKED_SMI_ELEMENTS -&gt; PACKED_DOUBLE_ELEMENTS] <span class="keyword">in</span> ~+34 at x.js:2 <span class="keyword">for</span> 0x1df87228c911 &lt;JSArray[3]&gt; from 0x1df87228c889 &lt;FixedArray[3]&gt; to 0x1df87228c941 &lt;FixedDoubleArray[22]&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;注：该文章翻译自&lt;a href=&quot;https://v8.dev/blog/elements-kinds&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://v8.dev/blog/elements-kinds&lt;/a&gt; V8 的官方博客，这是关于解释在 V8 中「elements」的类型都有哪些的一篇文章，文章有翻译的不是很清楚的地方，欢迎各位指正&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="翻译" scheme="https://strugglebak.github.io/categories/%E7%BF%BB%E8%AF%91/"/>
    
    
      <category term="V8" scheme="https://strugglebak.github.io/tags/V8/"/>
    
  </entry>
  
  <entry>
    <title>手摸手踩坑react-template</title>
    <link href="https://strugglebak.github.io/2021/11/23/%E6%89%8B%E6%91%B8%E6%89%8B%E8%B8%A9%E5%9D%91react-template/"/>
    <id>https://strugglebak.github.io/2021/11/23/手摸手踩坑react-template/</id>
    <published>2021-11-23T04:22:02.000Z</published>
    <updated>2022-06-04T08:13:29.428Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>注意：为了方便统一，本文中出现的安装包依赖的方式均使用 <code>yarn</code> 来安装</p></blockquote><a id="more"></a><h2 id="采取最简便的方式"><a href="#采取最简便的方式" class="headerlink" title="采取最简便的方式"></a>采取最简便的方式</h2><p>如果说搭建一个 react template 最简便的方式，那便是使用官方的 cli，即 <code>create-react-app</code>，因为这边还需要使用 typescript 技术栈，所以在搭建的过程中可以加一个参数 <code>--template typescript</code>，表示使用的模板是 typescript 的模板</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yarn create react-app my-app --template typescript</span><br></pre></td></tr></table></figure><p>然后在项目的目录中执行如下的命令安装依赖</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yarn add typescript @types/node @types/react @types/react-dom @types/jest</span><br></pre></td></tr></table></figure><p>然后生成的目录结构基本上如下所示</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># my-app</span></span><br><span class="line">├── README.md</span><br><span class="line">├── package.json</span><br><span class="line">├── public</span><br><span class="line">│   ├── favicon.ico</span><br><span class="line">│   ├── index.html</span><br><span class="line">│   ├── logo192.png</span><br><span class="line">│   ├── logo512.png</span><br><span class="line">│   ├── manifest.json</span><br><span class="line">│   └── robots.txt</span><br><span class="line">├── src</span><br><span class="line">│   ├── App.css</span><br><span class="line">│   ├── App.test.tsx</span><br><span class="line">│   ├── App.tsx</span><br><span class="line">│   ├── index.css</span><br><span class="line">│   ├── index.tsx</span><br><span class="line">│   ├── logo.svg</span><br><span class="line">│   ├── react-app-env.d.ts</span><br><span class="line">│   ├── serviceWorker.ts</span><br><span class="line">│   └── setupTests.ts</span><br><span class="line">├── tsconfig.json</span><br><span class="line">└── yarn.lock</span><br></pre></td></tr></table></figure><p>其中比较重要的就是 <code>src</code> 以及 <code>tsconfig.json</code> 文件，一个用来存放源码，一个用来定义 <code>tsconfig.json</code> 文件。但这两个文件并不是在最开始搭建的时候一个大障碍，一个比较大的障碍是，使用 cra 创建的项目，如果以后项目的需求变更，就必须使用 <code>config-overide.js</code> 去做一个覆盖原本默认 <code>webpack</code> 配置的配置文件。同时你还需要下载 <a href="https://github.com/timarney/react-app-rewired/blob/master/README_zh.md" target="_blank" rel="noopener"><code>react-app-rewired</code></a> 这个库来重新构建整个项目。考虑到 <code>react-app-rewired</code> 社区中维护的插件/包/库都不是特别的多，并且使用这种过度包装的 package 也比较黑盒，难于调试，所以最后决定使用 <code>yarn eject</code> 抛出该项目的 webpack 配置，手动实现真正自定义的配置和其他的操作(做注释以及方便后面的维护)</p><h3 id="yarn-eject"><a href="#yarn-eject" class="headerlink" title="yarn eject"></a>yarn eject</h3><p>执行 <code>yarn eject</code> 之后，基本上就多了两个文件夹 <code>scripts</code> 以及 <code>config</code></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># scripts</span></span><br><span class="line">├── build.js</span><br><span class="line">├── start.js</span><br><span class="line">└── test.js</span><br></pre></td></tr></table></figure><p>其中的 <code>build.js</code>、<code>start.js</code>、<code>test.js</code> 分别对应 <code>package.json</code> 文件中的 <code>scripts</code> 脚本</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">// package.json</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="attr">"scripts"</span>: &#123;</span><br><span class="line">    <span class="attr">"start"</span>: <span class="string">"node scripts/start.js"</span>,</span><br><span class="line">    <span class="attr">"build"</span>: <span class="string">"node scripts/build.js"</span>,</span><br><span class="line">    <span class="attr">"test"</span>: <span class="string">"node scripts/test.js"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>道理我都明白，<code>start</code> 对应启动一个本地的 devServer 进行调试，而 <code>build</code> 对应打包最终的文件，<code>test</code> 对应代码的测试脚本，但是你特么的为啥要引入这么多个包啊？全部都是函数套函数的形式，你这谁看的懂啊？</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># config</span></span><br><span class="line">├── env.js</span><br><span class="line">├── getHttpsConfig.js</span><br><span class="line">├── jest</span><br><span class="line">│   ├── cssTransform.js</span><br><span class="line">│   └── fileTransform.js</span><br><span class="line">├── modules.js</span><br><span class="line">├── paths.js</span><br><span class="line">├── pnpTs.js</span><br><span class="line">├── webpack.config.js</span><br><span class="line">└── webpackDevServer.config.js</span><br></pre></td></tr></table></figure><p>还有这个所谓的 eject 出来的 <code>webpack</code> 的配置，粗略看了下核心文件 <code>webpack.config.js</code> 中光是配置文件的行数就有 <code>670</code> 行，尽管中间参杂了各种英文的注释，但是对于一个需要配置的新人来说，还是过于繁杂了，光是看到它引入的各种插件也是头疼无比，其实到这个时候，就已经有不详的预感了(对于如此复杂的一个配置，任何修改和添加或者删除都将是灾难性的)</p><h3 id="sass-loader-的-bug"><a href="#sass-loader-的-bug" class="headerlink" title="sass-loader 的 bug"></a>sass-loader 的 bug</h3><p>因为在之前的 xp 项目中(比如 <code>xp-homework</code>)，可以通过 <code>.env</code> 中的环境变量给一个 scss 变量赋值并追加到某个定义好的 scss 文件中，在 <code>xp-homework</code> 项目中的 <code>vue.config.js</code> 有这样的代码</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  ...</span><br><span class="line">  css: &#123;</span><br><span class="line">    loaderOptions: &#123;</span><br><span class="line">      sass: &#123;</span><br><span class="line">        data: <span class="string">`@import "@/styles/variables.scss"; $userSelect: <span class="subst">$&#123;process.env</span></span></span><br><span class="line"><span class="string"><span class="subst">          .VUE_APP_USER_SELECT || <span class="string">'none'</span>&#125;</span>;`</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考 <a href="https://webpack.js.org/loaders/sass-loader/#prependdata" target="_blank" rel="noopener">webpack 中有关 sassloader prependData 属性的文档</a>，里面的解释如下</p><blockquote><p>Prepends Sass/SCSS code before the actual entry file. In this case, the sass-loader will not override the data option but just append the entry’s content.</p></blockquote><p>This is especially useful when some of your Sass variables depend on the environment</p><p>以及里面的函数配置的写法</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    loader: <span class="string">'sass-loader'</span>,</span><br><span class="line">    options: &#123;</span><br><span class="line">      prependData: <span class="function">(<span class="params">loaderContext</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// More information about available properties https://webpack.js.org/api/loaders/</span></span><br><span class="line">        <span class="keyword">const</span> &#123; resourcePath, rootContext &#125; = loaderContext;</span><br><span class="line">        <span class="keyword">const</span> relativePath = path.relative(rootContext, resourcePath);</span><br><span class="line">        <span class="keyword">if</span> (relativePath === <span class="string">'styles/foo.scss'</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="string">'$value: 100px;'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'$value: 200px;'</span>;</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将项目中的 <code>webpack.config.js</code> 中如下的代码</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">if</span> (preProcessor) &#123;</span><br><span class="line">  loaders.push(</span><br><span class="line">    &#123;</span><br><span class="line">      loader: <span class="built_in">require</span>.resolve(<span class="string">'resolve-url-loader'</span>),</span><br><span class="line">      options: &#123;</span><br><span class="line">        sourceMap: isEnvProduction &amp;&amp; shouldUseSourceMap,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      loader: <span class="built_in">require</span>.resolve(preProcessor),</span><br><span class="line">      options: &#123;</span><br><span class="line">        sourceMap: <span class="literal">true</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> loaders;</span><br></pre></td></tr></table></figure><p>改写成</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (preProcessor) &#123;</span><br><span class="line">  <span class="keyword">const</span> loader = &#123;</span><br><span class="line">    loader: <span class="built_in">require</span>.resolve(preProcessor),</span><br><span class="line">    options: &#123;</span><br><span class="line">      sourceMap: <span class="literal">true</span>,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (preProcessor === <span class="string">'sass-loader'</span>) &#123;</span><br><span class="line">    loader.options.prependData = <span class="function">(<span class="params">loaderContext</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123; resourcePath, rootContext &#125; = loaderContext</span><br><span class="line">      <span class="keyword">const</span> relativePath = path.relative(rootContext, resourcePath)</span><br><span class="line">      <span class="keyword">if</span> (relativePath === <span class="string">'src/styles/base.scss'</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">`$userSelect: <span class="subst">$&#123;process.env.REACT_APP_USER_SELECT || <span class="string">'none'</span>&#125;</span>`</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  loaders.push(</span><br><span class="line">    &#123;</span><br><span class="line">      loader: <span class="built_in">require</span>.resolve(<span class="string">'resolve-url-loader'</span>),</span><br><span class="line">      options: &#123;</span><br><span class="line">        sourceMap: isEnvProduction &amp;&amp; shouldUseSourceMap</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    loader</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> loaders</span><br></pre></td></tr></table></figure><p>使用 <code>yarn start</code> 后报如下的错误</p><p><img src="./1.png" alt></p><p>就非常的奇怪，一个比较 trick 的解决方式是，将所有需要引入到 .scss 文件的地方，都改为 .sass，并将其语法也改写成 sass 语法。编译通过。不过这并不是一个好的解决方式，因为定位的问题应该是 sass-loader，可能还有其他的配置，于是去 github 上找了 <a href="https://github.com/webpack-contrib/sass-loader" target="_blank" rel="noopener">sass-loader 的相关配置</a>，找到了这么一段话</p><p><img src="./2.png" alt></p><p>但是看了下，项目中其实是安装了 sass 的，按照道理来说应该会自动使用 sass 来 implementation 才对，但是这里又报错，于是尝试去掉 sass，直接安装 node-sass，问题居然解决了!!!所以如果以后需要用到 sass-loader 的地方，最好还是先安装 node-sass 比较稳妥</p><h3 id="路径-alias-引入失败"><a href="#路径-alias-引入失败" class="headerlink" title="路径 alias 引入失败"></a>路径 alias 引入失败</h3><p>之前在搭建模板的过程中，只是在 <code>tsconfig.json</code> 文件中设置了 <code>baseUrl</code> 以及 <code>paths</code></p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"baseUrl"</span>: <span class="string">"./src"</span>, <span class="comment">// 解析非相对模块名的基准目录</span></span><br><span class="line">  <span class="attr">"paths"</span>: &#123; <span class="comment">// 这个属性就是用来填写编译时对应的 alias 用的</span></span><br><span class="line">    <span class="attr">"@"</span>: [<span class="string">"./src"</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果是在 webpack 中不做设置，那么在编译时 webpack 会报错，所以在该项目中的 <code>webpack.config.js</code> 中也需要做 alias 的配置</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">alias: &#123;</span><br><span class="line">  <span class="string">'@'</span>: path.resolve(__dirname, <span class="string">'../src'</span>),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是设置完后编译，typescript 表示依然找不到模块，这个时候就是 <code>tsconfig.json</code> 配置的问题了。如果你的 <code>baseUrl</code> 中已经写了 <code>./src</code>，那么 <code>paths</code> 应该这么写</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"baseUrl"</span>: <span class="string">"./src"</span>, <span class="comment">// 解析非相对模块名的基准目录</span></span><br><span class="line">  <span class="attr">"paths"</span>: &#123; <span class="comment">// 这个属性就是用来填写编译时对应的 alias 用的</span></span><br><span class="line">    <span class="attr">"@/*"</span>: [<span class="string">"."</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>@/*</code> 表示匹配代码中的以 <code>@/xxx/yyy</code> 这种形式引入模块，由于已经设置了 <code>baseUrl</code>，所以这里 <code>paths</code> 中的配置就自动加上了 <code>baseUrl</code>了。比如引入一个包 <code>import XXX from &#39;@/xxx/yyy&#39;</code>，而你的配置为 <code>&quot;@/*&quot;: [&quot;.&quot;]</code> 的话，它会自动在 <code>./src/xxx/yyy</code> 下去寻找这个模块。另外为了保持格式，我将对应的 webpack 的 alias 以及 tsconfig 的 alias 都做了一一对应，如下</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line">alias: &#123;</span><br><span class="line">  <span class="comment">// 设置 webpack 编译时的 alias</span></span><br><span class="line">  <span class="comment">// ../ 目录的原因是因为当前 src 目录相当于当前 webpack.config.js 的就是上级目录</span></span><br><span class="line">  <span class="string">'@'</span>: path.resolve(__dirname, <span class="string">'../src'</span>),</span><br><span class="line">  <span class="string">'@api'</span>: path.resolve(__dirname, <span class="string">'../src/api'</span>),</span><br><span class="line">  <span class="string">'@assets'</span>: path.resolve(__dirname, <span class="string">'../src/assets'</span>),</span><br><span class="line">  <span class="string">'@components'</span>: path.resolve(__dirname, <span class="string">'../src/components'</span>),</span><br><span class="line">  <span class="string">'@router'</span>: path.resolve(__dirname, <span class="string">'../src/router'</span>),</span><br><span class="line">  <span class="string">'@styles'</span>: path.resolve(__dirname, <span class="string">'../src/styles'</span>),</span><br><span class="line">  <span class="string">'@utils'</span>: path.resolve(__dirname, <span class="string">'../src/utils'</span>),</span><br><span class="line">  <span class="string">'@views'</span>: path.resolve(__dirname, <span class="string">'../src/views'</span>),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">// tsconfig.json</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"baseUrl"</span>: <span class="string">"."</span>, <span class="comment">// 解析非相对模块名的基准目录</span></span><br><span class="line">  <span class="attr">"paths"</span>: &#123; <span class="comment">// 这个属性就是用来填写编译时对应的 alias 用的</span></span><br><span class="line">     <span class="attr">"@/*"</span>: [<span class="string">"./src/*"</span>],</span><br><span class="line">     <span class="attr">"@api/*"</span>: [<span class="string">"./src/api/*"</span>],</span><br><span class="line">     <span class="attr">"@assets/*"</span>: [<span class="string">"./src/assets/*"</span>],</span><br><span class="line">     <span class="attr">"@components/*"</span>: [<span class="string">"./src/components/*"</span>],</span><br><span class="line">     <span class="attr">"@router/*"</span>: [<span class="string">"./src/router/*"</span>],</span><br><span class="line">     <span class="attr">"@styles/*"</span>: [<span class="string">"./src/styles/*"</span>],</span><br><span class="line">     <span class="attr">"@utils/*"</span>: [<span class="string">"./src/utils/*"</span>],</span><br><span class="line">     <span class="attr">"@views/*"</span>: [<span class="string">"./src/views/*"</span>],</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="引入-svg-报错"><a href="#引入-svg-报错" class="headerlink" title="引入 svg 报错"></a>引入 svg 报错</h3><p>虽然现在能够以 img 标签 src 方式引入 svg，如下</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react</span></span><br><span class="line"><span class="string">import logoPng from '</span>@assets/logo.png<span class="string">'</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">class Demo extends React.Component &#123;</span></span><br><span class="line"><span class="string">    return (</span></span><br><span class="line"><span class="string">      &lt;div&gt;</span></span><br><span class="line"><span class="string">        &lt;img src=&#123;logoPng&#125; alt="logo" /&gt;</span></span><br><span class="line"><span class="string">      &lt;/div&gt;</span></span><br><span class="line"><span class="string">    )</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>但是我们更希望能将 svg 当成一个组件的方式引入，如下</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react</span></span><br><span class="line"><span class="string">import Logo from '</span>../../assets/logo.svg<span class="string">'</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">class Demo extends React.Component &#123;</span></span><br><span class="line"><span class="string">    return (</span></span><br><span class="line"><span class="string">      &lt;div&gt;</span></span><br><span class="line"><span class="string">        &lt;Logo /&gt;</span></span><br><span class="line"><span class="string">      &lt;/div&gt;</span></span><br><span class="line"><span class="string">    )</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>最开始是参考 <a href="https://create-react-app.dev/docs/adding-images-fonts-and-files/" target="_blank" rel="noopener">Adding SVGs</a> 这篇文章，它的解决方案如下</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; ReactComponent <span class="keyword">as</span> Logo &#125; <span class="keyword">from</span> <span class="string">'./logo.svg'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &#123;<span class="comment">/* Logo is an actual React component */</span>&#125;</span><br><span class="line">      &lt;Logo /&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>试了下发现是不行的，然后继续搜集线索，发现有个 babel 的插件可以解决这个问题，即 <code>babel-plugin-inline-react-svg</code>，而这是需要在 <code>babel-loader</code> 的 <code>options.plugins</code> 进行配置，如下</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">oneOf: [</span><br><span class="line">  &#123;</span><br><span class="line">    test: <span class="regexp">/\.(js|mjs|jsx|ts|tsx)$/</span>,</span><br><span class="line">    ...</span><br><span class="line">    loader: <span class="built_in">require</span>.resolve(<span class="string">'babel-loader'</span>),</span><br><span class="line">    options: &#123;</span><br><span class="line">      ...</span><br><span class="line">      plugins: [</span><br><span class="line">        <span class="built_in">require</span>.resolve(<span class="string">'babel-plugin-inline-react-svg'</span>), <span class="comment">// 这里只是需要添加这个插件即可</span></span><br><span class="line">        [</span><br><span class="line">          <span class="built_in">require</span>.resolve(<span class="string">'babel-plugin-named-asset-import'</span>),</span><br><span class="line">          &#123;</span><br><span class="line">            loaderMap: &#123;</span><br><span class="line">              svg: &#123;</span><br><span class="line">                ReactComponent:</span><br><span class="line">                  <span class="string">'@svgr/webpack?-svgo,+titleProp,+ref![path]'</span></span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">     ],</span><br><span class="line">  &#125;,</span><br><span class="line">  ...</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>在说 <code>babel-plugin-inline-react-svg</code> 这个插件的原理之前，先说下 <code>babel-plugin-named-asset-import</code> 的原理，这个插件本质上会将如下的语句</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; url <span class="keyword">as</span> logoUrl &#125; <span class="keyword">from</span> <span class="string">'./logo.png'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; ReactComponent <span class="keyword">as</span> Icon &#125; <span class="keyword">from</span> <span class="string">'./icon.svg'</span>;</span><br></pre></td></tr></table></figure><p>转换成</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> logoUrl <span class="keyword">from</span> <span class="string">'url-loader!./logo.png'</span>;</span><br><span class="line"><span class="keyword">import</span> Icon <span class="keyword">from</span> <span class="string">'svgr/webpack?-svgo,+titleProp,+ref!./icon.svg'</span>;<span class="string">"</span></span><br></pre></td></tr></table></figure><p>但是由于这个插件对 svg 的处理，只能是通过 img 的 src 标签引入，所以才需要 <code>babel-plugin-inline-react-svg</code> 这个插件，能把 svg 自动封装成一个组件来使用，原理应该是 babel-loader 在对文件进行处理时，对源码做了一些修改导致的</p><h3 id="新的问题"><a href="#新的问题" class="headerlink" title="新的问题"></a>新的问题</h3><p>但是紧接着又带来了新的问题，<strong>在使用 alias 的方式引入 svg 时，会报错，即 svg 文件对应的路径找不到</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Logo <span class="keyword">from</span> <span class="string">'@assets/logo.svg'</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p><img src="./3.png" alt></p><p>出现这个问题的原因，可能在于 babel-loader 的 plugin 那里，之前我有提到过 <code>babel-plugin-named-asset-import</code> 这个插件的工作原理，有可能是 webpack 在处理 alias 之前，<strong>优先</strong>被这个插件做了处理了，即以上的代码会被转换成</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Logo <span class="keyword">from</span> <span class="string">'svgr/webpack?-svgo,+titleProp,+ref!@assets/logo.svg'</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>这个时候 svgr/webpack 这个 loader 自然就找不到路径为 <code>@assets/logo.svg</code> 的这个模块，于是编译就会报错了。</p><h2 id="所以更好的方式？"><a href="#所以更好的方式？" class="headerlink" title="所以更好的方式？"></a>所以更好的方式？</h2><p>由以上的方式，我们就懂得了一个道理，最 easy 的方式，有的时候往往也是最 hard 的。且不说上面的 svg 引入的问题没有得到完美的解决，要是以后项目逐渐的变得复杂了，需要对项目的基建做修改和升级呢？出了问题之后要怎么维护呢？连现在这个简单的问题的解决方案都如此麻烦的情况下，那万一以后出了更加匪夷所思的问题需要将项目基建整体重构呢? …etc</p><p>基于以上的风险考虑，从项目的可读性和可维护性着想的话，也许最好的方式，就是自己手撸一个 template 出来</p><h3 id="重构-config"><a href="#重构-config" class="headerlink" title="重构 config"></a>重构 config</h3><p>进行重构的操作之前，可以先将依赖包进行删除(包括 package.json 中的)，然后执行如下安装基础包</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安装 typesript</span></span><br><span class="line">yarn add -D typescript</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装 react 相关包</span></span><br><span class="line">yarn add react react-dom react-router-dom</span><br><span class="line">yarn add -D @types/react-router-dom @types/react-dom @types/react</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装 babel 相关包</span></span><br><span class="line">yarn add -D</span><br><span class="line">@babel/core <span class="comment"># babel 核心</span></span><br><span class="line">@babel/plugin-proposal-class-properties <span class="comment"># 支持 class xxx &#123; a = 'xxx' &#125; 这样在类中定义属性</span></span><br><span class="line">@babel/plugin-proposal-decorators <span class="comment"># 支持使用装饰器</span></span><br><span class="line">@babel/plugin-syntax-dynamic-import <span class="comment"># 支持异步加载(improt (xxx))</span></span><br><span class="line">@babel/preset-react  @babel/preset-typescript <span class="comment"># 支持将 react 以及 ts 编译成 js</span></span><br><span class="line">babel-loader</span><br><span class="line">babel-plugin-import <span class="comment"># 若是需要 antd 的包，可以安装这个进行按需加载</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装 html-webpack-plugin</span></span><br><span class="line">yarn add -D html-webpack-plugin</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装 sass 以及 style 配置相关包</span></span><br><span class="line">yarn add -D sass-loader node-sass style-loader css-loader css-modules-typescript-loader</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装 url-loader</span></span><br><span class="line">yarn add -D url-loader</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装 @svgr/webpack</span></span><br><span class="line">yarn add -D @svgr/webpack</span><br></pre></td></tr></table></figure><p>然后需要做的就是删除 config 文件夹下的各种 js 文件，然后新建几个文件</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># config</span></span><br><span class="line">├── devServerConfig.js <span class="comment"># webpack devServer 相关配置</span></span><br><span class="line">├── devServerProxyConfig.js <span class="comment"># webpack devServer proxy 相关配置</span></span><br><span class="line">├── pluginsConfig.js <span class="comment"># webpack plugins 相关配置</span></span><br><span class="line">├── resolveConfig.js <span class="comment"># webpack resolve 相关配置</span></span><br><span class="line">├── rules <span class="comment"># webpack rules 相关配置</span></span><br><span class="line">│   ├── assetsRules.js <span class="comment"># assets 资源文件相关 rules</span></span><br><span class="line">│   ├── fileRules.js <span class="comment"># file 文件相关 rules</span></span><br><span class="line">│   ├── jsRules.js <span class="comment"># js 相关 rules</span></span><br><span class="line">│   └── styleRules.js <span class="comment"># style 相关 rules</span></span><br><span class="line">├── utils.js <span class="comment"># 工具库 js，将一些可能用到公共的函数放到这个里面</span></span><br><span class="line">└── webpack.config.js <span class="comment"># webpack 配置</span></span><br></pre></td></tr></table></figure><p>从整体上看，<code>webpack.config.js</code> 的配置文件只有寥寥几行</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; resolve &#125; = <span class="built_in">require</span>(<span class="string">'./utils'</span>)</span><br><span class="line"><span class="keyword">const</span> jsRules = <span class="built_in">require</span>(<span class="string">'./rules/jsRules'</span>)</span><br><span class="line"><span class="keyword">const</span> styleRules = <span class="built_in">require</span>(<span class="string">'./rules/styleRules'</span>)</span><br><span class="line"><span class="keyword">const</span> fileRules = <span class="built_in">require</span>(<span class="string">'./rules/fileRules'</span>)</span><br><span class="line"><span class="keyword">const</span> assetsRules = <span class="built_in">require</span>(<span class="string">'./rules/assetsRules'</span>)</span><br><span class="line"><span class="keyword">const</span> pluginsConfig = <span class="built_in">require</span>(<span class="string">'./pluginsConfig'</span>)</span><br><span class="line"><span class="keyword">const</span> resolveConfig = <span class="built_in">require</span>(<span class="string">'./resolveConfig'</span>)</span><br><span class="line"><span class="keyword">const</span> devServerConfig = <span class="built_in">require</span>(<span class="string">'./devServerConfig'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@type <span class="type">&#123;import('webpack').Configuration&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    app: resolve(<span class="string">'src/index.tsx'</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: resolve(<span class="string">'dist'</span>),</span><br><span class="line">    filename: <span class="string">'[name].js'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  devServer: devServerConfig,</span><br><span class="line">  resolve: resolveConfig,</span><br><span class="line">  plugins: [...pluginsConfig],</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      ...jsRules,</span><br><span class="line">      ...styleRules,</span><br><span class="line">      ...fileRules,</span><br><span class="line">      ...assetsRules</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结构非常清晰了，相信大家应该都对这个配置挺熟悉了，所以下面就重点来详细说说这几个文件</p><h4 id="utils-js"><a href="#utils-js" class="headerlink" title="utils.js"></a>utils.js</h4><p>源码如下</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@title </span>utils.js</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description </span>这个文件是为了方便路径处理用的</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"></span><br><span class="line">exports.resolve = <span class="function"><span class="params">dir</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> path.join(__dirname, <span class="string">'./../'</span>, dir)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为这里是用 node 启动的，所以我们可以将其当成一个 commonjs 模块，<code>exports.resolve</code> 表示暴露出一个叫 <code>resolve</code> 的模块给外部，里面的逻辑就是将一个 dir 的名字拼凑成上级目录并返回。因为很多地方会用到，所以这里封装成一个模块比较好</p><h4 id="jsRules-js"><a href="#jsRules-js" class="headerlink" title="jsRules.js"></a>jsRules.js</h4><p>源码如下</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@title </span>jsRules.js</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description </span>定义 js 规则</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; resolve &#125; = <span class="built_in">require</span>(<span class="string">'../utils'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// 这里编写 babel 对 .tsx 文件编译的配置</span></span><br><span class="line">    test: <span class="regexp">/\.(j|t)sx?$/</span>, <span class="comment">// 正则匹配以 .jsx 或者 .tsx 结尾的文件</span></span><br><span class="line">    include: resolve(<span class="string">'src'</span>), <span class="comment">// 表示限定范围在 src 目录下</span></span><br><span class="line">    use: [</span><br><span class="line">      &#123;</span><br><span class="line">        loader: <span class="string">'babel-loader'</span>,</span><br><span class="line">        options: &#123;</span><br><span class="line">          babelrc: <span class="literal">false</span>, <span class="comment">// 这里不用 babelrc 文件</span></span><br><span class="line">          presets: [<span class="string">'@babel/preset-typescript'</span>, <span class="string">'@babel/preset-react'</span>],</span><br><span class="line">          plugins: [</span><br><span class="line">            [<span class="string">'@babel/plugin-proposal-decorators'</span>, &#123; <span class="attr">legacy</span>: <span class="literal">true</span> &#125;], <span class="comment">// 支持使用装饰器语法</span></span><br><span class="line">            [<span class="string">'@babel/plugin-proposal-class-properties'</span>, &#123; <span class="attr">loose</span>: <span class="literal">false</span> &#125;], <span class="comment">// 非宽松模式，类属性编译成赋值表达式，而不是 Object.defineProperty 这种形式</span></span><br><span class="line">            <span class="string">'@babel/plugin-syntax-dynamic-import'</span> <span class="comment">// 支持动态引入 import</span></span><br><span class="line">          ]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><a href="https://juejin.im/post/5c822e426fb9a04a0a5ffb49" target="_blank" rel="noopener">为什么不使用 ts-loader 以及 awesome-typescript-loader? 是因为 babel 的编译速度更快</a></p><h4 id="styleRules-js"><a href="#styleRules-js" class="headerlink" title="styleRules.js"></a>styleRules.js</h4><p>源码如下</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@title </span>styleRules.js</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description </span>定义 style 规则</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; resolve &#125; = <span class="built_in">require</span>(<span class="string">'../utils'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// 支持 scss/sass</span></span><br><span class="line">    test: <span class="regexp">/\.(scss|sass)$/</span>,</span><br><span class="line">    use: [</span><br><span class="line">      <span class="string">'style-loader'</span>,</span><br><span class="line">      <span class="string">'css-modules-typescript-loader'</span>, <span class="comment">// 在编写或改动了scss文件后，这个插件会自动生成 xxx.scss.d.ts 文件</span></span><br><span class="line">      &#123;</span><br><span class="line">        loader: <span class="string">'css-loader'</span>,</span><br><span class="line">        options: &#123;</span><br><span class="line">          modules: &#123; <span class="comment">// 支持 css-module</span></span><br><span class="line">            localIdentName: <span class="string">'[local]_[hash:base64:10]'</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        loader: <span class="string">'sass-loader'</span>,</span><br><span class="line">        options: &#123;</span><br><span class="line">          includePaths: [ <span class="comment">// 添加公共样式文件路径，这里 sass-loader 的版本为 7.3.1，请勿瞎升级！！！</span></span><br><span class="line">            resolve(<span class="string">'src/styles'</span>)</span><br><span class="line">          ]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123; <span class="comment">// 支持 less</span></span><br><span class="line">    test: <span class="regexp">/\.less$/</span>,</span><br><span class="line">    use: [</span><br><span class="line">      <span class="string">'style-loader'</span>,</span><br><span class="line">      <span class="string">'css-loader'</span>,</span><br><span class="line">      &#123;</span><br><span class="line">        loader: <span class="string">'less-loader'</span>,</span><br><span class="line">        options: &#123; <span class="comment">// 这里 javascriptEnabled 一定要为 true</span></span><br><span class="line">          javascriptEnabled: <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>这里需要注意的是，如果不做特殊的设置，webpack 的调用 loader 的顺序是从右往左的，即对于上面的支持 sass 的 loader 来说，它的执行顺序如下</p><ol><li>sass-loader: 将 sass|scss 文件编译成 css</li><li>css-loader: 将 css 转化为 commonjs 模块，比如 css 中有 <code>url(./xxx)</code> 的将其转化成 <code>require(./xxx)</code></li><li>css-modules-typescript-loader: 在编写或改动了scss文件后，这个插件会自动生成 xxx.scss.d.ts 文件</li><li>style-loader: 将经过 css-loader 转化成的 js 字符串转化成 style 的内容然后挂在 dom 上</li></ol><p>为什么需要 <code>css-modules-typescript-loader</code> 这个 loader 呢，因为对于 react 来说，我们一般通过这种方式使用一个 css 文件的类</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// index.tsx</span></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> style <span class="keyword">from</span> <span class="string">'./index.scss'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> App = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#123;style.xxx&#125;</span>&gt;</span>你好<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App</span><br></pre></td></tr></table></figure><p>这个时候不做设置，<code>index.tsx</code> 文件会报错说找不到这个 <code>index.scss</code> 模块。这是因为 ts 不认识这个 <code>index.scss</code> 文件，这个时候就需要加 <code>.d.ts</code> 写对应的类型文件才行(毕竟是 ts 的项目。。。)</p><p>可以自己在 <code>src/types</code> 目录下新建这个文件，然后写上</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">declare <span class="built_in">module</span> <span class="string">'*.scss'</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> content: any</span><br><span class="line">  <span class="keyword">export</span> = content</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个时候就可以了，当然我们可以想，不可能每个 scss 文件都这样做，能不能做的自动化一点，可以的，就使用 <code>css-modules-typescript-loader</code> 这个 loader 来帮我们做事情</p><p>那么这里做的 <code>css-module</code> 有什么好处呢？就是 react 中的 <strong>css 的模块化</strong>，<code>local</code> 表示 <strong>类名</strong>，<code>[hash:base64:10]</code> 表示这是一串由 base64 码生成的 hash，并且这个码的长度有 10 位。那么在浏览器上对应的 dom 上就会生成对应的类，这个对应的类下就有对应的 css 了，就形成来 css 的模块化，也就是自行隔离</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">xxx_1oiiefdai &#123;</span><br><span class="line">  background: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="fileRules-js"><a href="#fileRules-js" class="headerlink" title="fileRules.js"></a>fileRules.js</h4><p>源码如下</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@title </span>fileRules.js</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description </span>定义 file 输出文件的规则</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"><span class="keyword">const</span> imageInlineSizeLimit = <span class="built_in">parseInt</span>(</span><br><span class="line">  process.env.IMAGE_INLINE_SIZE_LIMIT || <span class="string">'10000'</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = [</span><br><span class="line">  &#123;</span><br><span class="line">    test: <span class="regexp">/\.(png|jpe?g|gif|bmp)(\?.*)?$/</span>,</span><br><span class="line">    use: [</span><br><span class="line">      &#123;</span><br><span class="line">        loader: <span class="string">'url-loader'</span>,</span><br><span class="line">        options: &#123;</span><br><span class="line">          limit: imageInlineSizeLimit,</span><br><span class="line">          <span class="comment">// 在任意操作系统上使用 POSIX 文件路径时获得一致的结果</span></span><br><span class="line">          name: path.posix.join(<span class="string">'static/media'</span>, <span class="string">'[name].[hash:8].[ext]'</span>)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>这里主要是对 png 等图片格式的处理，这里注意 <code>limit</code> 属性配置，这个属性配置是用来指定文件的最大的 byte 也就是字节数的，若文件的大小超过定义的字节数，那么 webpack 就会使用 file-loader 去处理文件，并且所有的查询参数都会传递给 file-loader。这里在使用 url-loader 时不需要安装 file-loader，因为它本身就依赖 file-loader。<code>name</code> 属性配置表示最终生成的目标资源文件的路径以及名字</p><h4 id="assetsRules-js"><a href="#assetsRules-js" class="headerlink" title="assetsRules.js"></a>assetsRules.js</h4><p>源码如下</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@title </span>assetsRules.js</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description </span>定义资源的规则</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// 支持本地 svg 导入</span></span><br><span class="line">    test: <span class="regexp">/\.svg$/</span>,</span><br><span class="line">    use: [<span class="string">'@svgr/webpack'</span>],</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>终于来了！只要单纯使用这个 loader，便可以解决上文中提到的本地以组件方式引入 svg 的问题！没有其他任何的幺蛾子！非常简单的配置!!!(这里当然也顺便解决了 alias 引入的问题)</p><h4 id="pluginsConfig-js"><a href="#pluginsConfig-js" class="headerlink" title="pluginsConfig.js"></a>pluginsConfig.js</h4><p>源码如下</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@title </span>plugins.js</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description </span>这个文件是为了存放 webpack 插件用的</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>)</span><br><span class="line"><span class="keyword">const</span> &#123; resolve &#125; = <span class="built_in">require</span>(<span class="string">'./utils'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = [</span><br><span class="line">  <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">    template: resolve(<span class="string">'public/index.html'</span>),</span><br><span class="line">    inject: <span class="literal">true</span> <span class="comment">// script 注入到 template 的 body 下</span></span><br><span class="line">  &#125;)</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><code>html-webpack-plugin</code> 一个耳熟能详的插件了，本质上的作用就是将生成的 js 生成 script 标签并且注入到模板页面的 body 中</p><p>当然在这个文件中统一做插件的处理，这样就能够方便的管理配置</p><h4 id="resolveConfig-js"><a href="#resolveConfig-js" class="headerlink" title="resolveConfig.js"></a>resolveConfig.js</h4><p>源码如下</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@title </span>aliases.js</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description </span>webpack 中需要配置的 alias</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> &#123; resolve &#125; = <span class="built_in">require</span>(<span class="string">'./utils'</span>)</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  extensions: [<span class="string">'.js'</span>, <span class="string">'.jsx'</span>, <span class="string">'.ts'</span>, <span class="string">'.tsx'</span>], <span class="comment">// 定义了文件的下标之后，以后 import js 模块的时候可以不用加后缀</span></span><br><span class="line">  alias: &#123; <span class="comment">// 定义 alias</span></span><br><span class="line">    <span class="string">'@'</span>: resolve(<span class="string">'src'</span>),</span><br><span class="line">    <span class="string">'@api'</span>: resolve(<span class="string">'src/api'</span>),</span><br><span class="line">    <span class="string">'@assets'</span>: resolve(<span class="string">'src/assets'</span>),</span><br><span class="line">    <span class="string">'@components'</span>: resolve(<span class="string">'src/components'</span>),</span><br><span class="line">    <span class="string">'@router'</span>: resolve(<span class="string">'src/router'</span>),</span><br><span class="line">    <span class="string">'@styles'</span>: resolve(<span class="string">'src/styles'</span>),</span><br><span class="line">    <span class="string">'@utils'</span>: resolve(<span class="string">'src/utils'</span>),</span><br><span class="line">    <span class="string">'@views'</span>: resolve(<span class="string">'src/views'</span>),</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个文件的配置也很简单，基本就是配置了下 <code>extensions</code> 以及 <code>alias</code> 属性，都是为了方便写代码做的配置。不过这里需要注意的是，对于 <code>extensions</code> 配置，如果引入的是同名的文件，比如在某个文件夹下有两个文件 <code>xxx.js</code>、<code>xxx.jsx</code>，你这边做引入了 <code>import xxx from &#39;xxx&#39;</code>，那么这个时候 webpack 就会采用你 <code>extensions</code> 中配置的第一个后缀名，剩下的不要，也就是说你最终引入的就是 <code>xxx.js</code></p><h4 id="devServerConfig-js"><a href="#devServerConfig-js" class="headerlink" title="devServerConfig.js"></a>devServerConfig.js</h4><p>源码如下</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@title </span>devServerConfig.js</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description </span>devServer 配置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="built_in">require</span>(<span class="string">'./devServerProxyConfig'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> host = process.env.HOST || <span class="string">'0.0.0.0'</span></span><br><span class="line"><span class="keyword">const</span> port = process.env.PORT || <span class="number">3000</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  compress: <span class="literal">true</span>, <span class="comment">// 为所有 served 的文件启用 gzip 压缩</span></span><br><span class="line">  clientLogLevel: <span class="string">'debug'</span>, <span class="comment">// 设置 log 等级，可设置为 'silent' | 'trace' | 'debug' | 'info' | 'warn' | 'error' | 'none' | 'warning'</span></span><br><span class="line">  hot: <span class="literal">true</span>, <span class="comment">// 开启热重载</span></span><br><span class="line">  host,</span><br><span class="line">  overlay: <span class="literal">false</span>, <span class="comment">// 出现编译器错误或警告时，在浏览器中显示全屏覆盖。 如果只想显示编译器错误就置为 true</span></span><br><span class="line">  port,</span><br><span class="line">  proxy,</span><br><span class="line">  quiet: <span class="literal">false</span>, <span class="comment">// 允许 errors 或者 warnings log</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释都写的很清楚了，其实都是些基本的配置</p><h4 id="devServerProxyConfig-js"><a href="#devServerProxyConfig-js" class="headerlink" title="devServerProxyConfig.js"></a>devServerProxyConfig.js</h4><p>源码如下</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@title </span>devServerProxyConfig.js</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description </span>devServer proxy 代理配置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="string">'/xhb_api'</span>: &#123;</span><br><span class="line">    target: <span class="string">'https://demo.xxx.cn'</span>,</span><br><span class="line">    changeOrigin: <span class="literal">true</span>, <span class="comment">// 默认情况下，代理时会保留主机头的来源，您可以将 changeOrigin 设置为 true 来覆盖此行为。</span></span><br><span class="line">    pathRewrite: &#123;</span><br><span class="line">      <span class="string">'^/xhb_api'</span>: <span class="string">'/api'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">'/api'</span>: &#123;</span><br><span class="line">    target: process.env.REACT_APP_API_DOMAIN,</span><br><span class="line">    changeOrigin: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代理配置，跟之前 <code>vue.config.js</code> 中的代理配置很像的，上面第一个代理配置表示 <strong>请求 /xhb_api/users/xxx 类似的接口时，请求本来会被代理到 <a href="https://demo.xxx.cn/xhb_api/user/xxx" target="_blank" rel="noopener">https://demo.xxx.cn/xhb_api/user/xxx</a> 这个上面来，但是因为你写了 pathRewrite，中间的 /xhb_api 会被替换成 /api，也就是说最终的代理地址为 <a href="https://demo.xxx.cn/api/user/xxx" target="_blank" rel="noopener">https://demo.xxx.cn/api/user/xxx</a></strong></p><h3 id="微小的总结"><a href="#微小的总结" class="headerlink" title="微小的总结"></a>微小的总结</h3><p>至此为止，一个基本的基于 react 以及 typescript 的项目就搭建完成了，后续的部分就是对模板进行些许优化的步骤了。不过总体来看，比之前使用 cra eject 的配置清爽了不少，并且由于配置的模块化(而不是函数嵌套似的模块化)，也使得项目本身易于阅读和拓展</p><h3 id="优化配置"><a href="#优化配置" class="headerlink" title="优化配置"></a>优化配置</h3><h4 id="构建加速与构建缓存"><a href="#构建加速与构建缓存" class="headerlink" title="构建加速与构建缓存"></a>构建加速与构建缓存</h4><p>首先需要安装两个 loader</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yarn add -D cache-loader thread-loader</span><br></pre></td></tr></table></figure><p>一般使用 <code>cache-loader</code> 构建缓存，用 <code>thread-loader</code> 构建加速。首先创建 <code>config/loaders.js</code> 文件。然后源码如下所示</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"> * @description 这个文件是为了设置构建缓存和构建加速用的</span><br><span class="line"> *<span class="regexp">/</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">const &#123; resolve &#125; = require('./u</span>tils<span class="string">')</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">// 构建缓存</span></span><br><span class="line"><span class="string">const cacheLoader = &#123;</span></span><br><span class="line"><span class="string">  loader: '</span>cache-loader<span class="string">',</span></span><br><span class="line"><span class="string">  options: &#123;</span></span><br><span class="line"><span class="string">    // 缓存文件路径</span></span><br><span class="line"><span class="string">    cacheDirectory: resolve('</span>.cache-loader<span class="string">')</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">// 构建加速，多线程编译</span></span><br><span class="line"><span class="string">const threadLoader = workerParallelJobs =&gt; &#123;</span></span><br><span class="line"><span class="string">  const options = &#123; workerParallelJobs &#125;</span></span><br><span class="line"><span class="string">  Object.assign(options, &#123;</span></span><br><span class="line"><span class="string">    poolTimeout: 2000</span></span><br><span class="line"><span class="string">  &#125;)</span></span><br><span class="line"><span class="string">  return &#123;</span></span><br><span class="line"><span class="string">    loader: '</span>thread-loader<span class="string">',</span></span><br><span class="line"><span class="string">    options</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">module.exports = &#123;</span></span><br><span class="line"><span class="string">  cacheLoader,</span></span><br><span class="line"><span class="string">  threadLoader</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>构建缓存的原理就是在本地有一个 .cache-loader 的文件夹，所有的需要缓存的玩意儿都放在这个里面，这样每次构建的时候若变化不大就直接取缓存里面的东西输出，可以加快构建的速度。而构建加速就是开启多线程编译。</p><p>因为平常在编译时，需要编译的主要是 js 以及 css 文件，所以应当在 <code>jsRules</code> 以及 <code>styleRules</code> 里引入</p><p><img src="./4.png" alt><br><img src="./5.png" alt></p><p>这里 <code>less-loader</code> 就没有用到 <code>thread-loader</code> 了，因为会报错</p><h4 id="优化打包和抽离-css"><a href="#优化打包和抽离-css" class="headerlink" title="优化打包和抽离 css"></a>优化打包和抽离 css</h4><p>优化打包方面主要用到了两个插件</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yarn add -D terser-webpack-plugin optimize-css-assets-webpack-plugin</span><br></pre></td></tr></table></figure><ul><li>terser-webpack-plugin 是用来优化 js 的压缩过程的，这里没有用到 <code>webpack.optimize.UglifyJsPlugin</code> 的原因是该插件不支持 es6 语法，为了方便就直接使用它了</li><li>optimize-css-assets-webpack-plugin 是用来优化 css 的压缩过程的</li></ul><p>再加上 webpack 本身有对代码分割的 <code>optimization</code> 配置，那么一个优化配置文件 <code>config/optimizationConfig.js</code> 的源码就是如下</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@title </span>optimizationConfig.js</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description </span>定义 webpack 优化配置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> TerserPlugin = <span class="built_in">require</span>(<span class="string">'terser-webpack-plugin'</span>)</span><br><span class="line"><span class="keyword">const</span> OptimizeCSSAssetsPlugin = <span class="built_in">require</span>(<span class="string">'optimize-css-assets-webpack-plugin'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// 将部分清单代码单独打包出来并命名为 manifest</span></span><br><span class="line">  runtimeChunk: &#123;</span><br><span class="line">    name: <span class="string">'manifest'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  splitChunks: &#123; <span class="comment">// 这是 webpack optimization 的优化配置，具体可以参考官网，本质上就是配置需要分离的包</span></span><br><span class="line">    cacheGroups: &#123;</span><br><span class="line">      <span class="keyword">default</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="comment">// 抽离 node_modules 下的公共代码</span></span><br><span class="line">      <span class="comment">// TODO 这里还可以继续抽离代码，待优化</span></span><br><span class="line">      commons: &#123;</span><br><span class="line">        test: <span class="regexp">/[\\/]node_modules[\\/]/</span>,</span><br><span class="line">        name: <span class="string">'commons'</span>,</span><br><span class="line">        chunks: <span class="string">'initial'</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">// 这里还可以为一些其他的包做单独打包的配置，比如</span></span><br><span class="line">      <span class="comment">// antd: &#123;</span></span><br><span class="line">      <span class="comment">//   name: 'antd',</span></span><br><span class="line">      <span class="comment">//   test: /[\\/]node_modules[\\/](antd)[\\/]/,</span></span><br><span class="line">      <span class="comment">//   chunks: 'all',</span></span><br><span class="line">      <span class="comment">//   priority: 9</span></span><br><span class="line">      <span class="comment">// &#125;,</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  minimizer: [</span><br><span class="line">    <span class="comment">// 优化 js 压缩过程</span></span><br><span class="line">    <span class="keyword">new</span> TerserPlugin(&#123;</span><br><span class="line">      <span class="comment">// 开启缓存</span></span><br><span class="line">      cache: <span class="literal">true</span>,</span><br><span class="line">      <span class="comment">// 开启多线程</span></span><br><span class="line">      parallel: <span class="literal">true</span>,</span><br><span class="line">      extractComments: <span class="literal">false</span></span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="comment">// 优化 css 压缩过程</span></span><br><span class="line">    <span class="keyword">new</span> OptimizeCSSAssetsPlugin(&#123;</span><br><span class="line">      <span class="comment">// 使用 cssnano 压缩，插件自带</span></span><br><span class="line">      cssProcessor: <span class="built_in">require</span>(<span class="string">'cssnano'</span>),</span><br><span class="line">      cssProcessorOptions: &#123;</span><br><span class="line">        safe: <span class="literal">true</span>,</span><br><span class="line">        autoprefixer: <span class="literal">false</span>,</span><br><span class="line">        discardComments: &#123;</span><br><span class="line">          removeAll: <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">// 将压缩过程输出到控制台</span></span><br><span class="line">      canPrint: <span class="literal">true</span></span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>css 文件若是都堆积在一坨也会变的很大，所以需要 <code>mini-css-extract-plugin</code> 来对 css 进行抽离</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">yarn add -D mini-css-extract-plugin</span><br></pre></td></tr></table></figure><p>在 <code>config/pluginsConfig.js</code> 中加上这个插件配置</p><p><img src="./6.png" alt></p><p>然后在 <code>styleRules.js</code> 中加上这个 MiniCssExtractPluginLoader（是的，本身这个插件是包含一个 loader 和一个 plugin 的）</p><p><img src="./7.png" alt></p><p>这里为啥要对 <code>style-loader</code> 做一个替换呢，因为我们知道在 <code>style-loader</code> 是在页面上添加一个 style 节点的，而分离 css 的步骤应该发生在 <code>css-loader</code> 之后，所以需要做一个替换(也就是说 minicss extract 这个插件内部帮我们做了 style-loader 的事情)</p><p>这里需要注意几个 hash 值所表达的意思</p><ol><li>hash: hash 和整个项目的配置有关，只要项目中有代码改变，那么所有打包出来的 hash 值都会变，并且所有文件共用一个 hash 值</li><li>chunkhash: chunkhash 和 hash 不同点在于，它根据入口文件进行依赖文件解析，然后构建对应的 hash 值，也就是每个打包出来的文件 hash 值都是不一样的，每次修改代码时候，他会根据依赖关系自动修改相关模块的 hash 值，但是打包出来对应的 js 和 css 文件的 hash 会相同。</li><li>contenthash: 在打包代码的时候，一般会将 css 文件分离出来，然后我们通常会在组件中引入 css 文件，这时候如果使用的是 chunkhash，在只修改组件 js 代码的情况下因为对应的 css 文件的 hash 值相同，打包出来的 css 文件的 hash 值也会跟着变，这时候就可以使用 contenthash了，他会针对每个文件的内容来计算 hash 值</li></ol><h4 id="将-config-json-拷贝到-dist-目录"><a href="#将-config-json-拷贝到-dist-目录" class="headerlink" title="将 config.json 拷贝到 dist 目录"></a>将 config.json 拷贝到 dist 目录</h4><p>这个很简单，只需要装一个插件 <code>copy-webpack-plugin</code></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yarn add -D copy-webpack-plugin</span><br></pre></td></tr></table></figure><p>然后在 <code>config/pluginsConfig.js</code> 中配置这个插件</p><p><img src="./8.png" alt></p><h4 id="支持在代码中使用环境变量"><a href="#支持在代码中使用环境变量" class="headerlink" title="支持在代码中使用环境变量"></a>支持在代码中使用环境变量</h4><p>可以使用 <code>dotenv-webpack</code> 这个插件</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yarn add -D dotenv-webpack</span><br></pre></td></tr></table></figure><p>然后在 <code>config/pluginsConfig.js</code> 中引入这个插件</p><p><img src="./9.png" alt></p><p><code>path</code> 属性表示引入的是哪个文件</p><h4 id="支持-px-向-vw-的单位转换"><a href="#支持-px-向-vw-的单位转换" class="headerlink" title="支持 px 向 vw 的单位转换"></a>支持 px 向 vw 的单位转换</h4><p>这个配置是直接从 xp 的项目拷贝过来的，即 <code>postcss.config.js</code></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  plugins: &#123;</span><br><span class="line">    autoprefixer: &#123;&#125;,</span><br><span class="line">    <span class="string">'postcss-px-to-viewport'</span>: &#123;</span><br><span class="line">      viewportWidth: <span class="string">'375'</span>, <span class="comment">// 视窗的宽度，对应的是我们设计稿的宽度，一般是750</span></span><br><span class="line">      unitPrecision: <span class="number">3</span>, <span class="comment">// 指定`px`转换为视窗单位值的小数位数（很多时候无法整除）</span></span><br><span class="line">      viewportUnit: <span class="string">'vw'</span>, <span class="comment">// 指定需要转换成的视窗单位，建议使用vw</span></span><br><span class="line">      <span class="comment">// propList: ['*', '!background-image'],</span></span><br><span class="line">      selectorBlackList: [</span><br><span class="line">        <span class="comment">// 指定不转换为视窗单位的类，可以自定义，可以无限添加,建议定义一至两个通用的类名</span></span><br><span class="line">        <span class="string">'ignore'</span>,</span><br><span class="line">      ],</span><br><span class="line">      minPixelValue: <span class="number">1</span>, <span class="comment">// 小于或等于`1px`不转换为视窗单位</span></span><br><span class="line">      mediaQuery: <span class="literal">false</span>, <span class="comment">// 允许在媒体查询中转换`px`</span></span><br><span class="line">      <span class="comment">// exclude: /(\/|\\)(node_modules)(\/|\\)/</span></span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这里需要安装两个东西</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yarn add -D postcss-loader postcss-px-to-viewport</span><br></pre></td></tr></table></figure><p>因为是对 css 做一个预处理，所以应该是在 sass-loader 转换为 css 之后应该执行这个 loader，所以直接在 sass-loader 后添加这个 loader 即可</p><p><img src="./10.png" alt></p><h4 id="提交自动检查-commit"><a href="#提交自动检查-commit" class="headerlink" title="提交自动检查 commit"></a>提交自动检查 commit</h4><p>在 <code>pre-commit</code> 之前要能够自动检查代码以及 commit，首先需要安装 husky</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yarn add -D husky</span><br></pre></td></tr></table></figure><p>然后在 <code>package.json</code> 中做配置</p><p><img src="./11.png" alt></p><p>要规范 commit 提交，就必须安装如下的库</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yarn add -D @commitlint/cli @commitlint/config-conventional</span><br></pre></td></tr></table></figure><p>然后新建一个 <code>commitlint.config.js</code>，自定义 commit 提交规则</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// commitlint.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  extends: [<span class="string">'@commitlint/config-conventional'</span>],</span><br><span class="line">  rules: &#123;</span><br><span class="line">    <span class="string">'type-enum'</span>: [</span><br><span class="line">      <span class="number">2</span>,</span><br><span class="line">      <span class="string">'always'</span>,</span><br><span class="line">      [</span><br><span class="line">        <span class="string">'chore'</span>,</span><br><span class="line">        <span class="string">'feat'</span>,</span><br><span class="line">        <span class="string">'fix'</span>,</span><br><span class="line">        <span class="string">'test'</span>,</span><br><span class="line">        <span class="string">'perf'</span>,</span><br><span class="line">        <span class="string">'style'</span>,</span><br><span class="line">        <span class="string">'merge'</span>,</span><br><span class="line">        <span class="string">'config'</span>,</span><br><span class="line">        <span class="string">'improvement'</span>,</span><br><span class="line">      ],</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样每次提交时都会先检查代码，然后再检查提交，提交的规则可以<a href="https://github.com/conventional-changelog/commitlint" target="_blank" rel="noopener">参考</a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上基本就是搭建模板中踩过的坑以及一系列的搭建步骤了，总的来说，还是手撸一遍项目比较香，不仅比当初的 cra eject 项目简单，而且也更利于后续人员的优化和配置</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;注意：为了方便统一，本文中出现的安装包依赖的方式均使用 &lt;code&gt;yarn&lt;/code&gt; 来安装&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="web前端" scheme="https://strugglebak.github.io/categories/web%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="webpack" scheme="https://strugglebak.github.io/tags/webpack/"/>
    
      <category term="react" scheme="https://strugglebak.github.io/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>从Promise本质开始(三):TDD方式实现基于Promises/A+规范的复杂Promise</title>
    <link href="https://strugglebak.github.io/2020/05/28/%E4%BB%8EPromise%E6%9C%AC%E8%B4%A8%E5%BC%80%E5%A7%8B-%E4%B8%89-TDD%E6%96%B9%E5%BC%8F%E5%AE%9E%E7%8E%B0%E5%9F%BA%E4%BA%8EPromises-A-%E8%A7%84%E8%8C%83%E7%9A%84%E5%A4%8D%E6%9D%82Promise/"/>
    <id>https://strugglebak.github.io/2020/05/28/从Promise本质开始-三-TDD方式实现基于Promises-A-规范的复杂Promise/</id>
    <published>2020-05-28T00:20:30.000Z</published>
    <updated>2022-06-04T08:13:29.222Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>前情提要：之前<a href="https://strugglebak.github.io/2020/03/09/%E4%BB%8EPromise%E6%9C%AC%E8%B4%A8%E5%BC%80%E5%A7%8B-%E4%B8%80-%E5%AE%9E%E7%8E%B0Promise%E5%89%8D%E8%A8%80/">为手动实现 Promise 搭建了环境</a>，然后还<a href="https://strugglebak.github.io/2020/03/20/%E4%BB%8EPromise%E6%9C%AC%E8%B4%A8%E5%BC%80%E5%A7%8B-%E4%BA%8C-TDD%E6%96%B9%E5%BC%8F%E5%AE%9E%E7%8E%B0%E5%9F%BA%E4%BA%8EPromises-A-%E8%A7%84%E8%8C%83%E7%9A%84%E7%AE%80%E6%98%93Promise/">基于 Promises/A+ 规范实现了一个简单的 Promise</a>。这次本文就接着上面的补充，实现一个复杂的 Promise。</p></blockquote><a id="more"></a><p><a href="https://github.com/strugglebak/promise-complex" target="_blank" rel="noopener">项目链接</a></p><h2 id="2-2-7"><a href="#2-2-7" class="headerlink" title="2.2.7"></a>2.2.7</h2><blockquote><p>2.2.7 then must return a promise</p></blockquote><blockquote><p>2.2.7 promise2 = promise1.then(onFulfilled, onRejected);</p></blockquote><p>这里就是 <code>Promise.then</code> 必须返回一个 Promise</p><h3 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">it(<span class="string">'2.2.7 then必须返回一个promise'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    resolve()</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">const</span> promise2 = promise.then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;)</span><br><span class="line">  <span class="comment">// 断言 promise2 是一个 Promise</span></span><br><span class="line">  assert(promise2 <span class="keyword">instanceof</span> <span class="built_in">Promise</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PromiseComplex</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  then(succeed?, fail?) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 将函数 push 进 callbacks 中</span></span><br><span class="line">    <span class="keyword">this</span>.callbacks.push(handle)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> PromiseComplex(<span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> PromiseComplex</span><br></pre></td></tr></table></figure><p>这里需要做的操作就是 <code>then</code> 函数中需要返回一个 <code>Promise</code> 即可，注意这里的 <code>Promise</code> 是自己的写的 <code>PromiseComplex</code></p><h2 id="2-2-7-1"><a href="#2-2-7-1" class="headerlink" title="2.2.7.1"></a>2.2.7.1</h2><blockquote><p>2.2.7.1 If either <code>onFulfilled</code> or <code>onRejected</code> returns a value <code>x</code>, run the Promise Resolution Procedure <code>[[Resolve]](promise2, x)</code></p></blockquote><p>Promises/A+ 规范的 <strong>2.2.7.1</strong> 里面这句话什么意思？就是说，<strong>如果 <code>onFulfilled</code> 或者 <code>onRejected</code> 函数返回了一个 x 的值， 那么就运行 Promise 的 Resolution 步骤，即运行 <code>[[Resolve]](promise2, x)</code></strong></p><p>云里雾里的，其实这句话的意思就是，在 <code>promise</code> 内部执行 <code>resolve</code> 或者 <code>reject</code> 函数时，会调用一个成功或者失败的函数，这个函数会返回一个值叫 <code>x</code>，然后再把这个值 <code>x</code> 跟一个新的 <code>promise</code> 传给一个叫做 <code>Resolve</code> 的函数。这个叫做 <code>Resolve</code> 的函数干了什么事情呢，它会将这个值 <code>x</code> 变成 <code>then</code> 里面传的回调的参数。这么说可能不太直观，接着看下面的测试用例应该会明白一些。</p><h3 id="测试用例-1"><a href="#测试用例-1" class="headerlink" title="测试用例"></a>测试用例</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">it(<span class="string">`2.2.7.1 如果 then(success, fail) 中的 success 返回一个值 x,</span></span><br><span class="line"><span class="string">  运行 Promise Resolution Procedure [[Resolve]](promise2, x)`</span>, done =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    resolve()</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// 注意这里的返回值 x 为 '123'，在 then 的回调传的参数 result 中可以获取到</span></span><br><span class="line">  promise.then(<span class="function"><span class="params">()</span> =&gt;</span> <span class="string">'123'</span>).then(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">    assert.equal(result, <span class="string">'123'</span>)</span><br><span class="line">    done()</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">it(<span class="string">`2.2.7.1.2 x 是一个 promise 实例`</span>, done =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    resolve()</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">const</span> fn = sinon.fake()</span><br><span class="line">  promise</span><br><span class="line">    .then(<span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> resolve()))</span><br><span class="line">    .then(fn)</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    assert.isTrue(fn.called)</span><br><span class="line">    done()</span><br><span class="line">  &#125;, <span class="number">10</span>) <span class="comment">// 这里有个小 bug, 如果将延时时间改为 0 则不通过</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">it(<span class="string">`2.2.7.1.2 x 是一个 promise 实例, 测试第一个 then 的失败回调`</span>, done =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    resolve()</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">const</span> fn = sinon.fake()</span><br><span class="line">  promise</span><br><span class="line">    .then(<span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> reject()))</span><br><span class="line">    .then(<span class="literal">null</span>, fn)</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    assert.isTrue(fn.called)</span><br><span class="line">    done()</span><br><span class="line">  &#125;, <span class="number">0</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">it(<span class="string">`2.2.7.1.2 fail 的返回值是一个 promise 实例`</span>, done =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    reject()</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">const</span> fn = sinon.fake()</span><br><span class="line">  promise</span><br><span class="line">    .then(<span class="literal">null</span>, () =&gt; <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> resolve()))</span><br><span class="line">    .then(fn)</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 这里主要看 promise.then 里的 Promise</span></span><br><span class="line">    <span class="comment">// 如果是成功则调用 succeed 函数</span></span><br><span class="line">    <span class="comment">// 如果是失败则调用 fail 函数</span></span><br><span class="line">    assert(fn.called)</span><br><span class="line">    done()</span><br><span class="line">  &#125;, <span class="number">0</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">it(<span class="string">`2.2.7.1.2 fail 的返回值是一个 promise 实例, 且失败了`</span>, done =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    reject()</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">const</span> fn = sinon.fake()</span><br><span class="line">  promise</span><br><span class="line">    .then(<span class="literal">null</span>, () =&gt; <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> reject()))</span><br><span class="line">    .then(<span class="literal">null</span>, fn)</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    assert(fn.called)</span><br><span class="line">    done()</span><br><span class="line">  &#125;, <span class="number">0</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="源码-1"><a href="#源码-1" class="headerlink" title="源码"></a>源码</h3><p>那么测试用例有了，源码应该怎么考虑呢？答案很简单，跟着规范来写。首先我们这里因为是用类写的，所以我们可以使用 <code>Promise.Resovle(x)</code> 的方式来表达 <strong>2.2.7.1</strong> 规范中出现的调用方式。这里可以将 <code>Resolve</code> 这个函数的名字改动下，我们叫它 <code>resolveWith</code> 吧，然后在源码中定义 <code>resolveWith</code></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PromiseComplex</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  resolveWith(x) &#123;</span><br><span class="line">    <span class="comment">//TODO</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为定义调用 <code>resolveWith</code> 的方式是通过 <code>Promise.resolveWith</code> 的方式调用的，而这个 <code>Promise</code> 根据规范是一个 <code>promise2</code>，也就意味着这是一个新的 <code>Promise</code>，还记得之前源码中的 <code>then</code> 中的 <code>return new PromiseComplex(() =&gt; {})</code> 么，现在我们这么做</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PromiseComplex</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  then(succeed?, fail?) &#123;</span><br><span class="line">    <span class="keyword">const</span> handle = []</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> succeed === <span class="string">'function'</span>) &#123;</span><br><span class="line">      handle[<span class="number">0</span>] = succeed</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> fail === <span class="string">'function'</span>) &#123;</span><br><span class="line">      handle[<span class="number">1</span>] = fail</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将下一个 promise 放入 handle[2] 中</span></span><br><span class="line">    handle[<span class="number">2</span>] = <span class="keyword">new</span> PromiseComplex(<span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;)</span><br><span class="line">    <span class="comment">// 将函数 push 进 callbacks 中</span></span><br><span class="line">    <span class="keyword">this</span>.callbacks.push(handle)</span><br><span class="line">    <span class="keyword">return</span> handle[<span class="number">2</span>]</span><br><span class="line">  &#125;</span><br><span class="line">  resolveWith(x) &#123;</span><br><span class="line">    <span class="comment">//TODO</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里将这个新的 <code>Promise</code> 存在 <code>handle</code> 这个数组的第三个元素中，然后再返回就好。接下来就需要对 <code>resolve</code> 以及 <code>reject</code> 中改写下逻辑了</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PromiseComplex</span> </span>&#123;</span><br><span class="line">  resolve(result) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 遍历 callbacks, 调用所有的 handle</span></span><br><span class="line">    <span class="keyword">this</span>.callbacks.forEach(<span class="function"><span class="params">handle</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> succeed = handle[<span class="number">0</span>]</span><br><span class="line">      <span class="comment">// 注意这里拿到了规范中定义的 promise2</span></span><br><span class="line">      <span class="keyword">const</span> nextPromise = handle[<span class="number">2</span>]</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> succeed === <span class="string">'function'</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> x = succeed.call(<span class="literal">undefined</span>, result)</span><br><span class="line">        <span class="comment">// 2.2.7.1 如果onFulfilled或onRejected返回一个值x,</span></span><br><span class="line">        <span class="comment">// 运行 Promise Resolution Procedure [[Resolve]](promise2, x)</span></span><br><span class="line">        <span class="comment">// promise2 表示第二个 promise</span></span><br><span class="line">        nextPromise.resolveWith(x)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  reject(reason) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 遍历 callbacks, 调用所有的 handle</span></span><br><span class="line">    <span class="keyword">this</span>.callbacks.forEach(<span class="function"><span class="params">handle</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> fail = handle[<span class="number">1</span>]</span><br><span class="line">      <span class="keyword">const</span> nextPromise = handle[<span class="number">2</span>]</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> fail === <span class="string">'function'</span>) &#123;</span><br><span class="line">        <span class="comment">// 这里 reject 的逻辑也是一样的</span></span><br><span class="line">        <span class="keyword">const</span> x = fail.call(<span class="literal">undefined</span>, reason)</span><br><span class="line">        nextPromise.resolveWith(x)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来就是 <strong>重头戏</strong> 了，因为要实现这一条规范，或者说通过上面的测试用例，还需要结合 <strong>规范 2.3.x</strong> 来看，因为 2.3.x 的规范是教你怎么写上面说到的 <code>resolveWith</code> 函数的</p><h3 id="resolveWith"><a href="#resolveWith" class="headerlink" title="resolveWith"></a>resolveWith</h3><p>为了实现 <code>resolveWith</code>,必须遵循以下步骤(规范)</p><h4 id="2-3-1"><a href="#2-3-1" class="headerlink" title="2.3.1"></a>2.3.1</h4><blockquote><p>If promise and x refer to the same object, reject promise with a TypeError as the reason</p></blockquote><p><strong>如果 promise 和值 x 引用的是同一个对象，则用 TypeError 作为 reason 拒绝（reject）promise</strong>，因为之前 <code>resolveWith</code> 函数是通过 <code>nextPromise.resolveWith(x)</code> 这种方式调用的，所以这里规范说的 <strong>promise</strong> 就是指这个代码中的 <code>nextPromise</code>，而在 <code>resolveWith</code> 函数中，<code>nextPromise</code> 就是 <code>this</code>。即为了实现 2.3.1 规范， <code>resolveWith</code> 函数应该这么写</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">resolveWith(x) &#123;</span><br><span class="line">  <span class="keyword">if</span> (x === <span class="keyword">this</span>) &#123;</span><br><span class="line">    <span class="comment">// 2.3.1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.reject(<span class="keyword">new</span> <span class="built_in">TypeError</span>())</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-3-2"><a href="#2-3-2" class="headerlink" title="2.3.2"></a>2.3.2</h4><p>如果 x 是一个 promise，采取它的状态</p><blockquote><p>2.3.2.1 If x is pending, promise must remain pending until x is fulfilled or rejected.<br>2.3.2.2 If/when x is fulfilled, fulfill promise with the same value.<br>2.3.2.3 If/when x is rejected, reject promise with the same reason.</p></blockquote><p>上面的规范，说白了就是，<strong>如果 x 是一个 promise，就采取 promise 的状态</strong>，所以就在 <code>resolveWith</code> 函数中加判断条件</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">resolveWith(x) &#123;</span><br><span class="line">  <span class="keyword">if</span> (x === <span class="keyword">this</span>) &#123;</span><br><span class="line">    <span class="comment">// 2.3.1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.reject(<span class="keyword">new</span> <span class="built_in">TypeError</span>())</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (x <span class="keyword">instanceof</span> PromiseComplex) &#123;</span><br><span class="line">    <span class="comment">// 2.3.2</span></span><br><span class="line">    x.then(</span><br><span class="line">      result =&gt; <span class="keyword">this</span>.resolve(result),</span><br><span class="line">      reason =&gt; <span class="keyword">this</span>.reject(reason)</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-3-3"><a href="#2-3-3" class="headerlink" title="2.3.3"></a>2.3.3</h4><p>否则，如果 x 是一个对象或者函数</p><blockquote><p>2.3.3.1 Let <code>then</code> be <code>x.then</code>.</p></blockquote><p>这句话的意思就是代码，即声明一个 <code>then</code> 变量，将 <code>x.then</code> 赋值给这个变量</p><blockquote><p>2.3.3.2 If retrieving the property <code>x.then</code> results in a thrown exception <code>e</code>, reject <code>promise</code> with <code>e</code> as the reason.</p></blockquote><p>如果 <code>x.then</code> 抛出一个异常，则使用 <code>e</code> 作为 reason 并 reject 这个 promise</p><blockquote><p>2.3.3.3 If <code>then</code> is a function, call it with <code>x</code> as <code>this</code>, first argument <code>resolvePromise</code>, and second argument <code>rejectPromise</code>, where:</p></blockquote><p>如果 <code>then</code> 是一个方法，把 <code>x</code> 当作 <code>this</code> 来调用它， 第一个参数为 <code>resolvePromise</code>，第二个参数为 <code>rejectPromise</code></p><blockquote><p>2.3.3.3.1 If/when <code>resolvePromise</code> is called with a value <code>y</code>, run <code>[[Resolve]](promise, y)</code>.</p></blockquote><p>如果 <code>resolvePromise</code> 调用时传了参数 <code>y</code>，则执行 <code>resolveWith(y)</code></p><blockquote><p>2.3.3.3.2 If/when <code>rejectPromise</code> is called with a reason <code>r</code>, reject <code>promise</code> with <code>r</code></p></blockquote><p>如果 <code>rejectPromise</code> 调用时传了参数 <code>r</code>，则执行 <code>resolveWith(r)</code>(这里也可以直接调用 <code>this.reject(r)</code> 函数，为了程序的统一性，这边改动成了 <code>resolveWith(r)</code>)</p><blockquote><p>2.3.3.3.3 If both <code>resolvePromise</code> and <code>rejectPromise</code> are called, or multiple calls to the same argument are made, the first call takes precedence, and any further calls are ignored</p></blockquote><p>如果 <code>resolvePromise</code> 和 <code>rejectPromise</code> 都被调用了，或者对同一个参数进行多次调用，则以第一次调用为优先级最高，其他未来的调用会被忽略掉。这里解释下这个情况，就是比方说如下的代码，可以说明 2.3.3.3.3 中所说的例子</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> PromiseComplex(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> resolve(&#123;</span><br><span class="line">  then: <span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">'123'</span>)</span><br><span class="line">    reject(<span class="string">'456'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;))</span><br><span class="line"></span><br><span class="line">promise.then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(res)) <span class="comment">// '123'</span></span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> PromiseComplex(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> resolve(&#123;</span><br><span class="line">  then: <span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">'123'</span>)</span><br><span class="line">    resolve(<span class="string">'456'</span>)</span><br><span class="line">    resolve(<span class="string">'789'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;))</span><br><span class="line"></span><br><span class="line">promise.then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(res)) <span class="comment">// '123'</span></span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> PromiseComplex(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  PromiseComplex.resolve(<span class="string">'123'</span>).then(<span class="function"><span class="params">result</span> =&gt;</span> resolve(result))</span><br><span class="line">  PromiseComplex.resolve(<span class="string">'456'</span>).then(<span class="function"><span class="params">result</span> =&gt;</span> resolve(result))</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">promise.then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(res)) <span class="comment">// '123'</span></span><br></pre></td></tr></table></figure><p>上面的代码，多次进行了 <code>resolve</code> 的操作，但是只取第一次的，所以最终打印出来的就是 <code>&#39;123&#39;</code>。由于该功能已经在<a href="https://strugglebak.github.io/2020/03/20/%E4%BB%8EPromise%E6%9C%AC%E8%B4%A8%E5%BC%80%E5%A7%8B-%E4%BA%8C-TDD%E6%96%B9%E5%BC%8F%E5%AE%9E%E7%8E%B0%E5%9F%BA%E4%BA%8EPromises-A-%E8%A7%84%E8%8C%83%E7%9A%84%E7%AE%80%E6%98%93Promise/">上一篇</a>博客文章中解决，所以这里的规则可以自动忽略掉</p><blockquote><p>2.3.3.3.4 if calling <code>then</code> throws an exception <code>e</code><br>2.3.3.3.4.1 If <code>resolvePromise</code> or <code>rejectPromise</code> have been called, ignore it.<br>2.3.3.3.4.2 Otherwise, reject <code>promise</code> with <code>e</code> as the reason.</p></blockquote><p>如果调用 <code>then</code> 的时候抛出异常了</p><ul><li>如果 <code>resolvePromise</code> 和 <code>rejectPromise</code> 的都被调用了，就忽略它</li><li>否则，reject 掉这个 <code>promise</code></li></ul><blockquote><p>2.3.3.4 If <code>then</code> is not a function, fulfill <code>promise</code> with <code>x</code>.</p></blockquote><p>如果 <code>then</code> 不是一个函数，则 resolve 掉这个 <code>promise</code></p><p>根据以上的描述，<code>resolveWith</code> 中的代码可以增加为</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">resolveWith(x) &#123;</span><br><span class="line">  <span class="keyword">if</span> (x === <span class="keyword">this</span>) &#123;</span><br><span class="line">    <span class="comment">// 2.3.1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.reject(<span class="keyword">new</span> <span class="built_in">TypeError</span>())</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (x <span class="keyword">instanceof</span> PromiseComplex) &#123;</span><br><span class="line">    <span class="comment">// 2.3.2</span></span><br><span class="line">    x.then(</span><br><span class="line">      result =&gt; <span class="keyword">this</span>.resolve(result),</span><br><span class="line">      reason =&gt; <span class="keyword">this</span>.reject(reason)</span><br><span class="line">    )</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (x <span class="keyword">instanceof</span> <span class="built_in">Object</span>) &#123;</span><br><span class="line">    <span class="comment">// 2.3.3 另外，如果 x 是个对象或者方法</span></span><br><span class="line">    <span class="keyword">let</span> then</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 2.3.3.1</span></span><br><span class="line">      then = x.then</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      <span class="comment">// 2.3.3.2 如果取回的 x.then 属性的结果为一个异常 e,用 e 作为原因 reject promise</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.reject(e)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2.3.3.3 如果 then 是一个方法，把 x 当作 this 来调用它， 第一个参数为 resolvePromise，第二个参数为 rejectPromise</span></span><br><span class="line">    <span class="keyword">if</span> (then <span class="keyword">instanceof</span> <span class="built_in">Function</span>) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 2.3.3.3.1/2.3.3.3.2/2.3.3.3.3</span></span><br><span class="line">        then.call(x, y =&gt; <span class="keyword">this</span>.resolveWith(y), r =&gt; <span class="keyword">this</span>.resolveWith(r))</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="comment">// 2.3.3.3.4</span></span><br><span class="line">        <span class="keyword">this</span>.reject(e)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 2.3.3.4 如果 then 不是一个函数，用 x 完成 (fulfill) promise</span></span><br><span class="line">      <span class="keyword">this</span>.resolve(x)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-2-7-2"><a href="#2-2-7-2" class="headerlink" title="2.2.7.2"></a>2.2.7.2</h2><blockquote><p>2.2.7.2 If either <code>onFulfilled</code> or <code>onRejected</code> throws an exception <code>e</code>, <code>promise2</code> must be rejected with <code>e</code> as the reason.</p></blockquote><p>如果在调用 <code>resolve</code> 或者 <code>reject</code> 时抛出了异常，则 <code>nextPromise</code> 必须调用 <code>reject</code>，并将这个 <code>e</code> 作为参数传入</p><h3 id="测试用例-2"><a href="#测试用例-2" class="headerlink" title="测试用例"></a>测试用例</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">it(<span class="string">'2.2.7.2 如果 success 或 fail 抛出一个异常 e, promise2 必须被拒绝'</span>, done =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    resolve()</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">const</span> error = <span class="keyword">new</span> <span class="built_in">Error</span>()</span><br><span class="line">  <span class="keyword">const</span> fn = sinon.fake()</span><br><span class="line">  promise</span><br><span class="line">    .then(<span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="keyword">throw</span> error &#125;)</span><br><span class="line">    .then(<span class="literal">null</span>, fn)</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    assert(fn.called)</span><br><span class="line">    assert(fn.calledWith(error))</span><br><span class="line">    done()</span><br><span class="line">  &#125;, <span class="number">0</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="源码-2"><a href="#源码-2" class="headerlink" title="源码"></a>源码</h3><p>由规范的定义可知，这里就需要在 <code>resolve</code> 以及 <code>reject</code> 函数中，在调用成功或者失败函数时，需要加个 <code>try catch</code>，因为在调用这些函数的时候，有可能会失败</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PromiseComplex</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  resolve(result) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> succeed === <span class="string">'function'</span>) &#123;</span><br><span class="line">      <span class="comment">// 这里调用的时候有可能报错</span></span><br><span class="line">      <span class="keyword">let</span> x</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        x = succeed.call(<span class="literal">undefined</span>, result)</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="comment">// 2.2.7.2 如果onFulfilled或onRejected抛出一个异常e</span></span><br><span class="line">        <span class="comment">// promise2 必须被拒绝（rejected）并把e当作原因</span></span><br><span class="line">        <span class="keyword">return</span> nextPromise.reject(e)</span><br><span class="line">      &#125;</span><br><span class="line">      nextPromise.resolveWith(x)</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">  &#125;,</span><br><span class="line">  reject(reason) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> fail === <span class="string">'function'</span>) &#123;</span><br><span class="line">      <span class="keyword">let</span> x</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        x = fail.call(<span class="literal">undefined</span>, reason)</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="keyword">return</span> nextPromise.reject(e)</span><br><span class="line">      &#125;</span><br><span class="line">      nextPromise.resolveWith(x)</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="API-实现"><a href="#API-实现" class="headerlink" title="API 实现"></a>API 实现</h2><p>以上，基本就是实现了一个复杂的符合 Promises/A+ 规范的 Promise 了，接下来就是实现该 Promise 的其他 API 的工作了</p><h3 id="resolve-reject"><a href="#resolve-reject" class="headerlink" title="resolve/reject"></a>resolve/reject</h3><p>真正的 Promise 中是能直接访问到这个方法的，而我们这里实现的 <code>PromiseComplex</code> 是一个类，如果要能访问到这个方法，则必须在方法上加上 <code>static</code> 属性</p><h4 id="测试用例-3"><a href="#测试用例-3" class="headerlink" title="测试用例"></a>测试用例</h4><p>这里另起一个 <code>describe</code>，专门用来测试该 <code>Promise</code> 的 API 用。之后的各种 API 相关的测试用例都在这个里面写</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">describe(<span class="string">'Promise API'</span>, () =&gt; &#123;</span><br><span class="line">  it(<span class="string">'测试 resolve'</span>, done =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> promise = <span class="built_in">Promise</span>.resolve2(<span class="number">123</span>)</span><br><span class="line">    assert(promise <span class="keyword">instanceof</span> <span class="built_in">Promise</span>)</span><br><span class="line">    promise.then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">      assert(result === <span class="number">123</span>)</span><br><span class="line">      done()</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">const</span> promise2 = <span class="built_in">Promise</span>.resolve2(<span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;))</span><br><span class="line">    assert(promise2 <span class="keyword">instanceof</span> <span class="built_in">Promise</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  it(<span class="string">'测试 resolve thenable'</span>, done =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> promise2 = <span class="built_in">Promise</span>.resolve2(&#123;</span><br><span class="line">      then(resolve, reject) &#123; resolve(<span class="string">'233'</span>) &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    assert(promise2 <span class="keyword">instanceof</span> <span class="built_in">Promise</span>)</span><br><span class="line">    promise2.then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">      assert(result === <span class="string">'233'</span>)</span><br><span class="line">      done()</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">  it(<span class="string">'测试 reject'</span>, done =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> promise = <span class="built_in">Promise</span>.reject2(<span class="number">123</span>)</span><br><span class="line">    assert(promise <span class="keyword">instanceof</span> <span class="built_in">Promise</span>)</span><br><span class="line">    promise.then(<span class="literal">null</span>, result =&gt; &#123;</span><br><span class="line">      assert(result === <span class="number">123</span>)</span><br><span class="line">      done()</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// reject thenable</span></span><br><span class="line">    <span class="keyword">const</span> promise2 = <span class="built_in">Promise</span>.reject2(&#123;</span><br><span class="line">      then(resolve, reject) &#123; reject(<span class="string">'233'</span>) &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    assert(promise2 <span class="keyword">instanceof</span> <span class="built_in">Promise</span>)</span><br><span class="line">    promise2.then(<span class="literal">null</span>, result =&gt; &#123;</span><br><span class="line">      assert(result === <span class="string">'233'</span>)</span><br><span class="line">      done()</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="源码-3"><a href="#源码-3" class="headerlink" title="源码"></a>源码</h4><blockquote><p>简便起见，这里直接使用 <code>resolve2</code> 和 <code>reject2</code> 来命名这两个方法</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PromiseComplex</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">static</span> resolve2(result) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> PromiseComplex(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (result &amp;&amp; result.then &amp;&amp; <span class="keyword">typeof</span> result.then === <span class="string">'function'</span>) &#123;</span><br><span class="line">        result.then(resolve, reject)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        resolve(result)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> reject2(reason) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> PromiseComplex(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      reject(reason)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，基本上就是调用了类里面的逻辑，new 一个 Promise，然后调用里面的 <code>resolve</code> 或者 <code>reject</code> 方法。但是对于 <code>resolve</code> 来说，如果 result 中有 then，并且这个 then 是一个函数，则需要继续调用这个 <code>result.then</code></p><h3 id="catch"><a href="#catch" class="headerlink" title="catch"></a>catch</h3><p>用来捕获 Promise reject 的错误用的，这里实现的逻辑也很简单</p><h4 id="测试用例-4"><a href="#测试用例-4" class="headerlink" title="测试用例"></a>测试用例</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">it(<span class="string">'测试 catch'</span>, done =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    resolve()</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">const</span> fn = sinon.fake()</span><br><span class="line">  promise</span><br><span class="line">    .then(<span class="function"><span class="params">result</span> =&gt;</span> &#123; <span class="keyword">throw</span> <span class="string">'233'</span> &#125;)</span><br><span class="line">    .catch(<span class="function">(<span class="params">e</span>) =&gt;</span> &#123; assert(e === <span class="string">'233'</span>) &#125;)</span><br><span class="line">    .then(fn)</span><br><span class="line"></span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    assert(fn.called)</span><br><span class="line">    done()</span><br><span class="line">  &#125;, <span class="number">0</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="源码-4"><a href="#源码-4" class="headerlink" title="源码"></a>源码</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PromiseComplex</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">catch</span>(reject) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.then(<span class="literal">null</span>, reject)</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意这里 <code>catch</code> 的参数 <code>reject</code> 是一个失败函数</p><h3 id="finally"><a href="#finally" class="headerlink" title="finally"></a>finally</h3><p>测试 <code>finally</code> 这个 API 的关键就是看 <code>finally</code> 中传的函数有没有得到执行，所以测试用例可以写成下面这样</p><h4 id="测试用例-5"><a href="#测试用例-5" class="headerlink" title="测试用例"></a>测试用例</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">it(<span class="string">'测试 finally'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    resolve()</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">const</span> callbacks = [sinon.fake(), sinon.fake(), sinon.fake()]</span><br><span class="line">  promise</span><br><span class="line">    .then(<span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="keyword">throw</span> <span class="string">'error'</span> &#125;)</span><br><span class="line">    .catch(callbacks[<span class="number">0</span>])</span><br><span class="line">    .finally(callbacks[<span class="number">1</span>])</span><br><span class="line">    .then(callbacks[<span class="number">2</span>])</span><br><span class="line"></span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    assert(callbacks[<span class="number">0</span>].called)</span><br><span class="line">    assert(callbacks[<span class="number">1</span>].called) <span class="comment">// 测试被调用</span></span><br><span class="line">    assert(callbacks[<span class="number">2</span>].called)</span><br><span class="line">    assert(callbacks[<span class="number">2</span>].calledAfter(callbacks[<span class="number">1</span>]))</span><br><span class="line">  &#125;, <span class="number">0</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="源码-5"><a href="#源码-5" class="headerlink" title="源码"></a>源码</h4><p>因为无论成功或者失败，都会走到 <code>finally</code> 中，所以 <code>finally</code> 都可以继续 <code>then</code></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PromiseComplex</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">finally</span>(callback) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.then(</span><br><span class="line">      (result) =&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> PromiseComplex.resolve2(callback()).then(<span class="function"><span class="params">()</span> =&gt;</span> result)</span><br><span class="line">      &#125;,</span><br><span class="line">      (error) =&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> PromiseComplex.resolve2(callback()).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;<span class="keyword">throw</span> error&#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有个疑问，为何 <code>finally</code> 不能做如下的实现</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">finally</span>(callback) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.then(</span><br><span class="line">    callback,</span><br><span class="line">    callback</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是因为假如我们想要再其调用失败函数的时候报错，比如需要做一个 <code>throw an error</code> 之类的操作，这个时候你只能通过 <code>Promise.resolve</code> 之类的方式去实现它。而为了能够跟失败函数被调用时代码逻辑一致，所以成功函数也写成跟失败函数类似的逻辑。</p><h3 id="all"><a href="#all" class="headerlink" title="all"></a>all</h3><p>all API 的逻辑看起来简单，就是遍历执行，但是内部是做了一些情况的判断的，不过测试用例还是很简单的，如下</p><h4 id="测试用例-6"><a href="#测试用例-6" class="headerlink" title="测试用例"></a>测试用例</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">it(<span class="string">'测试 all, 等待所有都完成(或第一个失败) '</span>, done =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> promise1 = <span class="built_in">Promise</span>.resolve2(<span class="number">3</span>)</span><br><span class="line">  <span class="keyword">const</span> promise2 = <span class="number">1337</span></span><br><span class="line">  <span class="keyword">const</span> promise3 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">'foo'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">let</span> ret</span><br><span class="line">  <span class="built_in">Promise</span>.all([promise1, promise2, promise3]).then(<span class="function"><span class="params">results</span> =&gt;</span> &#123;</span><br><span class="line">    ret = results</span><br><span class="line">  &#125;)</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    assert(ret[<span class="number">0</span>] === <span class="number">3</span>)</span><br><span class="line">    assert(ret[<span class="number">1</span>] === <span class="number">1337</span>)</span><br><span class="line">    assert(ret[<span class="number">2</span>] === <span class="string">'foo'</span>)</span><br><span class="line">    done()</span><br><span class="line">  &#125;, <span class="number">10</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="源码-6"><a href="#源码-6" class="headerlink" title="源码"></a>源码</h4><p>先说下实现 all API 需要注意的几个点</p><ul><li>如果传入的参数是一个空的可迭代对象，那么此 promise 对象回调完成(resolve), 只有此情况是同步执行的，其它都是异步返回</li><li>promises 中所有的 promise 都“完成”时，或参数中(result)不包含 promise 时回调完成。</li><li>如果传入的参数(promises[i])不包含任何 promise，则返回一个异步完成</li><li>如果参数中有一个 promise 失败，那么 Promise.all 返回的 promise 对象失败</li><li>在任何情况下，Promise.all 返回的 promise 的完成状态的结果都是一个数组</li></ul><p>所以实现的逻辑如下</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PromiseComplex</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">static</span> all(promises) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> PromiseComplex(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> index = <span class="number">0</span></span><br><span class="line">      <span class="comment">// 5. 在任何情况下，Promise.all 返回的 promise 的完成状态的结果都是一个数组</span></span><br><span class="line">      <span class="keyword">let</span> resultArray = []</span><br><span class="line">      <span class="comment">// 1. 如果传入的参数是一个空的可迭代对象，</span></span><br><span class="line">      <span class="comment">// 那么此promise对象回调完成(resolve),</span></span><br><span class="line">      <span class="comment">// 只有此情况，是同步执行的，其它都是异步返回</span></span><br><span class="line">      <span class="keyword">if</span> (promises &amp;&amp; promises.length === <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> resolve(resultArray)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">const</span> processResult = <span class="function">(<span class="params">result, i</span>) =&gt;</span> &#123;</span><br><span class="line">        resultArray[i] = result</span><br><span class="line">        <span class="comment">// 2. promises 中所有的promise都“完成”时</span></span><br><span class="line">        <span class="comment">// 或参数中(result)不包含 promise 时回调完成。</span></span><br><span class="line">        <span class="keyword">if</span> (++index === promises.length) resolve(resultArray)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; promises.length; i++) &#123;</span><br><span class="line">        <span class="comment">// 3. 如果传入的参数(promises[i])不包含任何 promise，则返回一个异步完成</span></span><br><span class="line">        PromiseComplex.resolve2(promises[i])</span><br><span class="line">          .then(</span><br><span class="line">            result =&gt; processResult(result, i),</span><br><span class="line">            <span class="comment">// 4. 如果参数中有一个promise失败，那么Promise.all返回的promise对象失败</span></span><br><span class="line">            reason =&gt; reject(reason)</span><br><span class="line">          )</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="allSettled"><a href="#allSettled" class="headerlink" title="allSettled"></a>allSettled</h3><p>allSettled API 在 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/allSettled" target="_blank" rel="noopener">MDN</a> 的解释如下</p><blockquote><p>The <code>Promise.allSettled()</code> method returns a promise that resolves after all of the given promises have either fulfilled or rejected, with an array of objects that each describes the outcome of each promise.</p></blockquote><p>即</p><blockquote><p><code>Promise.allSettled</code> 方法会返回一个 promise，then 中传的函数的参数就是一个对象数组，这个对象数组描述了每个 promise 的输出情况，这个 promise 能够 resolve 所有给到的 promises，无论这些 promises 是被 fulfilled 了还是被 rejected</p></blockquote><p>比如如下的代码</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise1 = <span class="built_in">Promise</span>.resolve(<span class="number">3</span>);</span><br><span class="line"><span class="keyword">const</span> promise2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> setTimeout(reject, <span class="number">100</span>, <span class="string">'foo'</span>));</span><br><span class="line"><span class="keyword">const</span> promises = [promise1, promise2];</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.allSettled(promises).</span><br><span class="line">  then(<span class="function">(<span class="params">results</span>) =&gt;</span> results.forEach(<span class="function">(<span class="params">result</span>) =&gt;</span> <span class="built_in">console</span>.log(result)));</span><br></pre></td></tr></table></figure><p>输出就是如下</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; Object &#123; status: <span class="string">"fulfilled"</span>, value: 3 &#125;</span><br><span class="line">&gt; Object &#123; status: <span class="string">"rejected"</span>, reason: <span class="string">"foo"</span> &#125;</span><br></pre></td></tr></table></figure><h4 id="测试用例-7"><a href="#测试用例-7" class="headerlink" title="测试用例"></a>测试用例</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">it(<span class="string">'测试 allSettled'</span>, done =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> promise1 = <span class="built_in">Promise</span>.resolve2(<span class="number">3</span>)</span><br><span class="line">  <span class="keyword">const</span> promise2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> reject(<span class="string">'foo'</span>))</span><br><span class="line">  <span class="keyword">const</span> promises = [promise1, promise2]</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> ret</span><br><span class="line">  <span class="built_in">Promise</span>.allSettled(promises).then(<span class="function"><span class="params">results</span> =&gt;</span> &#123;</span><br><span class="line">    ret = results</span><br><span class="line">  &#125;)</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    assert(ret[<span class="number">0</span>].state === <span class="string">'fulfilled'</span> &amp;&amp; ret[<span class="number">0</span>].result === <span class="number">3</span>)</span><br><span class="line">    assert(ret[<span class="number">1</span>].state === <span class="string">'rejected'</span> &amp;&amp; ret[<span class="number">1</span>].reason === <span class="string">'foo'</span>)</span><br><span class="line">    done()</span><br><span class="line">  &#125;, <span class="number">10</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="源码-7"><a href="#源码-7" class="headerlink" title="源码"></a>源码</h4><p>源码的逻辑就是在 <code>all</code> API 的基础上做修改，注意这里返回的状态</p><ul><li>如果成功，那么每个 promise 产出的结果应该是 <code>{ state: &#39;fulfilled&#39;, result: 123 }</code></li><li>如果失败，那么每个 promise 产出的结果应该是 <code>{ state: &#39;rejected&#39;, reason: 456 }</code></li></ul><p>所以应该这么写</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PromiseComplex</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">static</span> allSettled(promises) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> PromiseComplex(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> index = <span class="number">0</span></span><br><span class="line">      <span class="keyword">let</span> resultArray = []</span><br><span class="line">      <span class="keyword">if</span> (promises &amp;&amp; promises.length === <span class="number">0</span>) <span class="keyword">return</span> resolve(resultArray)</span><br><span class="line">      <span class="comment">// 这里的逻辑需要对 state 做个判断</span></span><br><span class="line">      <span class="keyword">const</span> processResult = <span class="function">(<span class="params">result, i, state</span>) =&gt;</span> &#123;</span><br><span class="line">        resultArray[i] = status === <span class="string">'fulfilled'</span></span><br><span class="line">          ? &#123;status, result&#125;</span><br><span class="line">          : &#123;status, <span class="attr">reason</span>: result&#125;</span><br><span class="line">        <span class="keyword">if</span> (++index === promises.length) resolve(resultArray)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; promises.length; i++) &#123;</span><br><span class="line">        PromiseComplex.resolve2(promises[i])</span><br><span class="line">          .then(</span><br><span class="line">            result =&gt; processResult(result, i, <span class="string">'fulfilled'</span>),</span><br><span class="line">            <span class="comment">// 无论成功或者失败，都调用 resolve</span></span><br><span class="line">            reason =&gt; processResult(reason, i, <span class="string">'rejected'</span>)</span><br><span class="line">          )</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>但是这里其实还有一种更加优雅的写法，直接调用 <code>Promise.all</code> 的形式来实现</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> allSettled(promises) &#123;</span><br><span class="line">  <span class="keyword">const</span> x = <span class="function">(<span class="params">promises</span>) =&gt;</span> promises.map(</span><br><span class="line">    promise =&gt; promise.then(</span><br><span class="line">      value =&gt; (&#123;<span class="attr">status</span>: <span class="string">'fulfilled'</span>, value&#125;),</span><br><span class="line">      reason =&gt; (&#123;<span class="attr">status</span>: <span class="string">'rejected'</span>, reason&#125;)</span><br><span class="line">    )</span><br><span class="line">  )</span><br><span class="line">  <span class="keyword">return</span> PromiseComplex.all(x(promises))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里将 promises 做了一个 map，然后它返回的是一个数组 <code>x(promises)</code>，代码就变得更加精简和易读了。你可能会迷惑，这里为啥要用到一个 <code>promise.then</code> 对其做一个值的构建呢？因为我们这里，<code>then</code> 是会返回一个 promise 的，通过使用 <code>.then()</code> 这种方式来修改 promise 中的传值参数才是一种符合 promise 的方式。</p><h3 id="race"><a href="#race" class="headerlink" title="race"></a>race</h3><p>race 在 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/race" target="_blank" rel="noopener">MDN</a> 上的解释如下</p><blockquote><p>The <code>Promise.race()</code> method returns a promise that fulfills or rejects as soon as one of the promises in an iterable fulfills or rejects, with the value or reason from that promise.</p></blockquote><p>即</p><blockquote><p><code>Promise.race()</code> 方法返回一个 promise，一旦其中一个 promise 处于一个可迭代的 fulfills 或者 rejects 中时，那这个对应的 promise 就会 fulfill 一个 value 出来或者 reject 一个 reason 出来</p></blockquote><p>简单来说就是 <strong>竞争</strong>，哪个先执行 resolve 或者 reject，哪个就先导出对应的结果</p><h4 id="测试用例-8"><a href="#测试用例-8" class="headerlink" title="测试用例"></a>测试用例</h4><p>上面可能说的不是很清楚，先看下测试用例吧</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">it(<span class="string">'测试 race'</span>, done =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> promise1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(</span><br><span class="line">    (resolve, reject) =&gt; setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> resolve(<span class="number">200</span>), <span class="number">200</span>)</span><br><span class="line">  )</span><br><span class="line">  <span class="keyword">const</span> promise2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(</span><br><span class="line">    (resolve, reject) =&gt; setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> resolve(<span class="number">10</span>), <span class="number">10</span>)</span><br><span class="line">  )</span><br><span class="line">  <span class="keyword">const</span> promise3 = <span class="keyword">new</span> <span class="built_in">Promise</span>(</span><br><span class="line">    (resolve, reject) =&gt; setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> reject(<span class="number">100</span>), <span class="number">100</span>)</span><br><span class="line">  )</span><br><span class="line">  <span class="keyword">let</span> result, reason</span><br><span class="line">  <span class="built_in">Promise</span>.race([promise1, promise2, promise3])</span><br><span class="line">    .then(</span><br><span class="line">      data =&gt; result = data,</span><br><span class="line">      error =&gt; reason = error</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    assert(result === <span class="number">10</span>)</span><br><span class="line">    done()</span><br><span class="line">  &#125;, <span class="number">500</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>以上的测试用例，由于 promise2 持续的时间最短，那么按照道理来说，promise2 的结果就是最终的结果</p><h4 id="源码-8"><a href="#源码-8" class="headerlink" title="源码"></a>源码</h4><p>race API 源码实现思路也是通过遍历来实现，但是这里是通过调用 <code>Promise.resolve(xxx).then</code> 来实现的。只要其中有一个 <code>resolve</code> 或者 <code>reject</code> 了，那么就<strong>自动</strong>走 <code>then</code> 的逻辑，其他的就忽略掉。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> race(promises) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> PromiseComplex(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (promises &amp;&amp; promises.length === <span class="number">0</span>) <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; promises.length; i++) &#123;</span><br><span class="line">      PromiseComplex.resolve2(promises[i])</span><br><span class="line">      .then(</span><br><span class="line">        <span class="comment">// 谁(promises[i]) 先完成谁先 resolve</span></span><br><span class="line">        result =&gt; resolve(result),</span><br><span class="line">        reason =&gt; reject(reason)</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你可能会疑惑了，为啥这里可以自动走 <code>then</code> 的逻辑呢？这又牵扯到 <strong>微任务宏任务</strong> 的知识了。先说结论，<strong>在 eventLoop 中，一旦执行一个阶段里的一个宏任务(setTimeout, setInterval 和 setImmediate)就立刻执行微任务队列(Node 11 及以上或者浏览器环境中)</strong>，而我们代码中的 <code>resolve</code> 方法(不是 <code>resolve2</code> 方法) 是放在微任务队列中的(下文优化代码部分会说到)。所以它会先执行 <code>PromiseComplex.resolve2(promises[i])</code>(宏任务)，在下一个宏任务(<code>promise2</code> 中的 <code>resolve</code>)到来之前，执行微任务(<code>resolve</code> 中的代码逻辑)，发现状态没有变(<code>state === &#39;pending&#39;</code>)就往下执行，将状态改变，并且将 <code>nextTick</code> 中的代码入<strong>微任务队列</strong>。然后时间到，执行宏任务(<code>promise2</code> 中的 <code>resolve</code>)，然后执行<strong>微任务</strong>(<code>resolve</code> 中的代码逻辑)，发现状态变了(<code>state !== &#39;pending&#39;</code>)，后面的逻辑就不执行了。这个时候因为你已经将 <code>then</code> 中的 <code>callback</code> 当作参数传给了 <code>Promise</code> 内部的变量，所以就可以拿着这些 <code>callbacks</code> 去执行。这样看起来就是 <code>then</code> 中的逻辑被 <em>自动执行</em> 了</p><p>你可能又会疑惑了，为啥这里可以忽略掉其他的 <code>promise</code> 呢？还记得规范 2.3.3.3.3 中说的是啥么(手动滑稽)，以及结合规范 2.2.2 和 2.2.3 来看的话，关键的地方在于，<strong>这个 <code>promise</code> 内部的 <code>state</code> 改变了</strong>，一旦这个 <code>state</code> 被改变了，那么无论后面怎么 <code>resolve</code> 或者 <code>reject</code>，那么都会在判断 <code>state</code> 状态时被 return 掉</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">resolve (result) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.state !== <span class="string">'pending'</span>) <span class="keyword">return</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">reject (reason) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.state !== <span class="string">'pending'</span>) <span class="keyword">return</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="重构-resolve-reject-API"><a href="#重构-resolve-reject-API" class="headerlink" title="重构 resolve/reject API"></a>重构 resolve/reject API</h2><p>在之前的这两个 api 的逻辑中，关于异步的部分只是用了 <code>setTimeout</code> 来解决的，但是这里就会存在一个 bug，在测试用例中，要断言 assert 测试代码的结果，也需要用到 <code>setTimeout</code>，但是这里需要延时一小段时间，不然会和源码中的 <code>setTimeout</code> 有冲突(即如果测试用例中 <code>setTimeout</code> 传的时间是 0 ms，那么有可能这个会优先源码中的 <code>setTimeout</code> 执行)，这是一个 bug 隐患。那么解决方式是什么呢？很简单，将 <code>setTimeout</code> 修改成 <code>process.nextTick</code>(微任务，优先级更高) 即可</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">resolve(result) &#123;</span><br><span class="line">  process.nextTick(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">reject(reason) &#123;</span><br><span class="line">  process.nextTick(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这样又会带来新的问题，如果是浏览器环境就不支持 <code>process.nextTick</code>，所以这里就需要想办法做一个兼容的处理。怎么兼容呢，这里可以参考 <a href="https://juejin.im/post/5d519abce51d453b753a1a9d" target="_blank" rel="noopener">Vue 源码中关于 <code>nextTick</code> 是怎么处理的</a>。这里方便起见就直接上代码了</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 兼容 process.nextTick 和 setImmediate 方案</span></span><br><span class="line"><span class="comment">// 其实就是 vue 里面的 nextTick 方案</span></span><br><span class="line"><span class="comment">// 主要是用 mutationObserver 实现的，这个只要改动下 dom 去更新一个函数</span></span><br><span class="line"><span class="comment">// 而在这个函数里面去做操作即可，这个是比 setTimeout 要快的</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">nextTick</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 兼容处理</span></span><br><span class="line">  <span class="keyword">if</span> (process !== <span class="literal">undefined</span> &amp;&amp; <span class="keyword">typeof</span> process.nextTick === <span class="string">'function'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> process.nextTick(fn)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> counter = <span class="number">1</span></span><br><span class="line">  <span class="keyword">var</span> observer = <span class="keyword">new</span> MutationObserver(fn)</span><br><span class="line">  <span class="keyword">var</span> textNode = <span class="built_in">document</span>.createTextNode(<span class="built_in">String</span>(counter))</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 监听节点变化</span></span><br><span class="line">  observer.observe(textNode, &#123; <span class="attr">characterData</span>: <span class="literal">true</span> &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 修改节点</span></span><br><span class="line">  counter = (counter + <span class="number">1</span>) % <span class="number">2</span></span><br><span class="line">  textNode.data = <span class="built_in">String</span>(counter)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里是通过 <a href="https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver" target="_blank" rel="noopener">MutationObserver</a> 这个 API，通过创建一个 textNode 的节点，然后使用 <code>observer.observe</code> 去 <strong>监听这个节点的变化</strong>，节点一旦变化就会去执行传入的 <code>fn</code> 回调，这样就可以做一个兼容的处理了。</p><p>最后只需要将 <code>resolve/reject</code> API 中的 <code>process.nextTick</code> 改写成 <code>nextTick</code> 函数即可</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上就是实现一个复杂的 <code>Promise</code> 的完整步骤了，<a href="https://github.com/strugglebak/promise-complex" target="_blank" rel="noopener">仓库链接可以点击这里</a>，另外我还在这个项目中对部分代码进行了优化，但总体上的逻辑和本文都是一样的，若有看到源码不一样的同学还请不要惊讶</p><p>本质上来说，这里主要就规范中的 2.2.7 以及 2.3 的部分进行了比较细的描述，如果有问题欢迎各位大佬在项目中提 issue</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;前情提要：之前&lt;a href=&quot;https://strugglebak.github.io/2020/03/09/%E4%BB%8EPromise%E6%9C%AC%E8%B4%A8%E5%BC%80%E5%A7%8B-%E4%B8%80-%E5%AE%9E%E7%8E%B0Promise%E5%89%8D%E8%A8%80/&quot;&gt;为手动实现 Promise 搭建了环境&lt;/a&gt;，然后还&lt;a href=&quot;https://strugglebak.github.io/2020/03/20/%E4%BB%8EPromise%E6%9C%AC%E8%B4%A8%E5%BC%80%E5%A7%8B-%E4%BA%8C-TDD%E6%96%B9%E5%BC%8F%E5%AE%9E%E7%8E%B0%E5%9F%BA%E4%BA%8EPromises-A-%E8%A7%84%E8%8C%83%E7%9A%84%E7%AE%80%E6%98%93Promise/&quot;&gt;基于 Promises/A+ 规范实现了一个简单的 Promise&lt;/a&gt;。这次本文就接着上面的补充，实现一个复杂的 Promise。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="手写源码" scheme="https://strugglebak.github.io/categories/%E6%89%8B%E5%86%99%E6%BA%90%E7%A0%81/"/>
    
    
      <category term="Promise" scheme="https://strugglebak.github.io/tags/Promise/"/>
    
  </entry>
  
  <entry>
    <title>从Promise本质开始(二):TDD方式实现基于Promises/A+规范的简易Promise</title>
    <link href="https://strugglebak.github.io/2020/03/20/%E4%BB%8EPromise%E6%9C%AC%E8%B4%A8%E5%BC%80%E5%A7%8B-%E4%BA%8C-TDD%E6%96%B9%E5%BC%8F%E5%AE%9E%E7%8E%B0%E5%9F%BA%E4%BA%8EPromises-A-%E8%A7%84%E8%8C%83%E7%9A%84%E7%AE%80%E6%98%93Promise/"/>
    <id>https://strugglebak.github.io/2020/03/20/从Promise本质开始-二-TDD方式实现基于Promises-A-规范的简易Promise/</id>
    <published>2020-03-19T16:21:02.000Z</published>
    <updated>2022-06-04T08:13:29.234Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>之前我还讲过 <a href="https://strugglebak.github.io/2020/03/09/%E4%BB%8EPromise%E6%9C%AC%E8%B4%A8%E5%BC%80%E5%A7%8B-%E4%B8%80-%E5%AE%9E%E7%8E%B0Promise%E5%89%8D%E8%A8%80/">如何为实现 Promise 搭建 TDD 环境</a>，而本文的目的主要是探讨如何基于 TDD 这样的方式实现一个 Promise，并且描述了部分 Promises/A+ 规范，以此为基础实现的一个 Promise</p></blockquote><a id="more"></a><p><a href="https://github.com/strugglebak/promise-easy" target="_blank" rel="noopener">项目地址</a></p><h2 id="先实现一个最基础版本的-Promise"><a href="#先实现一个最基础版本的-Promise" class="headerlink" title="先实现一个最基础版本的 Promise"></a>先实现一个最基础版本的 Promise</h2><p>有了之前的准备，现在就可以进行 TDD(Test Driven Develop)测试驱动开发了，注意，以下的测试代码都写在测试文件 <code>test/index.ts</code> 中，并且文件大致的代码结构为如下所示</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; assert &#125; <span class="keyword">from</span> <span class="string">'chai'</span></span><br><span class="line"><span class="keyword">import</span> &#123; describe, it &#125; <span class="keyword">from</span> <span class="string">'mocha'</span></span><br><span class="line"><span class="keyword">import</span> <span class="built_in">Promise</span> <span class="keyword">from</span> <span class="string">'../src/promise'</span></span><br><span class="line"></span><br><span class="line">describe(<span class="string">'Promise'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="comment">// TODO</span></span><br><span class="line">  it(<span class="string">'TODO'</span>, () =&gt; &#123;</span><br><span class="line">    <span class="comment">// TODO</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>并且源码文件为 <code>src/promise.ts</code></p><h3 id="Promise-是一个类"><a href="#Promise-是一个类" class="headerlink" title="Promise 是一个类"></a>Promise 是一个类</h3><h4 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h4><p>测试用例是这样写</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">it(<span class="string">'是一个类'</span>, () =&gt; &#123;</span><br><span class="line">  assert.isFunction(<span class="built_in">Promise</span>)</span><br><span class="line">  assert.isObject(<span class="built_in">Promise</span>.prototype)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>即 <code>assert</code> 断言</p><ul><li>Promise 是一个 <code>function</code></li><li>Promise 的原型 <code>prototype</code> 是一个对象</li></ul><p>那么就可以证明 Promise 是一个类了</p><h4 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PromiseEasy</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="comment">// TODO</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很简单吧，其实就是用 <strong>测试的需求</strong> 来推动 <strong>开发</strong></p><h3 id="new-Promise-如果接受的不是函数就报错"><a href="#new-Promise-如果接受的不是函数就报错" class="headerlink" title="new Promise() 如果接受的不是函数就报错"></a>new Promise() 如果接受的不是函数就报错</h3><p>这里的逻辑是 Promise 需要接受一个函数作为参数，所以测试用例应该这么写</p><h4 id="测试用例-1"><a href="#测试用例-1" class="headerlink" title="测试用例"></a>测试用例</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">it(<span class="string">'new Promise() 如果接受的不是函数就报错'</span>, () =&gt; &#123;</span><br><span class="line">  assert.throw(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// @ts-ignore</span></span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>()</span><br><span class="line">  &#125;)</span><br><span class="line">  assert.throw(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// @ts-ignore</span></span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="number">1</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  assert.throw(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// @ts-ignore</span></span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="literal">true</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>这里 <code>// @ts-ignore</code> 的意思就是 <strong>注释会忽略下一行中产生的所有错误</strong>，但是因为这里要是不通过就很麻烦，所以还是加上</p></blockquote><blockquote><p><code>assert.throw</code> 这个 API 的意思就是断言一段会报错的代码</p></blockquote><h4 id="源码-1"><a href="#源码-1" class="headerlink" title="源码"></a>源码</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PromiseEasy</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(fn) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> fn !== <span class="string">'function'</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'这里只接受函数'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>逻辑也很简单，对传入的参数做一个判断即可</p><h3 id="new-Promise-fn-会生成一个对象，该对象会有个-then-方法"><a href="#new-Promise-fn-会生成一个对象，该对象会有个-then-方法" class="headerlink" title="new Promise(fn) 会生成一个对象，该对象会有个 then 方法"></a>new Promise(fn) 会生成一个对象，该对象会有个 then 方法</h3><p>嗯，该往 Promise 里面添加 <code>then</code> 方法了，不过之前还是得写测试用例</p><h4 id="测试用例-2"><a href="#测试用例-2" class="headerlink" title="测试用例"></a>测试用例</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">it(<span class="string">'new Promise(fn) 会生成一个对象，该对象会有个 then 方法'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">()</span>=&gt;</span>&#123;&#125;)</span><br><span class="line">  assert.isFunction(promise.then)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="源码-2"><a href="#源码-2" class="headerlink" title="源码"></a>源码</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PromiseEasy</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(fn) &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">  then() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="new-Promise-fn-中的函数立即执行"><a href="#new-Promise-fn-中的函数立即执行" class="headerlink" title="new Promise(fn) 中的函数立即执行"></a>new Promise(fn) 中的函数立即执行</h3><p>这个的测试代码就很简单了</p><h4 id="测试用例-3"><a href="#测试用例-3" class="headerlink" title="测试用例"></a>测试用例</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">it(<span class="string">'new Promise(fn) 中的函数立即执行'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> called = <span class="literal">false</span></span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    called = <span class="literal">true</span></span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// @ts-ignore</span></span><br><span class="line">  assert(called === <span class="literal">true</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>判断是否被调用就是判断 <code>called</code> 这个变量有没有变化</p><h4 id="源码-3"><a href="#源码-3" class="headerlink" title="源码"></a>源码</h4><p>那就很简单了，直接调用构造函数里面传入的 <code>fn</code> 即可</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PromiseEasy</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(fn) &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    fn()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Promise-then-success-中的-success-会在-resolve-被调用后执行"><a href="#Promise-then-success-中的-success-会在-resolve-被调用后执行" class="headerlink" title="Promise.then(success) 中的 success 会在 resolve 被调用后执行"></a>Promise.then(success) 中的 success 会在 resolve 被调用后执行</h3><p>所以这里的核心就是需要验证 <code>then</code> 之后里面 <code>resolve</code> 的函数有没有被执行过了</p><h4 id="测试用例-4"><a href="#测试用例-4" class="headerlink" title="测试用例"></a>测试用例</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">it(<span class="string">'promise.then(success) 中的 success 会在 resolve 被调用后执行'</span>, done =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> called = <span class="literal">false</span></span><br><span class="line">  <span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    assert(called === <span class="literal">false</span>)</span><br><span class="line">    resolve()</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      assert(called === <span class="literal">true</span>)</span><br><span class="line">      done()</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// @ts-ignore</span></span><br><span class="line">  promise.then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    called = <span class="literal">true</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>注意这里在 <code>Promise</code> 中使用了 <code>setTimeout</code>,这是因为</p><ul><li>这里只有等一会才能断言 <code>called = true</code></li><li>因为顺序是先 then -&gt; 调用 fn -&gt; 调用 succeed</li><li>而 succeed 是放入了 setTimeout 中的</li></ul><p>并且还使用了 <code>done</code>，这是因为</p><ul><li>如果代码里面需要异步的测试，则需要加 <code>done</code></li><li>表示异步测试的完成，告诉 mocha 可以检查其测试结果了</li><li>不然很多个任务都是异步测试的话，mocha 就不知道哪个是先完成的(这里 mocha 对于测试用例是一个一个同步执行的)</li></ul><h4 id="源码-4"><a href="#源码-4" class="headerlink" title="源码"></a>源码</h4><p>首先需要在 <code>Promise</code> 里面声明两个变量 <code>succeed</code> 和 <code>fail</code> 分别保存成功和失败回调</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PromiseEasy</span> </span>&#123;</span><br><span class="line">  succeed = <span class="literal">null</span> <span class="comment">// 保存成功回调</span></span><br><span class="line">  fail = <span class="literal">null</span> <span class="comment">// 保存失败回调</span></span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>then</code> 函数执行时保存回调</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PromiseEasy</span> </span>&#123;</span><br><span class="line">  succeed = <span class="literal">null</span> <span class="comment">// 保存成功回调</span></span><br><span class="line">  fail = <span class="literal">null</span> <span class="comment">// 保存失败回调</span></span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">  then(succeed, fail) &#123;</span><br><span class="line">    <span class="keyword">this</span>.succeed = succeed</span><br><span class="line">    <span class="keyword">this</span>.fail = fail</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么什么时候这个 <code>succeed</code> 函数被调用呢，就是 <code>resolve</code> 的时候。众所周知 Promise 不仅仅有 <code>resolve</code>，还有 <code>reject</code>，并且在 <code>new Promise</code> 中使用 <code>resolve</code> 时并不会立刻调用成功回调，而是在执行 <code>then</code> 之后才调用，所以 <code>resolve</code> 和 <code>reject</code> 函数是异步的，这里仅就用 <code>setTimeout</code> 做一个简单的处理</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PromiseEasy</span> </span>&#123;</span><br><span class="line">  succeed = <span class="literal">null</span> <span class="comment">// 保存成功回调</span></span><br><span class="line">  fail = <span class="literal">null</span> <span class="comment">// 保存失败回调</span></span><br><span class="line"></span><br><span class="line">  resolve() &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.succeed()</span><br><span class="line">    &#125;, <span class="number">0</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  reject() &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.fail()</span><br><span class="line">    &#125;, <span class="number">0</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">  then(succeed, fail) &#123;</span><br><span class="line">    <span class="keyword">this</span>.succeed = succeed</span><br><span class="line">    <span class="keyword">this</span>.fail = fail</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在构造函数中需要将 <code>resolve</code> 和 <code>reject</code> 传给 <code>fn</code> 当参数就可以了，当然这里需要 <code>bind</code> 下 <code>this</code>，不然 <code>resolve</code> 和 <code>reject</code> 函数中的 <code>this</code> 是访问不到的</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PromiseEasy</span> </span>&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="keyword">constructor</span>(fn) &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    fn(<span class="keyword">this</span>.resolve.bind(<span class="keyword">this</span>), <span class="keyword">this</span>.reject.bind(<span class="keyword">this</span>))</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Promise-then-null-fail-中的-fail-会在-reject-被调用后执行"><a href="#Promise-then-null-fail-中的-fail-会在-reject-被调用后执行" class="headerlink" title="Promise.then(null, fail) 中的 fail 会在 reject 被调用后执行"></a>Promise.then(null, fail) 中的 fail 会在 reject 被调用后执行</h3><p>这里的测试代码不用说了，和上面的基本差不多</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">it(<span class="string">'promise.then(null, fail) 中的 fail 会在 reject 被调用后执行'</span>, done =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> fail = sinon.fake()</span><br><span class="line">  <span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    assert.isFalse(fail.called)</span><br><span class="line">    reject()</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      assert.isTrue(fail.called)</span><br><span class="line">      done()</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// @ts-ignore</span></span><br><span class="line">  promise.then(<span class="literal">null</span>, fail)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>至此，一个基本的简单的 Promise 框架就算完成了，剩下就是按照 A+ 规范标准在上面添砖加瓦了</p><h2 id="遵循比较重要的-Promise-A-规范增加功能"><a href="#遵循比较重要的-Promise-A-规范增加功能" class="headerlink" title="遵循比较重要的 Promise/A+ 规范增加功能"></a>遵循比较重要的 Promise/A+ 规范增加功能</h2><h3 id="2-2-1-Both-onFulfilled-and-onRejected-are-optional-arguments"><a href="#2-2-1-Both-onFulfilled-and-onRejected-are-optional-arguments" class="headerlink" title="2.2.1 Both onFulfilled and onRejected are optional arguments"></a>2.2.1 Both onFulfilled and onRejected are optional arguments</h3><p><code>onFulfilled</code> 和 <code>onRejected</code> 都是可选的参数</p><h4 id="测试用例-5"><a href="#测试用例-5" class="headerlink" title="测试用例"></a>测试用例</h4><p>这里的测试用例很简单</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">it(<span class="string">'2.2.1 onFulfilled 和 onRejected 都是可选的参数'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resovle</span> =&gt;</span> &#123;</span><br><span class="line">    resovle()</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  promise.then(<span class="literal">false</span>, <span class="literal">null</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>参数可选什么意思，就是 <code>then</code> 传的俩参数都是可以传或者可以不传，所以这里的测试用例很简单</p><h4 id="源码-5"><a href="#源码-5" class="headerlink" title="源码"></a>源码</h4><p>所以这个时候就需要在 3 个地方对参数做判断了</p><ul><li><code>resolve</code> 函数</li><li><code>reject</code> 函数</li><li><code>then</code> 函数</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PromiseEasy</span> </span>&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  resolve() &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span>.succeed === <span class="string">'function'</span>) &#123; <span class="comment">// 添加判断</span></span><br><span class="line">        <span class="keyword">this</span>.succeed()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, <span class="number">0</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  reject() &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span>.fail === <span class="string">'function'</span>) &#123; <span class="comment">// 添加判断</span></span><br><span class="line">        <span class="keyword">this</span>.fail()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, <span class="number">0</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  then(succeed?, fail?) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> succeed === <span class="string">'function'</span>) &#123; <span class="comment">// 添加判断</span></span><br><span class="line">      <span class="keyword">this</span>.succeed = succeed</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> fail === <span class="string">'function'</span>) &#123; <span class="comment">// 添加判断</span></span><br><span class="line">      <span class="keyword">this</span>.fail = fail</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-2-If-onFulfilled-is-a-function"><a href="#2-2-2-If-onFulfilled-is-a-function" class="headerlink" title="2.2.2 If onFulfilled is a function"></a>2.2.2 If onFulfilled is a function</h3><p>2.2.2 这里有三点</p><ol><li>it must be called after promise is fulfilled, with promise’s value as its first argument</li><li>it must not be called before promise is fulfilled</li><li>it must not be called more than once</li></ol><p>总的来说，大意就是 <strong>此函数必须在 promise 完成(fulfilled) 后被调用,并把 promise 的 result 值作为它的第一个参数</strong></p><p>这里先在测试用例中将以上 3 点都测试一遍，但是为了方便起见就只用一个标题</p><h4 id="测试用例-6"><a href="#测试用例-6" class="headerlink" title="测试用例"></a>测试用例</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">it(<span class="string">'2.2.2.1 此函数必须在 promise 完成(fulfilled) 后被调用,并把 promise 的 result 值作为它的第一个参数'</span>, done =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> success = sinon.fake()</span><br><span class="line">  <span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    assert.isFalse(success.called) <span class="comment">// 测试第 2 点</span></span><br><span class="line">    resolve(<span class="string">'hi'</span>)</span><br><span class="line">    resolve(<span class="string">'hii'</span>) <span class="comment">// 调用两次</span></span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      assert(promise.state === <span class="string">'fulfilled'</span>) <span class="comment">// 测试第 1 点</span></span><br><span class="line">      assert.isTrue(success.calledOnce) <span class="comment">// 测试第 3 点</span></span><br><span class="line">      assert.isTrue(success.calledWith(<span class="string">'hi'</span>)) <span class="comment">// 测试第 1 点</span></span><br><span class="line">      done()</span><br><span class="line">    &#125;, <span class="number">0</span>)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  promise.then(success)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>这里使用了 <code>sinon.fake</code> 作为假函数，然后使用 <code>assert.isTrue/assert.isFalse</code> 判断 <code>sinon.fake.called</code> 是否为 <code>true</code>，为 <code>true</code> 说明其已经被调用了，使用 <code>sinon.fake.calledOnce</code> 判断其是否只被调用一次，使用 <code>sinon.fake.calledWith</code> 判断其是否在调用 <code>resolve</code> 时传了对应的参数</p></blockquote><p>所以要实现这一条规范，我们就需要在 Promise 内部维护一个 <code>state</code> 状态判断当前是否是处于 <code>初始状态</code>/<code>resolve</code>/<code>reject</code>，现在我们定义 <code>state</code> 有 3 种状态</p><ul><li><code>pending</code>: 表示初始状态</li><li><code>fulfilled</code>: 表示用户调用了 <code>resolve</code> 函数</li><li><code>rejected</code>: 表示用户调用了 <code>reject</code> 函数</li></ul><blockquote><p>这里还要说明的是，<code>state</code> 状态只能是单向的变化，即只能是 <code>pending</code> -&gt; <code>fulfilled</code> 或者 <code>pending</code> -&gt; <code>rejected</code>，而不能三者两两互相变化</p></blockquote><h4 id="源码-6"><a href="#源码-6" class="headerlink" title="源码"></a>源码</h4><p>所以源码应该是要对 <code>resolve</code> 以及 <code>reject</code> 做修改，并且还要增加一个 <code>state</code></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PromiseEasy</span> </span>&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  state = <span class="string">'pending'</span></span><br><span class="line">  resolve(result) &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.state !== <span class="string">'pending'</span>) <span class="keyword">return</span></span><br><span class="line">      <span class="keyword">this</span>.state = <span class="string">'fulfilled'</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span>.succeed === <span class="string">'function'</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.succeed(result)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, <span class="number">0</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  reject(reason) &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.state !== <span class="string">'pending'</span>) <span class="keyword">return</span></span><br><span class="line">      <span class="keyword">this</span>.state = <span class="string">'rejected'</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span>.fail === <span class="string">'function'</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.fail(reason)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, <span class="number">0</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在进入 <code>resolve</code>/ <code>reject</code> 之后，先判断其是否是在 <code>pending</code> 状态，否则就 <code>return</code>，即保证上述规范第3点，之后才将状态改变，并且对 <code>succeed</code>/<code>fail</code> 函数做判断，只有其是函数时才能被调用。其中还添加了 <code>resolve</code> 的参数 <code>result</code> 以及 <code>reject</code> 参数 <code>reason</code></p><h3 id="2-2-3-If-onRejected-is-a-function"><a href="#2-2-3-If-onRejected-is-a-function" class="headerlink" title="2.2.3 If onRejected is a function"></a>2.2.3 If onRejected is a function</h3><ul><li>it must be called after promise is rejected, with promise’s reason as its first argument</li><li>it must not be called before promise is rejected</li><li>it must not be called more than once</li></ul><p>这个跟 2.2.2 其实很像的，就是做 <code>reject</code> 之后的逻辑</p><h4 id="测试用例-7"><a href="#测试用例-7" class="headerlink" title="测试用例"></a>测试用例</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">it(<span class="string">'2.2.3.1 此函数必须在 promise 失败(rejected) 后被调用,并把 promise 的值作为它的第一个参数'</span>, done =&gt; &#123;</span><br><span class="line">   <span class="keyword">const</span> fail = sinon.fake()</span><br><span class="line">   <span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">     assert.isFalse(fail.called)</span><br><span class="line">     reject(<span class="string">'hi'</span>)</span><br><span class="line">     reject(<span class="string">'hii'</span>)</span><br><span class="line">     setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">       assert(promise.state === <span class="string">'rejected'</span>)</span><br><span class="line">       assert.isTrue(fail.calledOnce)</span><br><span class="line">       assert.isTrue(fail.calledWith(<span class="string">'hi'</span>))</span><br><span class="line">       done()</span><br><span class="line">     &#125;, <span class="number">0</span>)</span><br><span class="line">   &#125;)</span><br><span class="line"></span><br><span class="line">   promise.then(<span class="literal">null</span>, fail)</span><br><span class="line"> &#125;)</span><br></pre></td></tr></table></figure><h4 id="源码-7"><a href="#源码-7" class="headerlink" title="源码"></a>源码</h4><p><a href="#2.2.2-If-onFulfilled-is-a-function">参考 2.2.2 If onFulfilled is a function</a></p><h3 id="2-2-4-onFulfilled-or-onRejected-must-not-be-called-until-the-execution-context-stack-contains-only-platform-code"><a href="#2-2-4-onFulfilled-or-onRejected-must-not-be-called-until-the-execution-context-stack-contains-only-platform-code" class="headerlink" title="2.2.4 onFulfilled or onRejected must not be called until the execution context stack contains only platform code"></a>2.2.4 onFulfilled or onRejected must not be called until the execution context stack contains only platform code</h3><p>这句话给人很疑惑的感觉，因为官方的翻译就是</p><blockquote><p>在执行上下文堆栈（execution context）仅包含平台代码之前，不得调用 onFulfilled 和 onRejected</p></blockquote><p>再去看对应的解释(<a href="https://promisesaplus.com/#notes" target="_blank" rel="noopener">3.1</a>)</p><blockquote><p>Here “platform code” means engine, environment, and promise implementation code. In practice, this requirement ensures that <code>onFulfilled</code> and <code>onRejected</code> execute asynchronously, after the event loop turn in which <code>then</code> is called, and with a fresh stack. This can be implemented with either a “macro-task” mechanism such as <code>setTimeout</code> or <code>setImmediate</code>, or with a “micro-task” mechanism such as <code>MutationObserver</code> or <code>process.nextTick</code>. Since the promise implementation is considered platform code, it may itself contain a task-scheduling queue or “trampoline” in which the handlers are called.</p></blockquote><p>翻译一下，就是</p><blockquote><p>这里的 “platform code” 表示 (JS 的) 引擎，(JS 的)环境和 promise 执行的代码。实际上，这个(规范)要求能确保，<code>onFulfilled</code> 和 <code>onRejected</code> 在 eventLoop 之后调用 <code>then</code>，  它们可以(得到)异步地执行，然后(继续)使用新的堆栈。这里既可以使用 <code>setTimeout</code>/<code>setImmediate</code> 这样的 “宏任务” 机制实现，也可以使用 <code>MutationObserver</code>/<code>process.nextTick</code> 这样的 “微任务” 机制实现。由于 promise 的实现被看作是 platform code，所以它可能本身就包含一个任务调度队列或者用来处理调用(关系)的 “trampoline”</p></blockquote><p>还是不理解？我举个例子好了，比如有一个函数叫做 <code>XXX</code> 吧，一个 promise 做了如下的操作</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">promise.then(XXX)</span><br></pre></td></tr></table></figure><p>但是此时函数 <code>XXX</code> <strong>还没有执行</strong>哦，因为规范要求，<strong>一定要在调用 <code>then</code></strong> 之后执行。因为这才可以产生一个异步的操作，而这个异步的操作如何来？规范里面也写了，可以利用 <code>setTimeout</code>/<code>setImmediate</code> 这样的宏任务来解决，或者也可以使用 <code>MutationObserver</code>/<code>process.nextTick</code> 这样的微任务来解决。解决的关键点是什么呢？就是在 Promise 内部，其传入的函数里面执行的<strong>优先级</strong>比外面通过 <code>promise.then</code> 方式调用 <code>XXX</code> 的优先级 <strong>要高</strong>。那么怎么做到这种优先级要高呢？ <strong>就是在 <code>resolve</code>/<code>reject</code> 中加上 <code>setTimeout</code></strong>。当然了，这里只是简单的处理，比如我写如下的测试代码你大概就懂了</p><blockquote><p>如果实在不明白宏任务/微任务机制的可以<a href="https://github.com/strugglebak/front-end-daliy/issues/8" target="_blank" rel="noopener">点击参考我之前写的这篇</a></p></blockquote><h4 id="测试用例-8"><a href="#测试用例-8" class="headerlink" title="测试用例"></a>测试用例</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">it(<span class="string">'2.2.4 在我的代码执行完之前，不得调用 then 后面的两个函数'</span>, done =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> success = sinon.fake()</span><br><span class="line">  <span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    resolve()</span><br><span class="line">  &#125;)</span><br><span class="line">  promise.then(success)</span><br><span class="line">  <span class="comment">// 这个时候代码还没有执行完，success 函数还没有被调用</span></span><br><span class="line">  assert.isFalse(success.called)</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 这个时候代码执行完了，success 函数被调用了</span></span><br><span class="line">    assert.isTrue(success.called)</span><br><span class="line">    done()</span><br><span class="line">  &#125;, <span class="number">0</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">it(<span class="string">'2.2.4 失败回调'</span>, done =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> fail = sinon.fake()</span><br><span class="line">  <span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    reject()</span><br><span class="line">  &#125;)</span><br><span class="line">  promise.then(<span class="literal">null</span>, fail)</span><br><span class="line">  assert.isFalse(fail.called)</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    assert.isTrue(fail.called)</span><br><span class="line">    done()</span><br><span class="line">  &#125;, <span class="number">0</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>所以你可以看到，外面的 <code>setTimeout</code> 要 <strong>靠后 </strong> 执行了，为什么，因为 <code>success</code> 函数先进入了 Promise 内部，其内部有个 <code>setTimeout</code> 函数将其包裹了起来，eventLoop 时运行环境会将这个里面的代码放到了一个宏任务队列中，而这个外面调的 <code>setTimeout</code> 也将其紧随其后放到这个队列里面。执行时会优先执行先进去的任务，那么就是 <code>success</code> 先在里面执行了，然后外部的 <code>setTimeout</code> 自然就会觉察到 <code>success</code> 被调用了。</p><h4 id="源码-8"><a href="#源码-8" class="headerlink" title="源码"></a>源码</h4><p>参考最开始写的 <a href="#先实现一个最基础版本的-Promise">先实现一个最基础版本的 Promise</a></p><h3 id="2-2-5-onFulfilled-and-onRejected-must-be-called-as-functions-i-e-with-no-this-value"><a href="#2-2-5-onFulfilled-and-onRejected-must-be-called-as-functions-i-e-with-no-this-value" class="headerlink" title="2.2.5 onFulfilled and onRejected must be called as functions (i.e. with no this value)"></a>2.2.5 onFulfilled and onRejected must be called as functions (i.e. with no this value)</h3><p>这里的意思是 <code>onFulfilled</code> 和 <code>onRejected</code> 必须被当作函数调用(例如: 没有 <code>this</code>)</p><p>又懵逼了，啥玩意儿???还是看看<a href="https://promisesaplus.com/#notes" target="_blank" rel="noopener">说明 3.2</a>吧</p><blockquote><p>That is, in strict mode <code>this</code> will be <code>undefined</code> inside of them; in sloppy mode, it will be the global object</p></blockquote><p>意思就是说</p><blockquote><p>严格模式下，<code>this</code> 在 <code>onFulfilled</code> 以及 <code>onRejected</code> 内部是 <code>undefined</code>; 而在非严格模式下，<code>this</code> 在它们内部就是一个全局对象</p></blockquote><p>所以这里我们就选择严格模式就好了，因为本来就是由类封装起来的对象，在这种情况下，<code>this</code> 在 <code>onFulfilled</code> 以及 <code>onRejected</code> 内部只能是 <code>undefined</code>，那么测试用例应该这么写</p><h4 id="测试用例-9"><a href="#测试用例-9" class="headerlink" title="测试用例"></a>测试用例</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">it(<span class="string">'2.2.5 onFulfilled 和 onRejected 必须被当做函数调用(并且里面没有 this)'</span>, done =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    resolve()</span><br><span class="line">  &#125;)</span><br><span class="line">  promise.then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">    'use strict'</span></span><br><span class="line">    assert(<span class="keyword">this</span> === <span class="literal">undefined</span>) <span class="comment">// 断言这个函数里面的 this 为 undefined</span></span><br><span class="line">    done()</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">it(<span class="string">'2.2.5 失败回调'</span>, done =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    reject()</span><br><span class="line">  &#125;)</span><br><span class="line">  promise.then(<span class="literal">null</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">    'use strict'</span></span><br><span class="line">    assert(<span class="keyword">this</span> === <span class="literal">undefined</span>)</span><br><span class="line">    done()</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="源码-9"><a href="#源码-9" class="headerlink" title="源码"></a>源码</h4><p>源码就好改了，对应的 <code>resolve</code> 以及 <code>reject</code> 函数里面将对应的函数调用 <code>call</code> 一个 <code>undefined</code> 就好，如下</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PromiseEasy</span> </span>&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  resovle(result) &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span>.succeed === <span class="string">'function'</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.succeed.call(<span class="literal">undefined</span>, result)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  reject(reason) &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span>.fail === <span class="string">'function'</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.fail.call(<span class="literal">undefined</span>, reason)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-6-then-may-be-called-multiple-times-on-the-same-promise"><a href="#2-2-6-then-may-be-called-multiple-times-on-the-same-promise" class="headerlink" title="2.2.6 then may be called multiple times on the same promise"></a>2.2.6 then may be called multiple times on the same promise</h3><p><code>then</code> 可以在同一个 Promise 里被多次调用。那么基本上测试代码可以这么写</p><h4 id="测试用例-10"><a href="#测试用例-10" class="headerlink" title="测试用例"></a>测试用例</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">it(<span class="string">'2.2.6 then可以在同一个promise里被多次调用'</span>, done =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    resolve()</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">const</span> callbacks = [sinon.fake(), sinon.fake(), sinon.fake()]</span><br><span class="line">  promise.then(callbacks[<span class="number">0</span>])</span><br><span class="line">  promise.then(callbacks[<span class="number">1</span>])</span><br><span class="line">  promise.then(callbacks[<span class="number">2</span>])</span><br><span class="line"></span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    assert(callbacks[<span class="number">0</span>].called)</span><br><span class="line">    assert(callbacks[<span class="number">1</span>].called)</span><br><span class="line">    assert(callbacks[<span class="number">2</span>].called)</span><br><span class="line">    <span class="comment">// 如果/当 promise 完成执行（fulfilled）,各个相应的onFulfilled回调 必须根据最原始的then 顺序来调用</span></span><br><span class="line">    assert(callbacks[<span class="number">1</span>].calledAfter(callbacks[<span class="number">0</span>]))</span><br><span class="line">    assert(callbacks[<span class="number">2</span>].calledAfter(callbacks[<span class="number">1</span>]))</span><br><span class="line">    done()</span><br><span class="line">  &#125;, <span class="number">0</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">it(<span class="string">'2.2.6 失败回调'</span>, done =&gt; &#123;</span><br><span class="line">   <span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">     reject()</span><br><span class="line">   &#125;)</span><br><span class="line">   <span class="keyword">const</span> callbacks = [sinon.fake(), sinon.fake(), sinon.fake()]</span><br><span class="line">   promise.then(<span class="literal">null</span>, callbacks[<span class="number">0</span>])</span><br><span class="line">   promise.then(<span class="literal">null</span>, callbacks[<span class="number">1</span>])</span><br><span class="line">   promise.then(<span class="literal">null</span>, callbacks[<span class="number">2</span>])</span><br><span class="line"></span><br><span class="line">   setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">     assert(callbacks[<span class="number">0</span>].called)</span><br><span class="line">     assert(callbacks[<span class="number">1</span>].called)</span><br><span class="line">     assert(callbacks[<span class="number">2</span>].called)</span><br><span class="line">     assert(callbacks[<span class="number">1</span>].calledAfter(callbacks[<span class="number">0</span>]))</span><br><span class="line">     assert(callbacks[<span class="number">2</span>].calledAfter(callbacks[<span class="number">1</span>]))</span><br><span class="line">     done()</span><br><span class="line">   &#125;, <span class="number">0</span>)</span><br></pre></td></tr></table></figure><blockquote><p>这里 <code>sinon.fake.calledAfter</code> 表示在某个目标函数之后被调用</p></blockquote><h4 id="源码-10"><a href="#源码-10" class="headerlink" title="源码"></a>源码</h4><p>这里的 <code>promise</code> 要求能够多次调用 <code>then</code>，而我们原来 Promise 的逻辑是 <code>then</code> 只是保存了一次 <code>succeed</code> 和 <code>fail</code>，这样的话多次 <code>then</code> 就只会覆盖掉之前传入的函数。要能通过测试用例中的代码，我们很容易想到，每次 <code>then</code> 时，用<strong>数组来保存 <code>succeed</code> 和 <code>fail</code></strong> 即可。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PromiseEasy</span> </span>&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  callbacks = [] <span class="comment">// 用来保存成功以及失败回调的数组</span></span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  then(succeed?, fail?) &#123;</span><br><span class="line">    <span class="keyword">const</span> handle = []</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> succeed === <span class="string">'function'</span>) &#123;</span><br><span class="line">      handle[<span class="number">0</span>] = succeed</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> fail === <span class="string">'function'</span>) &#123;</span><br><span class="line">      handle[<span class="number">1</span>] = fail</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.callbacks.push(handle)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么在调用的时候怎么办呢？只需要在 <code>resolve</code> 和 <code>reject</code> 中 <strong>遍历调用</strong> 即可</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PromiseEasy</span> </span>&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  resolve(result) &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">//...</span></span><br><span class="line">      <span class="keyword">this</span>.callbacks.forEach(<span class="function"><span class="params">handle</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> succeed = handle[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> succeed === <span class="string">'function'</span>) &#123;</span><br><span class="line">          succeed.call(<span class="literal">undefined</span>, result)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;, <span class="number">0</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  reject(reason) &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">//...</span></span><br><span class="line">      <span class="keyword">this</span>.callbacks.forEach(<span class="function"><span class="params">handle</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> fail = handle[<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> fail === <span class="string">'function'</span>) &#123;</span><br><span class="line">          fail.call(<span class="literal">undefined</span>, reason)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;, <span class="number">0</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，本质就是两步</p><ul><li>添加一个<strong>二维数组</strong>，<code>then</code> 时保存 <code>succeed</code> 和 <code>fail</code> 的数组</li><li>在 <code>resolve</code>/<code>reject</code> 时<strong>遍历</strong>，取出对应的 <code>succeed</code>/<code>fail</code>，并执行</li></ul><h2 id="与-Promises-A-规范的区别"><a href="#与-Promises-A-规范的区别" class="headerlink" title="与 Promises/A 规范的区别"></a>与 Promises/A 规范的区别</h2><p>至此，我们已经完成一个 Promise 的基本功能，这个功能包括了 Promise 的核心 API，即 <code>new Promise</code> 以及 <code>then</code> 和里面的成功以及失败回调，下面就来讲(fan)讲(yi) Promises/A+ 规范和 Promises/A 规范的几个<strong>比较重要</strong>的区别</p><h3 id="Omissions"><a href="#Omissions" class="headerlink" title="Omissions"></a>Omissions</h3><p>下面的几点都是 Promises/A 规范所遗漏的:</p><ol><li>进度处理: 实际上，它并未被指定，并且当前在实现 promise 的社区中没有形成一致的意见</li><li>可交互的 promises: 这被认为超出了可互操作保证所必需的最小 API 的范围</li><li>对于 <code>var promise2 = promise1.then(onFulfilled, onRejected)</code> 这样的代码，<code>promise1 !== promise2</code> 并不是必要的</li></ol><h3 id="Clarifications"><a href="#Clarifications" class="headerlink" title="Clarifications"></a>Clarifications</h3><p>Promises/A+ 规范与 Promises/A 规范使用不同的术语，这体现在 Promise 的实现过程中，它们已经成为事实(标准)意义上的词汇。 特别是如下:</p><ol><li>给定的 promise 的状态是 “pending”、”fulfilled”、”rejected”</li><li>当 promises 被 fulfilled 时，它们会有 “value”; 当 promises 被 rejected 时，它们会有 “reason”</li><li>它引入了与 “promises” 不同的术语叫 “thenable”，以便更准确地讨论实现互操作所必需的 duck 测试</li></ol><h3 id="Additions"><a href="#Additions" class="headerlink" title="Additions"></a>Additions</h3><p>Promises/A+ 规范另外指定:</p><ol><li>当 <code>onFulfilled</code> 或 <code>onRejected</code> 返回一个 <code>thenable</code> 的行为时，应包括解析过程的详细信息</li><li>传给 <code>onRejected</code> 的 <code>reason</code> 在处理 <code>throws</code> 必须要抛异常</li><li><code>onFulfilled</code> 和 <code>onRejected</code> 必须是被异步调用的</li><li><code>onFulfilled</code> 和 <code>onRejected</code> 必须是当作函数来调用</li><li>对 <code>onFulfilled</code> 和 <code>onRejected</code> 的调用的严格排序，以便在同一个 promise 上调用 <code>then</code></li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>一个基础的 Promises/A+ 规范的 Promise 的实现需要注意以下几点</p><ol><li>构造函数需要传一个函数，并在构造函数内部调用这个函数，而这个函数传了两个参数作为参数: <code>resolve</code> 和 <code>reject</code>，这两个函数都是 Promise 内部实现的函数</li><li>每次 <code>then</code> 时都将传入的 <code>succeed</code> 和 <code>fail</code> 函数 push 进一个数组当中，而这个数组是一个二维数组，用来维护这一堆 <code>succeed</code> 和 <code>fail</code> 函数</li><li>Promise 内部的 <code>resolve</code> 函数和 <code>reject</code> 函数中都做了如下的操作<ul><li>判断 <code>state</code> 是否为 <code>pending</code> 状态，不是就 return</li><li>修改状态为 <code>fulfilled</code>/ <code>rejected</code></li><li>遍历上述的二维数组，找到 <code>succeed</code>/<code>fail</code> 函数并调用(<code>.call(undefined, result/reason)</code>)</li></ul></li><li><code>resolve</code>/<code>reject</code> 函数里面使用 <code>setTimeout</code> 做异步执行</li></ol><blockquote><p>另外，对应的<a href="https://github.com/strugglebak/promise-easy" target="_blank" rel="noopener">项目链接在这里</a></p></blockquote><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://promisesaplus.com/" target="_blank" rel="noopener">Promises/A+</a></p><p><a href="https://promisesaplus.com/differences-from-promises-a" target="_blank" rel="noopener">Differences from Promises/A</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;之前我还讲过 &lt;a href=&quot;https://strugglebak.github.io/2020/03/09/%E4%BB%8EPromise%E6%9C%AC%E8%B4%A8%E5%BC%80%E5%A7%8B-%E4%B8%80-%E5%AE%9E%E7%8E%B0Promise%E5%89%8D%E8%A8%80/&quot;&gt;如何为实现 Promise 搭建 TDD 环境&lt;/a&gt;，而本文的目的主要是探讨如何基于 TDD 这样的方式实现一个 Promise，并且描述了部分 Promises/A+ 规范，以此为基础实现的一个 Promise&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="手写源码" scheme="https://strugglebak.github.io/categories/%E6%89%8B%E5%86%99%E6%BA%90%E7%A0%81/"/>
    
    
      <category term="Promise" scheme="https://strugglebak.github.io/tags/Promise/"/>
    
  </entry>
  
  <entry>
    <title>watermelon-clock:基于TypeScript+React的西瓜闹钟项目的实践总结</title>
    <link href="https://strugglebak.github.io/2020/03/17/watermelon-clock-%E5%9F%BA%E4%BA%8ETypeScript-React%E7%9A%84%E8%A5%BF%E7%93%9C%E9%97%B9%E9%92%9F%E9%A1%B9%E7%9B%AE%E7%9A%84%E5%AE%9E%E8%B7%B5%E6%80%BB%E7%BB%93/"/>
    <id>https://strugglebak.github.io/2020/03/17/watermelon-clock-基于TypeScript-React的西瓜闹钟项目的实践总结/</id>
    <published>2020-03-16T16:05:52.000Z</published>
    <updated>2022-06-04T08:13:29.095Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>注意，本项目是基于 <code>create-react-app</code> 搭建，但是使用了 <code>--typescript</code> 选项，所以是基于 <code>TypeScript</code> 写的。另外，<a href="https://github.com/strugglebak/watermelon-clock" target="_blank" rel="noopener">项目地址在这里，求各位大佬看到了如果喜欢还请点个小星星(拜托啦这真的对我很重要 QAQ)</a></p></blockquote><a id="more"></a><h2 id="项目实现-Feature"><a href="#项目实现-Feature" class="headerlink" title="项目实现 Feature"></a>项目实现 Feature</h2><ul><li><p>小巧的用户验证</p><p>  这一部分主要是用来注册/登陆的验证用的，注册/登陆后会自动跳转至首页，所以这边也做了一个简单的路由鉴权功能</p></li><li><p>西瓜闹钟</p><p>  点击开始闹钟时，会显示 25 分钟的倒计时，计时结束后若没有打断则会生成一个西瓜</p></li><li><p>待办 todo 任务</p><p>  新建待办任务和完成待办任务后都会出现任务的列表，而且是不同的列表展示</p></li><li><p>数据统计</p><p>  主要有 3 个</p><ul><li>月度统计：统计每个月任务总量的累计/增长率/平均值</li><li>西瓜历史统计：主要是一个长达 25 分钟的西瓜量，表示自己长时间的执行完某个任务的量化显示，可编辑/删除/恢复，同时也可以手动增加西瓜记录</li><li>待办 todo 历史统计：表示自己短时间内执行完的小任务的量化表示，可编辑/删除/恢复，同时可以查看已经删除的任务</li></ul></li></ul><h2 id="项目主要技术栈"><a href="#项目主要技术栈" class="headerlink" title="项目主要技术栈"></a>项目主要技术栈</h2><ul><li>React 16.12</li><li>Antd 4.0.1</li><li>Axios 库</li><li>React-Router-DOM 5.1.2</li><li>React-Redux 7.1.3</li><li>Redux 4.0.5</li><li>TypeScript 3.8.3</li><li>History 4.10.1</li><li>Lodash 4.14</li><li>Stylus</li></ul><p>这里需要说明的是目前的 antd 用的是比较新的版本，但是由于组件目前并不涉及到非常复杂的结构，所以可以使用其升级工具进行无痛升级</p><p>在配置 <code>stylus</code> 时应该在项目对应的 <code>config-overrides.js</code> 目录做如下的配置</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">const</span> stylus = <span class="function"><span class="params">()</span> =&gt;</span> <span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> stylusLoader = &#123;</span><br><span class="line">    test: <span class="regexp">/\.styl$/</span>,</span><br><span class="line">    use: [</span><br><span class="line">      &#123;</span><br><span class="line">        loader: <span class="string">'style-loader'</span></span><br><span class="line">      &#125;, &#123;</span><br><span class="line">        loader: <span class="string">'css-loader'</span>,</span><br><span class="line">      &#125;, &#123;</span><br><span class="line">        loader: <span class="string">'stylus-loader'</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> oneOf = config.module.rules.find(<span class="function"><span class="params">rule</span> =&gt;</span> rule.oneOf).oneOf</span><br><span class="line">  oneOf.unshift(stylusLoader)</span><br><span class="line">  <span class="keyword">return</span> config</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = override(</span><br><span class="line">  ...</span><br><span class="line">  stylus()</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>这里的作用相当于找出原有配置中的 <code>oneOf</code> 然后将 <code>stylus</code> 的配置加入其中，很好理解(因为我目前使用的时 cra 所以在某些配置方面能省则省了，目的是体验并上手 React 结合 TypeScript 的开发)</p><h2 id="项目实现技术细节"><a href="#项目实现技术细节" class="headerlink" title="项目实现技术细节"></a>项目实现技术细节</h2><h3 id="部分组件使用-hooks"><a href="#部分组件使用-hooks" class="headerlink" title="部分组件使用 hooks"></a>部分组件使用 hooks</h3><p>主要是倒计时组件这里使用了 <code>useEffect</code> 以及 <code>useState</code> 这两个 hooks</p><p>原来的倒计时组件用类组件来写的话就比较繁琐</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/components/waterMelon/countDown.tsx</span></span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">countDown</span> <span class="keyword">extends</span> <span class="title">Component</span>&lt;<span class="title">ICountDownProps</span>, <span class="title">ICountDownState</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span>(props: ICountDownProps) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props)</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      countDown: <span class="keyword">this</span>.props.time,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">get</span> countDown() &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">get</span> progressWidth() &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentWillUnmount() &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (...)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本质上就是使用了一个生命周期的形式来实现效果，代码分散在多处不好做统一管理，但是使用了 hooks 之后代码量减少很多，减小了很多心智负担</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> CountDown:FunctionComponent&lt;ICountDownProps&gt; = <span class="function">(<span class="params">props: ICountDownProps</span>) =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> [countDown, setCountDown] = useState(props.time)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 时间换算显示</span></span><br><span class="line">  <span class="keyword">const</span> min = <span class="built_in">Math</span>.floor(countDown/<span class="number">1000</span>/<span class="number">60</span>)</span><br><span class="line">  <span class="keyword">const</span> sec = <span class="built_in">Math</span>.floor(countDown/<span class="number">1000</span>%<span class="number">60</span>)</span><br><span class="line">  <span class="keyword">const</span> time = <span class="string">`<span class="subst">$&#123;min &lt; <span class="number">10</span> ? <span class="string">`0<span class="subst">$&#123;min&#125;</span>`</span> : min&#125;</span>:<span class="subst">$&#123;sec &lt; <span class="number">10</span> ? <span class="string">`0<span class="subst">$&#123;sec&#125;</span>`</span> : sec&#125;</span>`</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// progress bar 进度条长度计算显示</span></span><br><span class="line">  <span class="keyword">const</span> &#123; duration &#125; = props</span><br><span class="line">  <span class="keyword">const</span> progressWidth = (<span class="number">100</span> - (countDown - <span class="number">1000</span>) * <span class="number">100</span> / duration).toFixed(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span>=&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">document</span>.title = <span class="string">`<span class="subst">$&#123;time&#125;</span> - 西瓜闹钟 App`</span></span><br><span class="line">    timerId = setInterval(<span class="function"><span class="params">()</span>=&gt;</span> &#123;</span><br><span class="line">      setCountDown(countDown - <span class="number">1000</span>)</span><br><span class="line">      <span class="keyword">if</span> (countDown &lt; <span class="number">1000</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(countDown)</span><br><span class="line">        props.onEnd()</span><br><span class="line">        <span class="built_in">window</span>.clearInterval(timerId)</span><br><span class="line">        <span class="built_in">document</span>.title = <span class="string">'西瓜闹钟 App'</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 组件销毁时</span></span><br><span class="line">      <span class="built_in">window</span>.clearInterval(timerId)</span><br><span class="line">      <span class="built_in">document</span>.title = <span class="string">'西瓜闹钟 App'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (...)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 <code>useEffect</code> 可以统一处理副作用以及组件销毁时的逻辑，而使用 <code>useState</code> 就可以统一状态的管理，这样就可以最大程度的减小代码量，可以将一些比较重要的逻辑统一起来管理，使得组件代码更加明了</p><h3 id="axios-配置"><a href="#axios-配置" class="headerlink" title="axios 配置"></a>axios 配置</h3><p>这里的配置比较简单，主要是通过使用 axios 的拦截器去拦截验证从后端发过来的 token 有没有，配置主要有以下两点</p><ul><li><p>发送请求前需要在请求头中加 token 方便后端验证</p>  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/config/http.ts</span></span><br><span class="line">instance.interceptors.request.use(</span><br><span class="line">  config =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> xToken = localStorage.getItem(<span class="string">'x-token'</span>)</span><br><span class="line">    <span class="keyword">if</span> (xToken) config.headers[<span class="string">'Authorization'</span>] = <span class="string">`Bearer <span class="subst">$&#123;xToken&#125;</span>`</span></span><br><span class="line">    <span class="keyword">return</span> config</span><br><span class="line">  &#125;,</span><br><span class="line">  e =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'request error: '</span>, e)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(e)</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li><li><p>接受响应之前设置下 token</p>  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">instance.interceptors.response.use(</span><br><span class="line">  res =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (res.headers[<span class="string">'x-token'</span>]) localStorage.setItem(<span class="string">'x-token'</span>, res.headers[<span class="string">'x-token'</span>])</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">  &#125;,</span><br><span class="line">  e =&gt; &#123;</span><br><span class="line">    <span class="comment">// eslint-disable-next-line</span></span><br><span class="line">    <span class="keyword">if</span> (e.response &amp;&amp; e.response.status === <span class="number">401</span> || e.response.status &gt;= <span class="number">500</span>) &#123;</span><br><span class="line">      <span class="comment">// 一般是如果鉴权失败，需要做重定向跳转到登录页</span></span><br><span class="line">      <span class="built_in">console</span>.log(history.location.pathname)</span><br><span class="line">      <span class="keyword">if</span> (history.location.pathname === <span class="string">'/'</span>) history.push(<span class="string">'/login'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(e)</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li></ul><p>这里做了一个简单的路由鉴权，不过更加详细的鉴权我写在了 redux 的 <code>userActions</code> 中，不过留着下面来说</p><h3 id="redux-以及-redux-thunk-这个中间件"><a href="#redux-以及-redux-thunk-这个中间件" class="headerlink" title="redux 以及 redux-thunk 这个中间件"></a>redux 以及 redux-thunk 这个中间件</h3><ul><li><p>模块划分<br>  说到模块划分，基本是如下的结构</p>  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">redux/</span><br><span class="line">├── actionTypes.ts</span><br><span class="line">├── actions</span><br><span class="line">│   ├── todosActions.ts</span><br><span class="line">│   ├── userActions.ts</span><br><span class="line">│   └── waterMelonActions.ts</span><br><span class="line">├── reducers</span><br><span class="line">│   ├── indexReducer.ts</span><br><span class="line">│   ├── todosReducer.ts</span><br><span class="line">│   ├── userReducer.ts</span><br><span class="line">│   └── waterMelonReducer.ts</span><br><span class="line">└── store.ts</span><br></pre></td></tr></table></figure><p>  因为这里的各种 <code>type</code> 都比较简单，所以这里就没有分各个模块文件了，只是就大概的 <code>actions</code> 以及 <code>reducers</code> 分了一下，<code>store.ts</code> 模块主要就是 <code>creatStore</code> 以及 <code>applyMiddleware</code> 中间件。这里还用了一个 <code>redux-devtools-extension</code> redux 的调试工具，在 debug 环境调试用的。</p></li><li><p>用户登陆/注册的鉴权</p><p>  其实在用户登陆和注册之前可以先调用下 <code>getUserInfo</code> 获取下用户的信息，先判断是否会得到错误，如果没错那么本来没有在 <code>/</code> 路由的就跳转到 <code>/</code>，如果出错了那么在判断其是否在 <code>/</code> 路由，在的话就强制跳转至 <code>/login</code> 路由页面</p><p>  登陆和注册的逻辑基本就是如下</p>  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">await</span> http.post(url, params)</span><br><span class="line">  <span class="keyword">const</span> response = <span class="keyword">await</span> http.get(<span class="string">'/me'</span>)</span><br><span class="line">  <span class="keyword">const</span> userInfo = response.data</span><br><span class="line">  dispatch(&#123;</span><br><span class="line">    type: VERIFY_USER_SUCCESS,</span><br><span class="line">    payload: userInfo</span><br><span class="line">  &#125;)</span><br><span class="line">  history.push(<span class="string">'/'</span>)</span><br><span class="line">&#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e.response)</span><br><span class="line">  <span class="keyword">let</span> errorInfo</span><br><span class="line">  <span class="keyword">if</span>(!e.response)&#123;</span><br><span class="line">    errorInfo = <span class="string">'请检查网络是否正常'</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; errors &#125; = e.response.data</span><br><span class="line">    errorInfo = errors.account</span><br><span class="line">    ? errors.account</span><br><span class="line">    : errors</span><br><span class="line">  &#125;</span><br><span class="line">  dispatch(&#123;</span><br><span class="line">    type: VERIFY_USER_FAILURE,</span><br><span class="line">    error: errorInfo</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>为什么使用 <code>redux-thunk</code> 来 <code>dispatch</code> 数据</p><p>  因为用到了异步，而我们这里的异步比较简单，实际上用 <code>redux-thunk</code> 这个中间件就能解决问题了。那么这里的 <code>actions</code> 的写法也比较简单，只是需要返回一个 <code>async</code> 的带有 <code>dispatch</code> 函数参数的一个函数即可，<code>redux-thunk</code> 会自己帮你 enhance 这个 <code>dispatch</code></p>  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> xxx = <span class="keyword">async</span> (dispatch: any) =&gt; &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  dispatch(&#123;</span><br><span class="line">    type: <span class="string">'YYY'</span>,</span><br><span class="line">    payload: &#123;...&#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>react-redux</code> 中的 <code>connect</code> 组件</p><p>  首先我不认同只有父级组件用 <code>connect</code> 而其他组件就被动传 <code>props</code> 的这种用法。因为尽管是比较简单的一个项目，但是在某个功能模块上依然存在层级嵌套比较深的情况。有一般而言传个三级就觉得很麻烦了，这个时候子组件使用 <code>connect</code> 是很有必要的(虽然可能写起来依然麻烦了点，但是的确能省点心思思考我的父级组件到底给我传了个啥)</p></li></ul><h3 id="封装的-history-配置"><a href="#封装的-history-配置" class="headerlink" title="封装的 history 配置"></a>封装的 <code>history</code> 配置</h3><p>这部分的代码也并不是特别复杂，如下所示</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createBrowserHistory &#125; <span class="keyword">from</span> <span class="string">'history'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ENV = process.env.NODE_ENV</span><br><span class="line"><span class="keyword">let</span> publicUrl: string = <span class="string">''</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ENV === <span class="string">'development'</span>) &#123;</span><br><span class="line">  publicUrl = <span class="string">'/'</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (ENV === <span class="string">'production'</span>) &#123;</span><br><span class="line">  publicUrl = <span class="string">'/watermelon-clock'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> history = createBrowserHistory(&#123;</span><br><span class="line">  basename: publicUrl</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> history</span><br></pre></td></tr></table></figure><p>虽然在 <code>App.tsx</code> 中使用过 <code>BrowserRouter</code>，但是不如自己封装来的快，因为这块很多地方都要用到，比如如上所述的鉴权的位置，用于登陆验证过后的跳转</p><h2 id="数据统计图"><a href="#数据统计图" class="headerlink" title="数据统计图"></a>数据统计图</h2><p>这次的数据统计图没有使用诸如 <code>echart.js</code> 和 <code>highchart.js</code> 的原因部分是因为觉得没有多大必要，觉得自己使用 <code>svg</code> 来实现或许会更加好一点，有点造轮子的意思，不过还是挺有趣的。当然这次也没有选中 <code>canvas</code> 的原因是 <code>svg</code> 有个好处就是不依赖 <strong>分辨率</strong>，因为它生成的图像是基于<strong>矢量位图</strong> 的，你放大缩小都不会失真。</p><h3 id="折线图"><a href="#折线图" class="headerlink" title="折线图"></a>折线图</h3><p>折线图就是下图这玩意儿</p><p><img src="./1.png" alt></p><p>我这边是先实现的折线图，所以先说一下大概是怎么实现的，代码如下所示</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">// src/components/statistics/polyline.tsx</span><br><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">className</span>=<span class="string">"polyline peity"</span> <span class="attr">width</span>=<span class="string">"100%"</span> <span class="attr">height</span>=<span class="string">"60"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">polygon</span></span></span><br><span class="line"><span class="tag">    <span class="attr">fill</span>=<span class="string">"rgba(215,78,78,0.1)"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">points</span>=<span class="string">&#123;this.points()&#125;</span></span></span><br><span class="line"><span class="tag">  /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">polygon</span></span></span><br><span class="line"><span class="tag">    <span class="attr">fill</span>=<span class="string">"none"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">stroke</span>=<span class="string">"rgba(215,78,78,0.5)"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">strokeWidth</span>=<span class="string">"1"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">strokeLinecap</span>=<span class="string">"square"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">points</span>=<span class="string">&#123;this.points()&#125;</span></span></span><br><span class="line"><span class="tag">  /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这里有几个属性，说明一下</p><ul><li><code>fill</code>: 表示填充进 <code>svg</code> 框住的那部分，取值是颜色</li><li><code>points</code>: 就是描线，线的坐标</li><li><code>stroke</code>: 表示 <code>fill</code> 外层的那条线，取值也是颜色</li><li><code>strokeWidth</code>: 表示线宽</li><li><code>strokeLinecap</code>: 表示从起点到终点的线它两边的形状，可以是 <code>butt | round | square | inherit</code></li></ul><p>这里的逻辑很好理解，就是 <code>svg</code> 包 <code>polygon</code> 画线并填充颜色，然后是坐标点的计算</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">points = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> &#123; data, finishedCount, width &#125; = <span class="keyword">this</span>.props</span><br><span class="line">  <span class="comment">// 首先传入的 data 是一个类似 &#123;'时间1': &#123;...&#125;, '时间2': &#123;...&#125;&#125; 这样的对象</span></span><br><span class="line">  <span class="comment">// 这里首先要做的就是根据时间大小排序</span></span><br><span class="line">  <span class="comment">// 得到一个 ['时间1', '时间2', ...] 的数组</span></span><br><span class="line">  <span class="keyword">const</span> datesKeys = <span class="built_in">Object</span>.keys(data).sort(</span><br><span class="line">    (a, b) =&gt; &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Date</span>.parse(a) - <span class="built_in">Date</span>.parse(b)</span><br><span class="line">    &#125;</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 计算起始点和终止点的坐标</span></span><br><span class="line">  <span class="keyword">const</span> firstDay = datesKeys[<span class="number">0</span>]</span><br><span class="line">  <span class="keyword">const</span> startPoints = <span class="string">'0,60'</span></span><br><span class="line">  <span class="keyword">const</span> lastPoints = <span class="string">`<span class="subst">$&#123;width&#125;</span>,60`</span></span><br><span class="line">  <span class="keyword">if</span> (!firstDay) <span class="keyword">return</span> [<span class="string">`<span class="subst">$&#123;startPoints&#125;</span>`</span>, <span class="string">`<span class="subst">$&#123;lastPoints&#125;</span>`</span>].join(<span class="string">' '</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> lastDay = datesKeys[datesKeys.length - <span class="number">1</span>]</span><br><span class="line">  <span class="comment">// 若是同一天有很多任务，并且只有这一天的情况下，dayRange 有可能是 0</span></span><br><span class="line">  <span class="keyword">const</span> dayRange = <span class="built_in">Date</span>.parse(lastDay) - <span class="built_in">Date</span>.parse(firstDay) || <span class="number">1</span></span><br><span class="line">  <span class="keyword">let</span> count = <span class="number">0</span></span><br><span class="line">  <span class="keyword">let</span> lastY</span><br><span class="line">  <span class="comment">// 画折线图需要 x y 坐标</span></span><br><span class="line">  <span class="comment">// 有断点的折线图每个 x y 都是有范围的</span></span><br><span class="line">  <span class="comment">// 所以这里需要除一个 range</span></span><br><span class="line">  <span class="keyword">const</span> pointsArray = datesKeys.map(<span class="function">(<span class="params">datesKey: any</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> x = (<span class="built_in">Date</span>.parse(datesKey) - <span class="built_in">Date</span>.parse(firstDay)) / dayRange * (width || <span class="number">320</span>)</span><br><span class="line">    count += <span class="keyword">this</span>.props.data[datesKey].length</span><br><span class="line">    <span class="keyword">const</span> y = (<span class="number">1</span> -  (count / finishedCount)) * <span class="number">60</span></span><br><span class="line">    lastY = y</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;x&#125;</span>,<span class="subst">$&#123;y&#125;</span>`</span></span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> [<span class="string">`<span class="subst">$&#123;startPoints&#125;</span>`</span>, ...pointsArray, <span class="string">`<span class="subst">$&#123;width&#125;</span>,<span class="subst">$&#123;lastY&#125;</span>`</span>, <span class="string">`<span class="subst">$&#123;lastPoints&#125;</span>`</span>].join(<span class="string">' '</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里本质上就是求出一个多边形每个点 x 和 y 的坐标，然后求出 range 范围有个对应的关系，基本上就能搞定了</p><h3 id="条形柱状图"><a href="#条形柱状图" class="headerlink" title="条形柱状图"></a>条形柱状图</h3><p>条形柱状图就是下面这玩意儿</p><p><img src="./2.png" alt></p><p>这个逻辑就是在 <code>svg</code> 中渲染 <code>rect</code></p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">className</span>=<span class="string">"bar-chart"</span> <span class="attr">width</span>=<span class="string">'100%'</span> <span class="attr">height</span>=<span class="string">&#123;height&#125;</span>&gt;</span></span><br><span class="line">&#123;</span><br><span class="line">  this.points().map((point, index) =&gt; (</span><br><span class="line">    <span class="tag">&lt;<span class="name">rect</span> <span class="attr">key</span>=<span class="string">&#123;index&#125;</span> <span class="attr">fill</span>=<span class="string">"rgba(215,78,78,0.5)"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">x</span>=<span class="string">&#123;point[0]&#125;</span> <span class="attr">y</span>=<span class="string">&#123;point[1]&#125;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">width</span>=<span class="string">&#123;16&#125;</span> <span class="attr">height</span>=<span class="string">&#123;height</span> <span class="attr">-</span> <span class="attr">point</span>[<span class="attr">1</span>] || <span class="attr">0</span>&#125;</span></span><br><span class="line"><span class="tag">    /&gt;</span></span><br><span class="line">  ))</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>width</code>: 柱子的宽度</li><li><code>height</code>: 柱子的高度</li><li><code>fill</code>: 颜色填充，之前说过</li><li><code>x</code>: <code>x</code> 坐标值</li><li><code>y</code>: <code>y</code> 坐标值</li><li><code>key</code>: 就是 <code>key</code>，一个 key 值，因为要渲染多个，所以需要这个指明每个 <code>rect</code> 元素的 id</li></ul><p>坐标点计算逻辑如下</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/components/statistics/barChart.tsx</span></span><br><span class="line">points = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; data, finishedCount &#125; = <span class="keyword">this</span>.props</span><br><span class="line">  <span class="keyword">const</span> xRange = <span class="number">10</span></span><br><span class="line">  <span class="comment">// 利用 reduce 找出数据中7天中完成西瓜数最多的数</span></span><br><span class="line">  <span class="comment">// data 传进来就是周一到周日的数据</span></span><br><span class="line">  <span class="comment">// &#123;0: [...], 1: [...], ...&#125;</span></span><br><span class="line">  <span class="keyword">const</span> yRange = data.reduce(</span><br><span class="line">    (acc, cur) =&gt; &#123;</span><br><span class="line">      <span class="keyword">return</span> acc &gt; cur.length ? acc : cur.length</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="number">0</span></span><br><span class="line">  )</span><br><span class="line">  <span class="comment">// 这里用的就是计数法，哪个上面 length 大说明这个柱子 y 坐标越大</span></span><br><span class="line">  <span class="keyword">return</span> data.map(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> x = (index + gap) / xRange * finishedCount - <span class="number">8</span></span><br><span class="line">    <span class="keyword">let</span> y = (<span class="number">1</span> - item.length / (yRange || <span class="number">1</span>)) * height</span><br><span class="line">    y &gt;= height &amp;&amp; (y = height - <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> [x, y]</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="点线图"><a href="#点线图" class="headerlink" title="点线图"></a>点线图</h3><p>点线图就是下面这玩意儿</p><p><img src="./3.png" alt></p><p>分析下，首先是背景的那个灰色的矩形框，就用 <code>rect</code> 绘制，然后使用 <code>path</code> 画线，用 <code>circle</code> 画圆圈，用 <code>text</code> 表示下面的点</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">width</span>=<span class="string">'100%'</span> <span class="attr">height</span>=<span class="string">'200'</span>&gt;</span></span><br><span class="line">  // 灰色背景图</span><br><span class="line">  <span class="tag">&lt;<span class="name">rect</span> <span class="attr">x</span>=<span class="string">&#123;0&#125;</span> <span class="attr">y</span>=<span class="string">&#123;0&#125;</span> <span class="attr">width</span>=<span class="string">'100%'</span> <span class="attr">height</span>=<span class="string">&#123;170&#125;/</span>&gt;</span></span><br><span class="line">  // 描线</span><br><span class="line">  <span class="tag">&lt;<span class="name">path</span></span></span><br><span class="line"><span class="tag">    <span class="attr">d</span>=<span class="string">&#123;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">this.points</span>()<span class="attr">.reduce</span>(</span></span><br><span class="line"><span class="tag">        // <span class="attr">M</span>,<span class="attr">x</span>,<span class="attr">y</span>,<span class="attr">x1</span>,<span class="attr">y1</span> 的形式画直线</span></span><br><span class="line"><span class="tag">        (<span class="attr">acc</span>, <span class="attr">cur</span>) =&gt;</span> acc.concat(`$&#123;cur.slice(0,2).join(',')&#125;,`),</span><br><span class="line">        'M'</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">   /&gt;</span><br><span class="line">  &#123;</span><br><span class="line">    // x 坐标轴上的值显示 1 2 3 4...</span><br><span class="line">    this.points().map(</span><br><span class="line">      // 隔一个显示一个</span><br><span class="line">      (point, index) =&gt; (</span><br><span class="line">        index % 2 === 0</span><br><span class="line">        ? <span class="tag">&lt;<span class="name">text</span> <span class="attr">key</span>=<span class="string">&#123;index&#125;</span> <span class="attr">x</span>=<span class="string">&#123;point[0]</span> <span class="attr">-</span> <span class="attr">5</span>&#125; <span class="attr">y</span>=<span class="string">"200"</span>&gt;</span></span><br><span class="line">            &#123;index + 1&#125;</span><br><span class="line">          <span class="tag">&lt;/<span class="name">text</span>&gt;</span></span><br><span class="line">        : null</span><br><span class="line">    ))</span><br><span class="line">  &#125;</span><br><span class="line">  &#123;</span><br><span class="line">    this.points().map((point, index) =&gt; (</span><br><span class="line">      <span class="tag">&lt;<span class="name">Tooltip</span></span></span><br><span class="line"><span class="tag">        <span class="attr">key</span>=<span class="string">&#123;index&#125;</span> <span class="attr">placement</span>=<span class="string">"top"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">title</span>=<span class="string">&#123;</span>`$&#123;<span class="attr">point</span>[<span class="attr">2</span>]&#125;`&#125; <span class="attr">overlayClassName</span>=<span class="string">'daily_tips'</span>&gt;</span></span><br><span class="line">        &#123;/* 坐标点对应的⚪ */&#125;</span><br><span class="line">        <span class="tag">&lt;<span class="name">circle</span> <span class="attr">r</span>=<span class="string">&#123;this.circleRadius&#125;</span> <span class="attr">cx</span>=<span class="string">&#123;point[0]&#125;</span> <span class="attr">cy</span>=<span class="string">&#123;point[1]&#125;</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">Tooltip</span>&gt;</span></span><br><span class="line">    ))</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注意这里使用了 <code>Tooltip</code> 组件， 表示鼠标悬浮上去之后会有一个提示冒出来</p><p>点坐标的计算就是如下</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">points = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; data, xRange, width &#125; = <span class="keyword">this</span>.props</span><br><span class="line">  <span class="comment">// data 同样是一个类似 &#123;0: [...], 1: [...]&#125; 的对象</span></span><br><span class="line">  <span class="comment">// 这里用 reduce 找出 y 的最大范围值，好用来定高度</span></span><br><span class="line">  <span class="keyword">let</span> yRange = <span class="built_in">Object</span>.keys(data).reduce(</span><br><span class="line">    (acc, cur) =&gt; &#123;</span><br><span class="line">      <span class="keyword">return</span> acc &gt; data[cur].length ? acc : data[cur].length</span><br><span class="line">    &#125;</span><br><span class="line">  , <span class="number">0</span>)</span><br><span class="line">  yRange === <span class="number">0</span> &amp;&amp; (yRange = <span class="number">5</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Object</span>.keys(data).map(</span><br><span class="line">    date =&gt; &#123;</span><br><span class="line">      <span class="keyword">const</span> x = (<span class="keyword">new</span> <span class="built_in">Date</span>(date).getDate() - <span class="number">0.5</span>) / xRange * (width - xBias)</span><br><span class="line">      <span class="keyword">const</span> y = (<span class="number">1</span> - data[date].length / yRange) * <span class="number">160</span> + yBias</span><br><span class="line">      <span class="comment">// 这里需要返回一个 [x, y, 一个数] 是为了 Tooltip 做兼容用的</span></span><br><span class="line">      <span class="keyword">return</span> [x, y, data[date].length]</span><br><span class="line">    &#125;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="项目难点"><a href="#项目难点" class="headerlink" title="项目难点"></a>项目难点</h2><p>项目难点有 2</p><h3 id="使用-svg-矢量图的大小缩放的问题"><a href="#使用-svg-矢量图的大小缩放的问题" class="headerlink" title="使用 svg 矢量图的大小缩放的问题"></a>使用 svg 矢量图的大小缩放的问题</h3><p><img src="./4.png" alt></p><p>因为在项目中还稍微用媒体查询做了下小屏幕的适配，但是在小屏幕适配下图形就显得不是很好看了，为了兼容这个小屏幕，花了点心思，首先使用 <code>css</code> 这种自适应适配的方式是不行的，不管是 <code>flex</code> 还是 <code>100%</code> 这种方式都不能使其适应小屏幕的宽度，所以最后采用 js 来解决，怎么解决的呢，一般来说分为以下几步</p><ul><li>获取到其中一个 <code>li</code> 的宽度<br>  因为其实三个宽度都一样，只要获取到其中一个就可以了</li><li>将其加入点坐标的计算</li><li>完</li></ul><p>加入点坐标计算上面已经说过了，现在说下宽度是怎么搞的</p><p>首先在 <code>statistics</code> 组件中引入两个变量</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/components/statistics/statistics.tsx</span></span><br><span class="line"><span class="keyword">this</span>.state = &#123;</span><br><span class="line">  liWidth: <span class="keyword">this</span>.liRef.current?.offsetWidth || <span class="number">0</span>,</span><br><span class="line">  ulWidth: <span class="keyword">this</span>.ulRef.current?.offsetWidth || <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应的 <code>liRef</code> 和 <code>ulRef</code> 为</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">ulRef = React.createRef&lt;HTMLUListElement&gt;()</span><br><span class="line">liRef = React.createRef&lt;HTMLLIElement&gt;()</span><br></pre></td></tr></table></figure><p>然后需要设定一个 <code>updateSize</code> 函数，就是当其宽度变时就要调用的</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">updateSize = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> liWidth = <span class="keyword">this</span>.liRef.current?.offsetWidth || <span class="number">0</span></span><br><span class="line">  <span class="keyword">let</span> ulWidth = <span class="keyword">this</span>.ulRef.current?.offsetWidth || <span class="number">0</span></span><br><span class="line">  ulWidth &lt; <span class="number">0</span> &amp;&amp; (ulWidth = <span class="number">0</span>)</span><br><span class="line">  <span class="keyword">this</span>.state.liWidth !== liWidth &amp;&amp; (</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; liWidth &#125;)</span><br><span class="line">  )</span><br><span class="line">  <span class="keyword">this</span>.state.ulWidth !== ulWidth &amp;&amp; (</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; ulWidth &#125;)</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到其实这里就是初始化的操作，利用 dom 的 <code>current.offsetWidth</code> 的属性确定宽度</p><p>然后在组件挂载时需要监听 <code>resize</code> 事件</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">componentDidMount() &#123;</span><br><span class="line">  <span class="keyword">this</span>.updateSize()</span><br><span class="line">  <span class="built_in">window</span>.addEventListener(<span class="string">'resize'</span>, <span class="keyword">this</span>.updateSize)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在组件销毁时需要取消监听 <code>resize</code> 事件避免内存泄露</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">componentWillUnmount() &#123;</span><br><span class="line">  <span class="built_in">window</span>.removeEventListener(<span class="string">'resize'</span>, <span class="keyword">this</span>.updateSize)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在把这两个 <code>ref</code> 定位到对应的 dom 上即可</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">className</span>=<span class="string">"statistics"</span> <span class="attr">ref</span>=<span class="string">&#123;this.ulRef&#125;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">className</span>=<span class="string">&#123;monthlyTitleClasses&#125;</span> <span class="attr">ref</span>=<span class="string">&#123;this.liRef&#125;</span> /&gt;</span></span><br><span class="line">  ...</span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure><p>这样通过 <code>resize</code> 就拿到了该组件的 <code>width</code>，在下面计算图形的宽度时就可以代入加参数计算了，一般来说这里就是计算一个 range 即可。</p><h3 id="有关一个组件通信的功能"><a href="#有关一个组件通信的功能" class="headerlink" title="有关一个组件通信的功能"></a>有关一个组件通信的功能</h3><p>就是西瓜闹钟在运行时，本来是想让 <code>waterMelon</code> 组件和 <code>todos</code> 组件有个通信的过程的，比如将正在计时中的 <code>waterMelon</code> 和 <code>todos</code> 关联起来，如果此时有完成的 <code>todos</code> 任务，那么在计时后，完成的 <code>todos</code> 几个任务的 “合体” <code>description</code> 就是西瓜闹钟的 <code>description</code>，比如我完成了 <code>todo1</code> 和 <code>todo2</code> 和 <code>todo3</code>，那么在 <code>watermelon</code> 结束计时后其 <code>description</code> 就是 <code>todo1 + todo2 + todo3</code> 这种形式做自动填充。不过这个地方有些难度，主要在于代码实现比较难看所以我没继续添加了。我想了下有几种方案</p><ol><li>每次完成一个 <code>todos</code>，都向后端发送一个请求记录当前的 <code>todos</code> 到 <code>waterMelon</code> 中</li><li>将 <code>todos</code> 的数据用 <code>props</code> 传给 <code>waterMelon</code> 组件，只要 <code>todos</code> 有变化就改变 <code>waterMelon</code> 中的 <code>state.description</code></li><li>将 <code>description</code> 提升到 <code>redux</code> 中，每次完成一个 <code>todos</code>，发送一个 <code>actionType</code>，<code>waterMelon</code> 接受这个并不属于它的 <code>actionType</code>，将 <code>todo</code> 的 <code>description</code> 合并到 <code>waterMelon</code> 中</li><li>搞一个 window 全局变量存 <code>description</code>…</li></ol><p>首先我想要说明的是，这里我尽量想做到 <strong>高内聚低耦合</strong>，然而这里的尴尬之处在于要实现这样的功能，这两个组件在这点上居然是强耦合的，以致于说以上的方案虽然可行一点点，但是在代码上就非常的不整洁，因为</p><ol><li>每次发请求处理相当的麻烦，而且也不是一种优化，要知道请求一多也容易降低 app 的性能</li><li>这样做只能是在 <code>componentDidUpdate</code> 这个生命周期里面来 <code>setState</code>，处理一不小心就无限循环了，这还能行???</li><li>这样也不好，耦合了，而且这个功能并不是一开始就想出来的，而是后面加的，如果要该则需要改动代码的范围大，只能是重构有时间的情况下弄弄。代码一旦庞大就不好出手了，这也是很重要的一点。</li><li>这个想都不要想，全局变量污染的问题不应该再犯了…</li></ol><p>综上，由于这个功能十分的的蛋疼(因为点击完成一个 todo 既要更新 <code>todos</code> 的数据又要更新 <code>waterMelon</code> 的数据简单使用 <code>actionType</code> 来做区分是不现实的)，而且目前也没有找到一个更加优雅的解决方案，故先搁置(或许如果各位感兴趣了我可以重构的((<em>^_^</em>)), 先别慌老铁)</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总之 TypeScript 是真香，少了自由度但是多了类型检查，能够不太费力的解决编程中因为静态视力导致的一些超级低级的 bug，以及 react 也真香，函数即UI这种思想很棒，而且天然支持 TypeScript，社区活跃并且轮子很多，也不乏优秀的插件，也许这就是是我转向 react 的原因之一吧哈哈。</p><h2 id="文档参考"><a href="#文档参考" class="headerlink" title="文档参考"></a>文档参考</h2><p><a href="https://ant.design/docs/react/use-in-typescript-cn" target="_blank" rel="noopener">在 TypeScript 中使用</a><br><a href="https://ant.design/docs/react/migration-v4-cn" target="_blank" rel="noopener">从 V3 到 V4</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;注意，本项目是基于 &lt;code&gt;create-react-app&lt;/code&gt; 搭建，但是使用了 &lt;code&gt;--typescript&lt;/code&gt; 选项，所以是基于 &lt;code&gt;TypeScript&lt;/code&gt; 写的。另外，&lt;a href=&quot;https://github.com/strugglebak/watermelon-clock&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;项目地址在这里，求各位大佬看到了如果喜欢还请点个小星星(拜托啦这真的对我很重要 QAQ)&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="TypeScript" scheme="https://strugglebak.github.io/categories/TypeScript/"/>
    
      <category term="React" scheme="https://strugglebak.github.io/categories/TypeScript/React/"/>
    
    
      <category term="TypeScript" scheme="https://strugglebak.github.io/tags/TypeScript/"/>
    
      <category term="React" scheme="https://strugglebak.github.io/tags/React/"/>
    
      <category term="WaterMelon-clock" scheme="https://strugglebak.github.io/tags/WaterMelon-clock/"/>
    
  </entry>
  
  <entry>
    <title>txios-基于TypeScript的http库的实践总结</title>
    <link href="https://strugglebak.github.io/2020/03/14/txios-%E5%9F%BA%E4%BA%8ETypeScript%E7%9A%84http%E5%BA%93%E7%9A%84%E5%AE%9E%E8%B7%B5%E6%80%BB%E7%BB%93/"/>
    <id>https://strugglebak.github.io/2020/03/14/txios-基于TypeScript的http库的实践总结/</id>
    <published>2020-03-13T16:06:28.000Z</published>
    <updated>2022-06-04T08:13:29.071Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本次项目是对自己用 TypeScript 造的一个轮子的总结，麻雀虽小，但已经尽量五脏俱全，希望各位能多多 star(摩多摩多~)，<a href="https://github.com/strugglebak/txios" target="_blank" rel="noopener">毕竟项目地址都在这儿了各位 QAQ</a></p></blockquote><a id="more"></a><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><h3 id="使用的工具库"><a href="#使用的工具库" class="headerlink" title="使用的工具库"></a>使用的工具库</h3><p>这里罗列下使用到的一些工具库吧</p><ul><li><p>rollupjs</p><p>  这是一个帮助 txios 项目打包的库，打包方面没有选择 Webpack 的原因是因为这个比较好配置, <strong>API 简单</strong>。并且由于其<strong>基于 ES2015 模块</strong>，比 Webpack 使用的 CommonJS 模块机制更加高效，同时也更加容易执行 <strong><code>tree-shaking</code></strong></p></li><li><p>prettier/tslint</p><p>  这两个是比较重要的代码风格检查工具库了，在写一些工具库的时候尤其需要注意配合使用的</p></li><li><p>typeDoc</p><p>  文档生成工具，毕竟写一个库需要自动生成文档给开发者看，并且这个库也能帮忙部署到 Github page 上</p></li><li><p>commitizen</p><p>  主要用来规范 commit 提交信息，这个是很有好处的，清晰和规范的提交可以看出你对修改过的文件做了什么，这个是很重要的</p></li><li><p>Semantic-release</p><p>  这个库主要用来处理自动化版本管理和包发布用的。</p></li><li><p>husky</p><p>  使用这个工具，可以在每次的 git commit 之前执行已经定义好的 hook 脚本，可以用来自动化的检查代码质量</p></li><li><p>conventional-changelog</p><p>  当写完一个工具库，你做了啥修改，使用这个配合 Commitizen ，在生成 release 包时会自动将你所修改的 changeLog 发布出来</p></li><li><p>jest</p><p>  著名的测试工具库，主要是用于一些工具库或者 UI 组件库的测试。一般而言是配合 <code>chai</code>、<code>sion</code> 使用</p></li></ul><blockquote><p>⚠: 1.如果搭建环境过程中碰到了 <code>permission denied</code> 之类的字样，请<strong>关闭 vscode 试试</strong></p></blockquote><blockquote><p>⚠: 2.如果在项目中执行 <code>semantic-release</code> 时遇到了类似这样的错误 <code>SemanticReleaseError: No GitHub token specified</code>，请首先去你的 github 账号的 settings 那里的 Developer settings 里新建一个 Personal access tokens ( <a href="https://strugglebak.github.io/2020/03/11/%E9%85%8D%E7%BD%AE%E4%BB%A3%E7%A0%81%E8%A6%86%E7%9B%96%E7%8E%87%E5%BE%BD%E6%A0%87%E7%9A%84%E9%97%AE%E9%A2%98/">具体可参考我写的一篇博客</a> )，然后再到<strong>本地</strong>执行 <code>export GITHUB_TOKEN=&quot;你的 token&quot;</code>，最后再执行 <code>semantic-release</code> 即可。我想了下这可能是由于 <code>semantic-release</code> 是读取系统当前用户的环境变量所导致的，本地的 travis 并没有将其设置进环境变量中，而只是设置到项目的 <code>.travis.yml</code> 配置文件中了</p></blockquote><h3 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h3><p>一般来说，这里是先建立 <code>src</code> 以及 <code>test</code> 文件夹，<code>src</code> 就存放源码部分，<code>test</code> 就存放测试代码部分, <code>examples</code> 就存放代码的用例，当然这个用例跟测试用例是不一样的，这个只是方便写出了功能做调试用。你可以理解为 <code>examples</code> 就是这个库的一个应用了，可以在 <code>examples</code> 目录下新建一个 <code>webpack.config.js</code>，里面利用 webpack 的 <code>HotModuleReplacementPlugin</code> 插件建立模块热替换，当更改了模块之后就可以进行局部更新了。</p><p>这里还要强调的部分是对 <code>entry</code> 做了处理，因为 <code>examples</code> 下面有多个 demo 目录，而每个 demo 目录下都有 <code>app.ts</code> 文件作为这个 webpack 的入口文件, 因此 <code>entries</code> 需要收集 <code>examples</code> 下的这些个 <code>app.ts</code>，因为每个入口又引入了一个用于热更新的文件，所以看到的 <code>entry</code> 的配置基本如下</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"></span><br><span class="line">entry: fs.readdirSync(__dirname).reduce(<span class="function">(<span class="params">entries, dir</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> fullDir = path.join(__dirname, dir);</span><br><span class="line">  <span class="keyword">const</span> entryFile = path.join(fullDir, <span class="string">'app.ts'</span>);</span><br><span class="line">  <span class="keyword">if</span> (fs.statSync(fullDir).isDirectory() &amp;&amp; fs.existsSync(entryFile)) &#123;</span><br><span class="line">    entries[dir] = [<span class="string">'webpack-hot-middleware/client'</span>, entryFile];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> entries;</span><br><span class="line">&#125;, &#123;&#125;),</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>而基本上可以看到这里就是典型的多入口配置，代码的逻辑其实很简单</p><ul><li>读取当前目录下的各个 demo 目录的 <code>app.ts</code></li><li>构建诸如 <code>{&#39;demo&#39;: [&#39;webpack-hot-middleware/client&#39;, &#39;./demo/app.ts&#39;]}</code> 这样的 <code>entries</code> 对象</li><li>返回这个 <code>entries</code> 对象</li></ul><p>那么为何要加上这个 <code>webpack-hot-middleware/client</code> 呢？先别急，我们先在 <code>examples</code> 目录下构建这样一个 <code>server.js</code> 文件，然后引入 <code>webpack</code> 以及 <code>webpack.config.js</code></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>);</span><br><span class="line"><span class="keyword">const</span> middleware = <span class="built_in">require</span>(<span class="string">'webpack-dev-middleware'</span>);</span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>);</span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"><span class="keyword">const</span> complier = webpack(webpackConfig);</span><br><span class="line"></span><br><span class="line">app.use(</span><br><span class="line">  middleware(compiler, &#123;</span><br><span class="line">    <span class="comment">// webpack-dev-middleware options</span></span><br><span class="line">  &#125;)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>, () =&gt; <span class="built_in">console</span>.log(<span class="string">'Example app listening on port 3000!'</span>));</span><br></pre></td></tr></table></figure><p>这里我们是通过 <code>node server.js</code> 来启动这个应用，然后引入 <code>webpack</code> 以及 <code>webpack.config.js</code> 来打包这个应用，然而这里我们还要引入一个包叫 <code>webpack-hot-middleware</code>，如果需要做热更新的话，需要在每个入口文件处引入 <code>hot middleware client</code>，具体的做法就是上面说的，在入口文件处添加 <code>webpack-hot-middleware/client</code> 就好</p><p>添加完后，在 <code>server.js</code> 中添加</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> webpackHotMiddleware = <span class="built_in">require</span>(<span class="string">'webpack-hot-middleware'</span>);</span><br><span class="line">...</span><br><span class="line">app.use(webpackHotMiddleware(complier));</span><br></pre></td></tr></table></figure><p><code>examples</code> 目录下应用 <code>demo</code> 的目录基本是这样的形式，<code>demo</code> 有两个文件</p><ul><li><code>app.ts</code></li><li><code>index.html</code></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// demo/app.ts</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> txios <span class="keyword">from</span> <span class="string">'../../src/index'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行 txios 相关的操作</span></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">// demo/index.html</span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Demo example<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  // 注意这里引入了生成好的 demo.js，也就是被编译好的当前目录下的 app.ts !!!</span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"/__build__/demo.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="其他工具的配置"><a href="#其他工具的配置" class="headerlink" title="其他工具的配置"></a>其他工具的配置</h3><p>说几个比较重要的</p><h4 id="非工作流工具配置"><a href="#非工作流工具配置" class="headerlink" title="非工作流工具配置"></a>非工作流工具配置</h4><ul><li><p>编辑器的配置，用于规范团队代码、文档在 vscode 上的统一编辑以及显示的 <code>.editorconfig</code></p>  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// .editorconfig</span><br><span class="line"><span class="comment">#root = true</span></span><br><span class="line">[*] <span class="comment"># 表示匹配所有文件</span></span><br><span class="line">end_of_line = lf <span class="comment">#  当一行文字被回车时，对应的回车字符为 lf</span></span><br><span class="line">charset = utf-8 <span class="comment"># 使用 utf-8 编码</span></span><br><span class="line">trim_trailing_whitespace = <span class="literal">false</span> <span class="comment"># 不从行尾删除空白</span></span><br><span class="line">insert_final_newline = <span class="literal">true</span> <span class="comment"># 文件以换行结束</span></span><br><span class="line">indent_style = space <span class="comment"># 以空格作为 tab</span></span><br><span class="line">indent_size = 2 <span class="comment"># tab 间距为 2 个 space 宽度</span></span><br><span class="line"></span><br><span class="line">[&#123;*.yml,*.json&#125;] <span class="comment"># 匹配 .yml .json 文件</span></span><br><span class="line">indent_style = space <span class="comment"># 以空格作为 tab</span></span><br><span class="line">indent_size = 2 <span class="comment"># tab 间距为 2 个 space 宽度</span></span><br></pre></td></tr></table></figure></li><li><p>检查正在编辑的代码的语法的 <code>.eslintrc</code></p>  <figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">// .eslintrc</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"parserOptions"</span>: &#123; <span class="comment">// 解析选项</span></span><br><span class="line">    <span class="attr">"ecmaVersion"</span>: <span class="number">2017</span> <span class="comment">// 使用 es2017</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"env"</span>: &#123;</span><br><span class="line">    <span class="attr">"es6"</span>: <span class="literal">true</span> <span class="comment">// 支持 es6 以及新的 es6 全局变量</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>用于检查编写的 js 代码中的可疑部分的 <code>.jshintrc</code></p>  <figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">// .jshitrc</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"esversion"</span>: <span class="number">6</span> <span class="comment">// 指定代码必须遵循 es6 版本</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>用于指定 TypeScript 编译选项的 <code>tsconfig.json</code></p>  <figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">// tsconfig.json</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"compilerOptions"</span>: &#123; <span class="comment">// 编译选项配置</span></span><br><span class="line">    <span class="attr">"moduleResolution"</span>: <span class="string">"node"</span>, <span class="comment">// 以 Nodejs 方式 resolve 模块</span></span><br><span class="line">    <span class="attr">"target"</span>: <span class="string">"es5"</span>, <span class="comment">// 指定 es 的目标版本，其默认是 es3</span></span><br><span class="line">    <span class="attr">"module"</span>:<span class="string">"es2015"</span>, <span class="comment">// 指定模块代码以 es2015 的方式生成</span></span><br><span class="line">    <span class="attr">"lib"</span>: [<span class="string">"es2015"</span>, <span class="string">"es2016"</span>, <span class="string">"es2017"</span>, <span class="string">"dom"</span>], <span class="comment">// 指定要包含在编译中的库文件列表(编译时要包含进 es5/6/7 以及 DOM 的一些 API)</span></span><br><span class="line">    <span class="attr">"strict"</span>: <span class="literal">true</span>, <span class="comment">// 启用所有的严格类型检查选项</span></span><br><span class="line">    <span class="attr">"sourceMap"</span>: <span class="literal">true</span>, <span class="comment">// 编译后要生成 .map 源码映射文件</span></span><br><span class="line">    <span class="attr">"declaration"</span>: <span class="literal">true</span>, <span class="comment">// 编译后要生成 .d.ts 声明文件</span></span><br><span class="line">    <span class="attr">"allowSyntheticDefaultImports"</span>: <span class="literal">true</span>, <span class="comment">// 默认允许 import 那些没有进行 default export 的模块(这不影响代码的 export，只是会影响到类型检查)</span></span><br><span class="line">    <span class="attr">"experimentalDecorators"</span>: <span class="literal">true</span>, <span class="comment">// 启用对 es 装饰器语法的支持</span></span><br><span class="line">    <span class="attr">"emitDecoratorMetadata"</span>: <span class="literal">true</span>, <span class="comment">// 启用对 reflect-metadata 库的支持</span></span><br><span class="line">    <span class="attr">"declarationDir"</span>: <span class="string">"dist/types"</span>, <span class="comment">// 定义编译后生成的声明文件的输出目录为 dist/types</span></span><br><span class="line">    <span class="attr">"outDir"</span>: <span class="string">"dist/lib"</span>, <span class="comment">// 定义编译后代码文件的输出目录为 dist/lib</span></span><br><span class="line">    <span class="attr">"typeRoots"</span>: [ <span class="comment">// 编译过程中只考虑编译 node_modules/@types 下的包</span></span><br><span class="line">      <span class="string">"node_modules/@types"</span></span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"include"</span>: [ <span class="comment">// 只编译 src 下的源码文件</span></span><br><span class="line">    <span class="string">"src"</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>用于检查编写的 ts 代码中可读性、可维护性和功能错误的 <code>tslint.json</code></p>  <figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">// tslint.json</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"extends"</span>: [ <span class="comment">// 指定使用 tslint-config-standard 和 tslint-config-prettier 来检查</span></span><br><span class="line">    <span class="string">"tslint-config-standard"</span>,</span><br><span class="line">    <span class="string">"tslint-config-prettier"</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>用于测试代码的 <code>jest.config.js</code></p>  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// jest.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="string">"verbose"</span>: <span class="literal">true</span>, <span class="comment">// 指定在运行期间需要报告测试结果</span></span><br><span class="line">  <span class="string">"transform"</span>: &#123; <span class="comment">// 转换器</span></span><br><span class="line">    <span class="string">".(ts|tsx)"</span>: <span class="string">"ts-jest"</span> <span class="comment">// 使用 ts-jest 对 .ts/.tsx 文件代码进行测试</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"testEnvironment"</span>: <span class="string">"jsdom"</span>, <span class="comment">// 使用 jsdom 来作为测试环境</span></span><br><span class="line">  <span class="string">"testRegex"</span>: <span class="string">"(/__tests__/.*|\\.(test|spec))\\.(ts|tsx|js)$"</span>, <span class="comment">// 测试 __test__ 目录下所有的以 .test/.spec 作为中间名的、以 .ts/.tsx/.js 结尾的文件</span></span><br><span class="line">  <span class="string">"moduleFileExtensions"</span>: [ <span class="comment">// 模块文件拓展，测试文件中引入的模块支持 .ts/.tsx/.js 模块</span></span><br><span class="line">    <span class="string">"ts"</span>,</span><br><span class="line">    <span class="string">"tsx"</span>,</span><br><span class="line">    <span class="string">"js"</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="string">"coveragePathIgnorePatterns"</span>: [ <span class="comment">// 执行测试时需要过滤掉的一些目录 node_modules 和 test</span></span><br><span class="line">    <span class="string">"/node_modules/"</span>,</span><br><span class="line">    <span class="string">"/test/"</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="string">"coverageThreshold"</span>: &#123; <span class="comment">// 代码测试覆盖率设定</span></span><br><span class="line">    <span class="string">"global"</span>: &#123; <span class="comment">// 指定一个全局的设定</span></span><br><span class="line">      <span class="string">"branches"</span>: <span class="number">90</span>, <span class="comment">// 测试能覆盖到 90% 的代码分支</span></span><br><span class="line">      <span class="string">"functions"</span>: <span class="number">95</span>, <span class="comment">// 测试能覆盖到 95% 的函数</span></span><br><span class="line">      <span class="string">"lines"</span>: <span class="number">95</span>, <span class="comment">// 测试能覆盖到 95% 的代码行数</span></span><br><span class="line">      <span class="string">"statements"</span>: <span class="number">95</span> <span class="comment">// 测试能覆盖到 95% 的声明</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"collectCoverageFrom"</span>: [ <span class="comment">// 从以下文件中收集测试代码覆盖率的信息</span></span><br><span class="line">    <span class="string">"src/*.&#123;js,ts&#125;"</span>, <span class="comment">// src 下的当前目录的 .js 或者 .ts 文件</span></span><br><span class="line">    <span class="string">"src/**/*.&#123;js,ts&#125;"</span> <span class="comment">// src 下的子目录的 .js 或者 .ts 文件</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="string">"setupFilesAfterEnv"</span>: [ <span class="comment">// 在测试之前需要运行的一些启动或者配置文件</span></span><br><span class="line">    <span class="string">"&lt;rootDir&gt;/test/boot.ts"</span> <span class="comment">// 项目根目录下的 test/boot.ts</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  在 <code>boot.ts</code> 中写了什么呢</p>  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// test/boot.ts</span></span><br><span class="line"><span class="keyword">const</span> JasmineCore = <span class="built_in">require</span>(<span class="string">'jasmine-core'</span>)</span><br><span class="line"><span class="comment">// @ts-ignore</span></span><br><span class="line">global.getJasmineRequireObj = <span class="function"><span class="params">()</span> =&gt;</span> JasmineCore</span><br><span class="line"><span class="built_in">require</span>(<span class="string">'jasmine-ajax'</span>)</span><br></pre></td></tr></table></figure><p>  因为这里需要测试 ajax，所以这里用到了 <code>jasmine-ajax</code>，而这个库依赖于 <code>jasmine-core</code>。而为了能让 <code>jasmine-ajax</code> 这个插件运行成功，需要手动添加全局的 <code>getJasmineRequireObj</code> 方法，这样每次在启动测试的时候都会去加载这个插件，那么在测试时就可以使用 <code>jasmine-ajax</code> 了</p></li><li><p>用于整理和打包库的 <code>rollup.config.js</code></p>  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// rollup.config.js</span></span><br><span class="line"><span class="keyword">import</span> resolve <span class="keyword">from</span> <span class="string">'rollup-plugin-node-resolve'</span></span><br><span class="line"><span class="keyword">import</span> commonjs <span class="keyword">from</span> <span class="string">'rollup-plugin-commonjs'</span></span><br><span class="line"><span class="keyword">import</span> sourceMaps <span class="keyword">from</span> <span class="string">'rollup-plugin-sourcemaps'</span></span><br><span class="line"><span class="keyword">import</span> camelCase <span class="keyword">from</span> <span class="string">'lodash.camelcase'</span></span><br><span class="line"><span class="keyword">import</span> typescript <span class="keyword">from</span> <span class="string">'rollup-plugin-typescript2'</span></span><br><span class="line"><span class="keyword">import</span> json <span class="keyword">from</span> <span class="string">'rollup-plugin-json'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> pkg = <span class="built_in">require</span>(<span class="string">'./package.json'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> libraryName = <span class="string">'txios'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  input: <span class="string">`src/index.ts`</span>, <span class="comment">// 入口文件</span></span><br><span class="line">  output: [ <span class="comment">// 出口文件</span></span><br><span class="line">    <span class="comment">// 一个用来打包成 umd</span></span><br><span class="line">    &#123; <span class="attr">file</span>: pkg.ain, <span class="attr">name</span>: camelCase(libraryName), <span class="attr">format</span>: <span class="string">'umd'</span>, <span class="attr">sourcemap</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">    <span class="comment">// 一个用来打包成 es5</span></span><br><span class="line">    &#123; <span class="attr">file</span>: pkg.module, <span class="attr">format</span>: <span class="string">'es'</span>, <span class="attr">sourcemap</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">  ],</span><br><span class="line">  <span class="comment">// 指定不会被打包的源码目录</span></span><br><span class="line">  external: [],</span><br><span class="line">  watch: &#123; <span class="comment">// 如果 include 配置下的 src/ 目录下的某个模块源码变更，则自动进行打包</span></span><br><span class="line">    include: <span class="string">'src/**'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [ <span class="comment">// rollup 插件</span></span><br><span class="line">    <span class="comment">// 允许 resolve json 文件</span></span><br><span class="line">    json(),</span><br><span class="line">    <span class="comment">// 编译 TypeScript 文件</span></span><br><span class="line">    <span class="comment">// 并且编译的声明文件将在 tsconfig 中指定的目录中发出</span></span><br><span class="line">    typescript(&#123; <span class="attr">useTsconfigDeclarationDir</span>: <span class="literal">true</span> &#125;),</span><br><span class="line">    <span class="comment">// 允许打包 commonjs 模块</span></span><br><span class="line">    commonjs(),</span><br><span class="line">    <span class="comment">// 允许 resolve node_modules 下的文件，可以使用 'external' 属性去控制</span></span><br><span class="line">    <span class="comment">// 哪个 external 模块是被包含进打包后的文件中的</span></span><br><span class="line">    <span class="comment">// https://github.com/rollup/rollup-plugin-node-resolve#usage</span></span><br><span class="line">    resolve(),</span><br><span class="line"></span><br><span class="line">    <span class="comment">// resolve 对应源码的源码映射文件</span></span><br><span class="line">    sourceMaps(),</span><br><span class="line">  ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="工作流工具配置"><a href="#工作流工具配置" class="headerlink" title="工作流工具配置"></a>工作流工具配置</h4><p>最后再讲讲这个 git commit 以及自动发布 release 如何形成一个 flow 流的。首先我们前面提到了几个工具</p><ul><li>husky</li><li>commitizen</li><li>jest</li><li>conventional-changelog</li><li>semantic-release</li></ul><p>然后看看 <code>package.json</code> 里面是怎么写的，几个相关的配置如下</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">// package.json</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="attr">"scripts"</span>: &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="attr">"test"</span>: <span class="string">"jest --coverage --config ./jest.config.js"</span>,</span><br><span class="line">    <span class="attr">"test:watch"</span>: <span class="string">"jest --coverage --watch --config ./jest.config.js"</span>,</span><br><span class="line">    <span class="attr">"test:prod"</span>: <span class="string">"npm run lint &amp;&amp; npm run test -- --no-cache"</span>,</span><br><span class="line">    <span class="attr">"commit"</span>: <span class="string">"git-cz"</span>,</span><br><span class="line">    <span class="attr">"sr"</span>: <span class="string">"semantic-release"</span>,</span><br><span class="line">    <span class="attr">"srp"</span>: <span class="string">"ts-node tools/semantic-release-prepare"</span>,</span><br><span class="line">    <span class="attr">"pre-commit"</span>: <span class="string">"lint-staged"</span>,</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"lint-staged"</span>: &#123;</span><br><span class="line">    <span class="attr">"&#123;src,test&#125;/**/*.ts"</span>: [</span><br><span class="line">      <span class="string">"prettier --write"</span>,</span><br><span class="line">      <span class="string">"git add"</span></span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"husky"</span>: &#123;</span><br><span class="line">    <span class="attr">"hooks"</span>: &#123;</span><br><span class="line">      <span class="attr">"commit-msg"</span>: <span class="string">"commitlint -E HUSKY_GIT_PARAMS"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"config"</span>: &#123;</span><br><span class="line">    <span class="attr">"commitizen"</span>: &#123;</span><br><span class="line">      <span class="attr">"path"</span>: <span class="string">"node_modules/cz-conventional-changelog"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"prettier"</span>: &#123;</span><br><span class="line">    <span class="attr">"semi"</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">"singleQuote"</span>: <span class="literal">true</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"commitlint"</span>: &#123;</span><br><span class="line">    <span class="attr">"extends"</span>: [</span><br><span class="line">      <span class="string">"@commitlint/config-conventional"</span></span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当 <code>src</code> 下或者 <code>test</code> 目录下的代码文件产生变动后，执行 <code>yarn commit</code>时 ，会先触发 <code>lint-staged</code><br>，<code>lint-staged</code> 里面会先执行 <code>prettier</code> 将代码进行格式化，然后执行 <code>git add</code>。这个执行完之后，就可以执行 <code>git-cz</code> 了，<code>git-cz</code> 是 <code>commitizen</code> 包里面的一个工具，它就会找到 <code>cz-cli</code> 以及 <code>cz-conventional-changelog</code> 这两个工具并执行，执行后会生成如下的命令行界面</p><p><img src="./1.png" alt></p><p>格式都做好了，其他的就是自己选择自己根据提示来 commit message 就好</p><p>在输入的信息完成之后，就会交给 <code>husky</code> 去拦截 git 的 hooks，它一旦发现有 <code>commit msg</code> 要提交了就去拦截，然后执行操作 <code>commitlint -E HUSKY_GIT_PARAMS</code>，<code>commitlint</code> 是一个检查 <code>commit msg</code> 是否符合要求的一个库，这句话的意思是通过 <code>commitlint</code> 这个工具与它自己定义的 <code>HUSKY_GIT_PARAMS</code> 变量结合起来，若 commit 不符合要求，则此次 commit 算作失败</p><p>一般而言，符合 <code>commitlint</code> 要求的 commit 是像下面这样的</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">chore: run tests on travis ci</span><br><span class="line">fix(server): send cors headers</span><br><span class="line">feat(blog): add comment section</span><br></pre></td></tr></table></figure><p>其实这些都是根据 <a href="https://www.conventionalcommits.org/en/v1.0.0/" target="_blank" rel="noopener">传统提交格式</a> 来的。</p><p>总结一下这个工作流，简单而言就是如下</p><ol start="0"><li>代码变更了，我要提交代码，执行 <code>yarn commit</code></li><li><code>lint-staged</code> –&gt; <code>prettier</code> –&gt; <code>git add</code>(格式化代码)</li><li><code>git-cz</code> –&gt; <code>cz-cli</code> –&gt; <code>cz-conventional-changelog</code>(生成选择 commit 格式的界面并记录 changelog)</li><li><code>husky</code>(提供 commit 钩子并触发 <code>commitlint</code>)</li><li><code>commitlint</code>(检查 commit 是否满足要求)</li></ol><p>对于发布一个 release 包而言，其实逻辑都差不多。在执行 <code>yarn sr</code> 时，会执行 <code>semantic-release</code>，这里不做配置会直接校验 npm 的 token 和 github 的 token，校验过后它就会分析你的 commit 然后生成一个 changelog 并上传至 github 。如果想在这条命令之前执行代码测试直接在前面加上 <code>yarn test</code> 即可</p><h2 id="Feature-实现"><a href="#Feature-实现" class="headerlink" title="Feature 实现"></a>Feature 实现</h2><p>这里就大体实现的有一些功能做个总结吧。在 <a href="https://github.com/strugglebak/txios/blob/master/README.md" target="_blank" rel="noopener">txios 的文档</a> 上也有说明</p><ul><li>支持使用 XMLHttpRequest 对象通信</li><li>支持 Promise API</li><li>支持请求/响应拦截以及其过程中的数据转换</li><li>支持取消请求</li><li>支持自动转换 JSON 数据</li><li>客户端支持 XSRF 防御</li></ul><h3 id="支持使用-XMLHttpRequest-对象通信"><a href="#支持使用-XMLHttpRequest-对象通信" class="headerlink" title="支持使用 XMLHttpRequest 对象通信"></a>支持使用 XMLHttpRequest 对象通信</h3><p>其实这里面就是对 <code>XMLHttpRequest</code> 对象的封装。这里整体封装的逻辑是，先写一个大体的逻辑，就是封装一个函数，然后再在其他地方引入这个函数做测试。这个大体的框架是什么呢，就是如下的代码</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">xhr</span>(<span class="params">config: TxiosRequestConfig</span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; data = <span class="literal">null</span>, url, method = <span class="string">'get'</span> &#125; = config</span><br><span class="line">  <span class="keyword">const</span> request = <span class="keyword">new</span> XMLHttpRequest()</span><br><span class="line">  request.open(method.toUpperCase(), url, <span class="literal">true</span>)</span><br><span class="line">  request.send(data)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最开始其只有一个 <code>open</code> 跟 <code>send</code>，功能极为简陋，所以需要在上面添砖加瓦。<br>一般来说需要处理的东西包括</p><ul><li>请求的 url 数据</li><li>请求的 body 数据</li><li>请求的 header 数据</li><li>响应的数据</li><li>响应的 header 数据</li></ul><p>所以在这里面，除了要对请求的数据做处理之外，还需要对响应的数据做处理。这一部分主要的操作就是需要定义 <code>TxiosRequestConfig</code> 的类型，因为请求配置的参数很重要，所以在这里可以看到一堆的类型声明。这里有一个比较特别的声明叫做 <strong>字符串索引</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/types/index.ts</span></span><br><span class="line"><span class="keyword">export</span> interface TxiosRequestConfig &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  [propName: string]: any</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种就是字符串索引签名了，一般会在 <code>xxx[key]</code> 这种方式去访问一个对象内部 <code>key</code> 对应的 <code>value</code> 时用上。</p><p>这里需要注意的一下就是，在对处理请求的 body 数据时(因为要转换成 JSON 字符串发送出去)，会用到一个判断其是不是”普通”的对象的函数，如下所式</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">isNormalObject</span> (<span class="params">val: any</span>): <span class="title">val</span> <span class="title">is</span> <span class="title">Object</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> toString.call(val) === <span class="string">'[object Object]'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于 <code>val !== null &amp;&amp; typeof val === &#39;object&#39;</code> 这种方式虽然也能判断一个数是否为对象，但是其已经包括了 <code>FormData</code> 或者 <code>ArrayBuffer</code> 这样的类型了。而这些类型在 body 中是不需要处理成 JSON 字符串的(<code>JSON.stringify</code>)，如果是 <code>FormData</code> 类似这种类型的直接返回 data 就好不需要做处理</p><p>在处理 url 参数上需要注意的情况比较多，一般而言有如下几种</p><ul><li>参数值为数组的</li><li>参数值为对象的</li><li>参数值为 Date 类型的</li><li>还有一些特殊字符的</li><li>一些空值如 null 或者 undefined</li><li>有 hash 参数的比如 # 后面的</li><li>已经有参数的</li></ul><p>需要对这些参数遍历之后重新建立新的 url，对这些条件判断后拼接字符串</p><p>在对异常处理的方面，有两个要注意的点</p><ul><li>使用 TypeScript 继承一个内置对象时，需要使用在你继承的类中使用 <code>Object.setPrototypeOf(this, 你的类.prototype)</code> 才能做到正确的继承</li><li>为了使得代码更加简化，可以为类对外暴露一个 <strong>工厂方法</strong></li></ul><p>什么是工厂方法？工厂方法指的是<strong>一个函数</strong>接受参数并返回一个 <code>new</code> 过的对象，这样在下次使用时就不必频繁的 <code>new</code> 了，直接调用这个方法即可</p><h3 id="支持-Promise-API"><a href="#支持-Promise-API" class="headerlink" title="支持 Promise API"></a>支持 Promise API</h3><p>首先需要构建一个 <code>TxiosPromise</code> 的接口，这个接口继承自 Promise</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/types/index.ts</span></span><br><span class="line"><span class="keyword">export</span> interface TxiosPromise extends <span class="built_in">Promise</span>&lt;TxiosResponse&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意这里的 <code>Promise</code> 在返回后其 <code>resolve</code> 或者 <code>reject</code> 中的 <code>data</code> 就是 <code>TxiosResponse</code> 类型的</p><p>然后需要在 <code>Txios</code> 这个接口中的每个扩展方法的后面都要加上 <code>TxiosPromise</code> 作为返回值的声明</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/types/index.ts</span></span><br><span class="line"><span class="keyword">export</span> interface Txios &#123;</span><br><span class="line">  <span class="keyword">get</span>&lt;T = any&gt;(url: string, config?: TxiosRequestConfig): TxiosPromise</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在封装 <code>XMLHttpRequest</code> 那块的代码上也需要加上 <code>TxiosPromise</code> 的声明并返回一个 <code>new Promise</code></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/core/xhr.ts</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">xhr</span>(<span class="params">config: TxiosRequestConfig</span>): <span class="title">TxiosPromise</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么这里还有个问题，即如何让响应的数据支持泛型呢？首先需要对 <code>TxiosResponse</code> 做改造</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/types/index.ts</span></span><br><span class="line"><span class="keyword">export</span> interface TxiosResponse&lt;T = any&gt; &#123;</span><br><span class="line">  data: T</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样 <code>data</code> 就是泛型的数据了，接下来还要对上文中出现的 <code>TxiosPromise</code> 做一个改造，使其也变成一个泛型的接口</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/types/index.ts</span></span><br><span class="line"><span class="keyword">export</span> interface TxiosPromise&lt;T = any&gt; extends <span class="built_in">Promise</span>&lt;TxiosResponse&lt;T&gt;&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样在 <code>Promise</code> 中 <code>resolve</code> 或者 <code>reject</code> 的 <code>data</code> 就是 <code>TxiosResponse&lt;T&gt;</code> 类型的了，需要注意的是这个 <code>data</code> 中还有个 <code>data</code>(这个是在 <code>TxiosResponse</code> 中定义过的) 是 <code>T</code> 类型。<code>TxiosPromise&lt;T = any&gt;</code> 这个表示 <code>resolve</code> 或 <code>reject</code> 的 <code>data</code> 可以是 <code>T</code> 类型的数据</p><h3 id="支持请求-响应拦截以及其过程中的数据转换"><a href="#支持请求-响应拦截以及其过程中的数据转换" class="headerlink" title="支持请求/响应拦截以及其过程中的数据转换"></a>支持请求/响应拦截以及其过程中的数据转换</h3><p>首先拦截器的工作原理可以用一张图来描述</p><p><img src="./2.png" alt></p><p>一般我们使用 <code>txios.interceptors.request.use</code> 来添加请求拦截器，使用 <code>txios.interceptors.response.use</code> 来添加响应拦截器。由上图可以知道，拦截器的执行顺序是 <strong>链式调用的</strong>，并且每个拦截器都支持 <strong>同步和异步</strong>的处理。所以这里最终还是采用 <code>Promise</code> 链式调用去实现这个功能。</p><p>实现的逻辑大概是这样的</p><ul><li><p>首先定义个拦截器的总体的管理类，它里面有两个方法: <code>use</code>(添加拦截器) 和 <code>eject</code>(删除拦截器)。</p>  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/types/index.ts</span></span><br><span class="line"><span class="keyword">export</span> interface TxiosInterceptorManager&lt;T&gt; &#123;</span><br><span class="line">  use(resolved: ResolvedFn&lt;T&gt;, rejected?: RejectedFn): number</span><br><span class="line">  eject(id: number): <span class="keyword">void</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>use</code> 方法里面有 <code>resolve</code> 和 <code>reject</code> 方法，所以这俩也是要定义的</p>  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/types/index.ts</span></span><br><span class="line"><span class="keyword">export</span> interface ResolvedFn&lt;T = any&gt; &#123;</span><br><span class="line">  (value: T): T | <span class="built_in">Promise</span>&lt;T&gt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> interface RejectedFn &#123;</span><br><span class="line">  (error: any): any</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>接下来去实现这个管理类的时候，基本上就是去实现 <code>use</code> 和 <code>eject</code>。注意这个类里面维护了一个私有的 <code>interceptors</code> 数组</p>  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/core/interceptor.ts</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">InterceptorManager</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// use 就是将 resolve 和 reject push 进这个数组中并返回一个位置 id</span></span><br><span class="line">  use(resolved: ResolvedFn&lt;T&gt;, rejected?: RejectedFn): number &#123;</span><br><span class="line">    <span class="keyword">this</span>.interceptors.push(&#123; resolved, rejected &#125;)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.interceptors.length - <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// eject 就是拿到位置 id 然后删除拦截器</span></span><br><span class="line">  eject(id: number): <span class="keyword">void</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.interceptors[id]) <span class="keyword">this</span>.interceptors[id] = <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这里还写了个 forEach 函数用来遍历拦截器并执行它传入的拦截器</span></span><br><span class="line">  forEach(fn: <span class="function">(<span class="params">interceptor: Interceptor&lt;T&gt;</span>) =&gt;</span> <span class="keyword">void</span>): <span class="keyword">void</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.interceptors.forEach(<span class="function"><span class="params">interceptor</span> =&gt;</span> &#123;</span><br><span class="line">      interceptor &amp;&amp; fn(interceptor)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li><li><p>需要在发送请求的逻辑中构建 <code>Promise</code> 链，这个链的接口定义是这样的</p>  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/core/txios-core.ts</span></span><br><span class="line">interface PromiseChain &#123;</span><br><span class="line">  resolved: ResolvedFn | <span class="function">(<span class="params">(config: TxiosRequestConfig</span>) =&gt;</span> TxiosPromise)</span><br><span class="line">  rejected?: RejectedFn</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在 <code>TxiosCore</code> 这个方法中构造 <code>interceptors</code></p>  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/core/txios-core.ts</span></span><br><span class="line"><span class="keyword">constructor</span>(initConfig: TxiosRequestConfig) &#123;</span><br><span class="line">  <span class="keyword">this</span>.interceptors = &#123;</span><br><span class="line">    request: <span class="keyword">new</span> InterceptorManager&lt;TxiosRequestConfig&gt;(),</span><br><span class="line">    response: <span class="keyword">new</span> InterceptorManager&lt;TxiosResponse&gt;()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>然后在 <code>request</code> 这个请求方法中开始构建这个 <code>Promise Chain</code></p>  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/core/txios-core.ts</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">TxiosCore</span> </span>&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  request(url: any, config?: any): TxiosPromise &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">const</span> chain: PromiseChain[] = [</span><br><span class="line">      &#123;</span><br><span class="line">        resolved: dispatchRequest,</span><br><span class="line">        rejected: <span class="literal">undefined</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关键代码!!!</span></span><br><span class="line">    <span class="keyword">this</span>.interceptors.request.forEach(<span class="function"><span class="params">interceptor</span> =&gt;</span> &#123;</span><br><span class="line">      chain.unshift(interceptor) <span class="comment">// 插入到 chain 前面</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">this</span>.interceptors.response.forEach(<span class="function"><span class="params">interceptor</span> =&gt;</span> &#123;</span><br><span class="line">      chain.push(interceptor) <span class="comment">// 插入到 chain 后面</span></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> promise = <span class="built_in">Promise</span>.resolve(config)</span><br><span class="line">    <span class="comment">// 循环这个 chain 拿到每个拦截器对象</span></span><br><span class="line">    <span class="comment">// 将其 resolved 以及 rejected 函数添加到 promise.then 的参数中</span></span><br><span class="line">    <span class="comment">// 通过 Promise 链式调用方式，可实现拦截器一层一层链式调用效果</span></span><br><span class="line">    <span class="keyword">while</span> (chain.length) &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123; resolved, rejected &#125; = chain.shift()!</span><br><span class="line">      promise = promise.then(resolved, rejected)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> promise</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  这里链式调用的直接效果，就是其执行完了拦截器之后的代码逻辑之后再发送请求。但是这里需要注意，<strong>拦截响应的逻辑同时也执行了</strong>，也就是说如果你在拦截响应的逻辑中对其 response 的 data 做了什么赋值操作的话，那么最终返回结果就是你拦截之后的结果。其实很好理解，要实现拦截器的真正效果，其核心就是 <strong>优先执行拦截器中的代码逻辑</strong></p></li></ul><h3 id="支持取消请求"><a href="#支持取消请求" class="headerlink" title="支持取消请求"></a>支持取消请求</h3><p>这个功能的适用场景是这样的，一般而言在搜索框输入的时候，如果第一次输入发出请求了，紧接着第二次输入也发出请求了，但是万一第二次输入的请求服务端反应比较快，一下子就返回了，而第一次请求服务端的反应比较慢，等很久之后才返回。这样就会出现一种情况，<strong>前面请求结果把后面的请求结果给覆盖了</strong>，这是用户极为不愿意看到的。所以如果在这种情况下，如果前面的请求响应很慢或者已经没办法响应了，就直接取消掉它就能解决这个问题了</p><p>实现的思路是这样的</p><ul><li>要取消请求，需要为该请求配置一个 <code>CancelToken</code> 来表示取消这次请求的操作，然后在外部调用一个 <code>cancel</code> 方法来取消</li><li><code>cancel</code> 方法本质上是通过执行 <code>XMLHttpRequest</code> 的 <code>abort</code> 方法来取消请求的</li><li>但是由于请求是异步的，而且取消请求操作是用户设置的，并且用户是访问不到这个 <code>XMLHttpRequest</code> 对象的。那么用什么方法才能做到，我外部调用一个 <code>cancel</code> 方法，就能通知到其内部的 <code>XMLHttpRequest</code> 对象，自动执行 <code>abort</code> 终止请求操作呢？</li><li>有个办法是这样的，在 <code>CancelToken</code> 内部维护一个 <code>Promise</code> 的对象，最开始设定这个 <code>Promise</code> 对象内部的 <code>state</code> 为 <code>pending</code> 状态。当我们外部调用了 <code>cancel</code> 方法后，会将这个 <code>CancelToken</code> 内部的 <code>Promise</code> 对象的 <code>state</code> 转变成 <code>fulfilled</code> 状态，这样的话如果之前就写了 <code>CancelToken.promise.then</code>，那么它就会<strong>自动执行</strong> <code>then</code> 里面的逻辑，在 <code>then</code> 里面直接调用 <code>abort</code> 就可以了</li></ul><p>调用是这么调用的</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 该请求通过 cancel() 方式取消</span></span><br><span class="line"><span class="keyword">let</span> cancel: Canceler;</span><br><span class="line">txios.get(<span class="string">'/cancel/get'</span>, &#123;</span><br><span class="line">  cancelToken: <span class="keyword">new</span> CancelToken(<span class="function"><span class="params">c</span> =&gt;</span> &#123; cancel = c &#125;)</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (txios.isCancel(e)) <span class="built_in">console</span>.log(<span class="string">'Request canceled'</span>);</span><br><span class="line">&#125;);</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123; cancel() &#125;, <span class="number">200</span>);</span><br></pre></td></tr></table></figure><p>然后基于 <code>XMLHttpRequest</code> 对象封装下的 <code>xhr</code> 的内部是这样子判断的</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/core/xhr.ts</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// 设置取消请求</span></span><br><span class="line"><span class="keyword">if</span> (cancelToken) &#123;</span><br><span class="line">  cancelToken.promise</span><br><span class="line">    .then(<span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">      request.abort()</span><br><span class="line">      reject(reason)</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// TODO</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了使用例子和以上的说明，核心代码就很好理解了</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/cancel/cancelToken.ts</span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">CancelToken</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">constructor</span>(executor: CancelExecutor) &#123; <span class="comment">// executor 是一个 callback !!!</span></span><br><span class="line">    <span class="keyword">let</span> resolvePromise: ResolvePromise <span class="comment">// resolvePromise 是一个函数 !!!</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// this.promise 用来表示一个 pending 状态的 Promise 对象</span></span><br><span class="line">    <span class="keyword">this</span>.promise = <span class="keyword">new</span> <span class="built_in">Promise</span>&lt;Cancel&gt;(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">      resolvePromise = resolve <span class="comment">// 注意这里将这个 resolve 函数保存起来了 !!!</span></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行传入的 executor 函数, 传的参数是一个 cancel 函数</span></span><br><span class="line">    <span class="comment">// 此时 executor === (c) =&gt; &#123; cancel = c &#125;</span></span><br><span class="line">    <span class="comment">// c 是 executor 的参数</span></span><br><span class="line">    <span class="comment">// 此时 c === (message) =&gt; &#123;...&#125;</span></span><br><span class="line">    <span class="comment">// 因为此时参数是一个函数</span></span><br><span class="line">    executor(<span class="function"><span class="params">message</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">      <span class="comment">// 此时 this.promise 会从 pending 状态变为 resolved 状态</span></span><br><span class="line">      <span class="comment">// 便于外部可以做 xxx.promise.then 的调用</span></span><br><span class="line">      resolvePromise(<span class="keyword">this</span>.reason)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意此时 <code>c === (message) =&gt; {...}</code>，而外部变量 <code>cancel === c</code>，所以当外部变量 <code>cancel()</code> 调用时，就会调用 <code>(message) =&gt; {...}</code> 这个函数，调用 <code>resolvePromise</code>，这会把 <code>CancelToken</code> 里面的 <code>this.promise</code> 的 <code>state</code> 从 <code>pending</code> 变为 <code>fulfilled</code> 状态。在程序的外部如果之前<strong>已经写好了 then</strong> ，那么它就会 <strong>自动执行 then</strong>，调用 <code>abort</code> 取消请求，从而达到异步分离的目的</p><blockquote><p>如果上面的函数调用的逻辑看不懂， <a href="https://jsbin.com/yacezusohu/edit?html,js,output" target="_blank" rel="noopener">请点击这个链接</a>相信可以帮助理解</p></blockquote><h3 id="支持自动转换-JSON-数据"><a href="#支持自动转换-JSON-数据" class="headerlink" title="支持自动转换 JSON 数据"></a>支持自动转换 JSON 数据</h3><p>这个逻辑实现就很简单了，在 <code>src/helper/data-helper.ts</code> 文件中，有如下的两个专门用于数据处理的函数</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">transformRequest</span>(<span class="params">data: any</span>): <span class="title">any</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (isNormalObject(data)) <span class="keyword">return</span> <span class="built_in">JSON</span>.stringify(data)</span><br><span class="line">  <span class="keyword">return</span> data</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">transformResponse</span>(<span class="params">data: any</span>): <span class="title">any</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> data === <span class="string">'string'</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      data = data &amp;&amp; <span class="built_in">JSON</span>.parse(data)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">      <span class="comment">// TODO</span></span><br><span class="line">      <span class="comment">// console.log(error)</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> data</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在请求数据之前先把数据做一个处理，将数据转换成 JSON 字符串(transformRequest)；在处理响应数据之前先把数据转成 JSON 对象处理(transformResponse)，分别就是调用如上的两个帮助函数实现</p><h3 id="客户端支持-XSRF-防御"><a href="#客户端支持-XSRF-防御" class="headerlink" title="客户端支持 XSRF 防御"></a>客户端支持 XSRF 防御</h3><p>XSRF 又叫 Cross-site request forgery，跨站请求伪造，一种前端老生长谈的攻击方式了，简单点来说你通过一个陌生的链接打开一个恶意的网站，这个网站利用你之前登陆其他网站的登陆状态发起一个跨站点的网络请求，从而伪造身份来攻击</p><p>所以解决这种攻击的一种方式，就是服务端生成一个 token，客户端收到后存为 cookie，每次访问时就带上这个 token，而这个 token 在客户端每次访问站点时都生成，算是一个服务端的验证，这样有了唯一性验证这种攻击方式就弱小了很多。</p><p>所以实现这种功能就是每次发送请求时，自动从 cookie 中读取 token，然后添加进请求头中，一般来说是这么调用</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> instance = txios.create(&#123;</span><br><span class="line">  xsrfCookieName: <span class="string">'XSRF-TOKEN-D'</span>,</span><br><span class="line">  xsrfHeaderName: <span class="string">'X-XSRF-TOKEN-D'</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">instance.get(<span class="string">'/more/get'</span>)</span><br><span class="line">  .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p>核心代码如下</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/core/xhr.ts</span></span><br><span class="line"><span class="comment">// 设置 cookie</span></span><br><span class="line"><span class="keyword">if</span> ((withCredentials || isUrlSameOrigin(url!)) &amp;&amp; xsrfCookieName) &#123;</span><br><span class="line">  <span class="keyword">const</span> token = cookie.getToken(xsrfCookieName)</span><br><span class="line">  <span class="keyword">if</span> (token) headers[xsrfHeaderName!] = token</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>逻辑是这样的</p><ol><li>若 withCredentials = true | <strong>同源</strong>请求，在 headers 中添加 xsrf 相关字段</li><li>判断成功,则从 cookie 中读取 xsrf 的 token</li><li>若能读到，则将其添加到请求 headers 的 xsrf 相关字段中</li></ol><blockquote><p>注意跨域请求中若要请求域中携带 cookie 则需要设置 <code>XMLHttpRequest</code> 对象的 <code>withCredentials</code> 为 true</p></blockquote><p>那么 <code>getToken</code> 干了什么事情呢</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//src/helpers/cookie-helper.ts</span></span><br><span class="line">getToken(name: string): string | <span class="literal">null</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> match = <span class="built_in">document</span>.cookie.match(</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">'(^|;\\s*)('</span> + name + <span class="string">')=([^;]*)'</span>)</span><br><span class="line">  )</span><br><span class="line">  <span class="keyword">return</span> match ? <span class="built_in">decodeURIComponent</span>(match[<span class="number">3</span>]) : <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里就是利用正则表达式解析到 <code>name</code> 对应的值，如果有的话就取 <code>match[3]</code> 也就是 token 的值了，这里再稍微解释下过程，比如你的 <code>document.cookie</code> 值为 <code>XSRF-TOKEN-D=1234abc</code>，本质上是需要将 <code>1234abc</code> 拿出来，那么实际上你的正则就是 <code>(^|;\s*)(XSRF-TOKEN-D)=([^;]*)</code></p><ul><li><code>(^|;\s*)</code> 表示匹配字符串开头的 <code>;</code> 或者是 <code>;空格</code> 的字符串或者是其他字符串(<code>;</code> 可有可无)</li><li><code>(XSRF-TOKEN-D)</code> 表示匹配 <code>XSRF-TOKEN-D</code> 这样的字符串</li><li><code>=</code> 表示匹配 <code>=</code> 这样的字符</li><li><code>([^;]*)</code> 表示匹配除了 <code>;</code> 这样的字符的其他字符串</li></ul><p>那么连起来就很明了了，就是匹配 <code>XSRF-TOKEN-D=</code> 这样的字符串，匹配到了后 <code>match</code> 伪数组结果长这样</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="number">0</span>: <span class="string">"XSRF-TOKEN-D=1234abc"</span></span><br><span class="line">  <span class="number">1</span>: <span class="string">""</span></span><br><span class="line">  <span class="number">2</span>: <span class="string">"XSRF-TOKEN-D"</span></span><br><span class="line">  <span class="number">3</span>: <span class="string">"1234abc"</span></span><br><span class="line">  index: <span class="number">0</span></span><br><span class="line">  input: <span class="string">"XSRF-TOKEN-D=1234abc"</span></span><br><span class="line">  groups: <span class="literal">undefined</span></span><br><span class="line">  length: <span class="number">4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>于是 <code>match[3]</code> 就是结果，直接取它就行</p><blockquote><p>若这里不懂也可以点击这个 <a href="https://github.com/ziishaned/learn-regex/blob/master/translations/README-cn.md" target="_blank" rel="noopener">正则参考链接</a></p></blockquote><h2 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h2><p>单元测试其实是个比较蛋疼的话题，说实话要做到一个比较高的代码覆盖率，需要自己写很多的代码取做验证，其核心的逻辑就是验证输入跟输出的对比，使用 jest 这个测试框架的 expert 断言去写，利用 <code>jasmine</code> 去做 <code>ajax</code> 异步的请求 mock，基本上就是这么个套路了。</p><p>而如果要做到很高的代码测试覆盖率，需要自己深入到函数里面，理清楚它的每个判断，然后对相应的代码走向编写测试代码就行。这是比较累的地方，但却是最能保证代码质量的地方。</p><h2 id="比较难实现的地方"><a href="#比较难实现的地方" class="headerlink" title="比较难实现的地方"></a>比较难实现的地方</h2><p>除了上面提及到的<a href="#支持-Promise-API">支持 Promise API</a> 以及<a href="#支持取消请求">支持取消请求</a>比较难实现外，还有一个就是合并配置功能的实现。<br>在合并配置时需要注意默认配置和用户在调用 <code>txios</code> 时的自定义配置，优先级比较高的是用户自定义的配置，这部分的配置包括 <code>headers</code> 以及一些 <code>config</code>。但是合并不是简单的合并覆盖属性就完了，对于不同的字段的合并，需要不同的策略</p><p>这里的合并策略主要有3个</p><ul><li><p>默认合并策略</p><p>  如果自定义配置中有某个属性，就采用自定义的，反之采用默认</p>  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defaultPolicy</span>(<span class="params">defaultValue: any, customValue: any</span>): <span class="title">any</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> customValue !== <span class="string">'undefined'</span> ? customValue : defaultValue</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>只接受自定义的配置策略</p><p>  这是对于 url params data 的合并策略</p>  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onlyCustomPolicy</span>(<span class="params">defaultValue: any, customValue: any</span>): <span class="title">any</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> customValue !== <span class="string">'undefined'</span>) <span class="keyword">return</span> customValue</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>复杂对象合并策略</p>  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepMergePolicy</span>(<span class="params">defaultValue: any, customValue: any</span>): <span class="title">any</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 优先检测自定义配置</span></span><br><span class="line">  <span class="keyword">if</span> (isNormalObject(customValue)) &#123;</span><br><span class="line">    <span class="comment">// 自定义配置 value 是普通对象</span></span><br><span class="line">    <span class="keyword">return</span> deepMerge(defaultValue, customValue)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> customValue !== <span class="string">'undefined'</span>) &#123; <span class="comment">// 这里判断踩了个坑</span></span><br><span class="line">    <span class="comment">// 自定义配置 value 是其他对象</span></span><br><span class="line">    <span class="keyword">return</span> customValue</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isNormalObject(defaultValue)) &#123;</span><br><span class="line">    <span class="comment">// 默认配置是普通对象</span></span><br><span class="line">    <span class="keyword">return</span> deepMerge(defaultValue)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 默认配置是其他对象</span></span><br><span class="line">    <span class="keyword">return</span> defaultValue</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>之前在复杂策略判断这里踩了个坑，原来的判断是少个 <code>typeof</code> 的，也就是说那条语句变成了 <code>else if (customValue !== &#39;undefined&#39;)</code>，然后单元测试老是过不去，弄了很久，逐行打印分析还以为是 <code>deepMerge</code> 函数那里写错了，后面定位问题才逐渐定位到这里，删除了代码又添加代码之后才发现的。看来使用 TypesSript 也有眼瞎的时候，虽然它已经能够帮你解决 80% 的低端 bug 了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这次的项目算是使用 TypeScript 对 axios 库功能的一次仿写，由代码测试来看，部分功能还算是比较成功的。同时也了解到了 TypeScript 这一门语言的强大之处，比起 js 来说，用的人都应该感觉算蛮香的。虽然类型定义有些奇怪，但用习惯之后觉得还好。另外，若大家有兴趣，还请 <a href="https://github.com/strugglebak/txios" target="_blank" rel="noopener">star 下我的 txios 库</a> ，各位有问题也可以直接 <a href="https://github.com/strugglebak/txios/pulls" target="_blank" rel="noopener">PR</a>，我通通合并(开玩笑哈哈)</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本次项目是对自己用 TypeScript 造的一个轮子的总结，麻雀虽小，但已经尽量五脏俱全，希望各位能多多 star(摩多摩多~)，&lt;a href=&quot;https://github.com/strugglebak/txios&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;毕竟项目地址都在这儿了各位 QAQ&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="TypeScript" scheme="https://strugglebak.github.io/categories/TypeScript/"/>
    
      <category term="Axios" scheme="https://strugglebak.github.io/categories/TypeScript/Axios/"/>
    
    
      <category term="Txios" scheme="https://strugglebak.github.io/tags/Txios/"/>
    
      <category term="Promise" scheme="https://strugglebak.github.io/tags/Promise/"/>
    
      <category term="TypeScript-Http" scheme="https://strugglebak.github.io/tags/TypeScript-Http/"/>
    
  </entry>
  
  <entry>
    <title>配置代码覆盖率徽标的问题</title>
    <link href="https://strugglebak.github.io/2020/03/11/%E9%85%8D%E7%BD%AE%E4%BB%A3%E7%A0%81%E8%A6%86%E7%9B%96%E7%8E%87%E5%BE%BD%E6%A0%87%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>https://strugglebak.github.io/2020/03/11/配置代码覆盖率徽标的问题/</id>
    <published>2020-03-10T16:21:44.000Z</published>
    <updated>2022-06-04T08:13:29.652Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>配置代码覆盖率的这个徽标也是一个很麻烦的问题，由于采用的是 travis 这个 ci 工具，所以坑还是有点多的，这里也记录了如何生成一个 github 的 token，也算做个记录</p></blockquote><a id="more"></a><h2 id="找库"><a href="#找库" class="headerlink" title="找库"></a>找库</h2><p>首先是看到 <a href="http://https://github.com/axios/axios" target="_blank" rel="noopener">axios 这个库</a> 里面有个 <code>coverage</code><br><img src="./1.png" alt></p><p>然后查人家的 <code>package.json</code> 发现是用 <code>coveralls</code> 这个工具的，并且命令为<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="string">"coveralls"</span>: <span class="string">"cat coverage/lcov.info | ./node_modules/coveralls/bin/coveralls.js"</span></span><br></pre></td></tr></table></figure></p><p>原理就是用 <code>coveralls</code> 这个工具计算好代码覆盖率之后，会在项目根目录下生成 <code>coveralls</code> 文件夹，里面就有相关的文件以及最关键的 – <code>lcov.info</code>， 这个文件就是我想要的那个徽标</p><h2 id="网站配置"><a href="#网站配置" class="headerlink" title="网站配置"></a>网站配置</h2><p>首先我项目都是基于 TravisCI 进行持续集成的，最开始的 <code>.travis.yml</code> 如下<br><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">language:</span> <span class="string">node_js</span></span><br><span class="line"><span class="attr">cache:</span></span><br><span class="line">  <span class="attr">directories:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">"~/.npm"</span></span><br><span class="line"><span class="attr">notifications:</span></span><br><span class="line">  <span class="attr">email:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">node_js:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">'10'</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">'11'</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">'8'</span></span><br><span class="line"><span class="attr">script:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">npm</span> <span class="string">run</span> <span class="string">test:prod</span> <span class="string">&amp;&amp;</span> <span class="string">npm</span> <span class="string">run</span> <span class="string">build</span></span><br><span class="line"><span class="attr">after_success:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">npm</span> <span class="string">run</span> <span class="string">travis-deploy-once</span> <span class="string">"npm run report-coverage"</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">if</span> <span class="string">[</span> <span class="string">"$TRAVIS_BRANCH"</span> <span class="string">=</span> <span class="string">"master"</span> <span class="string">-a</span> <span class="string">"$TRAVIS_PULL_REQUEST"</span> <span class="string">=</span> <span class="string">"false"</span> <span class="string">];</span> <span class="string">then</span> <span class="string">npm</span></span><br><span class="line">  <span class="string">run</span> <span class="string">travis-deploy-once</span> <span class="string">"npm run deploy-docs"</span><span class="string">;</span> <span class="string">fi</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">if</span> <span class="string">[</span> <span class="string">"$TRAVIS_BRANCH"</span> <span class="string">=</span> <span class="string">"master"</span> <span class="string">-a</span> <span class="string">"$TRAVIS_PULL_REQUEST"</span> <span class="string">=</span> <span class="string">"false"</span> <span class="string">];</span> <span class="string">then</span> <span class="string">npm</span></span><br><span class="line">  <span class="string">run</span> <span class="string">travis-deploy-once</span> <span class="string">"npm run sr"</span><span class="string">;</span> <span class="string">fi</span></span><br><span class="line"><span class="attr">branches:</span></span><br><span class="line">  <span class="attr">except:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">"/^v\\d+\\.\\d+\\.\\d+$/"</span></span><br></pre></td></tr></table></figure></p><p>按照道理来说，配置好后提交，然后 travis 那边只需要关联上你对应的项目就好，但是会出一个 bug 报错<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Error: GitHub authentication missing</span><br><span class="line">    at validate (/home/travis/build/strugglebak/txios/node_modules/travis-deploy-once/lib/validate.js:12:27)</span><br><span class="line">    at module.exports (/home/travis/build/strugglebak/txios/node_modules/travis-deploy-once/lib/travis-deploy-once.js:25:3)</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><p>看了下是执行<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm run travis-deploy-once <span class="string">"npm run report-coverage"</span></span><br></pre></td></tr></table></figure></p><p>这句话报错的，刚好是要执行代码覆盖率相关操作的语句。 先放在这里不管，继续找徽标</p><h2 id="shields-io"><a href="#shields-io" class="headerlink" title="shields.io"></a>shields.io</h2><p>google 搜 <code>github 徽标</code>，出来第一个结果就是 <code>shields.io</code> 相关的，然后找 <code>Code Coverage</code>，匹配到 <code>coveralls</code> 相关的<br><img src="./2.png" alt><br>再一搜原来需要登陆 <code>Coveralls</code> 的官方网站搞，于是用 github 账号登陆<a href="https://coveralls.io/" target="_blank" rel="noopener">coveralls 官网</a>，看了下应该也是需要关联仓库的，点击左边的 <code>Add Repos</code><br><img src="./3.png" alt></p><p>添加完之后点击 <code>REPOS</code> 然后再点击刚刚添加项目会发现如下说明<br><img src="./4.png" alt></p><p>wtf。。。我才知道原来 travis 还有 pro 版本，赶紧一搜，原来是 travis-ci.org 和 travis-ci.com 的区别，估计是重构了服务什么的吧，这个就先没管了，于是搜 [coveralls 使用]，条件是过去一年内, 看到了<a href="https://zhuanlan.zhihu.com/p/54958391" target="_blank" rel="noopener">知乎的一篇文章</a>,浏览量下也就很普通的解决方案，但是用的是 travis-ci.com 也就是所谓的 pro 版本，于是登陆 pro 版，也是 github 账号登陆，选择管理项目的时候选择了[自己的 github 的所有 repo] 而不是 [指定的项目]，但是在搜索框搜项目的时候居然不存在。。。</p><p><img src="./5.png" alt></p><p>于是乱点了下，点击那个 <code>Migrate</code> tab 后终于出现了</p><p><img src="./6.png" alt></p><p>现在我懂了，如果你是从 travis-ci.org 那边过来的，那边如果有项目在的话，要在这个 travis-ci.com 用，必须要[迁移]过来。</p><p>现在照着知乎那篇帖子配置了下， git push 后看结果，傻眼了，还是报那个错，而且刷新 Coveralls 的相关项目页的时候还是没有出现所谓的[代码覆盖率的报告]，但是如果<strong>不生成这个报告的话，你就拿不到代码覆盖率的徽标了</strong>，继续搜索尝试解决问题</p><h2 id="bug-报错的提示"><a href="#bug-报错的提示" class="headerlink" title="bug 报错的提示"></a>bug 报错的提示</h2><p>前面说了那个 bug 的提示就是<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Error: GitHub authentication missing</span><br></pre></td></tr></table></figure></p><p>貌似就是跟 github 项目相关的 token 验证有关系，于是搜<br>[travis github token set]，<a href="https://docs.travis-ci.com/user/deployment/pages/" target="_blank" rel="noopener">第一个</a>无脑点进去看</p><p>还是官方文档</p><p><img src="./7.png" alt></p><p>看懂了，是这样的一个过程。<br><strong>一般是你要在 travis 帮你在 github page 上部署你的静态文件时会用到 personal access token 这个玩意儿，然后这个 token 是很敏感的私密字符串(因为你可以用这个 token 代替密码来进行仓库的一些操作)， 所以你需要对其进行加密处理</strong></p><p><img src="./8.png" alt></p><p>点击人家推荐的链接<a href="https://help.github.com/en/github/authenticating-to-github/creating-a-personal-access-token-for-the-command-line" target="_blank" rel="noopener">repository settings 里面看</a><br>最终得到类似这么个玩意儿</p><p><img src="./9.png" alt></p><p>然后点击人家推荐的链接<a href="https://docs.travis-ci.com/user/environment-variables#defining-encrypted-variables-in-travisyml" target="_blank" rel="noopener">encrypted variables</a></p><p><img src="./10.png" alt></p><p>然后再点击 <a href="https://docs.travis-ci.com/user/encryption-keys#usage" target="_blank" rel="noopener">Encryption keys – Usage</a></p><p><img src="./11.png" alt></p><p>返回去看了下</p><p><img src="./12.png" alt></p><p>看了下，大致意思就是，你可以使用下面这条命令<br><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">travis encrypt --pro SOMEVAR=<span class="string">"secretvalue"</span> --<span class="keyword">add</span></span><br></pre></td></tr></table></figure></p><p>去加密一个变量，然后这个就会以加密后的一串字符串追加到 <code>.travis.yml</code> 文件后<br><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">env:</span></span><br><span class="line">  <span class="attr">global:</span></span><br><span class="line">    <span class="attr">secure:</span> <span class="string">WPuJZvLNAyAfwu2gM89Y3t520/rnO5GK25Bf1WViJff5q...</span></span><br></pre></td></tr></table></figure></p><p>这就表示把你定义的变量加入到 travis 这个环境变量里面去了，然后你在 travis 上编译测试成功后，会在你项目你自己已经定义好的变量中去找，因为这是一个 key 和 value，找到你对应的 key 再解密然后比对 value，就达到了权限验证的目的了。</p><blockquote><p>这里我执行的命令是 <code>travis encrypt --pro GITHUB_TOKEN=&quot;yourgithubtokenvalue&quot; --add</code></p></blockquote><p>比如我的就是设置的变量名就是 <code>GITHUB_TOKEN</code>，就在 travis 项目中的 <code>setting</code> 页面中的那个 <code>Environment Variables</code> 里填，<code>Value</code> 项就是你在 github 上设置成功的 token 值，然后点击 <code>Add</code> 添加</p><p><img src="./xxx.png" alt></p><p><img src="./13.png" alt></p><p>最后就是项目的修改和提交了，主要就是更改了 <code>.travis.yml</code> 配置文件，提交了之后等待 travis 测试通过，再刷新 <code>Coveralls</code> 官网对应的项目，看到下图表示代码覆盖率报告已经生成，也就是说可以在 <code>shields.io</code> 上拿到 <code>coverage</code> 的徽标了!</p><p><img src="./14.png" alt></p><h2 id="travis-相关文件配置"><a href="#travis-相关文件配置" class="headerlink" title="travis 相关文件配置"></a>travis 相关文件配置</h2><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">provider:</span> <span class="string">pages</span></span><br><span class="line">  <span class="attr">skip_cleanup:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">github_token:</span> <span class="string">$GITHUB_TOKEN</span></span><br><span class="line">  <span class="attr">keep_history:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">on:</span></span><br><span class="line">    <span class="attr">branch:</span> <span class="string">master</span></span><br><span class="line"><span class="attr">language:</span> <span class="string">node_js</span></span><br><span class="line"><span class="attr">cache:</span></span><br><span class="line">  <span class="attr">directories:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">"~/.npm"</span></span><br><span class="line"><span class="attr">notifications:</span></span><br><span class="line">  <span class="attr">email:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">node_js:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">'10'</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">'11'</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">'8'</span></span><br><span class="line"><span class="attr">script:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">npm</span> <span class="string">run</span> <span class="string">test:prod</span> <span class="string">&amp;&amp;</span> <span class="string">npm</span> <span class="string">run</span> <span class="string">build</span></span><br><span class="line"><span class="attr">after_success:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">npm</span> <span class="string">run</span> <span class="string">travis-deploy-once</span> <span class="string">"npm run report-coverage"</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">if</span> <span class="string">[</span> <span class="string">"$TRAVIS_BRANCH"</span> <span class="string">=</span> <span class="string">"master"</span> <span class="string">-a</span> <span class="string">"$TRAVIS_PULL_REQUEST"</span> <span class="string">=</span> <span class="string">"false"</span> <span class="string">];</span> <span class="string">then</span> <span class="string">npm</span></span><br><span class="line">  <span class="string">run</span> <span class="string">travis-deploy-once</span> <span class="string">"npm run deploy-docs"</span><span class="string">;</span> <span class="string">fi</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">if</span> <span class="string">[</span> <span class="string">"$TRAVIS_BRANCH"</span> <span class="string">=</span> <span class="string">"master"</span> <span class="string">-a</span> <span class="string">"$TRAVIS_PULL_REQUEST"</span> <span class="string">=</span> <span class="string">"false"</span> <span class="string">];</span> <span class="string">then</span> <span class="string">npm</span></span><br><span class="line">  <span class="string">run</span> <span class="string">travis-deploy-once</span> <span class="string">"npm run sr"</span><span class="string">;</span> <span class="string">fi</span></span><br><span class="line"><span class="attr">branches:</span></span><br><span class="line">  <span class="attr">except:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">"/^v\\d+\\.\\d+\\.\\d+$/"</span></span><br><span class="line"><span class="attr">env:</span></span><br><span class="line">  <span class="attr">global:</span></span><br><span class="line">    <span class="attr">secure:</span> <span class="string">WPuJZvLNAyAfwu2gM89Y3t520/rnO5GK25Bf1WViJff5q893Z...</span></span><br></pre></td></tr></table></figure><p>注意我写的 <code>$GITHUB_NAME</code> 这里就是获取到你在 travis 上配置的环境变量名。</p><p>最后的最后需要注意的，可能是一个坑，但是我还是加上了，就是有看到  github 上有 issue 讨论这个问题<a href="https://github.com/semantic-release/travis-deploy-once/issues/52" target="_blank" rel="noopener">GH_TOKEN has not authenticated Travis CI yet</a><br>然后他是通过在 <code>package.json</code> 中的 <code>travis-deploy-once</code> 后加 <code>--pro</code> 解决的</p><p><img src="./15.png" alt></p><p>为了以防万一，我也在项目中加了, 我的项目地址为<a href="https://github.com/strugglebak/txios.git" target="_blank" rel="noopener">txios - 基于 TypeScript 的轻量级 http 库</a></p><p>虽然没试过，但是加了没有问题，就这样问题解决了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这个坑之前搞 travis ci 的时候没碰到过，算是给自己一个记录，以后谁踩坑了可以参考我这篇博客哈哈。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;配置代码覆盖率的这个徽标也是一个很麻烦的问题，由于采用的是 travis 这个 ci 工具，所以坑还是有点多的，这里也记录了如何生成一个 github 的 token，也算做个记录&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="bug" scheme="https://strugglebak.github.io/categories/bug/"/>
    
    
      <category term="bug" scheme="https://strugglebak.github.io/tags/bug/"/>
    
  </entry>
  
  <entry>
    <title>有关react hooks这一堆东西的详细解释(万字长文)</title>
    <link href="https://strugglebak.github.io/2020/03/09/%E6%9C%89%E5%85%B3react-hooks%E8%BF%99%E4%B8%80%E5%A0%86%E4%B8%9C%E8%A5%BF%E7%9A%84%E8%AF%A6%E7%BB%86%E8%A7%A3%E9%87%8A-%E4%B8%87%E5%AD%97%E9%95%BF%E6%96%87/"/>
    <id>https://strugglebak.github.io/2020/03/09/有关react-hooks这一堆东西的详细解释-万字长文/</id>
    <published>2020-03-09T10:08:29.000Z</published>
    <updated>2022-06-04T08:13:29.500Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文主要会就 React hooks 中用的比较多的 <code>useState</code> 做一个详细讲解，其他的 hooks 会涉及到原理和使用但不会涉及到源码仿写，望周知</p></blockquote><a id="more"></a><h2 id="实现-useState"><a href="#实现-useState" class="headerlink" title="实现 useState"></a>实现 useState</h2><h3 id="useState-是怎么用的"><a href="#useState-是怎么用的" class="headerlink" title="useState 是怎么用的"></a>useState 是怎么用的</h3><p>在实现一个 <code>useState</code> 之前，先来看看 <code>useState</code> 大致是怎么用的</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123;useState&#125; <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [n, setN] = useState(<span class="number">0</span>)</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">"App"</span>&gt;</span><br><span class="line">      &lt;p&gt;&#123;n&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">      &lt;p&gt;</span></span><br><span class="line"><span class="regexp">        &lt;button onClick=&#123;() =&gt; setN(n+1)&#125;&gt;+1&lt;/</span>button&gt;</span><br><span class="line">      &lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里是一个简单的 <a href="https://codesandbox.io/s/inspiring-tree-3yrpr" target="_blank" rel="noopener">加法器的应用</a>，所以这里的效果就是点击一下 button, n 就会加 1。那么这里面的过程是怎么样的呢，这里分 2 部走</p><ul><li>首次渲染<br>  首次渲染时，会调用 <code>App()</code> 函数，得到一个 <strong>虚拟 DOM</strong>，然后再创建<strong>真实 DOM</strong></li><li>用户点击 button 时<br>  会先调用 <code>setN(n+1)</code> 函数，然后<strong>再次 render 渲染</strong>，渲染就调用 <code>App()</code> 函数，然后再次得到一个<strong>新的虚拟 DOM</strong>，这个虚拟 DOM 会和之前的虚拟 DOM 做一个 <strong>Diff</strong> 的操作，然后再更新对应的真实 DOM</li></ul><blockquote><p>这里注意，每次调用 <code>App()</code> 函数时，都会调用 <code>useState(0)</code></p></blockquote><p>所以这里我们可以看到两个问题</p><ul><li><strong>在执行 <code>setN</code></strong>时，<strong>n 不会变</strong>，但是 <code>App()</code> 函数会重新执行</li><li><code>App()</code> 函数在执行后，在 <code>useState(0)</code> 时，<strong>每次的 n 的值都是不同的</strong></li></ul><h3 id="分析-useState"><a href="#分析-useState" class="headerlink" title="分析 useState"></a>分析 useState</h3><p>对于数据 <code>X</code> 来说，使用 <code>useState</code> 会有如下的规律</p><ul><li><p><code>setN</code></p><ol><li><code>setN</code> 一定会修改数据 <code>X</code>, 将 <code>n+1</code> 存入 <code>X</code></li><li><code>setN</code> 一定会触发 <code>&lt;App/&gt;</code> 并重新渲染(执行 <code>App()</code> 函数)</li></ol></li><li><p><code>useState</code><br>  <code>useState</code> 肯定会从 <code>X</code> <strong>读取</strong> <code>n</code> 的最新值</p></li><li><p><code>X</code><br>  每个组件都有自己的数据 <code>X</code>，其实就是所谓的 <code>state</code></p></li></ul><h3 id="实现-useState-初级版本"><a href="#实现-useState-初级版本" class="headerlink" title="实现 useState 初级版本"></a>实现 useState 初级版本</h3><p>有了以上的分析，可以写一个简单的 <code>useState</code> 了</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> _state; <span class="comment">// 全局变量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> useState = <span class="function"><span class="params">initValue</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// _state 用来保存一个全局的状态</span></span><br><span class="line">  _state = _state === <span class="literal">undefined</span> ? initValue : _state;</span><br><span class="line">  <span class="comment">// setState 是一个 callback, 只要 setState 被调用，就会重新 render 一遍</span></span><br><span class="line">  <span class="comment">// 同时 _state 也会得到更新</span></span><br><span class="line">  <span class="keyword">const</span> setState = <span class="function"><span class="params">newValue</span> =&gt;</span> &#123;</span><br><span class="line">    _state = newValue;</span><br><span class="line">    render();</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> [_state, setState];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// render 函数</span></span><br><span class="line"><span class="keyword">const</span> render = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> rootElement = <span class="built_in">document</span>.getElementById(<span class="string">"root"</span>);</span><br><span class="line">  ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span></span>, rootElement);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里为了方便起见，其 <code>render</code> 函数就直接调用了 <code>ReactDom.render</code>。比较关键的是这个全局的 <code>_state</code>，这个 <code>_state</code> 是一个全局的变量，为了下次渲染时不被初始化而设立的，<code>setState</code> 实际上就是一个回调，作用就是 <strong>保存 state 并开启渲染</strong>，所以这里可以知道为何在调用 <code>setN</code> 时，<code>n</code> 不会变了。因为此的 <code>n</code> 只是被存放在 <code>_state</code> 中，最后返回的 <code>_state</code> 中才是变化的 <code>n</code>，而只有再次渲染才能得到这个变化的 <code>n</code></p><h3 id="实现-useState-升级版本"><a href="#实现-useState-升级版本" class="headerlink" title="实现 useState 升级版本"></a>实现 useState 升级版本</h3><p>但是目前还有一个问题，就是万一同一个组件，调用用了 <strong>2 次以上的 useState</strong> 怎么办。以上的初始版本的代码会带来什么问题呢？就是因为 <code>_state</code> 是全局的，导致组件的数据之间会相互冲突</p><h4 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h4><p>解决的思路有两个</p><ul><li>将 <code>_state</code> 变成对象的形式，比如变成 <code>_state: {n: 0, m: 0}</code><br>  实际上这样做是不可取的，因为 <code>useState</code> 中参数就是传一个初始值(initValue)，这种情况下我们怎么知道是 <code>n</code> 是 0, 还是 <code>m</code> 是 0 呢</li><li>将 <code>_state</code> 变成<strong>数组</strong>的形式，比如 <code>_state: [0, 0]</code><br>  这种是可以的，因为可以通过<strong>下标</strong>区分每个 <code>useState</code> 的数据</li></ul><h4 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> _state = []; <span class="comment">// 全局变量</span></span><br><span class="line"><span class="keyword">let</span> index = <span class="number">0</span>; <span class="comment">// 解决 state 冲突的问题,因为有可能使用多个 useState</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> useState = <span class="function"><span class="params">initValue</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 保存当前的 index</span></span><br><span class="line">  <span class="keyword">let</span> currentIndex = index;</span><br><span class="line">  <span class="comment">// _state 用来保存一个全局的状态</span></span><br><span class="line">  _state[currentIndex] =</span><br><span class="line">    _state[currentIndex] === <span class="literal">undefined</span> ? initValue : _state[currentIndex];</span><br><span class="line">  <span class="comment">// setState 是一个 callback, 只要 setState 被调用，就会重新 render 一遍</span></span><br><span class="line">  <span class="comment">// 同时 _state 也会得到更新</span></span><br><span class="line">  <span class="keyword">const</span> setState = <span class="function"><span class="params">newValue</span> =&gt;</span> &#123;</span><br><span class="line">    _state[currentIndex] = newValue;</span><br><span class="line">    render();</span><br><span class="line">  &#125;;</span><br><span class="line">  index += <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> [_state[currentIndex], setState];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> render = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  index = <span class="number">0</span>; <span class="comment">// 注意这里要 index 置零</span></span><br><span class="line">  <span class="keyword">const</span> rootElement = <span class="built_in">document</span>.getElementById(<span class="string">"root"</span>);</span><br><span class="line">  ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span></span>, rootElement);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>既然要采取上面的数组的方案做，那么 <code>_state</code> 自然初始值就是一个数组。其他的逻辑并没有变化，主要是增加了一个全局的变量 <code>index</code> 以及一个 <code>useState</code> 中的临时变量 <code>currentIndex</code>。每次当 <code>useState</code> 执行时，<code>index</code> 就自增 1 与其他的 <code>state</code> 做区分。<code>currentIndex</code> 的作用是能让 <code>_state[0]</code> 有个初始值而不至于是 <code>undefined</code>。同时在每次 <code>render</code> 时需要将 <code>index</code> 置为零。这样一来每次执行 <code>useState</code> 得到的就是不同的 <code>n</code> 以及 <code>setN</code> 了</p><p><a href="https://codesandbox.io/s/winter-surf-9nqr2" target="_blank" rel="noopener">测试代码链接点击这里</a></p><h4 id="数组方案的主要缺点"><a href="#数组方案的主要缺点" class="headerlink" title="数组方案的主要缺点"></a>数组方案的主要缺点</h4><p>数组的一个很明显的缺点就是它的 <strong>调用顺序</strong>。因为数组非常强调顺序，所以在 React 中不允许出现类似如下的代码</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;useState&#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">...</span><br><span class="line">  <span class="keyword">const</span> [n, setN] = useState(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">let</span> m, setM;</span><br><span class="line">  <span class="keyword">if</span> (n % <span class="number">2</span> === <span class="number">0</span>) &#123;</span><br><span class="line">    [m, setM] = useState(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>React 就会报如下的错误</p><blockquote><p>❌ :React Hook “React.useState” is called conditionally. React Hooks must be called in the exact same order in every component render</p></blockquote><p>意思是说，React 不能依照条件调用 <code>useState</code>，在每个组件渲染时应该依照一样的顺序调用 hooks</p><p>所以在使用 React 相关的 hook 时，上面的代码是不被 React 允许的</p><h4 id="数组方案的其他缺点以及解决方案"><a href="#数组方案的其他缺点以及解决方案" class="headerlink" title="数组方案的其他缺点以及解决方案"></a>数组方案的其他缺点以及解决方案</h4><ul><li><code>App</code> 组件使用了全局的 <code>_state</code> 和 <code>index</code>，那么其他组件怎么用？不还是冲突了么？<br>  只需要在每个组件内部维护一个 <code>_state</code> 和 <code>index</code> 即可</li><li>对于类组件来说，不存在全局作用域重名的问题，对于函数组件来说就有，这个时候怎么办？<br>  只需要将 <code>_state</code> 和 <code>index</code> 放在组件对应的虚拟 DOM 对象上即可</li></ul><p>原理是这样的</p><p><img src="./1.png" alt></p><p>在函数组件调用了 <code>useState</code> 时，就会更新绑定在虚拟 DOM 对象上的 <code>_state</code> 和 <code>index</code>，当下次数据有变化触发 render 时，会再次调用 <code>useState</code> 并生成一个新的虚拟 DOM 对象，这个对象会跟之前的旧对象进行一个 Diff 的操作，对比出要更改的节点后会出一个 Patch，然后再根据这个 Patch 更新虚拟 DOM 上的数据，这里面包括了 <code>_state</code> 和 <code>index</code>，最后再修改生成一个真实 DOM 节点。</p><h3 id="useState-注意点"><a href="#useState-注意点" class="headerlink" title="useState 注意点"></a>useState 注意点</h3><ul><li><p>对于其使用状态</p>  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> [n, setN] = React.useState(<span class="number">0</span>) <span class="comment">// 这里 n 的初始值就是 0</span></span><br><span class="line"><span class="keyword">const</span> [m, setM] = React.useState(&#123;<span class="attr">name</span>: <span class="string">'xxx'</span>&#125;) <span class="comment">// 这里 m 的初始值就是 &#123;name: 'xxx'&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>不可以局部更新<br>  <a href="https://codesandbox.io/s/laughing-dawn-v2d5t" target="_blank" rel="noopener">代码链接</a></p>  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> [user, setUser] = useState(&#123; <span class="attr">name</span>: <span class="string">"xxx"</span>, <span class="attr">age</span>: <span class="number">18</span> &#125;);</span><br><span class="line"><span class="keyword">const</span> onClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  setUser(&#123;</span><br><span class="line">    name: <span class="string">"Jack"</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line">  &lt;div className=<span class="string">"App"</span>&gt;</span><br><span class="line">    &lt;h1&gt;&#123;user.name&#125;&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">    &lt;h2&gt;&#123;user.age&#125;&lt;/</span>h2&gt;</span><br><span class="line">    &lt;button onClick=&#123;onClick&#125;&gt;Click&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>div&gt;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>  从贴出的代码链接可以看出，点击 button 后，<code>user.age</code> 并没有显示出来。这是因为 <strong>setState 并不会帮你合并属性，要合并的话需要自己额外操作，比如利用拓展运算符 <code>...</code></strong></p></li><li><p><code>setState(obj)</code> 中的地址要变<br>  <a href="https://codesandbox.io/s/runtime-feather-2wi3n" target="_blank" rel="noopener">代码链接</a></p>  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> [user, setUser] = useState(&#123; <span class="attr">name</span>: <span class="string">"xxx"</span>, <span class="attr">age</span>: <span class="number">18</span> &#125;);</span><br><span class="line"><span class="keyword">const</span> obj = user <span class="comment">// 注意这里 !!!</span></span><br><span class="line"><span class="keyword">const</span> onClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  obj.name = <span class="string">'Jack'</span> <span class="comment">// 注意这里 !!!</span></span><br><span class="line">  setUser(obj); <span class="comment">// 在这种情况下页面数据是不会更新的 !!!</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line">  &lt;div className=<span class="string">"App"</span>&gt;</span><br><span class="line">    &lt;h1&gt;&#123;user.name&#125;&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">    &lt;h2&gt;&#123;user.age&#125;&lt;/</span>h2&gt;</span><br><span class="line">    &lt;button onClick=&#123;onClick&#125;&gt;Click&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>div&gt;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>  只要 <code>obj</code> 的地址没变，React 就认为其数据没有变化，因此就不会触发更新</p></li><li><p><code>useState</code> 可以接受一个函数</p>  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> [state, setState] = useState(<span class="function"><span class="params">()</span> =&gt;</span> initialState) <span class="comment">// 该函数返回初始值 state，且只执行一次</span></span><br></pre></td></tr></table></figure></li><li><p><code>setState</code> 可以接受一个函数</p><p>  <a href="https://codesandbox.io/s/runtime-feather-2wi3n" target="_blank" rel="noopener">代码链接</a></p>  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> [n, setN] = useState(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">const</span> onClick = <span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">  setN(n+<span class="number">1</span>)</span><br><span class="line">  setN(n+<span class="number">1</span>) <span class="comment">// 你会发现 n 不能加 2</span></span><br><span class="line">  <span class="comment">// setN(i=&gt;i+1)</span></span><br><span class="line">  <span class="comment">// setN(i=&gt;i+1) // 但是使用了函数之后就可以加 2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line">  &lt;div className=<span class="string">"App"</span>&gt;</span><br><span class="line">    &lt;h1&gt;n: &#123;n&#125;&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">    &lt;button onClick=&#123;onClick&#125;&gt;+2&lt;/</span>button&gt;</span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">);</span></span><br></pre></td></tr></table></figure><p>  所以为了避免 bug，应该优先使用这种在 <code>setState</code> 中传函数更新 <code>state</code> 的方式</p></li></ul><h3 id="useState-总结"><a href="#useState-总结" class="headerlink" title="useState 总结"></a>useState 总结</h3><ul><li>每个函数组件对应着一个 React 节点(FiberNode)</li><li>每个节点保存着 <code>_state</code> 和 <code>index</code></li><li>useState 会读取 <code>_state[index]</code></li><li><code>index</code> 由 useState 出现的顺序决定</li><li><code>setState</code> 会修改 <code>_state</code>，并且之后会触发更新</li></ul><blockquote><p>⚠ 注意：这里只是一个对 <code>useState</code> 的思路型源码，并非是 React hook 中的源码。另这里的 <code>_state</code> 对应源码中的 <code>memorizedState</code>，而 <code>index</code> 在源码中是利用链表来实现的。这里只是抛砖引玉一下。</p></blockquote><h2 id="useReducer"><a href="#useReducer" class="headerlink" title="useReducer"></a>useReducer</h2><p><code>useReducer</code> 本质就是用来践行 <code>Flux/Redux</code> 的思想的这么一个 hook，例子的<a href="https://codesandbox.io/s/practical-lederberg-f1hp6" target="_blank" rel="noopener">代码链接</a>在这里</p><h3 id="使用-useReducer"><a href="#使用-useReducer" class="headerlink" title="使用 useReducer"></a>使用 useReducer</h3><p>首先是声明一个 <code>initial</code> 初始变量</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> initial = &#123;</span><br><span class="line">  n: <span class="number">0</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后声明 <code>reducer</code></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> reducer = <span class="function">(<span class="params">state, action</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (action.type === <span class="string">"add"</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">n</span>: state.n + action.number &#125;;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (action.type === <span class="string">"multi"</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">n</span>: state.n * <span class="number">2</span> &#125;;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"unknown type"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后在 <code>App()</code> 函数组件中使用将这个 <code>reducer</code> 以及 <code>initial</code> 值当作参数传入 <code>useReducer</code> 中，返回的就是一个 <code>state</code> 和 <code>dispatch</code></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注意这里参数的传入顺序</span></span><br><span class="line"><span class="keyword">const</span> [state, dispatch] = useReducer(reducer, initial);</span><br><span class="line"><span class="keyword">const</span> &#123; n &#125; = state;</span><br><span class="line"><span class="keyword">const</span> onClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  dispatch(&#123; <span class="attr">type</span>: <span class="string">"add"</span>, <span class="attr">number</span>: <span class="number">1</span> &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> onClick2 = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  dispatch(&#123; <span class="attr">type</span>: <span class="string">"add"</span>, <span class="attr">number</span>: <span class="number">2</span> &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line">  &lt;div className=<span class="string">"App"</span>&gt;</span><br><span class="line">    &lt;h1&gt;n: &#123;n&#125;&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">    &lt;button onClick=&#123;onClick&#125;&gt;+1&lt;/</span>button&gt;</span><br><span class="line">    &lt;button onClick=&#123;onClick2&#125;&gt;+<span class="number">2</span>&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>div&gt;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>可以看出，以上的代码是分几步走的</p><ol><li>创建初始值 <code>initial</code></li><li>创建 <code>reducer</code> 这个操作的集合，它接受一个 <code>state</code> 和一个 <code>action</code></li><li>将 <code>reducer</code> 和 <code>initial</code> 传给 <code>useReducer</code>，并得到一个读(<code>state</code>)和写(<code>dispatch</code>)的 API</li><li>调用写(<code>dispatch</code>) API 传入 <code>{type: &#39;操作类型&#39;}</code> 去对 <code>state</code> 做相应的更新</li></ol><p>从以上描述我们不难看出，这个 <code>useReducer</code> 可以用来代替 <code>redux</code></p><h3 id="使用-useReducer-代替-redux"><a href="#使用-useReducer-代替-redux" class="headerlink" title="使用 useReducer 代替 redux"></a>使用 useReducer 代替 redux</h3><p><a href="https://codesandbox.io/s/interesting-volhard-lfxpm" target="_blank" rel="noopener">代码链接</a></p><blockquote><p>由于代码太长了所以这里就不放代码了，详情可以点击链接中的代码去查看</p></blockquote><p>由以上的代码我们可以知道一个基本的使用 <code>useReducer</code> 代替 redux 的步骤为</p><ol><li>声明一个 <code>store</code> 对象，对象中存放着该组件使用的数据</li><li>声明一个 <code>reducer</code> ，所有的相关的 crud 之类的操作都往这个里面放</li><li>使用 <code>createContext</code> 创建一个 <code>Context</code>，为组件间传递数据做准备</li><li>在 <code>App</code> 组件中使用 <code>useReducer</code> 创建读写 API，在其子组件中使用 <code>useContext</code> 创建读写 API(读: state 访问数据, 写: dispatch 对数据进行操作)</li><li>将第 4 步的返回内容放入到第 3 步的 <code>Context.Provider</code> 组件的 <code>value</code> 中</li><li>使用 <code>Context.Provider</code> 将 <code>Context</code> 提供给所有组件</li><li>然后各个子组件使用 <code>useContext(Context)</code> 获取到读写 API</li></ol><p>当然了，如果涉及到模块化的问题，将代码分开就可以了。比如</p><p><code>Context.js</code> 中可以放入</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Context.js</span></span><br><span class="line">mport React <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Context = React.createContext(<span class="literal">null</span>);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Context;</span><br></pre></td></tr></table></figure><p><code>reducers</code> 可以单独建立一个文件夹，里面放入的都是对应数据的一些操作，比如对 book 的操作可以这么写</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// reducers/books_reducer.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  setBooks: <span class="function">(<span class="params">state, action</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; ...state, <span class="attr">books</span>: action.books &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  deleteBook: <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后 <code>App</code> 子组件就放入 <code>components</code> 文件夹中，里面就是组件的一些东西了，这里不再赘述</p><p>最后的最后，在从 <code>src/index.js</code> 中引入这些文件即可，然后再做相应的代码优化。实际上模块化的本质就是分类整理代码，这样做了之后基本就能起到替代 <code>redux</code> 的作用了</p><h3 id="useReducer-注意点"><a href="#useReducer-注意点" class="headerlink" title="useReducer 注意点"></a>useReducer 注意点</h3><p>需要注意的是，<code>useReducer</code> 本身也不会帮你合并属性，所以同 <code>useState</code> 一样，要合并属性时需要自己动手操作</p><h3 id="useReducer-总结"><a href="#useReducer-总结" class="headerlink" title="useReducer 总结"></a>useReducer 总结</h3><p>总的来说，<code>useReducer</code> 这个 hook 其实本质上借鉴了 Flux/Redux 的一些思想，我们可以通过一些 hooks 来创建一个类似 <code>redux</code> 的写法，只要将其模块化后就可以替代 redux</p><h2 id="useRef"><a href="#useRef" class="headerlink" title="useRef"></a>useRef</h2><p>在理解 <code>uesRef</code> 之前，先看一个<a href="https://codesandbox.io/s/boring-booth-n6igq" target="_blank" rel="noopener">例子</a></p><h3 id="useState-的-bug"><a href="#useState-的-bug" class="headerlink" title="useState 的 bug"></a>useState 的 bug</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState &#125; <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [n, setN] = useState(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> log = <span class="function"><span class="params">()</span> =&gt;</span> setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">"n ="</span>, n), <span class="number">3000</span>);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">"App"</span>&gt;</span><br><span class="line">      &lt;p&gt;&#123;n&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">      &lt;p&gt;</span></span><br><span class="line"><span class="regexp">        &lt;button</span></span><br><span class="line"><span class="regexp">          onClick=&#123;() =&gt; &#123;</span></span><br><span class="line"><span class="regexp">            setN(n + 1);</span></span><br><span class="line"><span class="regexp">          &#125;&#125;</span></span><br><span class="line"><span class="regexp">        &gt;</span></span><br><span class="line"><span class="regexp">          +1</span></span><br><span class="line"><span class="regexp">        &lt;/</span>button&gt;</span><br><span class="line">      &lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">      &lt;p&gt;</span></span><br><span class="line"><span class="regexp">        &lt;button onClick=&#123;log&#125;&gt;log&lt;/</span>button&gt;</span><br><span class="line">      &lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在有个问题，在点击完 +1 button 然后点击 log，打印出来的 n 是正常的。但是如果是先 log 然后立即执行 +1，那么我们可以发现一个 bug，就是 <strong>n 居然没有变化!!!居然还是之前的旧数据!!!</strong></p><p>wtf, 这是什么情况???</p><p>先来看一张图</p><p><img src="./2.png" alt></p><ul><li>如果先点 +1 再点 log<br>  <code>setN</code> 会先执行，然后触发 <code>render</code>，3 秒过后，<code>log</code> 里面读到的 <code>n</code> 就是 <strong>已经从 <code>useState</code></strong> 里面读出来的 <code>n</code>，所以 <code>n = 1</code></li><li>如果先点 log 再点 +1<br>  <code>log</code> 会先执行，但是注意，此时 <code>log</code> 里的 <code>n</code> 还是初始状态下读到的 <strong>旧的 <code>n</code></strong>，随后 <code>setN</code> 执行后会产生一个<strong>新的 <code>n</code></strong>。然而此时其触发的 <code>render</code> 早就更新页面上的 <code>n</code> 了。所以会出现这种 “滞后” 的 bug</li></ul><h3 id="useState-bug-的解决方案"><a href="#useState-bug-的解决方案" class="headerlink" title="useState bug 的解决方案"></a>useState bug 的解决方案</h3><ul><li><p>将 <code>n</code> 和 <code>setN</code> 挂在全局变量 <code>window</code> 上<br>  这种解决方案太傻了，不考虑变量之间相互污染的问题么?</p></li><li><p>使用 <code>useRef</code></p>  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useRef &#125; <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> n = useRef(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> log = <span class="function"><span class="params">()</span> =&gt;</span> setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">"n ="</span>, n.current), <span class="number">3000</span>);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">"App"</span>&gt;</span><br><span class="line">      &lt;p&gt;&#123;n.current&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">      &lt;p&gt;</span></span><br><span class="line"><span class="regexp">        &lt;button</span></span><br><span class="line"><span class="regexp">          onClick=&#123;() =&gt; &#123;</span></span><br><span class="line"><span class="regexp">            n.current += 1;</span></span><br><span class="line"><span class="regexp">          &#125;&#125;</span></span><br><span class="line"><span class="regexp">        &gt;</span></span><br><span class="line"><span class="regexp">          +1</span></span><br><span class="line"><span class="regexp">        &lt;/</span>button&gt;</span><br><span class="line">      &lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">      &lt;p&gt;</span></span><br><span class="line"><span class="regexp">        &lt;button onClick=&#123;log&#125;&gt;log&lt;/</span>button&gt;</span><br><span class="line">      &lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  但你会发现这种<a href="https://codesandbox.io/s/boring-booth-n6igq" target="_blank" rel="noopener">方案</a>，页面上的元素不更新了，于是你可以这么改<a href="https://codesandbox.io/s/exciting-mirzakhani-4i06k" target="_blank" rel="noopener">代码</a></p>  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useRef, useState &#125; <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> n = useRef(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> update = useState(<span class="number">0</span>)[<span class="number">1</span>]; <span class="comment">// 注意这里!!!</span></span><br><span class="line">  <span class="keyword">const</span> log = <span class="function"><span class="params">()</span> =&gt;</span> setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">"n ="</span>, n.current), <span class="number">3000</span>);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">"App"</span>&gt;</span><br><span class="line">      &lt;p&gt;&#123;n.current&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">      &lt;p&gt;</span></span><br><span class="line"><span class="regexp">        &lt;button</span></span><br><span class="line"><span class="regexp">          onClick=&#123;() =&gt; &#123;</span></span><br><span class="line"><span class="regexp">            n.current += 1;</span></span><br><span class="line"><span class="regexp">            update(n.current); /</span><span class="regexp">/ 注意这里!!!</span></span><br><span class="line"><span class="regexp">          &#125;&#125;</span></span><br><span class="line"><span class="regexp">        &gt;</span></span><br><span class="line"><span class="regexp">          +1</span></span><br><span class="line"><span class="regexp">        &lt;/</span>button&gt;</span><br><span class="line">      &lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">      &lt;p&gt;</span></span><br><span class="line"><span class="regexp">        &lt;button onClick=&#123;log&#125;&gt;log&lt;/</span>button&gt;</span><br><span class="line">      &lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  这里做了一个小 trick，就是使用 <code>useState</code> 返回的第二个函数强制更新。。。当然这种方式太过 hack 肯定是不推荐的。不过由此我们可以知道 <code>useRef</code> 可以作为一种 <strong>贯穿始终的状态</strong> 来解决 <code>useState</code> 使用上的 bug</p></li></ul><h3 id="与-forwardRef-的关系"><a href="#与-forwardRef-的关系" class="headerlink" title="与 forwardRef 的关系"></a>与 forwardRef 的关系</h3><p>使用 <code>useRef</code> 时，<code>props</code> 是不能直接传递 <code>ref</code> 属性的，比如下面的代码</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> buttonRef = useRef(<span class="literal">null</span>);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">"App"</span>&gt;</span><br><span class="line">      &lt;Button2 ref=&#123;buttonRef&#125;&gt;按钮&lt;<span class="regexp">/Button2&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Button2 = <span class="function"><span class="params">props</span> =&gt;</span> &#123; <span class="comment">// 这里的 props 中的 ref 传不进来</span></span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">className</span>=<span class="string">"red"</span> &#123;<span class="attr">...props</span>&#125; /&gt;</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>浏览器会报错</p><blockquote><p>Warning: Function components cannot be given refs. Attempts to access this ref will fail. Did you mean to use React.forwardRef()?</p></blockquote><p>React 这个时候提醒你使用 <code>React.forwardRef()</code> 来传 <code>props</code> 中的 <code>ref</code> 属性，于是你可以这么改</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> buttonRef = useRef(<span class="literal">null</span>);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">"App"</span>&gt;</span><br><span class="line">      &lt;Button3 ref=&#123;buttonRef&#125;&gt;按钮&lt;<span class="regexp">/Button3&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意这里使用 React.forwardRef 多包裹了一层</span></span><br><span class="line"><span class="keyword">const</span> Button3 = React.forwardRef(<span class="function">(<span class="params">props, ref</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">className</span>=<span class="string">"red"</span> <span class="attr">ref</span>=<span class="string">&#123;ref&#125;</span> &#123;<span class="attr">...props</span>&#125; /&gt;</span></span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>当然你也可以通过两次传递 <code>ref</code> 来得到 button 的引用，这里就不细讲，有兴趣的童鞋可以参考<a href="https://codesandbox.io/s/amazing-snow-9f5g3" target="_blank" rel="noopener">这个链接</a><br>这个例子本质上也是参考上面代码的例子，只是这里我们需要理解的是 <code>ref</code> 属性是可以传一个引用的</p><p>所以由上面的例子我们知道了，其实 <code>useRef</code> <strong>既能引用 DOM 对象也能引用普通对象</strong>，但是在传 <code>ref</code> 时需要用到 <code>forwardRef</code></p><p>而对于 <code>forwardRef</code> 来说，由于 <code>props</code> 不包含 <code>ref</code>(主要是大部分时候也不需要 <code>props</code> 去传一个 <code>ref</code>)，这个时候才需要 <code>forwardRef</code>。</p><p>而 <code>forwardRef</code> 本身就是通过 <code>ref</code> 的透传来实现对于指定的 DOM 的定位的，这一点和 Vue 的 refs 是一样的</p><h3 id="useRef-总结"><a href="#useRef-总结" class="headerlink" title="useRef 总结"></a>useRef 总结</h3><p>由于每次的渲染，组件函数中对应的 <code>state</code> 都会不一样，比如上述代码中的 <code>n</code>。如果希望拿到同一个 <code>n</code>，那么可以考虑使用 <code>useRef</code> 这个 hook，那么这个时候你就需要访问的是 <code>n.current</code> 而不是 <code>n</code> 了。</p><p><code>useRef</code> <strong>不能做到变化时自动更新 render</strong>，前面说过解决方案，就是通过监听 <code>n</code>，当 <code>n.current</code> 变化时调用 <code>update</code> 解决，这里需要配合 <code>useState</code> 这个 hook 来使用。也就是说这个功能需要你自己加</p><h2 id="useContext"><a href="#useContext" class="headerlink" title="useContext"></a>useContext</h2><p>其实想想，<code>Context</code> 的译文就是 “上下文”。那么什么是上下文呢？</p><ul><li><strong>全局变量</strong> 是全局的 <strong>上下文</strong></li><li><strong>上下文</strong> 是局部的 <strong>全局变量</strong></li></ul><p>实际上 <code>useContext</code> 的用法跟 <code>useRef</code> 差不多，不过 <code>useContext</code> 不仅能<strong>贯穿始终</strong>，还能<strong>贯穿不同组件</strong></p><h3 id="使用-useContext"><a href="#使用-useContext" class="headerlink" title="使用 useContext"></a>使用 useContext</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useContext, useState &#125; <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> themeContext = React.createContext(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [theme, setTheme] = useState(<span class="string">"red"</span>);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="comment">// 这里 value 传入读写 API</span></span><br><span class="line">    &lt;themeContext.Provider value=&#123;&#123; theme, setTheme &#125;&#125;&gt;</span><br><span class="line">      &lt;div className=&#123;<span class="string">`App <span class="subst">$&#123;theme&#125;</span>`</span>&#125;&gt;</span><br><span class="line">        &lt;p&gt;&#123;theme&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">        &lt;div&gt;</span></span><br><span class="line"><span class="regexp">          &lt;ChildA /</span>&gt;</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;div&gt;</span></span><br><span class="line"><span class="regexp">          &lt;ChildB /</span>&gt;</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    &lt;<span class="regexp">/themeContext.Provider&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">function ChildA() &#123;</span></span><br><span class="line"><span class="regexp">  const &#123; theme, setTheme &#125; = useContext(themeContext); /</span><span class="regexp">/ 子组件中可以用 setTheme 函数</span></span><br><span class="line"><span class="regexp">  console.log(theme); /</span><span class="regexp">/ 子组件中可以拿到 theme 状态</span></span><br><span class="line"><span class="regexp">  return (</span></span><br><span class="line"><span class="regexp">    &lt;div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;button onClick=&#123;() =&gt; setTheme("red")&#125;&gt;red&lt;/</span>button&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">function ChildB() &#123;</span></span><br><span class="line"><span class="regexp">  const &#123; setTheme &#125; = useContext(themeContext); /</span><span class="regexp">/ 子组件中可以用 setTheme 函数</span></span><br><span class="line"><span class="regexp">  return (</span></span><br><span class="line"><span class="regexp">    &lt;div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;button onClick=&#123;() =&gt; setTheme("blue")&#125;&gt;blue&lt;/</span>button&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p><a href="https://codesandbox.io/s/exciting-mirzakhani-4i06k" target="_blank" rel="noopener">代码链接在这里</a></p><p>所以我们从中可以看到使用 <code>useContext</code> 的步骤了</p><ol><li>使用 <code>C = CreateContext(initial)</code> 创建上下文</li><li>使用 <code>C.Provider</code> 来限定要传的值的作用域在这个范围内</li><li>然后在 <code>C.Provider</code> 的作用域内使用 <strong><code>useContext(C)</code></strong> 来使用上下文(也就是 <code>C.Provider</code> 组件里面的 <code>value</code>)</li></ol><h3 id="useContext-注意点"><a href="#useContext-注意点" class="headerlink" title="useContext 注意点"></a>useContext 注意点</h3><p><code>useContext</code> 这个 hook 并不是响应式的，在一个组件中将 <code>C</code> 里面的值改变了(比如上述代码中的 <code>theme</code> 改变了)，另一个组件并不会知道这个变化。<strong>所以如果需要能够响应式，最好是配合 <code>useState</code> 来使用</strong></p><h3 id="useContext-总结"><a href="#useContext-总结" class="headerlink" title="useContext 总结"></a>useContext 总结</h3><p>如果希望拿到同一个 <code>n</code>，那么可以考虑使用 <code>useContext</code> 这个 hook，只需要将 <code>useRef</code> 的地方改成 <code>useContext</code> 就行</p><h2 id="useEffect"><a href="#useEffect" class="headerlink" title="useEffect"></a>useEffect</h2><p>这个就是 “副作用” 了，什么意思呢？</p><ul><li>在 js 中，我们把对环境的改变就叫 <strong>副作用</strong>，一个很典型的例子就是 <strong>修改 <code>document.title</code></strong></li><li>一定非得要把一些副作用的操作放到 <code>useEffect</code> 中执行么？<strong>不一定</strong></li><li>你可以把它理解为 <code>afterRender</code> ，因为这个<strong>总在 <code>render</code> 后执行</strong></li></ul><p>React 渲染的大致流程如下</p><figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">App()          <span class="comment">--&gt;  执行          --&gt; 生成虚拟 DOM --</span></span><br><span class="line">                                                    |</span><br><span class="line">             render 完毕                            |</span><br><span class="line">                ↓                                   |</span><br><span class="line">执行 useEffect &lt;<span class="comment">--  改变外观     &lt;-- 生成真实 DOM &lt;--</span></span><br><span class="line">      ↑                ↑</span><br><span class="line">&lt;<span class="keyword">div</span>&gt;<span class="number">1000</span>&lt;/<span class="keyword">div</span>&gt;     &lt;<span class="keyword">div</span>&gt;<span class="number">0</span>&lt;/<span class="keyword">div</span>&gt;</span><br></pre></td></tr></table></figure><p>如上面所示，在改变外观这里，render 完毕之后，就会执行 <code>useEffect</code>。</p><h3 id="使用-useEffect"><a href="#使用-useEffect" class="headerlink" title="使用 useEffect"></a>使用 useEffect</h3><ul><li><code>useEffect(() =&gt; {}, [])</code><br>  由于第二个参数传的是一个空数组，所以第一个参数函数只有在<strong>第一次渲染时执行</strong></li><li><code>useEffect(() =&gt; {}, [n])</code><br>  由于第二个参数传的是一个 <code>[n]</code>，这里表示<strong>只要 <code>n</code> 有变化</strong>，那么第一个参数函数就会执行</li><li><code>useEffect(() =&gt; {})</code><br>  由于没有传第二个参数，这里就表示 <strong>任何一个 state 变化时都不会执行</strong></li></ul><p><code>useEffect</code> 还有个用法，就是当组件处于 <code>componentWillUnmount</code> 时，即组件快要挂掉时使用，比如</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> id = setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;, <span class="number">1000</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="comment">// 这里 return 一个函数，当组件挂掉时调用这个，清理掉定时器，避免内存泄露</span></span><br><span class="line">    clearInterval(id)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, [])</span><br></pre></td></tr></table></figure><p><code>useEffect</code> 还有一个特点跟 <code>useState</code> 一样的，就是<strong>如果同时存在多个 <code>useEffect</code>， 会按照其出现的次序执行</strong></p><h3 id="useEffect-总结"><a href="#useEffect-总结" class="headerlink" title="useEffect 总结"></a>useEffect 总结</h3><ul><li>在对环境有些副作用操作的时候用 <code>useEffect</code></li><li>前面说的 <code>useEffect</code> 的几种用法中，可以都同时存在</li><li>可以将 <code>useEffect</code> 理解成 “afterRender”，因为它就是在 render 之后执行的</li></ul><h2 id="useLayoutEffect"><a href="#useLayoutEffect" class="headerlink" title="useLayoutEffect"></a>useLayoutEffect</h2><p>如果说 <code>useEffect</code> 在浏览器渲染完成后执行，那么 <code>useLayoutEffect</code> 就是在<strong>浏览器渲染完成前执行</strong>，它的位置在如下所示的位置</p><figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">App()          <span class="comment">--&gt;  执行          --&gt; 生成虚拟 DOM --</span></span><br><span class="line">                                                     |</span><br><span class="line">             render 完毕       useLayoutEffect       |</span><br><span class="line">                ↓                 ↓                  |</span><br><span class="line">执行 useEffect &lt;<span class="comment">--  改变外观     &lt;-- 生成真实 DOM &lt;--</span></span><br><span class="line">      ↑                ↑</span><br><span class="line">&lt;<span class="keyword">div</span>&gt;<span class="number">1000</span>&lt;/<span class="keyword">div</span>&gt;     &lt;<span class="keyword">div</span>&gt;<span class="number">0</span>&lt;/<span class="keyword">div</span>&gt;</span><br></pre></td></tr></table></figure><h3 id="useLayoutEffect-特点"><a href="#useLayoutEffect-特点" class="headerlink" title="useLayoutEffect 特点"></a>useLayoutEffect 特点</h3><ul><li>由图可知，<code>useLayoutEffect</code> 总是比 <code>useEffect</code> 先执行</li><li><code>useLayoutEffect</code> 里的操作最好是影响了 layout，虽然它性能更高，但是如果在这个里面的操作很多，它会影响用户看到画面变化的时间。从用户的角度来说，这是很影响用户体验的</li></ul><h3 id="useLayoutEffect-总结"><a href="#useLayoutEffect-总结" class="headerlink" title="useLayoutEffect 总结"></a>useLayoutEffect 总结</h3><ul><li>是跟 <code>useEffect</code> 差不多的玩意儿，不同之处在于其执行的优先级，它的优先级比 <code>useEffect</code> 高</li><li>为了用户体验，在能使用 <code>useEffect</code> 解决问题的前提下，尽量不要使用这个 <code>useLayoutEffect</code></li></ul><h2 id="useMemo"><a href="#useMemo" class="headerlink" title="useMemo"></a>useMemo</h2><p>这里 <code>Memo</code> 的全称应该是 <code>Memorize</code> 也就是 “记忆”，这个钩子的作用就是记忆代码，如果有多余的代码就不执行，怎么理解呢，在理解这个之前，需要先看看 <code>React.memo</code></p><h3 id="理解-React-memo"><a href="#理解-React-memo" class="headerlink" title="理解 React.memo"></a>理解 React.memo</h3><p>假设有如下的代码</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [n, setN] = React.useState(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> [m, setM] = React.useState(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> onClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    setN(n + <span class="number">1</span>);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">"App"</span>&gt;</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;button onClick=&#123;onClick&#125;&gt;update n &#123;n&#125;&lt;<span class="regexp">/button&gt; /</span>*点击 button 只让 n + <span class="number">1</span>*<span class="regexp">/</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">      &lt;Child data=&#123;m&#125; /&gt; <span class="comment">/* 这里的 m 没有变化，按照理由来说 child 不应该重新渲染才对*/</span></span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">function Child(props) &#123;</span></span><br><span class="line"><span class="regexp">  console.log("child 执行了");</span></span><br><span class="line"><span class="regexp">  console.log("假设这里有大量代码"); /</span><span class="regexp">/ 但是这里却执行了!!!</span></span><br><span class="line"><span class="regexp">  return &lt;div&gt;child: &#123;props.data&#125;&lt;/</span>div&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>传入的 <code>props.data</code> 根本没有变化，即 <code>m</code> 没有变，变的只是 <code>n</code>，但是这里 <code>Child()</code> 每次都执行了，要是 <code>Child()</code> 函数里面有很多的代码，势必会造成页面的卡顿现象，于是这个时候，<code>React.memo</code> 就排上用场了</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [n, setN] = React.useState(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> [m, setM] = React.useState(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> onClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    setN(n + <span class="number">1</span>);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">"App"</span>&gt;</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;button onClick=&#123;onClick&#125;&gt;update n &#123;n&#125;&lt;<span class="regexp">/button&gt; /</span>*点击 button 只让 n + <span class="number">1</span>*<span class="regexp">/</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">      &lt;Child2 data=&#123;m&#125; /&gt; <span class="comment">/* 这里的 m 没有变化，按照理由来说 child 不应该重新渲染才对*/</span></span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">function Child(props) &#123;</span></span><br><span class="line"><span class="regexp">  console.log("child 执行了");</span></span><br><span class="line"><span class="regexp">  console.log("假设这里有大量代码"); /</span><span class="regexp">/ 使用了 React.memo 后，这里就没有执行了!!!</span></span><br><span class="line"><span class="regexp">  return &lt;div&gt;child: &#123;props.data&#125;&lt;/</span>div&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Child2 = React.memo(Child)</span><br></pre></td></tr></table></figure><p>如果 <code>props</code> 没变，就没有必要再次执行一个函数组件，这个 <code>React.memo</code> 是属于 React 优化的一部分。原理就是跟缓存的道理一样的。在 React 中，其默认有多余的 render。为了解决这个问题后面才出来 memo</p><h3 id="React-memo-的-bug"><a href="#React-memo-的-bug" class="headerlink" title="React.memo 的 bug"></a>React.memo 的 bug</h3><p>请看如下的代码</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [n, setN] = React.useState(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> [m, setM] = React.useState(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> onClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    setN(n + <span class="number">1</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">const</span> onClickChild = <span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="comment">// 这里只是添加了一个 click 的回调而已。。。</span></span><br><span class="line">    <span class="built_in">console</span>.log(m);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">"App"</span>&gt;</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;button onClick=&#123;onClick&#125;&gt;update n &#123;n&#125;&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">      &lt;Child2 data=&#123;m&#125; onClick=&#123;onClickChild&#125; /&gt;</span><br><span class="line">      &#123;<span class="comment">/* Child2 居然又执行了 */</span>&#125;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">function Child(props) &#123;</span></span><br><span class="line"><span class="regexp">  console.log("child 执行了");</span></span><br><span class="line"><span class="regexp">  console.log("假设这里有大量代码"); /</span><span class="regexp">/ 这里的代码因为仅仅只是添加了回调的原因，居然又执行了!!!</span></span><br><span class="line"><span class="regexp">  return &lt;div onClick=&#123;props.onClick&#125;&gt;child: &#123;props.data&#125;&lt;/</span>div&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Child2 = React.memo(Child); <span class="comment">// memo 在这里就没用了!!!</span></span><br></pre></td></tr></table></figure><p>为什么在这种情况下 <code>React.memo</code> 的优化作用失效了呢？因为在点击 button 更新 <code>n</code> 的数据时会再次渲染页面，就会再次执行 <code>App()</code>，就会再次声明 <code>onClickChild</code> 这个函数，<strong>而这个函数的地址已经变了!!!!</strong>。因为这个函数地址变的原因，<strong>React 就判断其 <code>props</code> 产生了变化</strong>，于是就认为 <code>Child</code> 组件已经变化了，需要重新渲染它!!，于是乎 <code>Child()</code> 就会再次执行!!!</p><p>那么还有什么解决办法呢？有的，就是使用 <code>useMemo</code>，使用这个 hook 就不会有这个问题</p><h3 id="使用-useMemo"><a href="#使用-useMemo" class="headerlink" title="使用 useMemo"></a>使用 useMemo</h3><p>使用 <code>useMemo</code> 去解决上面的 bug 的话，只需要将 <code>onClickChild</code> 函数修改成如下</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> onClickChild = useMemo(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> fn = <span class="function"><span class="params">div</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"on click child, m: "</span> + m);</span><br><span class="line">    <span class="built_in">console</span>.log(div);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> fn;</span><br><span class="line">&#125;, [m]); <span class="comment">// 这里只要 m 变化才能说明 `onClickChild` 变化了，当然这里的 m 要是改为 n 会打印出旧的 n 的数据</span></span><br></pre></td></tr></table></figure><ul><li><code>useMemo</code> 第一个参数是一个工厂函数 <code>() =&gt; value</code>, 第二个参数是依赖<code>[n, m]</code>，只有当依赖变化时，才会计算出新的 <code>value</code></li><li>如果依赖没有变化，则服用之前的 <code>value</code></li></ul><h3 id="useMemo-注意点"><a href="#useMemo-注意点" class="headerlink" title="useMemo 注意点"></a>useMemo 注意点</h3><ul><li><p>如果本身 <code>value</code> 是一个函数，你就必须要这么写</p>  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">useMemo(<span class="function"><span class="params">()</span> =&gt;</span> <span class="function"><span class="params">x</span> =&gt;</span> <span class="built_in">console</span>.log(x), [m]) <span class="comment">// 注意这里是一个返回函数的函数</span></span><br></pre></td></tr></table></figure></li><li><p>如果觉得这很不优雅，推荐使用 <code>useCallback</code></p></li></ul><h3 id="useMemo-总结"><a href="#useMemo-总结" class="headerlink" title="useMemo 总结"></a>useMemo 总结</h3><p>从本质上看 <code>useMemo</code> 有点像 Vue 中的 Computed，其计算属性本来就依赖一个会变化的数据，数据变化时 vue 会帮你做相应的更新操作</p><p><code>useMemo</code> 一般是结合 <code>React.memo</code> 做一些代码层面的优化工作</p><h2 id="useCallback"><a href="#useCallback" class="headerlink" title="useCallback"></a>useCallback</h2><p><code>useCallback</code> 就是为了解决上述 <code>useMemo</code> 中 <code>value</code> 是一个函数时的传参写法问题的，它的用法如下</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">useCallback(<span class="function"><span class="params">x</span> =&gt;</span> <span class="built_in">console</span>.log(x), [m])</span><br></pre></td></tr></table></figure><p>其等价于<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">useMemo(<span class="function"><span class="params">()</span> =&gt;</span> <span class="function"><span class="params">x</span> =&gt;</span> <span class="built_in">console</span>.log(x), [m])</span><br></pre></td></tr></table></figure></p><h3 id="useCallback-总结"><a href="#useCallback-总结" class="headerlink" title="useCallback 总结"></a>useCallback 总结</h3><p>这个是跟 <code>useMemo</code> 功能相近的 hook，主要为了补充 <code>useMemo</code> 传参的写法用的</p><h2 id="useImperativeHandle"><a href="#useImperativeHandle" class="headerlink" title="useImperativeHandle"></a>useImperativeHandle</h2><p>你可以将其理解为 <code>setRef</code>，其作用就是 <strong>自定义 ref 的属性</strong>，<a href="https://codesandbox.io/s/elegant-poitras-mxoym" target="_blank" rel="noopener">代码链接在这里</a></p><p>关键的代码在这一句</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">setRef(ref, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    x: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      realButton.current.remove();</span><br><span class="line">    &#125;,</span><br><span class="line">    realButton: realButton</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>其实就是给 <code>ref</code> 增添了属性，让其对应的 <code>ref</code> 能够访问到 <code>realButton</code> 这个属性以及能够调用 <code>x</code> 这个方法</p><h2 id="hooks-其他内容-dlc"><a href="#hooks-其他内容-dlc" class="headerlink" title="hooks 其他内容(dlc)"></a>hooks 其他内容(dlc)</h2><h3 id="如何自定义-hook"><a href="#如何自定义-hook" class="headerlink" title="如何自定义 hook"></a>如何自定义 hook</h3><p>拿 <code>useState</code> 举例，可以将自己定义的 hook 作为一个模块封装起来然后 <code>export</code> 出去，具体来说就像如下代码所做的</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useState, useEffect &#125; <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> useList = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [list, setList] = useState(<span class="literal">null</span>);</span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    ajax(<span class="string">"/list"</span>).then(<span class="function"><span class="params">list</span> =&gt;</span> &#123;</span><br><span class="line">      setList(list); <span class="comment">// 异步请求</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;, []); <span class="comment">// [] 确保只在第一次运行</span></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    list: list,</span><br><span class="line">    setList: setList,</span><br><span class="line">    addItem: <span class="function"><span class="params">name</span> =&gt;</span> &#123;</span><br><span class="line">      setList([...list, &#123; <span class="attr">id</span>: <span class="built_in">Math</span>.random(), <span class="attr">name</span>: name &#125;]);</span><br><span class="line">    &#125;,</span><br><span class="line">    deleteIndex: <span class="function"><span class="params">index</span> =&gt;</span> &#123;</span><br><span class="line">      setList(list.slice(<span class="number">0</span>, index).concat(list.slice(index + <span class="number">1</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> useList;</span><br></pre></td></tr></table></figure><p>所以我们可以看到，这里本质上就是对 <code>useState</code> 这个 hook 做了一层封装，然后返回的依然是 <code>state</code> 以及 <code>setState</code> 这个方法，即返回的是一个<strong>读(查)写(增删改) API</strong></p><h3 id="自定义-hook-注意点"><a href="#自定义-hook-注意点" class="headerlink" title="自定义 hook 注意点"></a>自定义 hook 注意点</h3><ul><li>也可以在自定义 hook 里面使用 <code>Context</code> API</li><li><code>useState</code> 可以在函数里使用，关键是这个函数是在组件里面运行的就可以</li></ul><h3 id="Stale-Closure"><a href="#Stale-Closure" class="headerlink" title="Stale Closure"></a>Stale Closure</h3><p>这个主要是被尤大吐槽过的，说他在读一些使用 hooks 写的库时就十分的脑壳疼，评价其为过时的闭包(stale closure)</p><p>那么过时闭包是怎么一回事呢，来看如下的代码</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createIncrement</span>(<span class="params">i</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> value = <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">increment</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    value += i;</span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">    <span class="keyword">const</span> message = <span class="string">`Current value is <span class="subst">$&#123;value&#125;</span>`</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">logValue</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(message);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> increment;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> inc = createIncrement(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">const</span> log = inc(); <span class="comment">// logs 1</span></span><br><span class="line">inc();             <span class="comment">// logs 2</span></span><br><span class="line">inc();             <span class="comment">// logs 3</span></span><br><span class="line"><span class="comment">// Does not work!</span></span><br><span class="line">log();             <span class="comment">// logs "Current value is 1"</span></span><br></pre></td></tr></table></figure><p>最后 <code>log</code> 居然还是之前第一次的 <code>value</code>, 这不科学！！！但是这是正常的，毕竟你保存的是第一个函数执行的地址，而其他函数执行地址跟这个不一样，所以才有这个问题</p><p>于是解决办法也有，其实只要每次得到最新的 <code>value</code> 就可以了</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createIncrementFixed</span>(<span class="params">i</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> value = <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">increment</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    value += i;</span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">logValue</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">const</span> message = <span class="string">`Current value is <span class="subst">$&#123;value&#125;</span>`</span>; <span class="comment">// 注意这里将这句移动到 logValue 里面来了 !!!</span></span><br><span class="line">      <span class="built_in">console</span>.log(message);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> increment;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> inc = createIncrementFixed(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">const</span> log = inc(); <span class="comment">// logs 1</span></span><br><span class="line">inc();             <span class="comment">// logs 2</span></span><br><span class="line">inc();             <span class="comment">// logs 3</span></span><br><span class="line"><span class="comment">// Works!</span></span><br><span class="line">log();             <span class="comment">// logs "Current value is 3"</span></span><br></pre></td></tr></table></figure><p>所以说 hooks 中也有解决这些过时闭包的 bug 出现的措施，就是依赖更新。<br>比如 <code>useEffect</code> 中要传的第二个参数，比如 <code>useState</code> 中 <code>setState</code> 传一个函数更新的形式，都是为了解决这个 bug 而出现的举措。<br>这里就不详细说明了，有兴趣的童鞋可以去参考我列出的链接</p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://dmitripavlutin.com/react-hooks-stale-closures/" target="_blank" rel="noopener">Be Aware of Stale Closures when Using React Hooks</a></li><li><a href="https://zh-hans.reactjs.org/docs/hooks-intro.html" target="_blank" rel="noopener">hooks 简介</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文主要会就 React hooks 中用的比较多的 &lt;code&gt;useState&lt;/code&gt; 做一个详细讲解，其他的 hooks 会涉及到原理和使用但不会涉及到源码仿写，望周知&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="React" scheme="https://strugglebak.github.io/categories/React/"/>
    
    
      <category term="react-hooks" scheme="https://strugglebak.github.io/tags/react-hooks/"/>
    
  </entry>
  
  <entry>
    <title>从Promise本质开始(一):实现Promise前言</title>
    <link href="https://strugglebak.github.io/2020/03/09/%E4%BB%8EPromise%E6%9C%AC%E8%B4%A8%E5%BC%80%E5%A7%8B-%E4%B8%80-%E5%AE%9E%E7%8E%B0Promise%E5%89%8D%E8%A8%80/"/>
    <id>https://strugglebak.github.io/2020/03/09/从Promise本质开始-一-实现Promise前言/</id>
    <published>2020-03-09T10:02:39.000Z</published>
    <updated>2022-06-04T08:13:29.212Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>注意，由于本文讨论的是使用 TDD 方式实现一个 Promise，所以本文着重描述的是搭建 TDD 环境</p></blockquote><a id="more"></a><h2 id="Promise-能解决什么问题"><a href="#Promise-能解决什么问题" class="headerlink" title="Promise 能解决什么问题"></a>Promise 能解决什么问题</h2><p>先来看一段代码</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">fs.readdir(source, <span class="function"><span class="keyword">function</span> (<span class="params">err, files</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'Error finding files: '</span> + err)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        files.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">filename, fileIndex</span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(filename)</span><br><span class="line">            gm(source + filename).size(<span class="function"><span class="keyword">function</span> (<span class="params">err, values</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (err) &#123;</span><br><span class="line">                    <span class="built_in">console</span>.log(<span class="string">'Error identifying file size: '</span> + err)</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="built_in">console</span>.log(filename + <span class="string">' : '</span> + values)</span><br><span class="line">                    aspect = (values.width / values.height)</span><br><span class="line">                    widths.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">width, widthIndex</span>) </span>&#123;</span><br><span class="line">                        height = <span class="built_in">Math</span>.round(width / aspect)</span><br><span class="line">                        <span class="built_in">console</span>.log(<span class="string">'resizing '</span> + filename + <span class="string">'to '</span> + height + <span class="string">'x'</span> + height)</span><br><span class="line">                        <span class="keyword">this</span>.resize(width, height).write(dest + <span class="string">'w'</span> + width + <span class="string">'_'</span> + filename, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">                            <span class="keyword">if</span> (err) <span class="built_in">console</span>.log(<span class="string">'Error writing file: '</span> + err)</span><br><span class="line">                        &#125;)</span><br><span class="line">                    &#125;.bind(<span class="keyword">this</span>))</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>可以看到着里面产生了几个回调，也就是那个著名的 <code>callback hell</code>(回调地狱)</p><p>所以这有可能真的是回调地狱的问题么?来看看改善之后的代码吧</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">fs.readdir(source, (err, files) =&gt; &#123;</span><br><span class="line">  travalFiles = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">console</span>.log(<span class="string">'Error: 找不到目录'</span> + err)</span><br><span class="line">    &#125;</span><br><span class="line">    files.forEach(gmFile)</span><br><span class="line">  &#125;</span><br><span class="line">  gmFile = <span class="function">(<span class="params">filename</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(filename)</span><br><span class="line">    gm(source + filename).size(afterGetSize)</span><br><span class="line">  &#125;</span><br><span class="line">  afterGetSize = <span class="function">(<span class="params">err, values</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">return</span> <span class="built_in">console</span>.log(<span class="string">'无法读取文件尺寸: '</span> + err)</span><br><span class="line">    <span class="built_in">console</span>.log(filename + <span class="string">' : '</span> + values)</span><br><span class="line">    aspect = (values.width / values.height)</span><br><span class="line">    widths.forEach(<span class="function">(<span class="params">width, widthIndex</span>) =&gt;</span> resize(width, aspect))</span><br><span class="line">  &#125;</span><br><span class="line">  resize = <span class="function">(<span class="params">width, aspect</span>) =&gt;</span> &#123;</span><br><span class="line">    height = <span class="built_in">Math</span>.round(width / aspect)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'将'</span> + filename + <span class="string">'的尺寸变为'</span> + width + <span class="string">'x'</span> + height)</span><br><span class="line">    <span class="keyword">this</span>.resize(width, height).write(</span><br><span class="line">      dest + <span class="string">'w'</span> + width + <span class="string">'_'</span> + filename,</span><br><span class="line">      (err) =&gt; err &amp;&amp; <span class="built_in">console</span>.log(<span class="string">'Error writing file: '</span> + err)</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  travalFiles(err, files)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>上面的代码没有回调么？当然有，那么为什么看起来清晰了呢？是因为这里将 <strong>函数当作参数传给要调用的函数了</strong>，所以其实对于 <code>Promise</code> 而言也是一样的</p><h2 id="Promise-的优点"><a href="#Promise-的优点" class="headerlink" title="Promise 的优点"></a>Promise 的优点</h2><p>优点有俩</p><h3 id="减少缩进-在整体代码的意义上"><a href="#减少缩进-在整体代码的意义上" class="headerlink" title="减少缩进(在整体代码的意义上)"></a>减少缩进(在整体代码的意义上)</h3><p>将 <strong>函数套函数</strong> 的形式转变成 <strong>链式调用</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">f1(xxx, <span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">    f3(yyy, <span class="function"><span class="keyword">function</span> <span class="title">f4</span>(<span class="params">b</span>) </span>&#123;</span><br><span class="line">        f5(a+b, <span class="function"><span class="keyword">function</span> <span class="title">f6</span>(<span class="params"></span>) </span>&#123;&#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>转变成</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">f1(xxx)</span><br><span class="line">    .then(f2) <span class="comment">// f2 调用 f3，并同时将参数作为结果输出</span></span><br><span class="line">    .then(f4) <span class="comment">// f4 调用 f5，并同时接受到 f2 的结果(就是参数)，f5 就得到了 f2 以及 f4 的参数</span></span><br><span class="line">    .then(f6)</span><br></pre></td></tr></table></figure><h3 id="消灭-if-err-形式的代码"><a href="#消灭-if-err-形式的代码" class="headerlink" title="消灭 if(err) 形式的代码"></a>消灭 if(err) 形式的代码</h3><ul><li>关于错误的处理可以单独放到一个函数里面</li><li>如果不处理，则一直等到向后抛</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">f1(xxx)</span><br><span class="line">    .then(f2, error1)</span><br><span class="line">    .then(f4, error2)</span><br><span class="line">    .then(f6, error3)</span><br><span class="line">    .then(<span class="literal">null</span>, errorAll)</span><br><span class="line"><span class="comment">// 这里最后一句可以改成 catch, 意味着它可以处理所有的 error</span></span><br></pre></td></tr></table></figure><h2 id="如何使用-Promise"><a href="#如何使用-Promise" class="headerlink" title="如何使用 Promise"></a>如何使用 Promise</h2><p>对于一个异步的代码，以前是这么写</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        fn(<span class="string">'1 秒后调用'</span>) <span class="comment">// 这里相当于 fn.call(null, '1 秒后调用')</span></span><br><span class="line">    &#125; , <span class="number">1000</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test(<span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">'传入 fn'</span>) &#125;)</span><br></pre></td></tr></table></figure><p>如果使用 <code>Promise</code></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// new Promise 接受一个参数，返回一个 Promise 实例</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            resolve(<span class="string">'1 秒后调用'</span>)</span><br><span class="line">        &#125; , <span class="number">1000</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test(<span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">'传入 fn'</span>) &#125;)</span><br></pre></td></tr></table></figure><h2 id="Promise-有哪些-API"><a href="#Promise-有哪些-API" class="headerlink" title="Promise 有哪些 API"></a>Promise 有哪些 API</h2><ul><li><strong>Promise 是一个类</strong>(相当于一个特殊的函数)</li><li>类属性: <code>length</code></li><li>类方法: <code>all</code>, <code>allSettled</code>, <code>race</code>, <code>reject</code>, <code>resolve</code></li><li>对象属性: <strong><code>then</code></strong> , <code>finally</code>, <code>catch</code></li><li>对象内部属性: <strong><code>state</code></strong>(pending, fullfilled, rejected)</li></ul><p>这里注意，<code>state</code> 的 <code>pending</code> 状态的转变是单向的，即只有</p><ul><li>pending -&gt; fullfilled(成功)</li><li>pending -&gt; rejected(失败)</li></ul><p><strong>并且 fullfilled 以及 rejected 状态不能互相转变，也不能转化成 pending</strong></p><h2 id="Promise-API-怎么写"><a href="#Promise-API-怎么写" class="headerlink" title="Promise API 怎么写"></a>Promise API 怎么写</h2><ul><li>参考 <a href="https://promisesaplus.com/" target="_blank" rel="noopener">promise/A+ 规范</a> 或者其 <a href="https://juejin.im/post/5b6161e6f265da0f8145fb72" target="_blank" rel="noopener">翻译版文档</a></li><li>在写代码时根据文档<strong>写测试用例</strong>，规则都通过了说明 <code>Promise</code> 相关的逻辑也就完成了</li></ul><h2 id="使用测试工具"><a href="#使用测试工具" class="headerlink" title="使用测试工具"></a>使用测试工具</h2><h3 id="使用-chai"><a href="#使用-chai" class="headerlink" title="使用 chai"></a>使用 chai</h3><p>先全局安装两个包</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yarn add -g ts-node mocha</span><br></pre></td></tr></table></figure><p>然后创建项目 <code>promise-easy</code>，再执行</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> promise-easy</span><br><span class="line">yarn init -y</span><br></pre></td></tr></table></figure><p>最后再次给项目安装包</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yarn add -D ts-node mocha chai @types/chai @types/mocha typescript</span><br></pre></td></tr></table></figure><p>然后创建 <code>test/index.ts</code></p><figure class="highlight irpf90"><table><tr><td class="code"><pre><span class="line"><span class="keyword">touch</span> test/<span class="built_in">index</span>.ts</span><br></pre></td></tr></table></figure><p>最后增加 <code>package.json</code> 的 <code>scripts</code></p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">"scripts": &#123;</span><br><span class="line">    "test": "mocha -r ts-node/register test/**/*.ts" // mocha 使用 ts-node/register 模块来对 test 下的 ts 文件进行测试</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后执行</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yarn <span class="built_in">test</span></span><br></pre></td></tr></table></figure><p>出现如下打印输出则算配置成功</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yarn run v1.21.1</span><br><span class="line">$ mocha -r ts-node/register <span class="built_in">test</span>/**/*.ts</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  0 passing (5ms)</span><br><span class="line"></span><br><span class="line">Done <span class="keyword">in</span> 3.18s.</span><br></pre></td></tr></table></figure><p>然后说下这几个包的作用</p><ul><li><code>chai</code>: chai 是一个 BDD/TDD 的断言库，我们经常使用其 <code>assert</code> api 来做测试种断言的操作</li><li><code>mocha</code>: mocha 是一个多功能的测试框架，我们经常使用其 <code>describe</code> 以及 <code>it</code> api 来做相关的测试</li><li><code>ts-node</code>, <code>typescript</code>: ts-node 是用来编译 node 中的 typescript 用的，使用 typescript 时需要安装 typescript</li><li><code>@types/chai</code>, <code>@types/mocha</code>: chai 和 mocha 的 typescript 版本，方便在 ts 文件中引入</li></ul><p>现在就可以在 <code>test/index.ts</code> 中写代码了</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; assert &#125; <span class="keyword">from</span> <span class="string">'chai'</span></span><br><span class="line"><span class="keyword">import</span> &#123; describe, it &#125; <span class="keyword">from</span> <span class="string">'mocha'</span></span><br><span class="line"></span><br><span class="line">describe(<span class="string">'测试 Chai 的使用'</span>, () =&gt; &#123;</span><br><span class="line"> it(<span class="string">'可以测试相等'</span>, () =&gt; &#123;</span><br><span class="line">    assert(<span class="number">1</span> === <span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>其中 <code>describe</code> 表示描述测试的场景，而 <code>it</code> 表示在该测试场景下的对象</p><blockquote><p>注意，若在断言的那段代码的上面加 <code>//@ts-ignore</code> 即可屏蔽掉 typescript 对这段代码的检查，那么代码在编译运行时就不会报错</p></blockquote><p>对于 <code>assert</code> 这个 api 来说，它里面有很多的函数比如经常使用到的有如下几个</p><ul><li><code>isXXX</code>: 判断对象或变量的类型用的，比如 <code>isFunction</code>，<code>isObject</code></li><li><code>throw</code>: 这个一般用于你想让其传入的回调函数中的代码报错</li></ul><h3 id="使用-sinon"><a href="#使用-sinon" class="headerlink" title="使用 sinon"></a>使用 sinon</h3><p>安装 <code>sinon</code></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yarn add -D sinon sinon-chai @types/sinon @types/sinon-chai</span><br></pre></td></tr></table></figure><p>然后说下这几个包都是啥</p><ul><li><code>sinon</code>: 适用于任何单元测试框架的测试库</li><li><code>sinon-chai</code>: 为 <code>sinon</code> 提供了一系列自自定义的断言 api，相当于 chai 的拓展</li><li><code>@types/sinon</code>, <code>@types/sinon-chai</code>: sinon 和 sinon-chai 的 typescript 版本</li></ul><p>在这里主要是使用 <code>sinon.fake()</code> 提供一个假函数，然后通过判断这个假函数的 <code>called</code> 属性来判断函数是否被调用</p><p>你需要这样引入</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> chai <span class="keyword">from</span> <span class="string">'chai'</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> sinon <span class="keyword">from</span> <span class="string">'sinon'</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> sinonChai <span class="keyword">from</span> <span class="string">'sinon-chai</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">chai.use(sinonChai)</span></span><br></pre></td></tr></table></figure><p>然后像这样使用</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">it(<span class="string">'new Promise(fn) 中的函数立即执行'</span>, () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> fn = sinon.fake()</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(fn)</span><br><span class="line">    assert(fn.called)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文主要介绍了如何搭建测试环境，以及如何使用测试框架来进行开发(TDD)。其中比较重要的还设计到了 <code>Promise</code> 的几个要点，即</p><ul><li>Promise 要解决什么问题 - why</li><li>Promise 是怎么解决它的 - how</li><li>Promise (对比其他技术)有什么有点 - pros</li><li>Promise有什么缺点 - cons</li><li>如何解决这些缺点</li></ul><p>框架和环境已经搭建完毕，接下来就是遵循 Promise/A+ 规范实现一个简易 Promise</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;注意，由于本文讨论的是使用 TDD 方式实现一个 Promise，所以本文着重描述的是搭建 TDD 环境&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="手写源码" scheme="https://strugglebak.github.io/categories/%E6%89%8B%E5%86%99%E6%BA%90%E7%A0%81/"/>
    
    
      <category term="Promise" scheme="https://strugglebak.github.io/tags/Promise/"/>
    
  </entry>
  
  <entry>
    <title>从Webpack本质开始(四):手写tapable</title>
    <link href="https://strugglebak.github.io/2020/03/09/%E4%BB%8EWebpack%E6%9C%AC%E8%B4%A8%E5%BC%80%E5%A7%8B-%E5%9B%9B-%E6%89%8B%E5%86%99tapable/"/>
    <id>https://strugglebak.github.io/2020/03/09/从Webpack本质开始-四-手写tapable/</id>
    <published>2020-03-09T09:52:54.000Z</published>
    <updated>2022-06-04T08:13:29.385Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这个是探究 Webpack 本质的系列文章，会详细讲解如何手写一些源码如 Webpack, loader, plugin 等等，本文主要讲解的是如何手写 tapbable 库</p></blockquote><a id="more"></a><h2 id="tapable-是个啥"><a href="#tapable-是个啥" class="headerlink" title="tapable 是个啥"></a>tapable 是个啥</h2><p>由之前写的文章可以了解到，webpack 本质上是基于 <strong>事件流</strong> 的机制，它的工作流程就是将各个插件串联起来，而实现这一切的核心就是 <code>tapable</code>。<code>tapable</code> 就有点类似于 Node.js 的 <code>events</code> 库，核心原理也依赖于 <strong>发布订阅</strong> 模式</p><p>以下是 <code>tapable</code> 几个常用钩子</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;</span><br><span class="line">SyncHook,</span><br><span class="line">SyncBailHook,</span><br><span class="line">SyncWaterfallHook,</span><br><span class="line">SyncLoopHook,</span><br><span class="line"></span><br><span class="line">AsyncParallelHook,</span><br><span class="line">AsyncParallelBailHook,</span><br><span class="line">AsyncSeriesHook,</span><br><span class="line">AsyncSeriesBailHook,</span><br><span class="line">AsyncSeriesWaterfallHook</span><br><span class="line"> &#125; = <span class="built_in">require</span>(<span class="string">"tapable"</span>)</span><br></pre></td></tr></table></figure><blockquote><p>以 <code>Sync</code> 开头的都是同步钩子，以 <code>Async</code> 开头的都是异步钩子</p></blockquote><p>这些钩子基本上都是通过 <code>tap</code> 来绑定事件，然后使用 <code>call</code> 来触发事件，比如如下的代码</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; SyncHook &#125; = <span class="built_in">require</span>(<span class="string">'tapable'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.hooks = &#123;</span><br><span class="line">      <span class="comment">// new 一个钩子</span></span><br><span class="line">      arch: <span class="keyword">new</span> SyncHook([<span class="string">'name'</span>])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 注册监听函数</span></span><br><span class="line">  tap() &#123;</span><br><span class="line">    <span class="keyword">this</span>.hooks.arch.tap(<span class="string">'test1'</span>, (name) =&gt; &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'test1'</span>, name)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">this</span>.hooks.arch.tap(<span class="string">'test2'</span>, (name) =&gt; &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'test2'</span>, name)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 调用方法</span></span><br><span class="line">  call() &#123;</span><br><span class="line">    <span class="comment">// 'strugglebak' 就是 tap 函数中回调的 name</span></span><br><span class="line">    <span class="keyword">this</span>.hooks.arch.call(<span class="string">'strugglebak'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> t = <span class="keyword">new</span> Test()</span><br><span class="line">t.tap()</span><br><span class="line">t.call()</span><br></pre></td></tr></table></figure><p>执行下打印结果是</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">test1 strugglebak</span><br><span class="line">test2 strugglebak</span><br></pre></td></tr></table></figure><p>由以上可以看出，<code>tapable</code> 是将一堆 <code>tap</code> 中订阅的函数放到一个数组中去，调用 <code>call</code> 时分别按顺序去执行</p><h2 id="实现-SyncHook"><a href="#实现-SyncHook" class="headerlink" title="实现 SyncHook"></a>实现 SyncHook</h2><p>由以上的论证，代码不难实现</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SyncHook</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(args) &#123;</span><br><span class="line">    <span class="keyword">this</span>.tasks = []</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  tap(name, task) &#123;</span><br><span class="line">    <span class="keyword">this</span>.tasks.push(task)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// call 传入的不只有一个参数</span></span><br><span class="line">  call(...args) &#123;</span><br><span class="line">    <span class="keyword">this</span>.tasks.forEach(<span class="function"><span class="params">task</span> =&gt;</span> task(...args))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试代码</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> hook = <span class="keyword">new</span> SyncHook([<span class="string">'name'</span>])</span><br><span class="line">hook.tap(<span class="string">'test1'</span>, (name) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'test1'</span>, name)</span><br><span class="line">&#125;)</span><br><span class="line">hook.tap(<span class="string">'test2'</span>, (name) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'test2'</span>, name)</span><br><span class="line">&#125;)</span><br><span class="line">hook.call(<span class="string">'strugglebak'</span>)</span><br></pre></td></tr></table></figure><p>打印结果为</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">test1 strugglebak</span><br><span class="line">test2 strugglebak</span><br></pre></td></tr></table></figure><h2 id="实现-SyncBailHook"><a href="#实现-SyncBailHook" class="headerlink" title="实现 SyncBailHook"></a>实现 SyncBailHook</h2><p>这个钩子的作用是，<strong>只要有任何的监听函数返回了一个非 undefined 的结果，那么该监听函数里面的逻辑在执行完成后会就不会继续向下执行了</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SyncBailHook</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(args) &#123;</span><br><span class="line">    <span class="keyword">this</span>.tasks = []</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  tap(name, task) &#123;</span><br><span class="line">    <span class="keyword">this</span>.tasks.push(task)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  call(...args) &#123;</span><br><span class="line">    <span class="keyword">let</span> index = <span class="number">0</span>, ret</span><br><span class="line">    <span class="keyword">const</span> &#123; length &#125; = <span class="keyword">this</span>.tasks</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      <span class="comment">// 每个任务里面调用函数并传参</span></span><br><span class="line">      ret = <span class="keyword">this</span>.tasks[index++](...args)</span><br><span class="line">      <span class="comment">// while 里面对其返回的结果做判断</span></span><br><span class="line">    &#125; <span class="keyword">while</span>(ret === <span class="literal">undefined</span> &amp;&amp; index &lt; length)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试代码</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> hook = <span class="keyword">new</span> SyncBailHook([<span class="string">'name'</span>])</span><br><span class="line">hook.tap(<span class="string">'test1'</span>, (name) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'test1'</span>, name)</span><br><span class="line">&#125;)</span><br><span class="line">hook.tap(<span class="string">'test2'</span>, (name) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'test2'</span>, name)</span><br><span class="line">&#125;)</span><br><span class="line">hook.tap(<span class="string">'test3'</span>, (name) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'test3'</span>, name)</span><br><span class="line">  <span class="keyword">return</span> name</span><br><span class="line">&#125;)</span><br><span class="line">hook.tap(<span class="string">'test4'</span>, (name) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'test4'</span>, name)</span><br><span class="line">&#125;)</span><br><span class="line">hook.call(<span class="string">'strugglebak'</span>)</span><br></pre></td></tr></table></figure><p>打印结果</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">test1 strugglebak</span><br><span class="line">test2 strugglebak</span><br><span class="line">test3 strugglebak</span><br></pre></td></tr></table></figure><h2 id="实现-SyncWaterfallHook"><a href="#实现-SyncWaterfallHook" class="headerlink" title="实现 SyncWaterfallHook"></a>实现 SyncWaterfallHook</h2><p>这个钩子本质上就是，<strong>在调用函数的时候，将上一个函数的返回值作为下一个函数的参数</strong>，这样一个传递的流程</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SyncWaterfallHook</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(args) &#123;</span><br><span class="line">    <span class="keyword">this</span>.tasks = []</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  tap(name, task) &#123;</span><br><span class="line">    <span class="keyword">this</span>.tasks.push(task)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  call(...args) &#123;</span><br><span class="line">    <span class="keyword">const</span> [first, ...rest] = <span class="keyword">this</span>.tasks</span><br><span class="line">    <span class="keyword">const</span> ret = first(...args)</span><br><span class="line">    <span class="comment">// 由于是流水线式的传参数，所以这里可以用 reduce</span></span><br><span class="line">    rest.reduce(<span class="function">(<span class="params">acc, cur</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> cur(acc)</span><br><span class="line">    &#125;, ret) <span class="comment">// 初始传入是第一个函数的返回值</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试代码</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> hook = <span class="keyword">new</span> SyncWaterfallHook([<span class="string">'name'</span>])</span><br><span class="line">hook.tap(<span class="string">'test1'</span>, (name) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'test1'</span>, name)</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'test1'</span></span><br><span class="line">&#125;)</span><br><span class="line">hook.tap(<span class="string">'test2'</span>, (data) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'test2'</span>, data)</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'test2'</span></span><br><span class="line">&#125;)</span><br><span class="line">hook.tap(<span class="string">'test3'</span>, (data) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'test3'</span>, data)</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'test3'</span></span><br><span class="line">&#125;)</span><br><span class="line">hook.tap(<span class="string">'test4'</span>, (data) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'test4'</span>, data)</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'test4'</span></span><br><span class="line">&#125;)</span><br><span class="line">hook.call(<span class="string">'strugglebak'</span>)</span><br></pre></td></tr></table></figure><p>打印结果</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">test1 strugglebak</span><br><span class="line">test2 test1</span><br><span class="line">test3 test2</span><br><span class="line">test4 test3</span><br></pre></td></tr></table></figure><h2 id="实现-SyncLoopHook"><a href="#实现-SyncLoopHook" class="headerlink" title="实现 SyncLoopHook"></a>实现 SyncLoopHook</h2><p>这个钩子的作用就是 <strong>当在同步执行时，遇到某个不返回 undefined 的函数会多次执行</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SyncLoopHook</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(args) &#123;</span><br><span class="line">    <span class="keyword">this</span>.tasks = []</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  tap(name, task) &#123;</span><br><span class="line">    <span class="keyword">this</span>.tasks.push(task)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  call(...args) &#123;</span><br><span class="line">    <span class="keyword">this</span>.tasks.forEach(<span class="function">(<span class="params">task</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> ret</span><br><span class="line">      <span class="comment">// 某个不返回 undefined 的函数会多次执行</span></span><br><span class="line">      <span class="keyword">do</span> &#123;</span><br><span class="line">        ret = task(...args)</span><br><span class="line">      &#125; <span class="keyword">while</span> (ret !== <span class="literal">undefined</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试代码</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> hook = <span class="keyword">new</span> SyncLoopHook([<span class="string">'name'</span>])</span><br><span class="line"><span class="keyword">let</span> count = <span class="number">0</span></span><br><span class="line">hook.tap(<span class="string">'test1'</span>, (data) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'test1'</span>, data)</span><br><span class="line">  <span class="keyword">return</span> ++count === <span class="number">3</span> ? <span class="literal">undefined</span> : <span class="string">'keep going'</span></span><br><span class="line">&#125;)</span><br><span class="line">hook.tap(<span class="string">'test2'</span>, (data) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'test2'</span>, data)</span><br><span class="line">&#125;)</span><br><span class="line">hook.tap(<span class="string">'test3'</span>, (data) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'test3'</span>, data)</span><br><span class="line">&#125;)</span><br><span class="line">hook.tap(<span class="string">'test4'</span>, (data) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'test4'</span>, data)</span><br><span class="line">&#125;)</span><br><span class="line">hook.call(<span class="string">'strugglebak'</span>)</span><br></pre></td></tr></table></figure><p>打印结果</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">test1 strugglebak</span><br><span class="line">test1 strugglebak</span><br><span class="line">test1 strugglebak</span><br><span class="line">test2 strugglebak</span><br><span class="line">test3 strugglebak</span><br><span class="line">test4 strugglebak</span><br></pre></td></tr></table></figure><h2 id="实现-AsyncParallelHook"><a href="#实现-AsyncParallelHook" class="headerlink" title="实现 AsyncParallelHook"></a>实现 AsyncParallelHook</h2><p>首先需要说明的是，这是一个 <strong>异步并行</strong> 的钩子，所谓 “异步并行”，在这里的表现就是 <strong>需要等待所有并发的异步事件执行完成后再执行回调方法</strong></p><p>比如如下的代码</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; AsyncParallelHook &#125; = <span class="built_in">require</span>(<span class="string">'tapable'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.hooks = &#123;</span><br><span class="line">      arch: <span class="keyword">new</span> AsyncParallelHook([<span class="string">'name'</span>])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 注册监听函数</span></span><br><span class="line">  tapAsync() &#123;</span><br><span class="line">    <span class="keyword">this</span>.hooks.arch.tapAsync(<span class="string">'test1'</span>, (name, cb) =&gt; &#123;</span><br><span class="line">      <span class="comment">// 异步代码</span></span><br><span class="line">      setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'test1'</span>, name)</span><br><span class="line">        cb()</span><br><span class="line">      &#125;, <span class="number">1000</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">this</span>.hooks.arch.tapAsync(<span class="string">'test2'</span>, (name, cb) =&gt; &#123;</span><br><span class="line">      <span class="comment">// 异步代码</span></span><br><span class="line">      setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'test2'</span>, name)</span><br><span class="line">        cb()</span><br><span class="line">      &#125;, <span class="number">1000</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 调用方法</span></span><br><span class="line">  callAsync() &#123;</span><br><span class="line">    <span class="keyword">this</span>.hooks.arch.callAsync(<span class="string">'strugglebak'</span>, () =&gt; &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'end'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> t = <span class="keyword">new</span> Test()</span><br><span class="line">t.tapAsync()</span><br><span class="line">t.callAsync()</span><br></pre></td></tr></table></figure><p>打印输出为</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">test1 strugglebak</span><br><span class="line">test2 strugglebak</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>以上代码的意思是，只有当 <code>tapAsync</code> 里面的回调函数中，<code>cb</code> <strong>都执行完了</strong>，最后才会调用 <code>callAsync</code> 里的回调函数，即输出 <code>end</code></p><p>原理大致就是，每次执行完一个异步操作，就会调用 <code>cb</code>，而这个 <code>cb</code> 里面会有个计数器，如果计数器的总数等于当前回调函数注册的总数，就说明所有的异步操作执行完成，接着就可以执行最后的 <code>callAsync</code> 里面的回调了，所以代码可以这么写</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AsyncParallelHook</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(args) &#123;</span><br><span class="line">    <span class="keyword">this</span>.tasks = []</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  tapAsync(name, task) &#123;</span><br><span class="line">    <span class="keyword">this</span>.tasks.push(task)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  callAsync(...args) &#123;</span><br><span class="line">    <span class="comment">// 取出最后的函数</span></span><br><span class="line">    <span class="keyword">const</span> finalCallback = args.pop()</span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">0</span></span><br><span class="line">    <span class="comment">// 当注册的函数(cb)执行完成之后会执行 done 回调里的 finalCallback</span></span><br><span class="line">    <span class="keyword">const</span> done = <span class="function"><span class="params">()</span> =&gt;</span> &#123;(++count === <span class="keyword">this</span>.tasks.length) &amp;&amp; finalCallback()&#125;</span><br><span class="line">    <span class="keyword">this</span>.tasks.forEach(<span class="function">(<span class="params">task</span>) =&gt;</span> &#123;</span><br><span class="line">      task(...args, done)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试代码为</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> hook = <span class="keyword">new</span> AsyncParallelHook([<span class="string">'name'</span>])</span><br><span class="line">hook.tapAsync(<span class="string">'test1'</span>, (data, cb) =&gt; &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'test1'</span>, data)</span><br><span class="line">    cb()</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br><span class="line">hook.tapAsync(<span class="string">'test2'</span>, (data, cb) =&gt; &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'test2'</span>, data)</span><br><span class="line">    cb()</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br><span class="line">hook.callAsync(<span class="string">'strugglebak'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'end'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>打印输出为</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">test1 strugglebak</span><br><span class="line">test2 strugglebak</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>当然，以上的思想跟 <code>Promise.all</code> 很像，那么这种异步也可以用 <code>Promise</code> 来改写</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AsyncParallelHook</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(args) &#123;</span><br><span class="line">    <span class="keyword">this</span>.tasks = []</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  tapPromise(name, task) &#123;</span><br><span class="line">    <span class="keyword">this</span>.tasks.push(task)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  promise(...args) &#123;</span><br><span class="line">    <span class="comment">// 这里每个 task 都是 promise</span></span><br><span class="line">    <span class="keyword">const</span> tasks = <span class="keyword">this</span>.tasks.map(<span class="function"><span class="params">task</span> =&gt;</span> task(...args))</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.all(tasks)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试代码为</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> hook = <span class="keyword">new</span> AsyncParallelHook([<span class="string">'name'</span>])</span><br><span class="line">hook.tapPromise(<span class="string">'test1'</span>, (data) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'test1'</span>, data)</span><br><span class="line">      resolve(data)</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line">hook.tapPromise(<span class="string">'test2'</span>, (data) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'test2'</span>, data)</span><br><span class="line">      resolve(data)</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line">hook.promise(<span class="string">'strugglebak'</span>).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'end'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>测试结果为</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">test1 strugglebak</span><br><span class="line">test2 strugglebak</span><br><span class="line">end</span><br></pre></td></tr></table></figure><h2 id="实现-AsyncSeriesHook"><a href="#实现-AsyncSeriesHook" class="headerlink" title="实现 AsyncSeriesHook"></a>实现 AsyncSeriesHook</h2><p>注意这个是 <strong>异步串行</strong> 的钩子，而 <strong>异步串行</strong> 表示只有执行完 <strong>异步 1</strong> 之后才可以执行 <strong>异步 2</strong>，能够这么实现的就是使用回调函数</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AsyncSerieslHook</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(args) &#123;</span><br><span class="line">    <span class="keyword">this</span>.tasks = []</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  tapAsync(name, task) &#123;</span><br><span class="line">    <span class="keyword">this</span>.tasks.push(task)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  callAsync(...args) &#123;</span><br><span class="line">    <span class="comment">// 取出最后的函数</span></span><br><span class="line">    <span class="keyword">const</span> finalCallback = args.pop()</span><br><span class="line">    <span class="keyword">let</span> index = <span class="number">0</span></span><br><span class="line">    <span class="keyword">const</span> next = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (index === <span class="keyword">this</span>.tasks.length) <span class="keyword">return</span> finalCallback()</span><br><span class="line">      <span class="keyword">const</span> task = <span class="keyword">this</span>.tasks[index++]</span><br><span class="line">      <span class="comment">// 可以看出这里 next 是递归去在执行的</span></span><br><span class="line">      <span class="comment">// 这里的思想有点像 express 中间件</span></span><br><span class="line">      task(...args, next)</span><br><span class="line">    &#125;</span><br><span class="line">    next()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试代码为</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> hook = <span class="keyword">new</span> AsyncSerieslHook([<span class="string">'name'</span>])</span><br><span class="line">hook.tapAsync(<span class="string">'test1'</span>, (data, cb) =&gt; &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'test1'</span>, data)</span><br><span class="line">    cb()</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br><span class="line">hook.tapAsync(<span class="string">'test2'</span>, (data, cb) =&gt; &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'test2'</span>, data)</span><br><span class="line">    cb()</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br><span class="line">hook.callAsync(<span class="string">'strugglebak'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'end'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>打印输出为</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">test1 strugglebak</span><br><span class="line">test1 strugglebak</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>当然，有异步的地方也可以改写成 <code>Promise</code> 的形式，如下</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AsyncSerieslHook</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(args) &#123;</span><br><span class="line">    <span class="keyword">this</span>.tasks = []</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  tapPromise(name, task) &#123;</span><br><span class="line">    <span class="keyword">this</span>.tasks.push(task)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  promise(...args) &#123;</span><br><span class="line">    <span class="comment">// 注意这里 tasks 是一个 promise 的数组</span></span><br><span class="line">    <span class="keyword">const</span> [first, ...rest] = <span class="keyword">this</span>.tasks</span><br><span class="line">    <span class="keyword">const</span> ret = first(...args)</span><br><span class="line">    <span class="keyword">return</span> rest.reduce(<span class="function">(<span class="params">acc, cur</span>) =&gt;</span> &#123; <span class="comment">// 有些像 redux 的思想</span></span><br><span class="line">      <span class="keyword">return</span> acc.then(<span class="function"><span class="params">()</span> =&gt;</span> cur(...args)) <span class="comment">// promise 串行执行用 reduce</span></span><br><span class="line">    &#125;, ret)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试代码为</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> hook = <span class="keyword">new</span> AsyncSerieslHook([<span class="string">'name'</span>])</span><br><span class="line">hook.tapPromise(<span class="string">'test1'</span>, (data) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resovle, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'test1'</span>, data)</span><br><span class="line">      resovle(data)</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line">hook.tapPromise(<span class="string">'test2'</span>, (data) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resovle, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'test2'</span>, data)</span><br><span class="line">      resovle(data)</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line">hook.promise(<span class="string">'strugglebak'</span>).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'end'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>打印输出为</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">test1 strugglebak</span><br><span class="line">test2 strugglebak</span><br><span class="line">end</span><br></pre></td></tr></table></figure><h2 id="实现-AsyncSeriesWaterfallHook"><a href="#实现-AsyncSeriesWaterfallHook" class="headerlink" title="实现 AsyncSeriesWaterfallHook"></a>实现 AsyncSeriesWaterfallHook</h2><p>这里顾名思义，就是 <strong>异步 + 串行 + waterfall 钩子</strong>，那么代码应该这么写</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AsyncSeriesWaterfalllHook</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(args) &#123;</span><br><span class="line">    <span class="keyword">this</span>.tasks = []</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  tapAsync(name, task) &#123;</span><br><span class="line">    <span class="keyword">this</span>.tasks.push(task)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  callAsync(...args) &#123;</span><br><span class="line">    <span class="keyword">const</span> finalCallback = args.pop()</span><br><span class="line">    <span class="keyword">let</span> index = <span class="number">0</span></span><br><span class="line">    <span class="comment">// 这里需要异步迭代</span></span><br><span class="line">    <span class="keyword">const</span> next = <span class="function">(<span class="params">error, data</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> task = <span class="keyword">this</span>.tasks[index]</span><br><span class="line">      <span class="comment">// 如果没有注册函数，直接调用 callAsync 的回调</span></span><br><span class="line">      <span class="keyword">if</span> (!task) <span class="keyword">return</span> finalCallback()</span><br><span class="line">      <span class="keyword">if</span> (index === <span class="number">0</span>) &#123; <span class="comment">// 如果执行的是第一个注册的函数</span></span><br><span class="line">        <span class="comment">// 这里的 next 就是 cb</span></span><br><span class="line">        task(...args, next)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123; <span class="comment">// 如果执行的不是第一个注册的函数，这里就应该传 data</span></span><br><span class="line">        <span class="comment">// 因为这里是迭代传了，不应该传 args 而应该传 data</span></span><br><span class="line">        task(data, next)</span><br><span class="line">      &#125;</span><br><span class="line">      ++index</span><br><span class="line">    &#125;</span><br><span class="line">    next()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试代码为</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> hook = <span class="keyword">new</span> AsyncSeriesWaterfalllHook([<span class="string">'name'</span>])</span><br><span class="line">hook.tapAsync(<span class="string">'test1'</span>, (data, cb) =&gt; &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'test1'</span>, data)</span><br><span class="line">    cb(<span class="literal">null</span>, <span class="string">'hello world'</span>)</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br><span class="line">hook.tapAsync(<span class="string">'test2'</span>, (data, cb) =&gt; &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'test2'</span>, data)</span><br><span class="line">    cb(<span class="literal">null</span>)</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br><span class="line">hook.callAsync(<span class="string">'strugglebak'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'end'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>打印结果为</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">test1 strugglebak</span><br><span class="line">test2 hello world</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>当然，这里也可以用 <code>Promise</code> 改写</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AsyncSeriesWaterfalllHook</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(args) &#123;</span><br><span class="line">    <span class="keyword">this</span>.tasks = []</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  tapPromise(name, task) &#123;</span><br><span class="line">    <span class="keyword">this</span>.tasks.push(task)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  promise(...args) &#123;</span><br><span class="line">    <span class="keyword">const</span> [first, ...rest] = <span class="keyword">this</span>.tasks</span><br><span class="line">    <span class="keyword">const</span> ret = first(...args)</span><br><span class="line">    <span class="keyword">return</span> rest.reduce(<span class="function">(<span class="params">acc, cur</span>) =&gt;</span> &#123; <span class="comment">// 这里的代码可以参考之前写 SyncWaterfallHook 的</span></span><br><span class="line">      <span class="keyword">return</span> acc.then(<span class="function">(<span class="params">data</span>) =&gt;</span> cur(data))</span><br><span class="line">    &#125;, ret)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试代码为</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> hook = <span class="keyword">new</span> AsyncSeriesWaterfalllHook([<span class="string">'name'</span>])</span><br><span class="line">hook.tapPromise(<span class="string">'test1'</span>, (data) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resovle, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'test1'</span>, data)</span><br><span class="line">      resovle(<span class="string">'hello world'</span>)</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line">hook.tapPromise(<span class="string">'test2'</span>, (data, cb) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resole, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'test2'</span>, data)</span><br><span class="line">      resole(<span class="literal">null</span>)</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line">hook.promise(<span class="string">'strugglebak'</span>).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'end'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>打印结果为</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">test1 strugglebak</span><br><span class="line">test2 hello world</span><br><span class="line">end</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>由以上的描述我们可以看出一个规律，那就是</p><ul><li>tapable 库中有 3 种注册方法: tap(同步注册)、tapAsync(cb) (异步注册)、tapPromise(注册时是 promise)</li><li>tapable 库中有 3 种调用方法: call(同步调用)、callAsync(cb)(异步调用)、promise(调用时是 promise 用 .then)</li></ul><p>以上三者两两对应</p><p>同时，我们也知道了，对于 <code>tapable</code> 这个库的钩子来说，分同步钩子和异步钩子，同时钩子还分并行和串行钩子</p><p>对于异步并行钩子来说，异步的操作可以是同时发生的，即哪个执行快就先执行<br>对于异步串行钩子来说，异步的操作是依赖于上个异步的结果的，只有等上个异步执行了，才能执行下个异步</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;这个是探究 Webpack 本质的系列文章，会详细讲解如何手写一些源码如 Webpack, loader, plugin 等等，本文主要讲解的是如何手写 tapbable 库&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="前端工程化" scheme="https://strugglebak.github.io/categories/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/"/>
    
    
      <category term="tapable" scheme="https://strugglebak.github.io/tags/tapable/"/>
    
  </entry>
  
  <entry>
    <title>从Webpack本质开始(三):手写plugin</title>
    <link href="https://strugglebak.github.io/2020/03/09/%E4%BB%8EWebpack%E6%9C%AC%E8%B4%A8%E5%BC%80%E5%A7%8B-%E4%B8%89-%E6%89%8B%E5%86%99plugin/"/>
    <id>https://strugglebak.github.io/2020/03/09/从Webpack本质开始-三-手写plugin/</id>
    <published>2020-03-09T09:14:27.000Z</published>
    <updated>2022-06-04T08:13:29.296Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这个是探究 Webpack 本质的系列文章，会详细讲解如何手写一些源码如 Webpack, loader, plugin 等等，本文主要讲解的是如何手写 plugin</p></blockquote><a id="more"></a><h2 id="webpack-流程"><a href="#webpack-流程" class="headerlink" title="webpack 流程"></a>webpack 流程</h2><p>在手写 webpack <code>plugin</code> 之前，需要了解一下的是 webpack 整个流程是怎么样的，为了方便起见，这里用几张图来概括下</p><ul><li>整体的流程图<br>  <img src="./1.jpg" alt></li><li><code>compilation</code> 对象<br>  <img src="./2.jpg" alt></li></ul><p>为什么只是用这两张图呢，因为这是 webpack 运行流程中最重要的两个部分。我们对 webpack 的印象是什么，基本上 webpack 是以下这么个大致的流程</p><ol><li>整合配置 <code>options</code></li><li>实例化 <code>compiler</code> 对象</li><li>实例化所有的插件(这里包括内置的以及自己配置的)，调用其 <code>apply</code> 方法</li><li>返回 <code>compiler</code> 对象</li><li>执行 <code>complier</code> 对象的 <code>run</code> 方法</li></ol><p>而在 webpack 的内部(这里主要说它的 <code>compiler</code> 对象做了啥事)，它会经历大致如下的流程(以 <code>SingleEntryPlugin</code> 为例)</p><ol><li>调用 <code>beforeRun</code> 钩子</li><li>调用 <code>run</code> 钩子</li><li>调用 <code>compile</code> 方法(调用 <code>beforeCompiler</code> 钩子 -&gt; 调用 <code>compile</code> 钩子 -&gt; 实例化 <code>compilation</code> 对象 -&gt; 调用 <code>thisCompilation</code> 以及 <code>compliation</code> 钩子 -&gt; 执行 <code>make</code> 钩子 -&gt; <code>seal</code> 封装 -&gt; 调用 <code>afterCompile</code> 钩子)</li><li>编译结束后会 <code>run</code> 方法会执行 <code>onCompiled</code> 回调，在这个回调中会先调用 <code>shouldEmit</code> 钩子做判断，成功执行 <code>emitAssets</code> 然后调用 <code>emit</code> 钩子输出文件，失败则调用 <code>done</code> 钩子结束</li></ol><p>再细一点，我们深入到 <code>compilation</code> 里，看看在实例化 <code>compilation</code> 对象里面做了啥</p><ol><li>调用 <code>addEntry</code> 钩子，调用完毕后执行其回调通知 <code>make</code> 钩子插件编译完成</li><li>调用 <code>addEntry</code> 钩子时会执行 <code>_addModuleChain</code> 方法(根据 <code>dep</code> 拿到 <code>moduleFactory</code> -&gt; 调用 <code>moduleFactory.create</code> 拿到 <code>module</code> -&gt; 调用 <code>buildModule</code> 方法构建模块依赖 -&gt; 调用 <code>afterBuild</code> 方法<strong>递归</strong>用模块工厂创建依赖的模块)</li></ol><p>从以上的描述我们可以看到，webpack 的一个基本流程就是 <strong>读取配置， 实例化 compiler 时会调用各种钩子以及回调函数, 最后再去挂载相应的插件</strong></p><h2 id="所以插件是怎么回事"><a href="#所以插件是怎么回事" class="headerlink" title="所以插件是怎么回事"></a>所以插件是怎么回事</h2><p>webpack 中，如果要写自己的插件，其实就是利用 <strong>发布订阅模式</strong>来写的。因为在 webpack 里面有很多的事件，我们通过 “监听” 这些事件后去执行相应的回调就好，这样说是不是很像前端页面中的交互逻辑呢。是的，基本上原理是相似的。所以插件一般都是这么写</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestPlugin</span> </span>&#123;</span><br><span class="line">  apply(compiler) &#123;</span><br><span class="line">    compiler.hooks.compilation.tap(<span class="string">'TestPlugin'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">compilation</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'compilation'</span>, compilation);</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导出 Plugin</span></span><br><span class="line"><span class="built_in">module</span>.exports = TestPlugin;</span><br></pre></td></tr></table></figure><p>在 webpack 使用的钩子中，很大部分都是依赖 <code>tapable</code> 这个库，而这个库的作用就是为 <code>plugin</code> 创建钩子用的，它里面会有类似 <code>XXXHook</code> 类型的钩子，有同步的也有异步的。里面的 <code>tap</code> 方法就是用于 <strong>订阅事件</strong>。代码 <code>compiler.hooks.compilation.tap()</code> 就是当 <code>compilation</code> 这个钩子被触发时就会去执行 <code>tap</code> 里面的回调。</p><h2 id="手写文件列表插件"><a href="#手写文件列表插件" class="headerlink" title="手写文件列表插件"></a>手写文件列表插件</h2><p>这个插件主要就是将 webpack 最后 <code>emit</code> 时输出到终端的内容做一个 “拦截”，然后将其输出到一个设置的 <code>filename</code> 文件中。</p><blockquote><p>注意这里还要安装 <code>html-webpack-plugin</code> 插件</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FileListPlugin</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(&#123; filename &#125;) &#123;</span><br><span class="line">    <span class="keyword">this</span>.filename = filename</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  apply(compiler) &#123;</span><br><span class="line">    <span class="comment">// 在发射文件这个时候截取</span></span><br><span class="line">    compiler.hooks.emit.tap(<span class="string">'FileListPlugin'</span>, (compilation) =&gt; &#123;</span><br><span class="line">      <span class="comment">// 当前打包的资源会放在 assets 属性上</span></span><br><span class="line">      <span class="keyword">const</span> &#123; assets &#125; = compilation</span><br><span class="line">      <span class="keyword">let</span> content = <span class="string">`## 文件名    大小 \r\n`</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">const</span> [filename, stat] <span class="keyword">of</span> <span class="built_in">Object</span>.entries(assets)) &#123;</span><br><span class="line">        content += <span class="string">`- <span class="subst">$&#123;filename&#125;</span>    <span class="subst">$&#123;stat.size()&#125;</span>\r\n`</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 为 assets 添加一个 filename 的字段，在 webpack 接下来的处理中为输出相应的文件做准备</span></span><br><span class="line">      assets[<span class="keyword">this</span>.filename] = &#123;</span><br><span class="line">        source() &#123; <span class="keyword">return</span> content &#125;,</span><br><span class="line">        size() &#123; <span class="keyword">return</span> content.length &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = FileListPlugin</span><br></pre></td></tr></table></figure><p>这里我们就知道了为什么要知道 webpack 的流程才能写插件了，如果要做一个文件列表的插件，那么就应该是在 <strong>文件发射之前做</strong>，而不是在 webpack 调用其他的钩子的时候做</p><h2 id="手写内联-webpack-插件"><a href="#手写内联-webpack-插件" class="headerlink" title="手写内联 webpack 插件"></a>手写内联 webpack 插件</h2><p>这个所谓的内联插件实际上的功能就是将外链的标签变成内联的，主要体现在</p><ul><li>将 <code>link</code> 标签变成 <code>style</code> 标签，然后里面填充的是引入的 css 的内容</li><li>将 <code>script</code> 标签填充引入的 <code>script</code> 文件内容</li><li>删除掉已经生成的没必要引入的文件</li></ul><p>首先还需要安装三个插件 <code>css-loader</code> 、<code>mini-css-extract-plugin</code> 以及 <code>html-webpack-plugin/next</code></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yarn add css-loader mini-css-extract-plugin html-webpack-plugin/next</span><br></pre></td></tr></table></figure><p>webpack 配置如下</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>)</span><br><span class="line"><span class="keyword">const</span> MiniCssExtractPlugin = <span class="built_in">require</span>(<span class="string">'mini-css-extract-plugin'</span>)</span><br><span class="line"><span class="keyword">const</span> InlineSourcePlugin = <span class="built_in">require</span>(<span class="string">'./plugins/inlineSource-plugin'</span>)</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  mode: <span class="string">'development'</span>,</span><br><span class="line">  entry: <span class="string">'./src/index.js'</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">'bundle.js'</span>,</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'dist'</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        use: [MiniCssExtractPlugin.loader, <span class="string">'css-loader'</span>]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> MiniCssExtractPlugin(&#123;</span><br><span class="line">      filename: <span class="string">'main.css'</span></span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="keyword">new</span> InlineSourcePlugin(&#123;</span><br><span class="line">      test: <span class="regexp">/\.(js|css)/</span></span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">      template: <span class="string">'./src/index.html'</span></span><br><span class="line">    &#125;),</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后是关键的 <code>InlineSourcePlugin</code> 插件</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 因为最后是改变 html 的 tag 然后插入到 html 中的，所以这里会使用到</span></span><br><span class="line"><span class="comment">// html-webpack-plugin 提供的一些 hooks 来供我们使用</span></span><br><span class="line"><span class="comment">// 在 html-webpack-plugin 的基础上开发插件</span></span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InlineSourcePlugin</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(&#123; test &#125;) &#123;</span><br><span class="line">    <span class="comment">// 用于匹配文件的正则，这里主要寻找以 js 或 css 结尾的文件</span></span><br><span class="line">    <span class="keyword">this</span>.reg = test</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 处理一个 tag 的数据</span></span><br><span class="line">  processTag(tag, compilation) &#123;</span><br><span class="line">    <span class="keyword">let</span> newTag, url</span><br><span class="line">    <span class="keyword">const</span> &#123; tagName, attributes &#125; = tag</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (tagName === <span class="string">'link'</span> &amp;&amp; <span class="keyword">this</span>.reg.test(attributes.href)) &#123;</span><br><span class="line">      newTag = &#123;</span><br><span class="line">        tagName: <span class="string">'style'</span>,</span><br><span class="line">        attributes: &#123; <span class="attr">type</span>: <span class="string">'text/css'</span> &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      url = attributes.href</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (tagName === <span class="string">'script'</span> &amp;&amp; <span class="keyword">this</span>.reg.test(attributes.src)) &#123;</span><br><span class="line">      newTag = &#123;</span><br><span class="line">        tagName: <span class="string">'script'</span>,</span><br><span class="line">        attributes: &#123; <span class="attr">type</span>: <span class="string">'application/javascript'</span> &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      url = attributes.src</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (url) &#123;</span><br><span class="line">      <span class="comment">// 标签里面插入对应文件的源码</span></span><br><span class="line">      newTag.innerHTML = compilation.assets[url].source()</span><br><span class="line">      <span class="comment">// 既然都把源码怼 html 上了，就应该删除对应的文件</span></span><br><span class="line">      <span class="keyword">delete</span> compilation.assets[url]</span><br><span class="line">      <span class="keyword">return</span> newTag</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> tag</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 处理引入 tags 的数据</span></span><br><span class="line">  processTags(data, compilation) &#123;</span><br><span class="line">    <span class="keyword">const</span> headTags = []</span><br><span class="line">    data.headTags.forEach(<span class="function"><span class="params">headTag</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 处理引入 css 的 link 标签</span></span><br><span class="line">      headTags.push(<span class="keyword">this</span>.processTag(headTag, compilation))</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> bodyTags = []</span><br><span class="line">    data.bodyTags.forEach(<span class="function"><span class="params">bodyTag</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 处理引入 script 标签</span></span><br><span class="line">      bodyTags.push(<span class="keyword">this</span>.processTag(bodyTag, compilation))</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123; ...data, headTags, bodyTags &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  apply (compiler) &#123;</span><br><span class="line">    compiler.hooks.compilation.tap(<span class="string">'InlineSourcePlugin'</span>, (compilation) =&gt; &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'The compiler is starting a new compilation...'</span>)</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 静态插件接口 | compilation | HOOK NAME | register listener</span></span><br><span class="line">      <span class="comment">// 使用 alterAssetTagGroups 这个 hooks</span></span><br><span class="line">      HtmlWebpackPlugin.getHooks(compilation).alterAssetTagGroups.tapAsync(</span><br><span class="line">        <span class="string">'alterPlugin'</span>, <span class="comment">// 为堆栈取名</span></span><br><span class="line">        (data, cb) =&gt; &#123;</span><br><span class="line">          <span class="comment">// 处理 html 的某些 tags, 这里需要做处理的是 css 和 js</span></span><br><span class="line">          <span class="keyword">const</span> newData = <span class="keyword">this</span>.processTags(data, compilation)</span><br><span class="line">          <span class="comment">// 返回 data</span></span><br><span class="line">          cb(<span class="literal">null</span>, newData)</span><br><span class="line">        &#125;</span><br><span class="line">      )</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = InlineSourcePlugin</span><br></pre></td></tr></table></figure><p>其实这里整体的逻辑很简单，就是找出 <code>index.html</code> 中的 <code>link</code> 标签以及 <code>script</code> 标签，将其的 <code>innerHTML</code> 替换为对应文件的源码而已。从 <code>compliation</code> 这个对象里面找对应的字段然后做对应的修改即可。但是这里的重点是，应该在哪里或者说是哪个钩子里面去用？这里就用到了 <code>html-webpack-plugin</code> 这个插件了，众所周知这个插件的作用是 <strong>简化 html 文件的创建的</strong>，而且这个插件本身也提供了一些钩子给开发者在基于这个插件的基础上再开发插件。去看 <a href="https://github.com/jantimon/html-webpack-plugin" target="_blank" rel="noopener">html-webpack-plugin 的官方文档</a>，在 <code>plugin.js</code> 这个小标题下可以找到对应插件的写法，上面就是它说明的提供的一些钩子。不过这里不是用 <code>beforeEmit</code> 这个钩子，因为我们想要的是要修改标签，理所当然的就是跟 <code>tag</code> 相关的 hooks 了。这里有两个 <code>tag</code>，一个是 <code>alterAssetTags</code>，另一个是 <code>alterAssetTagGroups</code>，这里我们选择的是 <code>alterAssetTagGroups</code>，因为我们重点是在 <code>head</code> 以及 <code>body</code> 上找标签，而且为了之后能修改更多的标签，选这个比较靠谱。选择了之后将 <code>beforeEmit</code> 改为 <code>alterAssetTagGroups</code> 就可以整活了, 后面就是根据 <code>data</code> 的属性去做相应的修改， <code>processTags</code> 完成之后调用 <code>cb</code> 回调，代码修改执行完毕。</p><p>这里还有一张 <code>html-webpack-plugin</code> hooks 图，以供参考</p><p><img src="./3.jpg" alt></p><h2 id="手写打包自动发布插件"><a href="#手写打包自动发布插件" class="headerlink" title="手写打包自动发布插件"></a>手写打包自动发布插件</h2><p>这个插件的主要功能就是将打包后的文件(就是 <code>dist</code> 目录下的)放到 cdn 服务器上。然后页面中就直接引用 cdn 的文件就可以了。这里使用免费的 <strong>七牛云</strong> 来做</p><p>首先需要安装 <code>qiniu</code></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yarn add qiniu</span><br></pre></td></tr></table></figure><p>webpack 配置文件设置 <code>output</code> 的 <code>publicPath</code></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">output: &#123;</span><br><span class="line">    filename: <span class="string">'bundle.js'</span>,</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'dist'</span>),</span><br><span class="line">    publicPath: <span class="string">'http://test.strugglebak.com'</span> <span class="comment">// 在你的七牛云的 bucket 上设置的外链域名</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>然后写一个 <code>upload-plugin.js</code> 在 <code>plugin</code> 目录，webpack 配置文件引入和使用</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> UploadPlugin = <span class="built_in">require</span>(<span class="string">'./plugins/upload-plugin'</span>)</span><br><span class="line">...</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">...</span><br><span class="line">    plugins: [</span><br><span class="line">        <span class="keyword">new</span> UploadPlugin(&#123;</span><br><span class="line">            bucket: <span class="string">'ststatic'</span>, <span class="comment">// 你的七牛云对象存储中创建的 bucket 名字</span></span><br><span class="line">            domain: <span class="string">'test.strugglebak.com'</span> <span class="comment">// 在你的七牛云的 bucket 上设置的外链域名</span></span><br><span class="line">        &#125;)</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后是 <code>upload-plugin.js</code> 文件</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"><span class="keyword">const</span> qiniu = <span class="built_in">require</span>(<span class="string">'qiniu'</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UploadPlugin</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(&#123;bucket, domain&#125;) &#123;</span><br><span class="line">    <span class="comment">// 初始化七牛云参数以及内部变量</span></span><br><span class="line">    <span class="keyword">this</span>.init(&#123;bucket, domain&#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  apply(compiler) &#123;</span><br><span class="line">    <span class="comment">// 上传文件是多个，且返回的是 promise，所以这里用 tapPromise</span></span><br><span class="line">    compiler.hooks.afterEmit.tapPromise(</span><br><span class="line">      <span class="string">'UploadPlugin'</span>,</span><br><span class="line">      (compliation) =&gt; &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; assets &#125; = compliation</span><br><span class="line">        <span class="keyword">const</span> promises = []</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> [filename, stat] <span class="keyword">of</span> <span class="built_in">Object</span>.entries(assets)) &#123;</span><br><span class="line">          promises.push(<span class="keyword">this</span>.upload(filename))</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Promise</span>.all(promises)</span><br><span class="line">      &#125;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 上传文件</span></span><br><span class="line">  upload(filename) &#123;</span><br><span class="line">    <span class="comment">// 代码参考在 https://developer.qiniu.com/kodo/sdk/1289/nodejs#form-upload-file</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resovle, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 要上传的本地文件目录为 dist 目录下的</span></span><br><span class="line">      <span class="keyword">const</span> localFile = path.resolve(__dirname, <span class="string">'../dist'</span>, filename)</span><br><span class="line">      <span class="comment">// 使用表单方式上传本地文件</span></span><br><span class="line">      <span class="keyword">this</span>.formUploader.putFile(</span><br><span class="line">        <span class="keyword">this</span>.uploadToken, filename, localFile, <span class="keyword">this</span>.putExtra,</span><br><span class="line">        (respErr, respBody, respInfo) =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (respErr) &#123;</span><br><span class="line">          reject(respErr)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (respInfo.statusCode == <span class="number">200</span>) &#123;</span><br><span class="line">          resovle(respBody)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  init(&#123;bucket, domain&#125;) &#123;</span><br><span class="line">    <span class="comment">// 读取本地的 qiniu 的密钥文件，这样比较安全</span></span><br><span class="line">    <span class="keyword">const</span> keyJSON = fs.readFileSync(</span><br><span class="line">      path.resolve(__dirname, <span class="string">'../'</span>, <span class="string">'qiniu-key.json'</span>),</span><br><span class="line">      <span class="string">'utf8'</span></span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">const</span> &#123; accessKey, secretKey &#125; = <span class="built_in">JSON</span>.parse(keyJSON)</span><br><span class="line">    <span class="keyword">const</span> mac = <span class="keyword">new</span> qiniu.auth.digest.Mac(accessKey, secretKey)</span><br><span class="line">    <span class="keyword">const</span> putPolicy = <span class="keyword">new</span> qiniu.rs.PutPolicy(&#123; <span class="attr">scope</span>: bucket &#125;)</span><br><span class="line">    <span class="keyword">const</span> config = <span class="keyword">new</span> qiniu.conf.Config()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.uploadToken = putPolicy.uploadToken(mac)</span><br><span class="line">    <span class="keyword">this</span>.formUploader = <span class="keyword">new</span> qiniu.form_up.FormUploader(config)</span><br><span class="line">    <span class="keyword">this</span>.putExtra = <span class="keyword">new</span> qiniu.form_up.PutExtra()</span><br><span class="line">    <span class="keyword">this</span>.domain = domain</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = UploadPlugin</span><br></pre></td></tr></table></figure><p>这里的整体逻辑很简单，就是先初始化 <code>qiniu</code> 的一些参数，然后利用其 <code>formUploader</code> 对象进行<strong>表单方式的文件上传</strong>。而因为是在 <strong>发射文件之后</strong> 才采取的操作，所以这里就使用 <code>afterEmit</code> 这个 hooks，传的参数里面 <code>compilation</code> 对象的 <code>assets</code> 属性有对应的文件名和其对应的内容。拿到这个文件路径之后就将其 <code>push</code> 到一个 <code>promise</code> 数组里面，最后再整体返回(因为这里使用的是 <code>tapPromise</code>)。在文件上传代码的核心部分，就是利用 <a href="https://developer.qiniu.com/kodo/sdk/1289/nodejs#form-upload-file" target="_blank" rel="noopener">qiniu 表单上传代码</a> 来做的，本质上就是返回了一个 <code>promise</code>。在 <code>formUploader.putFile</code> 这个函数中，有几个参数</p><ul><li>uploadToken: upload 的 token，主要根据 <code>accessKey</code> 和 <code>secretKey</code> 生成的，用于身份的验证</li><li>filename: 这个相当于文件的 <code>key</code></li><li>localFile: 这个要上传的本地文件的 <code>value</code>，就是文件路径，与上面的 <code>filename</code> 对应</li><li>putExtra: qiniu.form_up.PutExtra() 对象(意义不明)</li></ul><p>这里主要 <code>resolve</code> 的是 <code>respBody</code> 这个数据。这样整体的逻辑就算完成。</p><h2 id="补充-在七牛云添加-cdn"><a href="#补充-在七牛云添加-cdn" class="headerlink" title="补充(在七牛云添加 cdn)"></a>补充(在七牛云添加 cdn)</h2><p>这里可能有些小伙伴不知道如何在七牛云添加 cdn 域名。下面我来说下步骤</p><ul><li><p>首先你需要有一个七牛云账号，在注册完账号后，点击主页的 <code>管理控制台</code> 进入控制台<br><img src="./console.jpg" alt></p></li><li><p>进入 <code>管理控制台</code> 后，点击左边的 <code>cdn</code><br>  <img src="./4.jpg" alt></p></li><li><p>然后点击 <code>域名管理</code><br>  <img src="./5.jpg" alt></p></li><li><p>再点击 <code>添加域名</code><br>  <img src="./6.jpg" alt></p></li><li><p>然后在 <code>加速域名</code> 那块输入要加速的域名<br>  <img src="./7.jpg" alt></p><p>  这里需要注意的是，你目前的域名已经<strong>注册并且备过案了!!!</strong>，比如我的 <code>strugglebak.com</code> 这个域名是备过案的才能用。<br>  我这里输入的要加速的域名是 <code>test.strugglebak.com</code>，其中 <code>test</code> 表示 <strong>主机记录</strong>，你也可以随便取啥名</p></li><li><p>再点击 <code>创建</code><br>  <img src="./8.jpg" alt></p></li><li><p>跳回到 <code>域名管理</code> 上，鼠标悬浮到你刚创建的域名上(<code>test.strugglebak.com</code>)，复制 <code>CNAME</code><br>  <img src="./9.jpg" alt></p></li><li><p>然后在自己的服务器在对应的域名上添加 <code>解析记录</code>(因为我这里通常就是用腾讯云小程序搞的，所以截图是小程序的手机截图)<br>  <img src="./10.jpg" alt></p><p>  点击 <code>域名解析</code></p><p>  <img src="./11.jpg" alt></p><p>  点击 <code>添加解析记录</code></p><p>  <img src="./12.jpg" alt></p><p>  然后填写 <code>主机记录</code> 以及 <code>记录值</code></p><p>  <img src="./13.jpg" alt></p><p>  其中 <code>test</code> 对应你设置的七牛云 <code>bucket</code> 的外链，而 <code>记录值</code> 就是 <code>CNAME</code></p></li><li><p>最后在你的七牛云 <code>对象存储</code> 中，在对应的 <code>bucket</code> 中设置外链<br>  <img src="./14.jpg" alt></p></li></ul><p>如果最后看到 cdn 外链的下面的图，则说明设置成功</p><p><img src="./15.jpg" alt></p><p>所以当你在访问 <code>test.strugglebak.com/xxx文件</code>时，就相当于在访问 <code>test-strugglebak-com-idva9dm.qiniudns.com/xxx文件</code>，效果就是会先访问你的服务器，然后再转到七牛的服务器上访问文件。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>由以上的内容我们知道了，在写一个 webpack 的插件之前，最重要的是要了解一个流程是怎么走的，都是利用 webpack 的钩子或者其他插件本身的钩子来进行编写。注意 webpack 插件的本质是利用了 <strong>发布订阅</strong> 的模式。我们订阅了这个事件后，执行对应的回调，并将执行回调的结果再传回给 webpack，最终结果会体现在打包的文件上。这样 webpack 就完成了对插件的加载以及处理。</p><p>另，<a href="https://github.com/strugglebak/webpack-plugin-test.git" target="_blank" rel="noopener">👉项目测试仓库戳这里</a></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://juejin.im/post/5d418879f265da03af19b03f" target="_blank" rel="noopener">Webpack 源码研究</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;这个是探究 Webpack 本质的系列文章，会详细讲解如何手写一些源码如 Webpack, loader, plugin 等等，本文主要讲解的是如何手写 plugin&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="前端工程化" scheme="https://strugglebak.github.io/categories/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/"/>
    
    
      <category term="webpack" scheme="https://strugglebak.github.io/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>从Webpack本质开始(二):手写loader</title>
    <link href="https://strugglebak.github.io/2020/02/24/%E4%BB%8EWebpack%E6%9C%AC%E8%B4%A8%E5%BC%80%E5%A7%8B-%E4%BA%8C-%E6%89%8B%E5%86%99loader/"/>
    <id>https://strugglebak.github.io/2020/02/24/从Webpack本质开始-二-手写loader/</id>
    <published>2020-02-24T14:06:07.000Z</published>
    <updated>2022-06-04T08:13:29.372Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这个是探究 Webpack 本质的系列文章，会详细讲解如何手写一些源码如 Webpack, loader, plugin 等等，本文主要讲解的是如何手写 loader</p></blockquote><a id="more"></a><h2 id="loader-是个啥"><a href="#loader-是个啥" class="headerlink" title="loader 是个啥"></a>loader 是个啥</h2><p>webpack 只能处理 js 中的模块，所以若是要处理<strong>其他类型</strong>的文件的时候，就需要 loader 去做<strong>转换(transform)</strong>。本质上来说，loader 是用来<strong>将一段代码转换成另一段代码的 webpack 加载器</strong>。为什么叫做 “loader”？因为当你使用 <code>import</code> 或者其他方式去 “加载” 模块时，这些 loader 就会对模块进行一些<strong>预处理</strong>的工作。这就是 loader 的作用。</p><p>我们经常写 <code>loader</code> 时会这么写</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loader</span>(<span class="params">source</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// TODO</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'loader'</span>)</span><br><span class="line">  <span class="keyword">return</span> source</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = loader</span><br></pre></td></tr></table></figure><p>可以看出 <code>loader</code> 本质上是一个<strong>函数</strong>，并且其<strong>参数就是源码</strong></p><h2 id="loader-的配置规则"><a href="#loader-的配置规则" class="headerlink" title="loader 的配置规则"></a>loader 的配置规则</h2><p>在 <code>webpack.config.js</code> 的配置中，<code>loader</code> 的配置一般有三种写法</p><ul><li><p>在 <code>use</code> 中写死路径</p>  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">  rules: [</span><br><span class="line">    &#123;</span><br><span class="line">      test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">      <span class="comment">// loader 为项目目录的 /loaders/demo-loader.js</span></span><br><span class="line">      use: path.resolve(__dirname, <span class="string">'loaders'</span>, <span class="string">'demo-loader.js'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在 <code>resolveLoader</code> 中建立别名，然后 <code>use</code> 使用这个别名</p>  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">resolveLoader: &#123;</span><br><span class="line">  alias: &#123;</span><br><span class="line">    demoLoader: path.resolve(__dirname, <span class="string">'loaders'</span>, <span class="string">'demo-loader.js'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">  rules: [</span><br><span class="line">    &#123;</span><br><span class="line">      test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">      <span class="comment">// 别名</span></span><br><span class="line">      use: <span class="string">'demoLoader'</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在 <code>resolveLoader</code> 中配置 <code>modules</code>，从自定义的目录开始寻找</p>  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">resolveLoader: &#123;</span><br><span class="line">  <span class="comment">// node_modules 目录下找不到，就会从 loaders 目录下寻找 loader</span></span><br><span class="line">  modules: [<span class="string">'node_modules'</span>, path.resolve(__dirname, <span class="string">'loaders'</span>)]</span><br><span class="line">&#125;,</span><br><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">  rules: [</span><br><span class="line">    &#123;</span><br><span class="line">      test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">      use: <span class="string">'demo-loader'</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="loader-的执行顺序"><a href="#loader-的执行顺序" class="headerlink" title="loader 的执行顺序"></a>loader 的执行顺序</h2><p>从配置来看，默认的 <code>loader</code> 执行顺序是<strong>从下到上、从右往左的</strong>。对于 <code>loader</code> 来说，它有如下的分类</p><ul><li>pre (在前面执行)</li><li>normal (默认不配置)</li><li>inline (插入)</li><li>post (在后面执行)</li></ul><p>比如下面的配置</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">  rules: [</span><br><span class="line">    &#123;</span><br><span class="line">      test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">      use: &#123; <span class="attr">loader</span>: <span class="string">'demo-loader'</span> &#125;,</span><br><span class="line">      enforce: <span class="string">'pre'</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">      use: &#123; <span class="attr">loader</span>: <span class="string">'demo-loader2'</span> &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">      use: &#123; <span class="attr">loader</span>: <span class="string">'demo-loader3'</span> &#125;,</span><br><span class="line">      enforce: <span class="string">'post'</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其执行顺序就变成了 <code>demo-loader -&gt; demo-loader2 -&gt; demo-loader3</code></p><p>那 <code>inline loader</code> 是怎么回事呢？它实际上就是插入的 loader，如果希望在 <code>require</code> 其他模块时将其导到 <code>post loader</code> 前面去执行，就这样写</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ./src/index.js</span></span><br><span class="line"><span class="keyword">const</span> moduleA = <span class="built_in">require</span>(<span class="string">'inline-loader!./moduleA'</span>)</span><br></pre></td></tr></table></figure><p>这里的 <code>inline-loader</code> 是 inline-loader 的名字，前面加个 <code>!</code> 表示希望交给 <code>inline-loader</code> 去做处理</p><p>那么打印顺序就变成了</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">loader</span><br><span class="line">loader2</span><br><span class="line">loader3</span><br><span class="line">loader</span><br><span class="line">loader2</span><br><span class="line">inline-loader</span><br><span class="line">loader3</span><br></pre></td></tr></table></figure><p>但是由于 <code>require</code> 配置的不同，<code>inline-loader</code> 插入的方式也不一样，比如</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ./src/index.js</span></span><br><span class="line"><span class="keyword">const</span> moduleA = <span class="built_in">require</span>(<span class="string">'-!inline-loader!./moduleA'</span>)</span><br></pre></td></tr></table></figure><p>那么打印顺序变成</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">loader</span><br><span class="line">loader2</span><br><span class="line">loader3</span><br><span class="line">inline-loader</span><br><span class="line">loader3</span><br></pre></td></tr></table></figure><p>后面的 <code>pre</code> 以及 <code>normal</code> 的就没有打印出来了</p><p>如果只有一个 <code>!</code> 表示后面的 <code>normal</code> 不执行</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ./src/index.js</span></span><br><span class="line"><span class="keyword">const</span> moduleA = <span class="built_in">require</span>(<span class="string">'!inline-loader!./moduleA'</span>)</span><br></pre></td></tr></table></figure><p>那么打印顺序变成</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">loader</span><br><span class="line">loader2</span><br><span class="line">loader3</span><br><span class="line">loader</span><br><span class="line">inline-loader</span><br><span class="line">loader3</span><br></pre></td></tr></table></figure><p>如果是两个 <code>!</code> ，则表示后面的啥都不执行</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ./src/index.js</span></span><br><span class="line"><span class="keyword">const</span> moduleA = <span class="built_in">require</span>(<span class="string">'!!inline-loader!./moduleA'</span>)</span><br></pre></td></tr></table></figure><p>那么打印顺序变成</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">loader</span><br><span class="line">loader2</span><br><span class="line">loader3</span><br><span class="line">inline-loader</span><br></pre></td></tr></table></figure><p>总结下符号的含义</p><ul><li><code>-!</code> 禁用前置和正常 loader</li><li><code>!</code> 禁用普通 loader</li><li><code>!!</code> 禁用前置后置以及正常 loader</li></ul><p>这里说一个为何 <code>inline-loader</code> 前面有打印输出，这是因为 <code>loader</code> 本身还由两个阶段组成: <strong>pitching</strong> 和 <strong>normal execution</strong></p><p>假如一个 use 配置是这样的</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">use: [<span class="string">'loader3'</span>, <span class="string">'loader2'</span>, <span class="string">'loader1'</span>]</span><br></pre></td></tr></table></figure><p>如果 <code>loader</code> 的 <code>pitch</code> 方法<strong>都没有返回值</strong>，那么它执行的顺序为</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">|- loader3 `pitch`</span><br><span class="line">  |- loader2 `pitch`</span><br><span class="line">    |- loader1 `pitch`</span><br><span class="line">      |- requested module is picked up as a dependency</span><br><span class="line">    |- loader1 normal execution</span><br><span class="line">  |- loader2 normal execution</span><br><span class="line">|- loader3 normal execution</span><br></pre></td></tr></table></figure><p>如果某一个 <code>loader</code> 的 <code>pitch</code> 方法<strong>有返回值</strong>(比如 <code>loader2</code>)，那么它执行的顺序为</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">|- loader3 `pitch`</span><br><span class="line">  |- loader2 `pitch`</span><br><span class="line">|- loader3 normal execution</span><br></pre></td></tr></table></figure><p>最后需要说下的是 <code>loader</code> 的特点</p><ul><li>第一个 <code>loader</code> 必须返回的是 js 脚本</li><li>每个 <code>loader</code> 只做其对应的事情，这是为了使 <code>loader</code> 能在更多的场景下进行<strong>链式调用</strong></li><li>每一个 <code>loader</code> 都是一个模块</li><li>每一个 <code>loader</code> 都应该是 <strong>无状态</strong> 的，确保 <code>loader</code> 在不同模块的转换之间不保存状态</li></ul><h2 id="手写-babel-loader"><a href="#手写-babel-loader" class="headerlink" title="手写 babel-loader"></a>手写 babel-loader</h2><p>首先需要装三个包</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yarn add @babel/core @babel/preset-env loader-utils</span><br></pre></td></tr></table></figure><ul><li>@babel/core: js 编译器的核心组件</li><li>@babel/preset-env babel 的插件预设，用来提供支持新语法的环境</li><li>loader-utils 一个专门用于写 webpack loader 的工具库</li></ul><p>然后 <code>webpack.config.js</code> 的内容如下</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    mode: <span class="string">'development'</span>,</span><br><span class="line">entry: <span class="string">'./src/index.js'</span>,</span><br><span class="line">output: &#123;</span><br><span class="line">filename: <span class="string">'bundle.js'</span>,</span><br><span class="line">path: path.resolve(__dirname, <span class="string">'dist'</span>)</span><br><span class="line">&#125;,</span><br><span class="line">resolveLoader: &#123;</span><br><span class="line">modules: [<span class="string">'node_modules'</span>, path.resolve(__dirname, <span class="string">'loaders'</span>)]</span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">// 整个 source map 作为一个单独的文件生成。它为 bundle 添加了一个引用注释，以便开发工具知道在哪里可以找到它</span></span><br><span class="line">devtool: <span class="string">'source-map'</span>,</span><br><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">rules: [</span><br><span class="line">&#123;</span><br><span class="line">test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">use: &#123;</span><br><span class="line">loader: <span class="string">'babel-loader'</span>,</span><br><span class="line">options: &#123;</span><br><span class="line">                      presets: [<span class="string">'@babel/preset-env'</span>] <span class="comment">// 使用 @babel/preset-env 来转化</span></span><br><span class="line">                &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里说一下 <code>source-map</code>，<code>source-map</code> 是一种提供 debug 的源码映射文件，它建立的是一种将压缩文件中的代码对应到源代码文件的方式，有这个source map 文件，出问题了就可以找到对应的代码是哪一段</p><p>然后就可以写 <code>babel-loader</code> 了</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> babel = <span class="built_in">require</span>(<span class="string">'@babel/core'</span>)</span><br><span class="line"><span class="keyword">const</span> loaderUtils = <span class="built_in">require</span>(<span class="string">'loader-utils'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loader</span>(<span class="params">source</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// this 就是 loaderContext</span></span><br><span class="line">  <span class="keyword">const</span> options = loaderUtils.getOptions(<span class="keyword">this</span>)</span><br><span class="line">  <span class="comment">// 异步返回需要用到 async 这个函数</span></span><br><span class="line">  <span class="keyword">const</span> cb = <span class="keyword">this</span>.async()</span><br><span class="line">  <span class="comment">// babel 转化代码</span></span><br><span class="line">  babel.transform(source, &#123;</span><br><span class="line">    ...options,</span><br><span class="line">    sourceMaps: <span class="literal">true</span>, <span class="comment">// 使用源码映射 生成 .js.map</span></span><br><span class="line">    filename: <span class="keyword">this</span>.resourcePath.split(<span class="string">'/'</span>).pop() <span class="comment">// 取出资源文件名</span></span><br><span class="line">  &#125;, (err, result) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; code, map &#125; = result</span><br><span class="line">    cb(err, code, map) <span class="comment">// 返回 code 以及 map 文件</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = loader</span><br></pre></td></tr></table></figure><p>这里的逻辑就是，拿到 <code>loader</code> 的 Context，将其转化成 <code>options</code>，然后使用 <code>babel</code> 的 <code>transform</code> API 来进行代码的转换(es6 -&gt; es5)，里面除了传入 <code>options</code> 之外，还要传入 <code>sourceMaps</code> 确定生成 soureMap 文件，然后 <code>filename</code> 设置 sourcemap 的文件名。最后是一个异步回调函数，由于是异步的，所以这里就需要 <code>async</code> 这个 API，只要调用它就会自动返回传的参数。</p><h2 id="手写-banner-loader"><a href="#手写-banner-loader" class="headerlink" title="手写 banner-loader"></a>手写 banner-loader</h2><p>实现这个 <code>loader</code> 的功能主要是这样</p><ul><li>读取 js 文件，获取其里面的内容，将其作为注释加入到最终生成的源码文件中</li><li>若这个 js 文件不存在，则读取其配置中的 <code>text</code> 选项的内容作为注释加入到最终生成的源码文件中</li></ul><p>先安装 <code>schema-utils</code>，这是一个 webpack 专门用于验证 <code>loaders</code> 以及 <code>plugins</code> 的 <code>options</code> 的库</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yarn add schema-utils</span><br></pre></td></tr></table></figure><p>然后是 <code>webpack.config.js</code> 配置，修改 <code>module.rules[0]</code> 选项</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">use: &#123;</span><br><span class="line">loader: <span class="string">'banner-loader'</span>,</span><br><span class="line">options: &#123;</span><br><span class="line">text: <span class="string">'这里是注释'</span>,</span><br><span class="line">filename: path.resolve(__dirname, <span class="string">'banner.js'</span>)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>同时设置 <code>watch</code> 选项为 <code>true</code></strong></p><p>在项目当前目录增加 <code>banner.js</code> 文件，文件里面写上 <code>helloworld</code></p><p>然后在 <code>loaders</code> 目录下增加 <code>banner-loader.js</code> 文件</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"><span class="keyword">const</span> loaderUtils = <span class="built_in">require</span>(<span class="string">'loader-utils'</span>)</span><br><span class="line"><span class="keyword">const</span> validateOptions = <span class="built_in">require</span>(<span class="string">'schema-utils'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loader</span>(<span class="params">source</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 若有缓存则优先用缓存</span></span><br><span class="line">  <span class="keyword">this</span>.cacheable &amp;&amp; <span class="keyword">this</span>.cacheable()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> cb = <span class="keyword">this</span>.async()</span><br><span class="line">  <span class="keyword">const</span> options = loaderUtils.getOptions(<span class="keyword">this</span>)</span><br><span class="line">  <span class="keyword">const</span> schema = &#123;</span><br><span class="line">    type: <span class="string">'object'</span>,</span><br><span class="line">    properties: &#123;</span><br><span class="line">      text: &#123; <span class="attr">type</span>: <span class="string">'string'</span> &#125;,</span><br><span class="line">      filename: &#123; <span class="attr">type</span>: <span class="string">'string'</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 验证配置有没有写正确</span></span><br><span class="line">  validateOptions(schema, options, <span class="string">'banner-loader'</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> &#123; filename, text &#125; = options</span><br><span class="line">  <span class="keyword">if</span> (filename) &#123;</span><br><span class="line">    <span class="comment">// 添加依赖 在 webpack 使用 watch 配置时使用，只要对应文件有改动，会自动打包更新</span></span><br><span class="line">    <span class="keyword">this</span>.addDependency(filename)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取文件并写入注释</span></span><br><span class="line">    fs.readFile(filename, <span class="string">'utf8'</span>, (err, data) =&gt; &#123;</span><br><span class="line">      cb(err, <span class="string">`/**<span class="subst">$&#123;data&#125;</span>*/<span class="subst">$&#123;source&#125;</span>`</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    cb(<span class="literal">null</span>, <span class="string">`/**<span class="subst">$&#123;text&#125;</span>*/<span class="subst">$&#123;source&#125;</span>`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = loader</span><br></pre></td></tr></table></figure><p>主要的逻辑很简单，就是看有没有配置有没有写对，配置写对了的话就看 <code>filename</code> 存在不存在，<code>filename</code> 不存在就走 <code>text</code>，<code>filename</code> 存在就读取相应文件然后写进去。这里有两个 <code>loader</code> 的 API 需要注意的，一个是 <code>cacheable</code>，另一个是 <code>addDependency</code>，前者是用来缓存文件的，后者是用来配合 <code>webpack</code> 的 <code>watch</code> 配置来用的</p><h2 id="手写-file-loader-以及-url-loader"><a href="#手写-file-loader-以及-url-loader" class="headerlink" title="手写 file-loader 以及 url-loader"></a>手写 file-loader 以及 url-loader</h2><p>首先新建一个图片 <code>demo.jpg</code> 放入 <code>assets</code> 目录下</p><p>然后在 <code>src/index.js</code> 中写入</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 测试 file-loader 以及 url-loader</span></span><br><span class="line"><span class="keyword">import</span> picture <span class="keyword">from</span> <span class="string">'./assets/demo.jpg'</span></span><br><span class="line"><span class="keyword">const</span> img = <span class="built_in">document</span>.createElement(<span class="string">'img'</span>)</span><br><span class="line">img.src = picture</span><br><span class="line"><span class="built_in">document</span>.body.appendChild(img)</span><br></pre></td></tr></table></figure><p><code>file-loader</code> 的作用就是</p><ul><li>根据图片生成 md5 发射到 <code>dist</code> 目录下</li><li>返回当前的图片路径</li></ul><p>首先是 <code>webpack.config.js</code></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    test: <span class="regexp">/\.(png|jpg)$/</span>,</span><br><span class="line">    use: &#123;</span><br><span class="line">        loader: <span class="string">'file-loader'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在项目 <code>loaders</code> 下新建 <code>file-loader.js</code> 文件</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> loaderUtils = <span class="built_in">require</span>(<span class="string">'loader-utils'</span>)</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loader</span>(<span class="params">source</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 根据 loaderContext 生成文件, 这个文件是一串 hash + .jpg 作为后缀名的</span></span><br><span class="line">  <span class="keyword">const</span> filename = loaderUtils.interpolateName(<span class="keyword">this</span>, <span class="string">'[hash].[ext]'</span>, &#123;</span><br><span class="line">    content: source</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// 发射文件</span></span><br><span class="line">  <span class="keyword">this</span>.emitFile(filename, source)</span><br><span class="line">  <span class="comment">// 最后 file-loader 需要返回一个路径，这样 index.js 在 import 图片的时候</span></span><br><span class="line">  <span class="comment">// img 的 src 才是正确的路径</span></span><br><span class="line">  <span class="keyword">return</span> <span class="string">`module.exports = "<span class="subst">$&#123;filename&#125;</span>"`</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 让 source 变成二进制的 buffer</span></span><br><span class="line">loader.raw = <span class="literal">true</span></span><br><span class="line"><span class="built_in">module</span>.exports = loader</span><br></pre></td></tr></table></figure><p>这里需要注意的一点是 <strong>需要将 source 变成二进制的 buffer</strong>，这样便于传参以及后续的处理。最后返回的是一个 <code>module.exports</code>，因为最终需要的是一个路径，这样相当于改变了模块的源码，别人在引入图片的时候就直接引入了路径了</p><p>当然更高级一点的写法是 <code>url-loader</code>，这个 loader 的作用就是</p><ul><li>将传入的文件做一个 <code>limit</code> 的判断，如果这个文件大于 <code>limit</code>，则返回的是文件路径</li><li>若小于 <code>limit</code>，则返回的是一串 <code>base64</code></li></ul><p>写这个之前需要安装 <code>mime</code></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yarn add mime</span><br></pre></td></tr></table></figure><p><code>mime</code> 是一个判断文件类型的工具包，生成 <code>base64</code> 的时候还需要注明图片类型</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> loaderUtils = <span class="built_in">require</span>(<span class="string">'loader-utils'</span>)</span><br><span class="line"><span class="keyword">const</span> mime = <span class="built_in">require</span>(<span class="string">'mime'</span>)</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loader</span>(<span class="params">source</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; limit &#125; = loaderUtils.getOptions(<span class="keyword">this</span>)</span><br><span class="line">  <span class="keyword">if</span> (limit &amp;&amp; source.length &lt; limit) &#123;</span><br><span class="line">    <span class="comment">// 图片没有超过设定的限制大小就返回 base64</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">`module.exports = "data:<span class="subst">$&#123;mime.getType(<span class="keyword">this</span>.resourcePath)&#125;</span>;base64,<span class="subst">$&#123;source.toString(<span class="string">'base64'</span>)&#125;</span>"`</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 图片超过了就调用 file-loader 返回图片本身路径</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">require</span>(<span class="string">'./file-loader'</span>).call(<span class="keyword">this</span>, source)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 让 source 变成二进制的 buffer</span></span><br><span class="line">loader.raw = <span class="literal">true</span></span><br><span class="line"><span class="built_in">module</span>.exports = loader</span><br></pre></td></tr></table></figure><p>这里我们看到使用二进制的好处是便于判断图片的大小</p><h2 id="手写-less-loader、css-loader-以及-style-loader"><a href="#手写-less-loader、css-loader-以及-style-loader" class="headerlink" title="手写 less-loader、css-loader 以及 style-loader"></a>手写 less-loader、css-loader 以及 style-loader</h2><p>由于上篇文章已经讲过 <code>less-loader</code> 以及 <code>style-loader</code> 的写法(那个时候将 <code>style-loader</code> 当成 <code>css-loader</code> 使用了，不过不影响讲解)，这里就列出 <code>less-loader</code> 以及 <code>style-loader</code> 的源码</p><p>首先还是要安装 <code>less</code></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yarn add less</span><br></pre></td></tr></table></figure><p>然后是 <code>webpack.config.js</code></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">test: <span class="regexp">/\.less$/</span>,</span><br><span class="line">use: [<span class="string">'style-loader'</span>, <span class="string">'css-loader'</span>, <span class="string">'less-loader'</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意这里 <code>use</code> 数组的顺序不能变</strong></p><p><code>src/index.less</code></p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">@color: red;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: @color;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>这里的分号必须是要的!!!</strong></p><p><code>src/index.js</code> 里面引入</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'./index.less'</span></span><br></pre></td></tr></table></figure><p>然后是 <code>less-loader.js</code></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> less = <span class="built_in">require</span>(<span class="string">'less'</span>)</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loader</span>(<span class="params">source</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> css = <span class="string">''</span></span><br><span class="line">  less.render(source, (err, c) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(c)</span><br><span class="line">    css = c.css</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> css</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = loader</span><br></pre></td></tr></table></figure><p>然后是 <code>style-loader</code></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loader</span>(<span class="params">source</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> str = <span class="string">`</span></span><br><span class="line"><span class="string">    let style = document.createElement('style')</span></span><br><span class="line"><span class="string">    style.innerHTML = <span class="subst">$&#123;<span class="built_in">JSON</span>.stringify(source)&#125;</span></span></span><br><span class="line"><span class="string">    document.head.appendChild(style)</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">  <span class="keyword">return</span> str</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = loader</span><br></pre></td></tr></table></figure><p>前面讲过，使用 <code>JSON.stringfy</code> 的原因是可以将源码转换成字符串，而且把里面的回车都转成 <code>\r\n</code></p><p>现在将 <code>index.less</code> 改成如下</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">@color: red;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: @color;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">url</span>(./assets/demo.jpg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很显然，打包进 <code>dist/bundle.js</code> 中的文件路径直接在这里使用是引用不到的，因为 <code>dist</code> 目录下并没有 <code>assets/demo.jpg</code>。这时候就必须要写 <code>css-loader</code> 来解析这个 <code>less</code> 文件，首先就是要考虑到 <code>url(./assets/demo.jpg)</code>，将他变成 <code>url(require(./assets/demo.jpg))</code> 就可以了，因为有 <code>require</code> 的情况下 <code>webpack</code> 就会自动将其打包到 <code>bundle.js</code> 中了</p><p>那么怎么做呢？可以将这个 <code>index.less</code> 分为三个部分</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">【@color: red;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: @color;</span><br><span class="line">  background:】【 url(./assets/demo.jpg);】</span><br><span class="line">【&#125;】</span><br></pre></td></tr></table></figure><p>如上，用 “【】”包起来的就是一部分了，接下来看看 <code>css-loader.js</code> 的代码</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loader</span>(<span class="params">source</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 匹配 url(xxx) 这个东西, 用 g 表示全局查找，因为 less 文件里不只是只有一个 url</span></span><br><span class="line">  <span class="keyword">const</span> reg = <span class="regexp">/url\((.+?)\)/g</span></span><br><span class="line">  <span class="comment">// 匹配的指针位置</span></span><br><span class="line">  <span class="keyword">let</span> pos = <span class="number">0</span></span><br><span class="line">  <span class="comment">// 当前匹配的结果</span></span><br><span class="line">  <span class="keyword">let</span> current</span><br><span class="line">  <span class="comment">// 这个数组本质上就是保存一个代码段的</span></span><br><span class="line">  <span class="keyword">const</span> arr = [<span class="string">'let list = []'</span>]</span><br><span class="line">  <span class="comment">// 在 source 中循环匹配 reg</span></span><br><span class="line">  <span class="keyword">while</span>(current = reg.exec(source)) &#123;</span><br><span class="line">    <span class="comment">// 匹配到了 ['url(./assets/demo.jpg)', './assets/demo.jpg']</span></span><br><span class="line">    <span class="keyword">const</span> [matchUrl, g] = current</span><br><span class="line">    <span class="comment">// ↓ lastPos 位置</span></span><br><span class="line">    <span class="comment">// url(./assets/demo.jpg)</span></span><br><span class="line">    <span class="keyword">const</span> lastPos = reg.lastIndex - matchUrl.length</span><br><span class="line">    <span class="comment">// 截取第一部分</span></span><br><span class="line">    arr.push(<span class="string">`list.push(<span class="subst">$&#123;<span class="built_in">JSON</span>.stringify(source.slice(pos, lastPos))&#125;</span>)`</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指针移动</span></span><br><span class="line">    <span class="comment">// pos 位置             ↓</span></span><br><span class="line">    <span class="comment">// url(./assets/demo.jpg)</span></span><br><span class="line">    pos = reg.lastIndex</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 截取第二部分</span></span><br><span class="line">    <span class="comment">// 把 g 替换成 require 的写法</span></span><br><span class="line">    <span class="comment">// 即 './assets/demo.jpg' =&gt; require('./assets/demo.jpg')</span></span><br><span class="line">    arr.push(<span class="string">`list.push('url(' + require('<span class="subst">$&#123;g&#125;</span>') + ')')`</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 截取第三部分</span></span><br><span class="line">  arr.push(<span class="string">`list.push(<span class="subst">$&#123;<span class="built_in">JSON</span>.stringify(source.slice(pos))&#125;</span>)`</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将整个 less 文件作为一个模块返回，而这个模块是一整个字符串</span></span><br><span class="line">  <span class="comment">// 当 style-loader require 引入时，里面的代码就可以直接执行了</span></span><br><span class="line">  arr.push(<span class="string">`module.exports = list.join('')`</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 为了好看，每行代码之间增加一个回车</span></span><br><span class="line">  <span class="keyword">return</span> arr.join(<span class="string">'\r\n'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = loader</span><br></pre></td></tr></table></figure><p>这里主要的思路就是将如上的 <code>less</code> 中的代码看成三个部分，然后以匹配 <code>url</code> 为界点将代码分成三个部分，前两个部分都在循环匹配 <code>url</code>，然后将 <code>url</code> 里的路径改为 <code>require</code> 引入。匹配修改完成之后再截取剩下的第三部分。这里用了数组 <code>arr</code> 的方式将 <code>less</code> 代码转变成了另一段代码，而这段代码也是用数组的形式将 <code>less</code> 代码 <strong>拼凑起来</strong>，最后形成了一个 <strong>模块</strong>。到最后，<code>style-loader</code> 在使用 <code>require</code> 引入时就以字符串的形式引入了这些代码。</p><p>接下来改造 <code>style-loader.js</code>，增加 <code>pitch</code> 函数</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> loaderUtils = <span class="built_in">require</span>(<span class="string">'loader-utils'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通 loader</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loader</span>(<span class="params">source</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> str = <span class="string">`</span></span><br><span class="line"><span class="string">    let style = document.createElement('style')</span></span><br><span class="line"><span class="string">    style.innerHTML = <span class="subst">$&#123;<span class="built_in">JSON</span>.stringify(source)&#125;</span></span></span><br><span class="line"><span class="string">    document.head.appendChild(style)</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">  <span class="keyword">return</span> str</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// pitch 执行的顺序是 style-loader css-loader less-loader</span></span><br><span class="line"><span class="comment">// 这里 remainingRequest 剩余请求表示的就是 css-loader!less-loader!./index.less</span></span><br><span class="line"><span class="comment">// 也就是剩下的还没操作的 css-loader less-loader</span></span><br><span class="line">loader.pitch = <span class="function">(<span class="params">remainingRequest</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 使用 stringifyRequest 的作用是</span></span><br><span class="line">  <span class="comment">// 将请求转换为可以在 require() 或 import 中使用的字符串，同时避免使用绝对路径</span></span><br><span class="line">  <span class="keyword">const</span> req = loaderUtils.stringifyRequest(<span class="keyword">this</span>, <span class="string">'!!'</span> + remainingRequest</span><br><span class="line">  <span class="keyword">const</span> str = <span class="string">`</span></span><br><span class="line"><span class="string">    let style = document.createElement('style')</span></span><br><span class="line"><span class="string">    style.innerHTML = require(<span class="subst">$&#123;req&#125;</span>)</span></span><br><span class="line"><span class="string">    document.head.appendChild(style)</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">  <span class="keyword">return</span> str</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = loader</span><br></pre></td></tr></table></figure><blockquote><p>注意，这里使用 <code>stringifyRequest</code> 的意义在于，由于 webpack 在将模块路径转换为模块 id 之前<strong>会计算哈希值</strong>，因此在这里<strong>必须避免使用绝对路径</strong>，以确保不同编译之间的哈希值保持一致。</p></blockquote><p>这样写的好处就是，<code>style-loader</code> 的 <code>pitch loader</code> 会首先执行，但是上面的普通 <code>loader</code> 就不会执行了。这里参数 <code>remainingRequest</code> 相当于<strong>剩下的请求</strong>，打印出来其实就相当于<strong>局部路径</strong> <code>css-loader!less-loader!./index.less</code>。还记得前面说的这些感叹号的意思么？ <code>require(&#39;css-loader!less-loader!./index.less&#39;)</code> 表示<strong>内联 loader</strong>，优先级是 <strong>从右往左</strong>。但是这里就有个问题，<code>index.less</code> 会先从 <code>style-loader</code> 的 <code>pitch</code> 开始，因为有 <code>require</code> 的存在，会经过 <code>less-loader</code> 和 <code>css-loader</code>，然后又会经过 <code>style-loader</code> 的 <code>pitch</code>，这样一来就会死循环了。所以需要在 <code>require</code> 时添加 <strong>!!</strong>，也就是 <code>require(&#39;!!css-loader!less-loader!./index.less&#39;)</code>，这里 <strong>!!</strong> 号就表示执行完 <code>less-loader</code> 和 <code>css-loader</code> 就不会调用 <code>style-loader</code> 去执行了，也就解决了之前的死循环的问题。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文写了比较多的 <code>loader</code>，现在对 <code>loader</code> 一个最基本的认识就是 <code>loader</code> 就是一个 <strong>函数</strong>，一旦有模块被 <code>import</code> 或者 <code>require</code> 时它就会去拦截这些模块的源码，对其进行改造，然后输出到另一个模块中，循环往复，最终迭代到入口文件中，形成最终的代码<br>所以它的本质在于对代码的 <strong>拼凑</strong> 和 <strong>转换</strong>，其中用的比较多的库是 <code>loaderUtils</code>，这个工具库在写 <code>loader</code> 时必用，需要注意。</p><p>另，<a href="https://github.com/strugglebak/webpack-loader-test.git" target="_blank" rel="noopener">👉项目测试仓库戳这里</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;这个是探究 Webpack 本质的系列文章，会详细讲解如何手写一些源码如 Webpack, loader, plugin 等等，本文主要讲解的是如何手写 loader&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="前端工程化" scheme="https://strugglebak.github.io/categories/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/"/>
    
    
      <category term="webpack" scheme="https://strugglebak.github.io/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>从Webpack本质开始(一):手写一个Webpack</title>
    <link href="https://strugglebak.github.io/2020/02/23/%E4%BB%8EWebpack%E6%9C%AC%E8%B4%A8%E5%BC%80%E5%A7%8B-%E4%B8%80-%E6%89%8B%E5%86%99%E4%B8%80%E4%B8%AAWebpack/"/>
    <id>https://strugglebak.github.io/2020/02/23/从Webpack本质开始-一-手写一个Webpack/</id>
    <published>2020-02-23T09:57:56.000Z</published>
    <updated>2022-06-04T08:13:29.247Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这个是探究 Webpack 本质的系列文章，会详细讲解如何手写一些源码如 Webpack, loader, plugin 等等，本文主要讲解的是如何手写一个 webpack</p></blockquote><a id="more"></a><h2 id="初始化项目"><a href="#初始化项目" class="headerlink" title="初始化项目"></a>初始化项目</h2><p>项目的目录如下</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">|-bin</span><br><span class="line">|  |-st-pack.js</span><br><span class="line">|-package-lock.json</span><br><span class="line">|-package.json</span><br><span class="line">|-README.md</span><br></pre></td></tr></table></figure><p>在 <code>package.json</code> 文件中追加</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="comment">// package.json</span></span><br><span class="line">"bin": &#123;</span><br><span class="line">  "st-pack": "./bin/st-pack.js"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个是方便在执行 <code>st-pack</code> 命令时 node 去找对应的 js 执行</p><p>然后是 <code>st-pack.js</code> 文件</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// st-pack.js</span></span><br><span class="line"><span class="meta">#! /usr/bin/env node</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'hello world'</span>)</span><br></pre></td></tr></table></figure><p>开头的 shebang 表示是在 node 环境下执行 js 代码</p><p>然后在项目的主目录执行 <code>npm link</code>, 就会看到如下的信息</p><p><img src="./1.jpg" alt></p><p>这个就是方便你在调试的时候，在别的项目中执行 <code>npx st-pack</code> 时，系统会去对应的 <code>st-pack</code> 目录下去寻找 <code>st-pack.js</code> 文件，并用 node 去执行它，本质上来说就是建立了一个软链接</p><p>然后你在随便一个目录执行 <code>npx st-pack</code>，出现 <code>hello world</code> 就算项目初始化成功</p><p><img src="./2.jpg" alt></p><h2 id="webpack-分析以及处理"><a href="#webpack-分析以及处理" class="headerlink" title="webpack 分析以及处理"></a>webpack 分析以及处理</h2><p>首先说下流程，一般来说，我们在使用 webpack 时，webpack 会解析对应项目下的 <code>webpack.config.js</code> 文件，抽取里面的配置信息传递给一个 <strong>Compiler</strong> 编译，由这个 <strong>Compiler</strong> 来执行之后的代码</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// st-pack.js</span></span><br><span class="line"><span class="meta">#! /usr/bin/env node</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"><span class="keyword">const</span> config = <span class="built_in">require</span>(path.resolve(<span class="string">'webpack.config.js'</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 找到项目目录下的 webpack.config.js 然后通过一个 compiler 解析它</span></span><br><span class="line"><span class="keyword">const</span> Complier = <span class="built_in">require</span>(<span class="string">'../lib/compiler.js'</span>)</span><br><span class="line"><span class="keyword">const</span> complier = <span class="keyword">new</span> Complier(config)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用 compiler 的 run 方法执行代码</span></span><br><span class="line">complier.run()</span><br></pre></td></tr></table></figure><h2 id="创建依赖关系"><a href="#创建依赖关系" class="headerlink" title="创建依赖关系"></a>创建依赖关系</h2><p>新建一个 <code>lib</code> 目录，在这个目录下新建一个 <code>compiler.js</code> 文件<br>这个里面主要是构造一个 <code>Compiler</code> 的类，然后里面主要有两个方法: <code>bindModule</code>(创建模块间的依赖关系) 以及 <code>emitFile</code>(完成后发送最终的文件到某个目录下)</p><p><code>bindModule</code> 的逻辑是这样的，首先需要获取到模块的源码和名字，然后再将模块的源码和该模块的 <strong>父级路径</strong> 传给一个 <code>parse</code> 函数，由这个 <code>parse</code> 函数来解决源码以及依赖的问题。本质上就是将模块的源码进行改造，然后返回一个依赖的列表。比如将 <code>require(&#39;./a.js&#39;)</code> 变成 <code>_webpack_require_(&#39;./src/a.js&#39;)</code>，如果 <code>a.js</code> 中还有其他的依赖，则需要<strong>递归的去查找对应的包然后做 parse</strong>，最后再把模块的路径和模块中被改造后的源码对应起来</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// lib/complier.js</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complier</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(config) &#123;</span><br><span class="line">    <span class="comment">// 需要保存的入口文件的路径，如 ./src/index.js</span></span><br><span class="line">    <span class="keyword">this</span>.entryId </span><br><span class="line">    <span class="comment">// 需要保存的所有模块的依赖</span></span><br><span class="line">    <span class="keyword">this</span>.modules = &#123;&#125;</span><br><span class="line">    <span class="keyword">this</span>.config = config</span><br><span class="line">    <span class="keyword">this</span>.entry = config.entry <span class="comment">// 入口路径</span></span><br><span class="line">    <span class="keyword">this</span>.root = process.cwd() <span class="comment">// 项目工作的全局路径</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  run() &#123;</span><br><span class="line">    <span class="keyword">this</span>.bindModule(path.resolve(<span class="keyword">this</span>.root, <span class="keyword">this</span>.entry), <span class="literal">true</span>)</span><br><span class="line">    <span class="keyword">this</span>.emitFile()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建模块间的依赖关系</span></span><br><span class="line">  bindModule(modulePath, isEntry) &#123;</span><br><span class="line">    <span class="keyword">const</span> moduleSource = <span class="keyword">this</span>.getModuleSource(modulePath)</span><br><span class="line">    <span class="keyword">const</span> moduleName = <span class="string">'./'</span> + path.relative(<span class="keyword">this</span>.root, modulePath)</span><br><span class="line">    isEntry &amp;&amp; (<span class="keyword">this</span>.entryId = moduleName)</span><br><span class="line">    <span class="comment">// 将模块的源码进行改造，并且返回一个依赖的列表</span></span><br><span class="line">    <span class="comment">// 主要是将 require 变成 __webpack_require__</span></span><br><span class="line">    <span class="comment">// 然后将 require('./a.js') 变成 __webpack_require__('./src/a.js')</span></span><br><span class="line">    <span class="keyword">const</span> &#123; newModuleSource, dependencies &#125; = </span><br><span class="line">      <span class="keyword">this</span>.parse(moduleSource, path.dirname(moduleName))</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 把相对路径和模块中的内容对应起来</span></span><br><span class="line">    <span class="keyword">this</span>.modules[moduleName] = newModuleSource</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 发射一个打包后的文件</span></span><br><span class="line">  emitFile() &#123;</span><br><span class="line">  </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  getModuleSource(modulePath) &#123;</span><br><span class="line">    <span class="keyword">return</span> fs.readFileSync(modulePath, <span class="string">'utf8'</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 解析模块源码</span></span><br><span class="line">  parse(moduleSource, parentPath) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(moduleSource, parentPath)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = Complier</span><br></pre></td></tr></table></figure><h2 id="AST-递归解析"><a href="#AST-递归解析" class="headerlink" title="AST 递归解析"></a>AST 递归解析</h2><p>如果要从头开始自己写一个 ast 编译工具未免太麻烦了，这里直接用如下几个工具库</p><ul><li>babylon 主要将 code 转换成 ast</li><li>@babel/traverse 截取并更新 ast node</li><li>@babel/types 一个类似于 lodash 的用于处理 ast 的工具包</li><li>@babel/generator 将 ast node 转换成 code</li></ul><p>直接安装</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yarn add babylon @babel/traverse @babel/types @babel/generator</span><br></pre></td></tr></table></figure><p>由于 <code>traverse</code> 和 <code>generator</code> 是 es6 模块，所以这里用 <code>require</code> 引入时需要在后面加 <code>default</code> 才能拿到这个函数</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// babylon 主要将源码转成 AST</span></span><br><span class="line"><span class="keyword">const</span> babylon = <span class="built_in">require</span>(<span class="string">'babylon'</span>) </span><br><span class="line"><span class="comment">// 用来遍历以及更新 AST node</span></span><br><span class="line"><span class="keyword">const</span> traverse = <span class="built_in">require</span>(<span class="string">'@babel/traverse'</span>).default <span class="comment">// es6 模块</span></span><br><span class="line"><span class="comment">// 类似 lodash 的一个用于处理 AST node 的工具库</span></span><br><span class="line"><span class="keyword">const</span> t = <span class="built_in">require</span>(<span class="string">'@babel/types'</span>)</span><br><span class="line"><span class="comment">// 将 AST node 转换成 code</span></span><br><span class="line"><span class="keyword">const</span> generator = <span class="built_in">require</span>(<span class="string">'@babel/generator'</span>).default <span class="comment">// es6 模块</span></span><br></pre></td></tr></table></figure><p>这里递归解析的目的就是<strong>改名字</strong>，所以逻辑的流程就是</p><ol><li>将模块源码转成 ast</li><li>在 ast 内部修改 <code>require</code>，并且收集依赖关系</li><li>将修改过后的 ast 转换成新的 code</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// lib/compiler.js </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 解析模块源码</span></span><br><span class="line">parse(moduleSource, parentPath) &#123;</span><br><span class="line">  <span class="comment">// 将源码转换成 AST</span></span><br><span class="line">  <span class="keyword">let</span> ast = babylon.parse(moduleSource)</span><br><span class="line">  <span class="comment">// 遍历以及修改 AST node</span></span><br><span class="line">  <span class="keyword">const</span> dependencies = []</span><br><span class="line">  traverse(ast, &#123;</span><br><span class="line">    CallExpression(p) &#123; <span class="comment">// 调用表达式</span></span><br><span class="line">      <span class="keyword">const</span> &#123; node &#125; = p</span><br><span class="line">      <span class="keyword">let</span> &#123; name &#125; = node.callee</span><br><span class="line">      <span class="comment">// 修改调用名，即将 require -&gt; __webpack_require__</span></span><br><span class="line">      <span class="keyword">if</span> (name === <span class="string">'require'</span>) &#123;</span><br><span class="line">        node.callee.name = <span class="string">'__webpack_require__'</span></span><br><span class="line">        <span class="comment">// 修改模块名，将其变成 ./src/a.js</span></span><br><span class="line">        <span class="keyword">let</span> moduleName = node.arguments[<span class="number">0</span>].value</span><br><span class="line">        <span class="comment">// 自动添加后缀名</span></span><br><span class="line">        moduleName += path.extname(moduleName) ? <span class="string">''</span> : <span class="string">'.js'</span></span><br><span class="line">        <span class="comment">// 添加父级路径</span></span><br><span class="line">        moduleName = <span class="string">'./'</span> + path.join(parentPath, moduleName)</span><br><span class="line">        <span class="comment">// 添加进依赖列表</span></span><br><span class="line">        dependencies.push(moduleName)</span><br><span class="line">        <span class="comment">// 构建 Literal 对象</span></span><br><span class="line">        node.arguments = [t.stringLiteral(moduleName)]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// 将 AST 转换成源码</span></span><br><span class="line">  <span class="keyword">const</span> newModuleSource = generator(ast).code</span><br><span class="line">  <span class="keyword">return</span> &#123; newModuleSource, dependencies &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在 <code>bindModule</code> 函数中递归的建立依赖</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 模块里面还有依赖的就要递归建立依赖关系</span></span><br><span class="line">dependencies.forEach(<span class="function"><span class="params">dp</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.bindModule(path.join(<span class="keyword">this</span>.root, dp), <span class="literal">false</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>在 <code>bindModule</code> 函数中打印 <code>newModuleSource</code> 和 <code>dependencies</code></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'code : '</span>, newModuleSource)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'denp : '</span>, dependencies)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'---------------------------'</span>)</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>在其他项目目录执行<code>npx st-pack</code> 结果可看到</p><p><img src="./3.jpg" alt></p><h2 id="生成打包结果"><a href="#生成打包结果" class="headerlink" title="生成打包结果"></a>生成打包结果</h2><p>在生成打包结果之前，必须先要一个模板，如果只是手动拼字符串太麻烦了，所以这里使用 <code>ejs</code> 来用于这次的模板工具</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yarn add ejs</span><br></pre></td></tr></table></figure><p>然后是模板代码, 在项目下新建目录 <code>template</code>，里面存放的是 <code>main.ejs</code></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main.ejs</span></span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">modules</span>) </span>&#123; <span class="comment">// webpackBootstrap</span></span><br><span class="line">  <span class="comment">// The module cache</span></span><br><span class="line">  <span class="keyword">var</span> installedModules = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// The require function</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">__webpack_require__</span>(<span class="params">moduleId</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check if module is in cache</span></span><br><span class="line">    <span class="keyword">if</span>(installedModules[moduleId]) &#123;</span><br><span class="line">      <span class="keyword">return</span> installedModules[moduleId].exports;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Create a new module (and put it into the cache)</span></span><br><span class="line">    <span class="keyword">var</span> <span class="built_in">module</span> = installedModules[moduleId] = &#123;</span><br><span class="line">      i: moduleId,</span><br><span class="line">      l: <span class="literal">false</span>,</span><br><span class="line">      exports: &#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Execute the module function</span></span><br><span class="line">    modules[moduleId].call(<span class="built_in">module</span>.exports, <span class="built_in">module</span>, <span class="built_in">module</span>.exports, __webpack_require__);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Flag the module as loaded</span></span><br><span class="line">    <span class="built_in">module</span>.l = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Return the exports of the module</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">module</span>.exports;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Load entry module and return exports</span></span><br><span class="line">  <span class="keyword">return</span> __webpack_require__(__webpack_require__.s = <span class="string">"&lt;%-entryId%&gt;"</span>);</span><br><span class="line">&#125;)</span><br><span class="line">(&#123;</span><br><span class="line">  &lt;%<span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> modules) &#123;%&gt;</span><br><span class="line">  <span class="string">"&lt;%-key%&gt;"</span>:</span><br><span class="line">  (<span class="function"><span class="keyword">function</span>(<span class="params">module, exports, __webpack_require__</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">eval</span>(<span class="string">`&lt;%-modules[key]%&gt;`</span>)</span><br><span class="line">  &#125;),</span><br><span class="line">  &lt;%&#125;%&gt;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><blockquote><p>这里顺便说下 <code>ejs</code> 的一点语法，它是用 <code>&lt;%%&gt;</code> 来包裹代码块的, 如果要换行就要加上去，其中 <code>&lt;%-xxx%&gt;</code> 这种形式表示 <code>xxx</code> 是里面的一个 <strong>变量</strong>，需要注意前面的 <code>-</code> 号</p></blockquote><p>可以看到这里的原理是，我们构建了一个 <code>ejs</code> 的模板，然后在这个模板里面插入了变量 <code>entryId</code> 以及 <code>modules</code>。代码从整体上是一个 IIFE(立即执行函数)，代码最开始的 <code>modules</code> 这个 <strong>参数</strong> 被传入时是一个 <code>{&#39;模块路径&#39;: &#39;模块执行代码&#39;}</code> 的 hash，它经历了如下的步骤</p><ol><li>声明一个模块的缓存</li><li>定义一个 <code>__webpack_require__</code> 的函数<ul><li>检查模块是否有缓存，有缓存就直接返回 </li><li>没有缓存就直接创建一个模块，然后把它添加进缓存</li><li>执行模块里面的代码</li><li>标致模块已经加载</li><li>返回该模块的 exports 对象</li></ul></li><li>加载模块并返回 exports 对象</li></ol><p>比较需要注意的是两段代码</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">  <span class="comment">// 执行 module 对应的代码，并传一个 __webpack_require__ 这个参数过去</span></span><br><span class="line">  modules[moduleId].call(<span class="built_in">module</span>.exports, <span class="built_in">module</span>, <span class="built_in">module</span>.exports, __webpack_require__);</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// 最开始的传的参数是一个入口文件</span></span><br><span class="line">  <span class="keyword">return</span> _webpack_require__(__webpack_require__.s = <span class="string">"&lt;%-entryId%&gt;"</span>);</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>这两句代码应该来说是最核心的，因为有一个入口文件，它执行了对应入口文件的代码时，会首先去找依赖，传一个 <code>__webpack_require__</code> 回调函数过去，然后这个再次执行了 <code>__webpack_require__</code> 回调函数后，再去寻找依赖，相当于就是一个递归的过程，当所有的递归完成后，所有的代码包括有依赖关系的都将执行完成</p><p>接下来需要补充的就是代码的输出了，即 <code>emitFile</code> 函数</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// lib/complier.js</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 发射一个打包后的文件</span></span><br><span class="line">emitFile() &#123;</span><br><span class="line">  <span class="comment">// 输出文件路径</span></span><br><span class="line">  <span class="keyword">const</span> &#123; filename &#125; = <span class="keyword">this</span>.config.output</span><br><span class="line">  <span class="keyword">const</span> &#123; entryId, modules &#125; = <span class="keyword">this</span></span><br><span class="line">  <span class="keyword">const</span> outputFilePath = path.join(<span class="keyword">this</span>.config.output.path, filename)</span><br><span class="line">  <span class="keyword">const</span> template = <span class="keyword">this</span>.getModuleSource(path.join(__dirname, <span class="string">'../template/main.ejs'</span>))</span><br><span class="line">  <span class="keyword">const</span> outputFileCode = ejs.render(template, &#123; entryId, modules &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 保存输出文件路径</span></span><br><span class="line">  <span class="keyword">this</span>.assert[outputFilePath] = outputFileCode</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 写入对应路径</span></span><br><span class="line">  fs.writeFileSync(outputFilePath, <span class="keyword">this</span>.assert[outputFilePath])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码的逻辑很简单，就是 <strong>找出配置中的 <code>path</code> 和 <code>filename</code>，使用 ejs 渲染模板，将真正的 code 代码输出到指定的目录中</strong></p><p>完成后，到有配置 <code>webpack.config.js</code> 项目中执行 <code>npx st-pack</code>，出现如下效果</p><p><img src="./4.jpg" alt></p><h2 id="增加-loader-的解析机制"><a href="#增加-loader-的解析机制" class="headerlink" title="增加 loader 的解析机制"></a>增加 loader 的解析机制</h2><blockquote><p>为了简明扼要，这里用 css 的 loader 来做解析工作</p></blockquote><p>在测试项目的 <code>webpack.config.js</code> 配置文件中加上</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">  rules: [&#123;</span><br><span class="line">    test: <span class="regexp">/\.less$/</span>,</span><br><span class="line">    use: [</span><br><span class="line">      path.resolve(__dirname, <span class="string">'loader'</span>, <span class="string">'style-loader'</span>),</span><br><span class="line">      path.resolve(__dirname, <span class="string">'loader'</span>, <span class="string">'less-loader'</span>)</span><br><span class="line">    ]</span><br><span class="line">  &#125;]</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>这里需要注意的是 <code>loader</code> 的执行顺序是 <strong>先添加进去的后执行</strong>，所以这里的顺序是 <code>less-loader</code> 先于 <code>style-loader</code> 执行</p><p>然后在项目根目录新建目录 <code>loader</code>, 里面添加两个文件 <code>less-loader.js</code> 以及 <code>style-loader.js</code>，这两个 <code>loader</code> 可以自己写，由于 <code>less-loader</code> 文件需要 <code>less</code>，所以在那之前先执行</p><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">yarn <span class="keyword">add</span><span class="bash"> less</span></span><br></pre></td></tr></table></figure><p>执行完成后可以写 <code>less-loader</code> 了</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> less = <span class="built_in">require</span>(<span class="string">'less'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loader</span>(<span class="params">source</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> css = <span class="string">''</span></span><br><span class="line">  less.render(source, (err, c) =&gt; &#123;</span><br><span class="line">    <span class="comment">// source 转成 c.css</span></span><br><span class="line">    css = c.css</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// 将 css code 中的 \n 字符转换成 \\n ，不然浏览器会报错</span></span><br><span class="line">  css = css.replace(<span class="regexp">/\n/g</span>, <span class="string">'\\n'</span>)</span><br><span class="line">  <span class="keyword">return</span> css</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = loader</span><br></pre></td></tr></table></figure><p>这个 <code>loader</code> 的逻辑很简单，就是利用 <code>less</code> 将传入的 css 代码进行 <code>render</code>。这里要注意的是需要将代码中的 <code>\n</code> 字符转换成 <code>\\n</code>，不然浏览器会报错</p><p>然后是 <code>style-loader</code> 的代码</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loader</span>(<span class="params">source</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> style = <span class="string">`</span></span><br><span class="line"><span class="string">    let style = document.createElement('style')</span></span><br><span class="line"><span class="string">    style.innerHTML = <span class="subst">$&#123;<span class="built_in">JSON</span>.stringify(source)&#125;</span></span></span><br><span class="line"><span class="string">    document.head.appendChild(style)</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">  <span class="keyword">return</span> style</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = loader</span><br></pre></td></tr></table></figure><p>逻辑也很简单，就是简单插入一段 <code>style</code> 标签</p><blockquote><p>同时这里也可以看到，所谓的 <code>loader</code> 不过也只是一个 <strong>函数</strong> 而已。它只是个利用了其他的 <code>node</code> 的工具解析 code，然后再返回解析后的结果的这么一个 <strong>加载器</strong></p></blockquote><p>写好了 <code>loader</code> 之后，就应该在 <code>st-pack</code> 项目中的 <code>lib/compiler.js</code> 的 <code>getModuleSource</code> 函数中做处理了。为什么是这个函数？因为它是做 code 解析的时候会用到的啊</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">getModuleSource(modulePath) &#123;</span><br><span class="line">  <span class="keyword">let</span> source = fs.readFileSync(modulePath, <span class="string">'utf8'</span>)</span><br><span class="line">  <span class="keyword">const</span> &#123; rules &#125; = <span class="keyword">this</span>.config.module</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; rules.length; i++) &#123;</span><br><span class="line">    <span class="comment">// 处理对应 test 下的 use</span></span><br><span class="line">    <span class="keyword">const</span> rule = rules[i]</span><br><span class="line">    <span class="keyword">const</span> &#123; test, use &#125; = rule</span><br><span class="line">    <span class="keyword">let</span> len = use.length - <span class="number">1</span></span><br><span class="line">    <span class="comment">// 先匹配 test 正则</span></span><br><span class="line">    <span class="keyword">if</span> (test.test(modulePath)) &#123;</span><br><span class="line">      <span class="comment">// 匹配对了就处理 loader， 这个是倒着处理的</span></span><br><span class="line">      <span class="function"><span class="keyword">function</span> <span class="title">normalLoader</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 获取对应 loader</span></span><br><span class="line">        <span class="keyword">const</span> loader = <span class="built_in">require</span>(use[len--])</span><br><span class="line">        <span class="comment">// 转化代码</span></span><br><span class="line">        source = loader(source)</span><br><span class="line">        <span class="comment">// loader 没调用完之前就继续递归调用 loader 来解析代码</span></span><br><span class="line">        len &gt;= <span class="number">0</span> &amp;&amp; normalLoader()</span><br><span class="line">      &#125;</span><br><span class="line">      normalLoader()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> source</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的逻辑就是如下</p><ol><li>解析配置文件中的 <code>rules</code></li><li>处理每个 <code>rules</code> 中的规则</li><li>如果规则(test)匹配，说明找到对应的后缀的文件了，这个时候就可以拿出其 <code>use</code>，用 <code>loader</code> 去解析代码了</li><li>从 <code>use</code> 数组倒序加载 <code>loader</code> 去做解析，并且这个过程是递归的</li></ol><p>最后在测试项目的 <code>src</code> 目录下新建 <code>index.less</code>，内容为</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>并且在 <code>index.js</code> 中引入</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="built_in">require</span>(<span class="string">'./foo.js'</span>)</span><br><span class="line"><span class="built_in">require</span>(<span class="string">'./index.less'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(str)</span><br></pre></td></tr></table></figure><p>这个时候执行 <code>npx st-pack</code>，查看 <code>bundle.js</code></p><p><img src="./5.jpg" alt></p><p>然后在 <code>dist</code> 目录新建 <code>index.html</code>，引入 <code>bundle.js</code>，用浏览器打开 <code>index.html</code></p><p><img src="./6.jpg" alt></p><h2 id="增加-plugin-解析机制"><a href="#增加-plugin-解析机制" class="headerlink" title="增加 plugin 解析机制"></a>增加 plugin 解析机制</h2><p>webpack 的插件机制其实很简单，就是在对应的生命周期的位置<strong>发布</strong>信息，而原来<strong>订阅</strong>到这些信息的插件收到这些信息时，就会<strong>执行对应的回调</strong>，本质上就是利用 <strong>发布订阅模式</strong>来实现 webpack 到对应的生命周期时执行对应的代码</p><p>首先为了方便这里使用 <code>tapable</code> 这个库，<code>tapble</code> 是一个用于为 plugins 创建钩子的库，它里面暴露了很多 hooks 类，目前这里使用 <code>SyncHook</code> 这个类来进行开发</p><p>先是安装 <code>tapable</code></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yarn add tapable</span><br></pre></td></tr></table></figure><p>在 <code>lib/complier.js</code> 文件中引入 <code>tapable</code></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; SyncHook &#125; = <span class="built_in">require</span>(<span class="string">'tapable'</span>)</span><br></pre></td></tr></table></figure><p>在 <code>Compiler</code> 类中，增加了 <code>hooks</code> 钩子</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 插件的生命周期钩子，这里为了方便统一使用同步的方式</span></span><br><span class="line"><span class="keyword">this</span>.hooks = &#123;</span><br><span class="line">  entryOptions: <span class="keyword">new</span> SyncHook(),</span><br><span class="line">  afterPlugins: <span class="keyword">new</span> SyncHook(),</span><br><span class="line">  run: <span class="keyword">new</span> SyncHook(),</span><br><span class="line">  compile: <span class="keyword">new</span> SyncHook(),</span><br><span class="line">  afterCompile: <span class="keyword">new</span> SyncHook(),</span><br><span class="line">  emit: <span class="keyword">new</span> SyncHook(),</span><br><span class="line">  done: <span class="keyword">new</span> SyncHook()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后将 <code>config</code> 中的 <code>plugins</code> 配置中的 <code>plugin</code> 的 <code>apply</code> 函数中的 <code>this</code> 也就是 <code>Compiler</code> 传入，让插件可以得到 <code>Compiler</code> 对象并订阅事件</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; plugins &#125; = <span class="keyword">this</span>.config</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(plugins)) &#123;</span><br><span class="line">    plugins.forEach(<span class="function"><span class="params">plugin</span> =&gt;</span> &#123;</span><br><span class="line">      plugin.apply(<span class="keyword">this</span>) <span class="comment">// 将 Compiler 这个类传入</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后 <code>call</code> 对应的生命周期钩子发布事件</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="meta">#! /usr/bin/env node</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"><span class="keyword">const</span> config = <span class="built_in">require</span>(path.resolve(<span class="string">'webpack.config.js'</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 找到项目目录下的 webpack.config.js 然后通过一个 compiler 解析它</span></span><br><span class="line"><span class="keyword">const</span> Complier = <span class="built_in">require</span>(<span class="string">'../lib/compiler.js'</span>)</span><br><span class="line"><span class="keyword">const</span> complier = <span class="keyword">new</span> Complier(config)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 run 之前发布一个 entryOptions 的钩子</span></span><br><span class="line">complier.hooks.entryOptions.call()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用 compiler 的 run 方法执行代码</span></span><br><span class="line">complier.run()</span><br></pre></td></tr></table></figure><p><img src="./7.jpg" alt></p><p>在测试项目目录创建 <code>plugins</code> 目录，然后写两个 <code>plugin</code> 插件</p><p><code>demo1-plugin.js</code></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo1Plugin</span> </span>&#123;</span><br><span class="line">  apply(compiler) &#123;</span><br><span class="line">    compiler.hooks.emit.tap(<span class="string">'emit'</span>, () =&gt; &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'emit'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = Demo1Plugin</span><br></pre></td></tr></table></figure><p><code>demo2-plugin.js</code></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo2Plugin</span> </span>&#123;</span><br><span class="line">  apply(compiler) &#123;</span><br><span class="line">    compiler.hooks.afterPlugins.tap(<span class="string">'afterPlugins'</span>, () =&gt; &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'afterPlugins'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = Demo2Plugin</span><br></pre></td></tr></table></figure><p>在其 <code>webpack.config.js</code> 文件中引入并使用</p><p><img src="./8.jpg" alt></p><p><img src="./9.jpg" alt></p><p>这里要强调的一点是，对于同步的钩子(如 <code>SyncHook</code>) 而言, <code>tap</code> 是添加 <code>plugin</code> 的唯一有效的方法，当然还有其他的异步钩子，这里不详细说，详情可以去看 <a href="https://www.npmjs.com/package/tapable" target="_blank" rel="noopener">tapble 官方文档说明</a></p><p>在测试项目根目录执行 <code>npx st-pack</code> 可以看到</p><p><img src="./10.jpg" alt></p><p>可以看到其正确的打印出了生命周期的顺序</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>由以上的分析可以看到，一个最基本的 webpack 的流程是这样的</p><ol><li><code>webpack</code> 在拿到配置文件后，将文件的配置传给一个 <code>Compiler</code> 对象，由这个对象 <code>run</code> 来处理对应的打包逻辑</li><li><code>Compiler</code> 主要做的就是两件事，<strong>递归创建依赖关系</strong> 和 <strong>生成打包后的文件</strong></li><li>在创建依赖关系的过程中，需要将模块的源码转成 ast，然后再遍历这个 ast node, 在遍历的过程中修改源码，最后再生成源码返回，此时返回的是一个修改过后的模板，用 <code>ejs</code> 渲染</li><li>模板本身就是 IIFE(立即执行函数)，也就是一个闭包，它通过这个函数去递归的执行对应模块的源码，直到最后输出结果</li><li>在解析 <code>loader</code> ，越靠后的越先执行。<code>loader</code> 本质上也是解析对应的 <code>loader</code> 源码执行的产物，不同的地方在于<strong><code>loader</code>中的参数即源码 <code>source</code> 是一个接着一个传递下去的</strong>，即 <code>loader</code> 之间是有一个传承的关系，他们的参数是相关联的。所以 <code>loader</code> 作为加载器，它的目的就是 <strong>加载代码 -&gt; 修改代码 -&gt; 执行代码</strong></li><li>在解析 <code>plugin</code> 时，本质上就是通过 <code>webpack</code> 暴露出来的事件，<code>plugin</code> 监听这些事件，在截获到这些事件的时候就可以做事情了。主要利用了<strong>发布订阅</strong>这样的一种设计模式</li></ol><p>另，<a href="https://github.com/strugglebak/webpack-resource-test-demo.git" target="_blank" rel="noopener">👉项目测试仓库戳这里</a>，以及<a href="https://github.com/strugglebak/st-pack.git" target="_blank" rel="noopener">👉手写 webpack 源码仓库戳这里</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;这个是探究 Webpack 本质的系列文章，会详细讲解如何手写一些源码如 Webpack, loader, plugin 等等，本文主要讲解的是如何手写一个 webpack&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="前端工程化" scheme="https://strugglebak.github.io/categories/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/"/>
    
    
      <category term="webpack" scheme="https://strugglebak.github.io/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>Vue全家桶之Vue-Router</title>
    <link href="https://strugglebak.github.io/2019/03/17/Vue%E5%85%A8%E5%AE%B6%E6%A1%B6%E4%B9%8BVue-Router/"/>
    <id>https://strugglebak.github.io/2019/03/17/Vue全家桶之Vue-Router/</id>
    <published>2019-03-17T12:41:34.000Z</published>
    <updated>2022-06-04T08:13:29.040Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这是 Vue 全家桶组件系列的文章，梳理一下比较难懂的几个点，此篇文章要说的就是 Vue-Router</p></blockquote><a id="more"></a><h2 id="什么是路由"><a href="#什么是路由" class="headerlink" title="什么是路由"></a>什么是路由</h2><p>在 web 领域，我们可以将 <strong>路由</strong> 简单的理解为 <strong>控制器</strong>, 这个控制器主要做什么呢？它能将输入到浏览器中的 url 导向至对应页面的组件，然后浏览器就将这个组件渲染出来。这个过程就是 <strong>路由</strong> 。</p><h2 id="什么是-Vue-Router"><a href="#什么是-Vue-Router" class="headerlink" title="什么是 Vue-Router"></a>什么是 Vue-Router</h2><p>以下是官方说明:</p><blockquote><p>Vue Router 是 Vue.js 官方的 <strong>路由管理器</strong><br>其实跟 Vuex 的思想是很像的，它通过一个全局的 <code>router</code>,来对浏览器中的 url 进行管理，最后导向不同的页面。</p></blockquote><h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><p>主要有几大核心概念</p><ul><li>动态路由匹配</li><li>重定向和别名</li><li>路由组件传参</li><li>History 模式</li><li>导航守卫</li><li>路由懒加载</li></ul><h3 id="动态路由匹配"><a href="#动态路由匹配" class="headerlink" title="动态路由匹配"></a>动态路由匹配</h3><p>什么是动态路由匹配？比如我输入的 url 中有 <code>/user/foo</code> 和 <code>/user/bar</code>,我们希望在输入这两个 url 后导向的是同一个页面的同一个组件，那么我们可以这么写(类似于用个变量代替 <code>/user/</code> 后面的参数，然后就往这个变量丢参数就完事儿了，因为不写死，所以就是动态的)<br><figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// User 组件</span></span><br><span class="line"><span class="keyword">const</span> User = &#123;</span><br><span class="line">  template: <span class="string">'&lt;div&gt;User&lt;/div&gt;'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 路由</span></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    <span class="comment">// 动态路径参数 以冒号开头</span></span><br><span class="line">    &#123; path: <span class="string">'/user/:id'</span>, component: User &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>同时在 <code>path</code> 中也可以设置多段 <em>路径的参数</em>,比如我想要输入 <code>/user/foo/post/100</code>,你可以这样写<br><figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line">/user/<span class="symbol">:id/post/</span><span class="symbol">:post_id</span></span><br></pre></td></tr></table></figure></p><p>当然了，动态路径的参数名字是可以随便取的，我们可以在 <code>$route.params</code> 中看到这个<br><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">console.log(<span class="variable">$route</span>.params); <span class="regexp">//</span> &#123;id: <span class="string">'foo'</span>, post_id: <span class="string">'100'</span>&#125;</span><br></pre></td></tr></table></figure></p><p>注意一下这里的匹配优先级，若存在多个路径匹配同一个路由的情况，如<br><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">const router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line"><span class="symbol">  routes:</span> [</span><br><span class="line">    <span class="comment">// 动态路径参数 以冒号开头</span></span><br><span class="line">    &#123; <span class="string">path:</span> <span class="string">'/xxx'</span>, <span class="string">component:</span> User1 &#125;,</span><br><span class="line">    &#123; <span class="string">path:</span> <span class="string">'/xxx'</span>, <span class="string">component:</span> User2 &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>那么会优先匹配先定义的，也就是输入 <code>/xxx</code> ,会匹配到 <code>User1</code></p><h3 id="重定向和别名"><a href="#重定向和别名" class="headerlink" title="重定向和别名"></a>重定向和别名</h3><p>Vue-Router 的这个功能可以实现一个逻辑，这个逻辑是什么呢？拿知乎来举例，若我是未登录的状态，那么当访问个人信息页面时，应该重定向到登录页面，如下<br><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">const router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line"><span class="symbol">  routes:</span> [</span><br><span class="line">    &#123; <span class="string">path:</span> <span class="string">'/login'</span>, <span class="string">component:</span> Login &#125;</span><br><span class="line">    &#123; <span class="string">path:</span> <span class="string">'/userInfo'</span>, <span class="string">redirect:</span> <span class="string">'/login'</span> &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>也可以是一个已经命名过的路由<br><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">const router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line"><span class="symbol">  routes:</span> [</span><br><span class="line">    &#123; <span class="string">path:</span> <span class="string">'/login'</span>, <span class="string">name:</span> <span class="string">'login'</span>, <span class="string">component:</span> Login &#125;,</span><br><span class="line">    &#123; <span class="string">path:</span> <span class="string">'/userInfo'</span>, <span class="string">redirect:</span> &#123; <span class="string">name:</span> <span class="string">'login'</span> &#125;&#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>也可以是一个方法<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">'/userInfo'</span>, <span class="attr">redirect</span>: <span class="function"><span class="params">to</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 方法接收 目标路由 作为参数</span></span><br><span class="line">      <span class="comment">// return 重定向的 字符串路径/路径对象</span></span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">          path: <span class="string">'/login'</span>,</span><br><span class="line">          name: <span class="string">'login'</span>,</span><br><span class="line">          component: Login</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;&#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>同样，你可以用 <strong>别名</strong> 的方式，什么是别名？比如在浏览器中输入的是 <code>/bar</code>,但实际上访问的是 <code>/foo</code><br><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">const router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line"><span class="symbol">  routes:</span> [</span><br><span class="line">    &#123; <span class="string">path:</span> <span class="string">'/foo'</span>, <span class="string">component:</span> Foo, <span class="string">alias:</span> <span class="string">'/bar'</span> &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><h3 id="路由组件传参"><a href="#路由组件传参" class="headerlink" title="路由组件传参"></a>路由组件传参</h3><p>什么是路由组件传参？我们可以这么理解，其实就是在浏览器输入一串 url ,然后渲染的对应组件能够接受到这串 url 中的某些参数，这就是<br><figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">      参数</span><br><span class="line">路由 <span class="comment">------&gt; 组件</span></span><br></pre></td></tr></table></figure></p><p>路由组件传参有 3 种方式: 布尔模式、对象模式、函数模式</p><ul><li>布尔模式</li></ul><p>其实就是通过 <code>props</code> 传参，比如我输入 <code>/user/foo</code> 这个 url,我想把 url 中 <code>foo</code> 这个参数传给组件，可以这么写<br><figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">// <span class="keyword">User</span> <span class="title">组件</span></span><br><span class="line"><span class="title">const</span> <span class="keyword">User</span> <span class="title">= &#123;</span></span><br><span class="line"><span class="title">  props</span>: ['id'],</span><br><span class="line">  template: '<span class="tag">&lt;div&gt;</span><span class="keyword">User</span> <span class="title">&#123;&#123; id</span> &#125;&#125;<span class="tag">&lt;/div&gt;</span>'</span><br><span class="line">&#125;</span><br><span class="line">// 路由</span><br><span class="line">const router = new VueRouter(&#123;</span><br><span class="line">    routes: [</span><br><span class="line">        &#123; path: '/user/:id', component: User, props: <span class="literal">true</span> &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>前提条件是要设置对应匹配路由的 <code>props</code> 为 <code>true</code><br>如果你在使用 <code>router-view</code> 时使用到了 <code>name</code> 这个属性，比如<br><figure class="highlight cos"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 渲染 user</span></span><br><span class="line">&lt;router-<span class="keyword">view</span>&gt;&lt;/router-<span class="keyword">view</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 渲染 sidebar</span></span><br><span class="line">&lt;router-<span class="keyword">view</span> name=<span class="string">"sidebar"</span>&gt;&lt;/router-<span class="keyword">view</span>&gt;</span><br></pre></td></tr></table></figure></p><p>你就需要为每个对应的 <code>命名视图</code> 添加 <code>props</code><br><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">const</span> <span class="string">router</span> <span class="string">=</span> <span class="string">new</span> <span class="string">VueRouter(&#123;</span></span><br><span class="line">  <span class="attr">routes:</span> <span class="string">[</span></span><br><span class="line">    <span class="string">&#123;</span></span><br><span class="line">      <span class="attr">path:</span> <span class="string">'/user/:id'</span><span class="string">,</span></span><br><span class="line">      <span class="attr">components:</span> <span class="string">&#123;</span> <span class="attr">default:</span> <span class="string">User,</span> <span class="attr">sidebar:</span> <span class="string">Sidebar</span> <span class="string">&#125;,</span></span><br><span class="line">      <span class="attr">props:</span> <span class="string">&#123;</span> <span class="attr">default:</span> <span class="literal">true</span><span class="string">,</span> <span class="attr">sidebar:</span> <span class="literal">false</span> <span class="string">&#125;</span></span><br><span class="line">    <span class="string">&#125;</span></span><br><span class="line">  <span class="string">]</span></span><br><span class="line"><span class="string">&#125;)</span></span><br></pre></td></tr></table></figure></p><ul><li>对象模式</li></ul><p>比如组件中 <code>props</code> 是个对象<br><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">// User 组件</span></span><br><span class="line">const User = &#123;</span><br><span class="line"><span class="symbol">  props:</span> &#123;</span><br><span class="line"><span class="symbol">      name:</span> <span class="string">''</span></span><br><span class="line">  &#125;,</span><br><span class="line"><span class="symbol">  template:</span> <span class="string">'&lt;div&gt;User &#123;&#123; name &#125;&#125;&lt;/div&gt;'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 路由</span></span><br><span class="line">const router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line"><span class="symbol">    routes:</span> [</span><br><span class="line">        &#123; <span class="string">path:</span> <span class="string">'/user/new-name'</span>, <span class="string">component:</span> User, <span class="string">props:</span> &#123; <span class="string">name:</span> <span class="string">'strugglebak'</span> &#125; &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><ul><li>函数模式</li></ul><p>其实本质上这个函数返回的还是一个对象，比如在浏览器中输入 <code>/search?name=strugglebak</code> 表示查询，可以这么写<br><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">// User 组件</span></span><br><span class="line">const User = &#123;</span><br><span class="line"><span class="symbol">  props:</span> &#123;</span><br><span class="line"><span class="symbol">      name:</span> <span class="string">''</span></span><br><span class="line">  &#125;,</span><br><span class="line"><span class="symbol">  template:</span> <span class="string">'&lt;div&gt;User &#123;&#123; name &#125;&#125;&lt;/div&gt;'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 路由</span></span><br><span class="line">const router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line"><span class="symbol">  routes:</span> [</span><br><span class="line">    &#123; <span class="string">path:</span> <span class="string">'/search'</span>, <span class="string">component:</span> User, <span class="string">props:</span> (route) =&gt; (&#123; <span class="string">query:</span> route.query.name &#125;) &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p><code>router.query.name</code> 返回的就是 <code>strugglebak</code> 这个字符串</p><h3 id="History-模式"><a href="#History-模式" class="headerlink" title="History 模式"></a>History 模式</h3><p>什么是 History 模式？我们知道，网易云的 url 一般来说是这种形式<br><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">http:<span class="regexp">//mu</span>sic.<span class="number">163</span>.com<span class="regexp">/#/my</span><span class="regexp">/m/mu</span>sic<span class="regexp">/playlist?id=121597667</span></span><br></pre></td></tr></table></figure></p><p>在播放歌曲时，每个 url 下都有一个 <code>#</code> 符号，我们知道这个符号是 url 的 hash 部分，这个符号后面那一大串不会传递到服务端，那么它有什么用？它的作用就是 <strong>通过这个 hash 来模拟传统的后端路由器，判断哪些请求可以直接导向哪个组件，进而渲染出这个组件</strong>,这就是前端路由器的作用。但是带个 <code>#</code> 号的 url 看起来比较丑，你看哪些传统的 web 应用的 url 就没有，那么有没有一种办法来去掉这个 <code>#</code> 号呢？<br>有的，Vue-Router 提供了这个 <strong>History模式</strong>,你只需要做如下设置<br><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">const router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  <span class="keyword">mode</span>: <span class="string">'history'</span>,</span><br><span class="line">  route<span class="variable">s:</span> [...]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>url 就会和正常的 url 一样没有 <code>#</code> 号，就对 url <strong>进行了美化处理</strong><br>但是这个还需要后端配置，官方文档是这么说的</p><blockquote><p>不过这种模式要玩好，还需要后台配置支持。因为我们的应用是个单页客户端应用，如果后台没有正确的配置，当用户在浏览器直接访问 <a href="http://oursite.com/user/id" target="_blank" rel="noopener">http://oursite.com/user/id</a> 就会返回 404，这就不好看了。<br>所以呢，你要在服务端增加一个覆盖所有情况的候选资源：如果 URL 匹配不到任何静态资源，则应该返回同一个 index.html 页面，这个页面就是你 app 依赖的页面。</p></blockquote><h3 id="导航守卫"><a href="#导航守卫" class="headerlink" title="导航守卫"></a>导航守卫</h3><p>什么是导航守卫呢？这其实就相当于一个 <strong>拦截器</strong>,在路由发生变化的之中通过这层拦截来实现一些业务需求。一般来说，我们认为当你点击 a 链接进行 <strong>重定向式跳转</strong> 时路由就产生 <strong>变化</strong> 了。<br>但是这里需要注意，<strong>params 或者 query 的变化并不会触发 enter/leave 这类路由拦截器</strong>,你可以通过<br><figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> User = &#123;</span><br><span class="line">  template: <span class="string">'...'</span>,</span><br><span class="line">  watch: &#123;</span><br><span class="line">    <span class="string">'$route'</span> (to, <span class="keyword">from</span>) &#123;</span><br><span class="line">      <span class="comment">// 对路由变化作出响应...</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>或者<br><figure class="highlight autoit"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> User = &#123;</span><br><span class="line">  template: <span class="string">'...'</span>,</span><br><span class="line">  beforeRouteUpdate (<span class="keyword">to</span>, from, <span class="keyword">next</span>) &#123;</span><br><span class="line">      // 对路由变化作出响应...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样的方式来监听以上的变化</p><p>导航守卫有几个 api，分别是 </p><ul><li>全局的守卫 <code>beforeEach</code>,<code>beforeResolve</code>,<code>afterEach</code></li><li>路由独享守卫 <code>beforeEnter</code></li><li>组件内的守卫 <code>beforeRouterEnter</code>,<code>beforeRouterUpdate</code>,<code>beforeRouterLeave</code></li></ul><p>首先我们应该先看看一个完整的导航解析过程是怎样的<br><figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line">           (失活组件)<span class="keyword">beforeRouterLeave</span></span><br><span class="line"><span class="keyword">1. </span>导航触发 ---------------------------&gt; <span class="keyword">beforeEach</span></span><br><span class="line"><span class="keyword"> </span>          (复用组件)<span class="keyword">beforeRouterUpdate</span></span><br><span class="line"><span class="keyword">2. </span>        ---------------------------&gt; <span class="keyword">beforeEnter</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">3. </span>        ---------------------------&gt; 解析组件</span><br><span class="line">           (激活组件)<span class="keyword">beforeEnter</span></span><br><span class="line"><span class="keyword">4. </span>        ---------------------------&gt; <span class="keyword">beforeResolve</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">5. </span>导航确认 ---------------------------&gt; afterEach</span><br><span class="line"></span><br><span class="line"><span class="number">6</span>. 触发 DOM 更新</span><br></pre></td></tr></table></figure></p><p>基本上解析过程就代表了它们之间的区别了<br>注意 <code>beforeEnter</code> 是 <strong>可以</strong> 在路由配置上定义<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123;</span><br><span class="line">      path: <span class="string">'/foo'</span>,</span><br><span class="line">      component: Foo,</span><br><span class="line">      beforeEnter: <span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>以及组件内的路由用法如下<br><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="regexp">//</span> Foo 组件</span><br><span class="line">const foo = &#123;</span><br><span class="line">  template: `...`,</span><br><span class="line">  beforeRouteEnter (to, from, <span class="keyword">next</span>) &#123;</span><br><span class="line">    <span class="regexp">//</span> 在渲染该组件的对应路由被 confirm 前调用</span><br><span class="line">    <span class="regexp">//</span> 不！能！获取组件实例 `this`</span><br><span class="line">    <span class="regexp">//</span> 因为当守卫执行前，组件实例还没被创建</span><br><span class="line">  &#125;,</span><br><span class="line">  beforeRouteUpdate (to, from, <span class="keyword">next</span>) &#123;</span><br><span class="line">    <span class="regexp">//</span> 在当前路由改变，但是该组件被复用时调用</span><br><span class="line">    <span class="regexp">//</span> 举例来说，对于一个带有动态参数的路径 <span class="regexp">/foo/</span>:id，在 <span class="regexp">/foo/</span><span class="number">1</span> 和 <span class="regexp">/foo/</span><span class="number">2</span> 之间跳转的时候，</span><br><span class="line">    <span class="regexp">//</span> 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。</span><br><span class="line">    <span class="regexp">//</span> 可以访问组件实例 `this`</span><br><span class="line">  &#125;,</span><br><span class="line">  beforeRouteLeave (to, from, <span class="keyword">next</span>) &#123;</span><br><span class="line">    <span class="regexp">//</span> 导航离开该组件的对应路由时调用</span><br><span class="line">    <span class="regexp">//</span> 可以访问组件实例 `this`</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="路由懒加载"><a href="#路由懒加载" class="headerlink" title="路由懒加载"></a>路由懒加载</h3><p>路由的懒加载是什么呢？一般我们使用 webpack 进行打包时，js 代码会变得很大，这样会对页面加载的性能造成影响，如何提升性能呢？就是 <strong>按需加载</strong>，当路由被访问的时候才加载对应组件。具体要怎么做呢？就是分离组件代码。<br>这里需要分两步来做</p><ol><li><p>将异步组件定义为返回一个 Promise 的工厂函数</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Foo = <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">Promise</span>.resolve(&#123; <span class="comment">/* 组件定义对象 */</span> &#125;)</span><br></pre></td></tr></table></figure></li><li><p>在 webpack 中 import</p><figure class="highlight coffeescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span>(<span class="string">'./Foo.vue'</span>).<span class="keyword">then</span>(<span class="function"><span class="params">(<span class="built_in">module</span>)</span>=&gt;</span> &#123;</span><br><span class="line">    <span class="regexp">//</span>...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ol><h3 id="还有其他常用-API"><a href="#还有其他常用-API" class="headerlink" title="还有其他常用 API"></a>还有其他常用 API</h3><p>常用 API 有 <code>router-link</code>/<code>router-view</code>/<code>this.$router.push</code>/<code>this.$router.replace</code>/<code>this.$route.params</code></p><ul><li><code>router-link</code></li></ul><p>一般写在需要进行路由跳转的地方，它最终渲染的是一个 a 标签<br><figure class="highlight dust"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="comment">&lt;!-- 使用字符串 --&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">"xxx"</span>&gt;</span>xxx<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="comment">&lt;!-- 使用 v-bind 绑定变量 --&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">:to</span>=<span class="string">"xxx"</span>&gt;</span>xxx<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="comment">&lt;!-- 绑定对象 --&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">:to</span>=<span class="string">"</span></span></span><span class="template-variable">&#123;</span></span><br><span class="line"><span class="template-variable">    path: 'xxx'</span></span><br><span class="line"><span class="template-variable">&#125;</span><span class="xml">"&gt;xxx<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="comment">&lt;!-- 绑定命名的路由 --&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">:to</span>=<span class="string">"</span></span></span><span class="template-variable">&#123;</span></span><br><span class="line"><span class="template-variable">    name: 'user',</span></span><br><span class="line"><span class="template-variable">    params: &#123; userId: 123 &#125;</span></span><br><span class="line"><span class="xml">&#125;"&gt;User<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="comment">&lt;!-- 带查询参数，下面的结果为 /register?plan=private --&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">:to</span>=<span class="string">"</span></span></span><span class="template-variable">&#123;</span></span><br><span class="line"><span class="template-variable">    path: 'register',</span></span><br><span class="line"><span class="template-variable">    query: &#123; plan: 'private' &#125;</span></span><br><span class="line"><span class="xml">&#125;"&gt;Register<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span></span><br></pre></td></tr></table></figure></p><ul><li><code>router-view</code></li></ul><p>如果 <code>router-view</code> 设置了名称，则会渲染对应的路由配置中 <code>components</code> 下的相应组件,一般我们是这么写<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 渲染一个 name 为 main 的组件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-view</span> <span class="attr">name</span>=<span class="string">"main"</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 渲染一个 name 为 slidebar 的组件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-view</span> <span class="attr">name</span>=<span class="string">"slidebar"</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>然后在路由中有如下配置<br><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">const router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">    route<span class="variable">s:</span> [</span><br><span class="line">        &#123;</span><br><span class="line">            name:<span class="string">'post'</span>,</span><br><span class="line">            path:<span class="string">'/post'</span>,</span><br><span class="line">            component<span class="variable">s:</span>&#123;</span><br><span class="line">                main: Article,</span><br><span class="line">                slidebar: SlideBar</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><ul><li><code>this.$router.push</code></li></ul><p>一个 <code>router-link</code> 的替代品,作用就是 <strong>向 history 添加记录</strong>,可以有如下用法<br><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 字符串</span></span><br><span class="line"><span class="selector-tag">router</span><span class="selector-class">.push</span>(<span class="string">'home'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象</span></span><br><span class="line"><span class="selector-tag">router</span><span class="selector-class">.push</span>(&#123; <span class="attribute">path</span>: <span class="string">'home'</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 命名的路由</span></span><br><span class="line"><span class="selector-tag">router</span><span class="selector-class">.push</span>(&#123; <span class="attribute">name</span>: <span class="string">'user'</span>, <span class="attribute">params</span>: &#123; <span class="attribute">userId</span>: <span class="string">'123'</span> &#125;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 带查询参数，变成 /register?plan=private</span></span><br><span class="line"><span class="selector-tag">router</span><span class="selector-class">.push</span>(&#123; <span class="attribute">path</span>: <span class="string">'register'</span>, <span class="attribute">query</span>: &#123; <span class="attribute">plan</span>: <span class="string">'private'</span> &#125;&#125;)</span><br></pre></td></tr></table></figure></p><p>注意，若写了 <code>path</code> ,则 <code>params</code> 会被忽略掉(<code>query</code> 除外),所以你应该这么写<br><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">const userId = <span class="string">'123'</span></span><br><span class="line">router.push(&#123; name: <span class="string">'user'</span>, params: &#123; userId &#125;&#125;) <span class="regexp">//</span> -&gt; <span class="regexp">/user/</span><span class="number">123</span></span><br><span class="line">router.push(&#123; path: `<span class="regexp">/user/</span><span class="variable">$&#123;userId&#125;</span>` &#125;) <span class="regexp">//</span> -&gt; <span class="regexp">/user/</span><span class="number">123</span></span><br></pre></td></tr></table></figure></p><ul><li><code>this.$router.replace</code></li></ul><p>跟上面的 <code>push</code> 方法很像,不过作用是 <strong>替换掉当前的 history 记录</strong>,用法跟上面的相同</p><ul><li><code>this.$router.params</code></li></ul><p>就是一个 <code>key/value</code> 对象，之前在 <a href="#动态路由匹配">动态路由匹配</a> 中说过，它里面保存的就是路由参数</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Vue-Router 是前端 SPA 项目的利器，它可以提升用户的体验，增加开发效率。本文只是简单梳理了一下 Vue-Router 开发经常会用到的东西，其他小细节还得多去翻翻 <a href="https://router.vuejs.org/zh/" target="_blank" rel="noopener">官方文档</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;这是 Vue 全家桶组件系列的文章，梳理一下比较难懂的几个点，此篇文章要说的就是 Vue-Router&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="web前端" scheme="https://strugglebak.github.io/categories/web%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="Vue-Router" scheme="https://strugglebak.github.io/tags/Vue-Router/"/>
    
  </entry>
  
  <entry>
    <title>Vue全家桶之Vuex</title>
    <link href="https://strugglebak.github.io/2019/03/16/Vue%E5%85%A8%E5%AE%B6%E6%A1%B6%E4%B9%8BVuex/"/>
    <id>https://strugglebak.github.io/2019/03/16/Vue全家桶之Vuex/</id>
    <published>2019-03-16T03:16:32.000Z</published>
    <updated>2022-06-04T08:13:29.050Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这是 Vue 全家桶组件系列的文章，梳理一下比较难懂的几个点，此篇文章要说的就是 Vuex</p></blockquote><a id="more"></a><div align="center"><br><img src="https://i.loli.net/2019/03/17/5c8e3c3102799.png" width="400"><br></div><h2 id="Vuex-是个啥"><a href="#Vuex-是个啥" class="headerlink" title="Vuex 是个啥"></a>Vuex 是个啥</h2><p>官方说明: Vuex 是一个专为 Vue.js 应用程序开发的 <strong>状态管理模式</strong> ,它采用 <em>集中式存储</em> 来管理应用中所有组件的状态，并以相应的规则保证 <em>状态</em> 以一种可预测的方式发生变化。</p><p>好了，道理我都懂，可是这段话究竟是什么意思呢？注意一个词: <strong>状态管理</strong> ,好了，什么是状态，它要怎么去管理？</p><p>Vuex 的官网上，有这么段简单的代码说明<br><figure class="highlight axapta"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  <span class="comment">// state</span></span><br><span class="line">  data () &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="keyword">count</span>: <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// view</span></span><br><span class="line">  template: `</span><br><span class="line">    &lt;<span class="keyword">div</span>&gt;&#123;&#123; <span class="keyword">count</span> &#125;&#125;&lt;/<span class="keyword">div</span>&gt;</span><br><span class="line">  `,</span><br><span class="line">  <span class="comment">// actions</span></span><br><span class="line">  methods: &#123;</span><br><span class="line">    increment () &#123;</span><br><span class="line">      <span class="keyword">this</span>.<span class="keyword">count</span>++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>从中我们可以看到</p><ul><li>所谓的 <code>state</code>,其实就是 <code>data</code></li><li>所谓的 <code>view</code>,其实就是模板 <code>template</code></li><li>所谓的 <code>actions</code>, 其实就是 <code>methods</code></li></ul><p>好了，我们现在想想，假如在一个页面中，多个组件需要进行通信，或者说需要一些数据的共享，我们应该怎么做？封装过组件的人都知道，组件通信一般有两种方式</p><ul><li>对于父子通信,可以使用 props 传递数据，使用 v-on 绑定自定义事件</li><li>对于爷孙、兄弟通信，可以使用 eventBus</li></ul><p>以上都是基于单向数据流的原则，非常之简洁。但是在 <strong>多个组件需要共享数据</strong> 这个情况下，上面两种方式就不适用了，为什么？</p><p>因为你会遇到如下两种情况</p><ul><li>多个 <code>view</code> 依赖同一个 <code>data</code></li><li>多个 <code>view</code> 要改变同一个 <code>data</code></li></ul><p>对于第一种情况来说，举个栗子，假如我 <code>data</code> 里面有个 <code>count</code>,只有当 <code>count</code> 大于 0 时，页面上的几个组件才能显示，但是假如有这么个奇葩的需求，就是有个组件它是 <strong>嵌套的</strong>,必须要最里面那个先显示，外层的才一个个跟着显示，那这里最里面的子组件就必须维护一个 <code>count</code>,然后父组件就通过 <code>$children</code> 来判断，假如这个嵌套很深，难道你不觉得这样做很 <strong>繁琐</strong> 很不优雅吗？</p><p>对于第二种情况来说，也举个栗子，假如有个极端的需求，子组件里面有个 <code>count</code>,有个 <code>button</code>,点击 <code>button</code> 后 <code>count</code> 会变，然后父组件上有三个这样的子组件，需求是当点击任何一个子组件的 <code>button</code>, 每个子组件的 <code>count</code> 都会变化，请问这种情况下该怎么做？要是后面需求将 <code>count</code> 改成 <code>apple</code> 怎么办？要是后面还增加了一个 <code>xxx</code> 的数据怎么办？这样就不好做代码维护吧。</p><h2 id="Vuex-是怎么做的"><a href="#Vuex-是怎么做的" class="headerlink" title="Vuex 是怎么做的"></a>Vuex 是怎么做的</h2><p>好了，既然大家都跟这个 <strong>状态</strong> 有关系，那么为什么不把它抽取出来做一个统一管理呢？其实在 js 中，我们可以很容易的想到用一个 <code>window</code> 来存一个全局变量，比如使用 <code>window.xxx</code>,那么其他模块就可以访问到这个 <code>xxx</code> 变量了。可是能访问到也不行啊， 要知道 <code>xxx</code> 这个变量是会变的，那么我们怎么能 <strong>动态地知道</strong> 这个变量的变化呢?很简单，就去 <strong>造个事件</strong> ,就是当 <code>xxx</code> 变量有变化的时候通知一下各个模块。</p><p>Vuex 做了啥？其实大致就做了上面的事</p><h2 id="开始认识-Vuex"><a href="#开始认识-Vuex" class="headerlink" title="开始认识 Vuex"></a>开始认识 Vuex</h2><p>一个 Vuex 中，有个叫 <code>Store</code> 的对象,这个对象中，平常用的多的就是如下几个<br><figure class="highlight autohotkey"><table><tr><td class="code"><pre><span class="line">const store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line"><span class="built_in">    state,</span></span><br><span class="line"><span class="built_in">    mutations,</span></span><br><span class="line"><span class="built_in">    getters,</span></span><br><span class="line"><span class="built_in">    actions,</span></span><br><span class="line">&#125;)<span class="comment">;</span></span><br></pre></td></tr></table></figure></p><h3 id="Store"><a href="#Store" class="headerlink" title="Store"></a>Store</h3><p><code>Store</code> 是个啥呢,你可以把它理解为一个数据管理中心，在这个数据管理中心里，有</p><ul><li>管理的数据，我们叫它 <code>state</code></li><li>管理数据的相关操作，你可以理解为 CUD 都在这里面，我们叫它 <code>mutations</code></li><li>获取数据的操作,你可以理解为数据库的 R 操作在这里面，我们叫他 <code>getters</code></li><li><strong>通知数据库要管理数据库了</strong>,这个操作我们叫它 <code>actions</code></li></ul><h3 id="state"><a href="#state" class="headerlink" title="state"></a>state</h3><p><code>state</code> 就是我们所说的数据了,注意，这里由于使用的是 <strong>单一状态树</strong>,也就是 <strong>唯一数据源</strong>, 所以每个应用就也只包含一个 <code>Store</code> 实例，所以它们才能共享这个实例里面的数据，也就是 <code>state</code>, 比如我们在 <code>state</code> 中有个 <code>count</code> 数据<br><figure class="highlight pf"><table><tr><td class="code"><pre><span class="line">const store = new Vuex.Store(&#123;</span><br><span class="line">    <span class="keyword">state</span>: &#123;</span><br><span class="line">        count: <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>在根组件中注入 <code>store</code> 实例<br><figure class="highlight coffeescript"><table><tr><td class="code"><pre><span class="line">const app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line">  <span class="regexp">//</span> 把 store 对象提供给 “store” 选项，这可以把 store 的实例注入所有的子组件</span><br><span class="line">  store,</span><br><span class="line">  components: &#123; Counter &#125;,</span><br><span class="line">  template: `</span><br><span class="line"><span class="javascript">    &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line"><span class="javascript">      &lt;counter&gt;&lt;<span class="regexp">/counter&gt;</span></span></span><br><span class="line"><span class="javascript">    &lt;<span class="regexp">/div&gt;</span></span></span><br><span class="line"><span class="javascript">  </span>`</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>然后在组件中访问它<br><figure class="highlight pf"><table><tr><td class="code"><pre><span class="line">const Counter = &#123;</span><br><span class="line">  template: `<span class="variable">&lt;div&gt;</span>&#123;&#123; count &#125;&#125;&lt;/div&gt;`,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    count () &#123;</span><br><span class="line">      return this.<span class="variable">$store</span>.<span class="keyword">state</span>.count // 通过 this.<span class="variable">$store</span>.<span class="keyword">state</span> 访问</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="getters"><a href="#getters" class="headerlink" title="getters"></a>getters</h3><p>获取数据的操作，我们同样可以不使用 <code>this.$store.state</code> 这种方式，而使用 <code>getters</code> 来代替，个人认为这是对前者的一种封装，当然 <code>getters</code> 的特点不止于此，你可以认为它是 <code>Store</code> 的计算属性，所以 <code>getter</code> 是有返回值的(废话),但是这个返回值会被 <strong>缓存</strong> 起来,只有其依赖发生改变才会重新计算<br><figure class="highlight pf"><table><tr><td class="code"><pre><span class="line">const store = new Vuex.Store(&#123;</span><br><span class="line">    <span class="keyword">state</span>: &#123;</span><br><span class="line">        count: <span class="number">0</span></span><br><span class="line">    &#125;,</span><br><span class="line">    getters: &#123;</span><br><span class="line">        doneCount: <span class="keyword">state</span> =&gt; &#123;</span><br><span class="line">            return <span class="keyword">state</span>.count;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>然后在组件中使用<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">computed: &#123;</span><br><span class="line">    count() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.$store.getters.doneCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><h3 id="mutations"><a href="#mutations" class="headerlink" title="mutations"></a>mutations</h3><p>我们要更改数据，就不要直接通过 <code>this.$store.state</code> 去修改了， Vuex 在这里提供了一个方式 <code>mutations</code>, 当我触发 <code>commit</code> 某个 <code>type</code> 事件，就会调用 <code>mutations</code> 中已经定义好的 <code>handler</code> 回调函数<br><figure class="highlight pf"><table><tr><td class="code"><pre><span class="line">const store = new Vuex.Store(&#123;</span><br><span class="line">  <span class="keyword">state</span>: &#123;</span><br><span class="line">    count: <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  mutations: &#123;</span><br><span class="line">    increment (<span class="keyword">state</span>) &#123;</span><br><span class="line">      // 变更状态</span><br><span class="line">      <span class="keyword">state</span>.count++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>在组件中你可以通过这样的方式触发<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.$store.commit(<span class="string">'increament'</span>);</span><br></pre></td></tr></table></figure></p><p><code>commit</code> 还可以传一个额外的参数，这个参数叫 <strong>payload 载荷</strong><br><figure class="highlight pf"><table><tr><td class="code"><pre><span class="line">mutations: &#123;</span><br><span class="line">  increment (<span class="keyword">state</span>, n) &#123;</span><br><span class="line">    <span class="keyword">state</span>.count += n</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后你可以在组件中这样触发<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.$store.commit(<span class="string">'increment'</span>, <span class="number">10</span>);</span><br></pre></td></tr></table></figure></p><p>你也可以采用对象的方式<br><figure class="highlight pf"><table><tr><td class="code"><pre><span class="line">mutations: &#123;</span><br><span class="line">  increment (<span class="keyword">state</span>, payload) &#123;</span><br><span class="line">    <span class="keyword">state</span>.count += payload.amount;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后你可以在组件中这样触发<br><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.$store.commit(<span class="string">'increament'</span>, &#123;<span class="string">amount:</span> <span class="number">10</span>&#125;);</span><br></pre></td></tr></table></figure></p><p>或者写成这样<br><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.$store.commit(&#123;<span class="string">type:</span> <span class="string">'increament'</span>, <span class="string">amount:</span> <span class="number">10</span>&#125;);</span><br></pre></td></tr></table></figure></p><h3 id="actions"><a href="#actions" class="headerlink" title="actions"></a>actions</h3><p>就像我之前所说，<code>actions</code> 的作用就是通知 <code>mutations</code> 该去处理数据了，至于处理数据的具体事宜，<code>actions</code> 并不关心，因为那个是 <code>mutations</code> 来负责的，接下来简单写一个 <code>actions</code><br><figure class="highlight pf"><table><tr><td class="code"><pre><span class="line">const store = new Vuex.Store(&#123;</span><br><span class="line">  <span class="keyword">state</span>: &#123;</span><br><span class="line">    count: <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  mutations: &#123;</span><br><span class="line">    increment (<span class="keyword">state</span>) &#123;</span><br><span class="line">      <span class="keyword">state</span>.count++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  actions: &#123;</span><br><span class="line">    increment (context) &#123;</span><br><span class="line">      context.commit('increment')</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>然后你就可以在组件对应的 <code>methods</code> 属性中这样写<br><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">    <span class="builtin-name">add</span>() &#123;</span><br><span class="line">        this.<span class="variable">$store</span>.dispatch(<span class="string">'increament'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>注意，这里 <code>actions</code> 函数中的 <code>context</code> 对象虽然能够使用 <code>commit</code> 方法，但它 <strong>并不是</strong> <code>store</code> 实例， 并且 <code>actions</code> 需要通过 <code>store.dispatch</code> 方法来触发</p><h2 id="其他的注意点"><a href="#其他的注意点" class="headerlink" title="其他的注意点"></a>其他的注意点</h2><ul><li><code>mutations</code> 里的函数必须是 <strong>同步执行</strong> 的，而 <code>actions</code> 里的函数 <strong>可以执行异步操作</strong></li></ul><figure class="highlight coffeescript"><table><tr><td class="code"><pre><span class="line">actions: &#123;</span><br><span class="line">  actionA (&#123; commit &#125;) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Promise(<span class="function"><span class="params">(resolve, reject)</span> =&gt;</span> &#123;</span><br><span class="line">      setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        commit(<span class="string">'someMutation'</span>)</span><br><span class="line">        resolve()</span><br><span class="line">      &#125;, <span class="number">1000</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后你就可以这样使用<br><figure class="highlight coffeescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.$store.dispatch(<span class="string">'actionA'</span>).<span class="keyword">then</span>(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="regexp">//</span> ...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>同样这里也支持 <code>async/await</code><br><figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 假设 getData() 和 getOtherData() 返回的是 Promise</span></span><br><span class="line"></span><br><span class="line">actions: &#123;</span><br><span class="line">  <span class="function"><span class="keyword">async</span> <span class="title">actionA</span> (<span class="params">&#123; commit &#125;</span>)</span> &#123;</span><br><span class="line">    commit(<span class="string">'gotData'</span>, <span class="keyword">await</span> getData())</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="keyword">async</span> <span class="title">actionB</span> (<span class="params">&#123; dispatch, commit &#125;</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">await</span> dispatch(<span class="string">'actionA'</span>) <span class="comment">// 等待 actionA 完成</span></span><br><span class="line">    commit(<span class="string">'gotOtherData'</span>, <span class="keyword">await</span> getOtherData())</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>对于表单来说，你可以使用带有 setter 的双向绑定计算属性</li></ul><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// html</span></span><br><span class="line">&lt;input v-model=<span class="string">"message"</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">computed: &#123;</span><br><span class="line">  message: &#123;</span><br><span class="line">    <span class="keyword">get</span> () &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.$store.state.obj.message</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">set</span> (value) &#123;</span><br><span class="line">      <span class="keyword">this</span>.$store.commit(<span class="string">'updateMessage'</span>, value)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>actions</code> 提交的是 <code>mutation</code>,而不是直接变更状态</li></ul><h2 id="关于辅助函数-mapXXX"><a href="#关于辅助函数-mapXXX" class="headerlink" title="关于辅助函数 mapXXX"></a>关于辅助函数 mapXXX</h2><p>个人认为， Vuex 中 map 函数的作用就是为了 <strong>简化代码</strong>,比如使用 <code>mapState</code> 函数可以帮你生成计算属性<br><figure class="highlight pf"><table><tr><td class="code"><pre><span class="line">import &#123; mapState &#125; <span class="keyword">from</span> 'vuex'</span><br><span class="line"></span><br><span class="line">export <span class="keyword">default</span> &#123;</span><br><span class="line">  // ...</span><br><span class="line">  computed: mapState(&#123;</span><br><span class="line">    // 箭头函数可使代码更简练</span><br><span class="line">    count: <span class="keyword">state</span> =&gt; <span class="keyword">state</span>.count,</span><br><span class="line"></span><br><span class="line">    // 传字符串参数 'count' 等同于 `<span class="keyword">state</span> =&gt; <span class="keyword">state</span>.count`</span><br><span class="line">    countAlias: 'count',</span><br><span class="line"></span><br><span class="line">    // 为了能够使用 `this` 获取局部状态，必须使用常规函数</span><br><span class="line">    countPlusLocalState (<span class="keyword">state</span>) &#123;</span><br><span class="line">      return <span class="keyword">state</span>.count + this.localCount</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>也可以写成<br><figure class="highlight pf"><table><tr><td class="code"><pre><span class="line">computed: mapState([</span><br><span class="line">  // 映射 this.count 为 store.<span class="keyword">state</span>.count</span><br><span class="line">  'count',</span><br><span class="line">])</span><br></pre></td></tr></table></figure></p><p>同时若想将属性混入(mixin) <code>computed</code>,你可以使用 <code>...</code> 对象展开运算符<br><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="attribute">computed</span>: &#123;</span><br><span class="line">  localComputed () &#123; <span class="comment">/* ... */</span> &#125;,</span><br><span class="line">  <span class="comment">// 使用对象展开运算符将此对象混入到外部对象中</span></span><br><span class="line">  ..<span class="selector-class">.mapState</span>(&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>至于其他的 <code>mapGetters</code>、<code>mapMutaions</code>、<code>mapActions</code> 用法都差不多，详细还请查询 <a href="https://vuex.vuejs.org/zh/guide/" target="_blank" rel="noopener">官方文档</a>，这里就不再过多赘述</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;这是 Vue 全家桶组件系列的文章，梳理一下比较难懂的几个点，此篇文章要说的就是 Vuex&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="web前端" scheme="https://strugglebak.github.io/categories/web%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="Vuex" scheme="https://strugglebak.github.io/tags/Vuex/"/>
    
  </entry>
  
</feed>
